{"data":{"title":"","description":"let LEFT_STYLE&#x3D;&#39;color: #fadfa3; background: #030307; padding:5px 0;&#39;,RIGHT_STYLE&#x3D;&#39;background: #fadfa3; padding:5px 0;&#39;,MESSAGE_TEMPLATE&#x3D;&#96;  %c Spark Lite 文章摘要AI生成 %c https:&#x2F;&#x2F;uuanqin.top&#x2F;  &#96;,PROXY_API_U","date":"2026-02-01T05:18:41.064Z","updated":"2025-07-08T14:27:11.307Z","language":"zh-CN","comments":true,"url":"unused/ai-summary.js","cover":null,"images":[],"content":"let LEFT_STYLE='color: #fadfa3; background: #030307; padding:5px 0;',RIGHT_STYLE='background: #fadfa3; padding:5px 0;',MESSAGE_TEMPLATE=`\n %c Spark Lite 文章摘要AI生成 %c https://uuanqin.top/ \n`,PROXY_API_URL='https://ai-summary.uuanqin.top/api/ai-summary/spark-lite',LINK_AI_ABOUT='https://blog.uuanqin.top/p/75efe9f3/',sparkLite_postSelector=(console.log(MESSAGE_TEMPLATE,LEFT_STYLE,RIGHT_STYLE),'#article-container'),sparkLite_wordLimit=1e3,sparkLite_typingAnimate=!0,sparkLite_postURLs=[],sparkLite_postURLs_regex=[/^https:\\/\\/.*\\.uuanqin\\.top\\/p\\/[0-9a-fA-F]+\\/$/,/^http:\\/\\/localhost:4000\\/p\\/[0-9a-fA-F]+\\/$/],MILLISECONDS_OF_A_WEEK=6048e5,sparkLite_localCacheTime=MILLISECONDS_OF_A_WEEK,initDB=()=>new Promise((resolve,reject)=>{var request=indexedDB.open('SparkLiteDB',1);request.onupgradeneeded=e=>{e=e.target.result;e.objectStoreNames.contains('summaries')||e.createObjectStore('summaries',{keyPath:'url'}).createIndex('timestamp','timestamp',{unique:!1})},request.onsuccess=e=>resolve(e.target.result),request.onerror=e=>reject(e.target.error)}),sparkLiteIsRunning=!1;function insertAIDiv(selector){removeExistingAIDiv();var aiDiv,aiIcon,aiTitleDiv,selector=document.querySelector(selector);selector&&((aiDiv=document.createElement('div')).className='post-SparkLite',(aiTitleDiv=document.createElement('div')).className='sparkLite-title',aiDiv.appendChild(aiTitleDiv),(aiIcon=document.createElement('i')).className='sparkLite-title-icon',aiTitleDiv.appendChild(aiIcon),aiIcon.innerHTML=`<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='48px' height='48px' viewBox='0 0 48 48'>\n  <title>机器人</title>\n  <g id='机器人' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'>\n    <path d='M34.717885,5.03561087 C36.12744,5.27055371 37.079755,6.60373651 36.84481,8.0132786 L35.7944,14.3153359 L38.375,14.3153359 C43.138415,14.3153359 47,18.1768855 47,22.9402569 L47,34.4401516 C47,39.203523 43.138415,43.0650727 38.375,43.0650727 L9.625,43.0650727 C4.861585,43.0650727 1,39.203523 1,34.4401516 L1,22.9402569 C1,18.1768855 4.861585,14.3153359 9.625,14.3153359 L12.2056,14.3153359 L11.15519,8.0132786 C10.920245,6.60373651 11.87256,5.27055371 13.282115,5.03561087 C14.69167,4.80066802 16.024865,5.7529743 16.25981,7.16251639 L17.40981,14.0624532 C17.423955,14.1470924 17.43373,14.2315017 17.43948,14.3153359 L30.56052,14.3153359 C30.56627,14.2313867 30.576045,14.1470924 30.59019,14.0624532 L31.74019,7.16251639 C31.975135,5.7529743 33.30833,4.80066802 34.717885,5.03561087 Z M38.375,19.4902885 L9.625,19.4902885 C7.719565,19.4902885 6.175,21.0348394 6.175,22.9402569 L6.175,34.4401516 C6.175,36.3455692 7.719565,37.89012 9.625,37.89012 L38.375,37.89012 C40.280435,37.89012 41.825,36.3455692 41.825,34.4401516 L41.825,22.9402569 C41.825,21.0348394 40.280435,19.4902885 38.375,19.4902885 Z M14.8575,23.802749 C16.28649,23.802749 17.445,24.9612484 17.445,26.3902253 L17.445,28.6902043 C17.445,30.1191812 16.28649,31.2776806 14.8575,31.2776806 C13.42851,31.2776806 12.27,30.1191812 12.27,28.6902043 L12.27,26.3902253 C12.27,24.9612484 13.42851,23.802749 14.8575,23.802749 Z M33.1425,23.802749 C34.57149,23.802749 35.73,24.9612484 35.73,26.3902253 L35.73,28.6902043 C35.73,30.1191812 34.57149,31.2776806 33.1425,31.2776806 C31.71351,31.2776806 30.555,30.1191812 30.555,28.6902043 L30.555,26.3902253 C30.555,24.9612484 31.71351,23.802749 33.1425,23.802749 Z' id='形状结合' fill='#444444' fill-rule='nonzero'></path>\n  </g>\n  </svg>`,(aiIcon=document.createElement('div')).className='sparkLite-title-text',aiIcon.textContent='AI 摘要',aiTitleDiv.appendChild(aiIcon),(aiIcon=document.createElement('a')).href=LINK_AI_ABOUT,aiIcon.target='_blank',aiIcon.className='sparkLite-about',aiIcon.style.color='var(--ai-summary-lighttext)',aiIcon.id='sparkLite-about',aiIcon.textContent='关于',aiTitleDiv.appendChild(aiIcon),(aiIcon=document.createElement('div')).className='sparkLite-tag',aiIcon.id='sparkLite-tag',aiIcon.textContent='Spark Lite',aiTitleDiv.appendChild(aiIcon),(aiTitleDiv=document.createElement('div')).className='sparkLite-explanation',aiTitleDiv.innerHTML='生成中...<span class=\"blinking-cursor\"></span>',aiDiv.appendChild(aiTitleDiv),selector.insertBefore(aiDiv,selector.firstChild))}function removeExistingAIDiv(){var existingAIDiv=document.querySelector('.post-SparkLite');existingAIDiv&&existingAIDiv.parentElement.removeChild(existingAIDiv)}let sparkLite={fetchSparkLiteSummary:async function(){var url=window.location.href;try{let request=(await initDB()).transaction('summaries','readonly').objectStore('summaries').get(url);var cachedData=await new Promise(resolve=>{request.onsuccess=()=>resolve(request.result),request.onerror=()=>resolve(null)});if(cachedData?.summary)if(!(Date.now()-cachedData.timestamp>sparkLite_localCacheTime))return cachedData.summary}catch(e){console.log('【AI 摘要前端】读取 IndexedDB 缓存失败',e)}cachedData={post_url:url};try{let controller=new AbortController;var timeoutId=setTimeout(()=>controller.abort(),3e4),response=await fetch(PROXY_API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(cachedData),signal:controller.signal}),data=(clearTimeout(timeoutId),await response.json());if(response.ok){try{let db=await initDB(),tx=db.transaction('summaries','readwrite');tx.objectStore('summaries').put({url:url,summary:data.summary,timestamp:Date.now()})}catch(e){console.log('【AI 摘要前端】IndexedDB 写入失败',e)}return data.summary}return console.error('【AI 摘要前端】代理或 API 错误: '+(data.error||response.statusText)),'【AI 摘要前端】获取摘要失败: '+(data.error||'HTTP 状态码: '+response.status)}catch(error){return'AbortError'===error.name?(console.error('【AI 摘要前端】Spark Lite 请求超时 (通过代理)'),'【AI 摘要前端】获取文章摘要超时，请稍后刷新重试。'):(console.error('【AI 摘要前端】Spark Lite 请求失败 (通过代理)：',error),error instanceof SyntaxError?'【AI 摘要前端】获取文章摘要失败：代理服务器响应格式错误。':'【AI 摘要前端】获取文章摘要失败，请检查网络连接或代理服务器状态。')}},aiShowAnimation:function(text){let element=document.querySelector('.sparkLite-explanation');if(!element)return;if(sparkLiteIsRunning)return;if(void 0!==sparkLite_typingAnimate&&!sparkLite_typingAnimate)return void(element.innerHTML=text);sparkLiteIsRunning=!0;element.style.display='block',element.innerHTML='生成中...<span class=\\'blinking-cursor\\'></span>';let animationRunning,currentIndex=0,lastUpdateTime=performance.now(),animate=()=>{var currentTime,timeDiff,letter;currentIndex<text.length&&animationRunning&&(timeDiff=(currentTime=performance.now())-lastUpdateTime,letter=text.slice(currentIndex,currentIndex+1),(/[，。！、？,.!?]/.test(letter)?150:25)<=timeDiff&&(element.innerText=text.slice(0,currentIndex+1),lastUpdateTime=currentTime,++currentIndex<text.length?element.innerHTML=text.slice(0,currentIndex)+'<span class=\"blinking-cursor\"></span>':(element.innerHTML=text,element.style.display='block',sparkLiteIsRunning=!1,observer.disconnect())),requestAnimationFrame(animate))},observer=new IntersectionObserver(entries=>{(animationRunning=entries[0].isIntersecting)&&setTimeout(()=>{requestAnimationFrame(animate)},200)},{threshold:0});var post_ai=document.querySelector('.post-SparkLite');observer.observe(post_ai)}};function runSparkLite(){removeExistingAIDiv(),insertAIDiv(sparkLite_postSelector),sparkLite.fetchSparkLiteSummary().then(summary=>{sparkLite.aiShowAnimation(summary)})}function checkURLAndRun(){if(sparkLiteIsRunning)return!1;if(void 0===sparkLite_postURLs&&void 0===sparkLite_postURLs_regex)return console.log('【AI 摘要前端】没有设置页面链接模板，所以我为每个页面都生成ai摘要.'),!0;try{let regExpEscape=s=>s.replace(/[|\\\\{}()[\\]^$+*?.]/g,'\\\\$&');var currentURL=window.location.href;let urlPattern=[...sparkLite_postURLs.map(s=>new RegExp('^'+s.split(/\\*+/).map(regExpEscape).join('.*')+'$')),...sparkLite_postURLs_regex];return url=currentURL,urlPattern.some(re=>re.test(url))?(console.log('【AI 摘要前端】匹配到了页面URL，将在此页面生成摘要'),!0):(console.log('【AI 摘要前端】因为不符合自定义的链接规则，我决定不执行摘要功能。'),removeExistingAIDiv(),!1)}catch(error){return console.error('【AI 摘要前端】我没有看懂你编写的自定义链接规则...',error),!1}var url}function initializeSparkLite(){document.querySelector(sparkLite_postSelector)?checkURLAndRun()&&runSparkLite():removeExistingAIDiv()}let originalPushState=history.pushState,originalReplaceState=history.replaceState;history.pushState=function(){var result=originalPushState.apply(this,arguments);return window.dispatchEvent(new Event('pushstate')),setTimeout(initializeSparkLite,100),result},history.replaceState=function(){var result=originalReplaceState.apply(this,arguments);return window.dispatchEvent(new Event('replacestate')),setTimeout(initializeSparkLite,100),result},window.addEventListener('popstate',()=>{setTimeout(initializeSparkLite,100)}),document.removeEventListener('DOMContentLoaded',initializeSparkLite),document.addEventListener('DOMContentLoaded',initializeSparkLite);","raw":"// 定义样式常量 - 便于集中管理和修改\nconst LEFT_STYLE = \"color: #fadfa3; background: #030307; padding:5px 0;\";\nconst RIGHT_STYLE = \"background: #fadfa3; padding:5px 0;\";\n\n// 构建消息模板 - 使用多行模板字符串保持视觉结构\nconst MESSAGE_TEMPLATE = `\n %c Spark Lite 文章摘要AI生成 %c https://uuanqin.top/ \n`;\n\nconst PROXY_API_URL = \"https://ai-summary.uuanqin.top/api/ai-summary/spark-lite\"; // 这里填的是 Vercel 的地址\nconst LINK_AI_ABOUT = \"https://blog.uuanqin.top/p/75efe9f3/\"\n\n// 输出格式化控制台消息\nconsole.log(\n    MESSAGE_TEMPLATE,\n    LEFT_STYLE,\n    RIGHT_STYLE\n);\n\n// --- 其他配置 (根据需要调整) ---\nconst sparkLite_postSelector = \"#article-container\"; // 文章内容容器的选择器，例如 #article-container, .post-content\nconst sparkLite_wordLimit = 1000;             // 提交给 API 的最大字数限制\nconst sparkLite_typingAnimate = true;         // 是否启用打字机效果\n// 指定博客文章URL类型，只在这样的界面上生成ai摘要\n// 通配符写法\nconst sparkLite_postURLs = [\n    // \"https://*.uuanqin.top/p/*\",\n    // \"http://localhost:*/p/*\"\n];\n// 正则写法\nconst sparkLite_postURLs_regex = [\n    /^https:\\/\\/.*\\.uuanqin\\.top\\/p\\/[0-9a-fA-F]+\\/$/,\n    /^http:\\/\\/localhost:4000\\/p\\/[0-9a-fA-F]+\\/$/\n];\n\nconst MILLISECONDS_OF_A_WEEK = 7 * 24 * 60 * 60 * 1000;\n\nconst sparkLite_localCacheTime = MILLISECONDS_OF_A_WEEK;\n\nconst initDB = () => {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open('SparkLiteDB', 1);\n\n        request.onupgradeneeded = (e) => {\n            const db = e.target.result;\n            if (!db.objectStoreNames.contains('summaries')) {\n                const store = db.createObjectStore('summaries', {keyPath: 'url'});\n                store.createIndex('timestamp', 'timestamp', {unique: false});\n            }\n        };\n\n        request.onsuccess = (e) => resolve(e.target.result);\n        request.onerror = (e) => reject(e.target.error);\n    });\n};\n\nlet sparkLiteIsRunning = false; // 重命名\n\n// --- insertAIDiv 函数 ---\nfunction insertAIDiv(selector) {\n    // 首先移除现有的 \"post-SparkLite\" 类元素（如果有的话）\n    removeExistingAIDiv(); // 需要同步修改 removeExistingAIDiv 函数选择器\n\n    // 获取目标元素\n    const targetElement = document.querySelector(selector);\n\n    // 如果没有找到目标元素，不执行任何操作\n    if (!targetElement) {\n        return;\n    }\n\n    // 创建要插入的HTML元素\n    const aiDiv = document.createElement('div');\n    aiDiv.className = 'post-SparkLite'; // 修改类名\n\n    const aiTitleDiv = document.createElement('div');\n    aiTitleDiv.className = 'sparkLite-title'; // 修改类名\n    aiDiv.appendChild(aiTitleDiv);\n\n    const aiIcon = document.createElement('i');\n    aiIcon.className = 'sparkLite-title-icon'; // 修改类名\n    aiTitleDiv.appendChild(aiIcon);\n\n    // 插入 SVG 图标 (保持不变或替换)\n    aiIcon.innerHTML = `<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='48px' height='48px' viewBox='0 0 48 48'>\n  <title>机器人</title>\n  <g id='机器人' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'>\n    <path d='M34.717885,5.03561087 C36.12744,5.27055371 37.079755,6.60373651 36.84481,8.0132786 L35.7944,14.3153359 L38.375,14.3153359 C43.138415,14.3153359 47,18.1768855 47,22.9402569 L47,34.4401516 C47,39.203523 43.138415,43.0650727 38.375,43.0650727 L9.625,43.0650727 C4.861585,43.0650727 1,39.203523 1,34.4401516 L1,22.9402569 C1,18.1768855 4.861585,14.3153359 9.625,14.3153359 L12.2056,14.3153359 L11.15519,8.0132786 C10.920245,6.60373651 11.87256,5.27055371 13.282115,5.03561087 C14.69167,4.80066802 16.024865,5.7529743 16.25981,7.16251639 L17.40981,14.0624532 C17.423955,14.1470924 17.43373,14.2315017 17.43948,14.3153359 L30.56052,14.3153359 C30.56627,14.2313867 30.576045,14.1470924 30.59019,14.0624532 L31.74019,7.16251639 C31.975135,5.7529743 33.30833,4.80066802 34.717885,5.03561087 Z M38.375,19.4902885 L9.625,19.4902885 C7.719565,19.4902885 6.175,21.0348394 6.175,22.9402569 L6.175,34.4401516 C6.175,36.3455692 7.719565,37.89012 9.625,37.89012 L38.375,37.89012 C40.280435,37.89012 41.825,36.3455692 41.825,34.4401516 L41.825,22.9402569 C41.825,21.0348394 40.280435,19.4902885 38.375,19.4902885 Z M14.8575,23.802749 C16.28649,23.802749 17.445,24.9612484 17.445,26.3902253 L17.445,28.6902043 C17.445,30.1191812 16.28649,31.2776806 14.8575,31.2776806 C13.42851,31.2776806 12.27,30.1191812 12.27,28.6902043 L12.27,26.3902253 C12.27,24.9612484 13.42851,23.802749 14.8575,23.802749 Z M33.1425,23.802749 C34.57149,23.802749 35.73,24.9612484 35.73,26.3902253 L35.73,28.6902043 C35.73,30.1191812 34.57149,31.2776806 33.1425,31.2776806 C31.71351,31.2776806 30.555,30.1191812 30.555,28.6902043 L30.555,26.3902253 C30.555,24.9612484 31.71351,23.802749 33.1425,23.802749 Z' id='形状结合' fill='#444444' fill-rule='nonzero'></path>\n  </g>\n  </svg>`;\n\n    const aiTitleTextDiv = document.createElement('div');\n    aiTitleTextDiv.className = 'sparkLite-title-text'; // 修改类名\n    aiTitleTextDiv.textContent = 'AI 摘要';\n    aiTitleDiv.appendChild(aiTitleTextDiv);\n\n    const aiAboutLink = document.createElement('a');\n    aiAboutLink.href = LINK_AI_ABOUT;\n    aiAboutLink.target = '_blank'; // 可选：在新标签页打开\n    aiAboutLink.className = 'sparkLite-about'; // 修改类名\n    aiAboutLink.style.color = 'var(--ai-summary-lighttext)'; // 内联样式防止覆写\n    aiAboutLink.id = 'sparkLite-about'; // 修改 ID\n    aiAboutLink.textContent = '关于'; // 修改显示文本\n    aiTitleDiv.appendChild(aiAboutLink);\n\n    const aiTagDiv = document.createElement('div');\n    aiTagDiv.className = 'sparkLite-tag'; // 修改类名\n    aiTagDiv.id = 'sparkLite-tag'; // 修改 ID\n    aiTagDiv.textContent = 'Spark Lite'; // 修改显示文本\n    aiTitleDiv.appendChild(aiTagDiv);\n\n\n    const aiExplanationDiv = document.createElement('div');\n    aiExplanationDiv.className = 'sparkLite-explanation'; // 修改类名\n    aiExplanationDiv.innerHTML = '生成中...' + '<span class=\"blinking-cursor\"></span>';\n    aiDiv.appendChild(aiExplanationDiv);\n\n    // 将创建的元素插入到目标元素的顶部\n    targetElement.insertBefore(aiDiv, targetElement.firstChild);\n}\n\n// --- removeExistingAIDiv 函数 ---\nfunction removeExistingAIDiv() {\n    // 查找具有 \"post-SparkLite\" 类的元素\n    const existingAIDiv = document.querySelector(\".post-SparkLite\"); // 修改选择器\n\n    // 如果找到了这个元素，就从其父元素中删除它\n    if (existingAIDiv) {\n        existingAIDiv.parentElement.removeChild(existingAIDiv);\n    }\n}\n\n\n// --- 主要逻辑对象 ---\nconst sparkLite = { // 重命名对象\n    // --- fetchSparkLiteSummary 函数 (核心修改) ---\n    fetchSparkLiteSummary: async function () {\n        // const title = document.title;\n        const url = window.location.href;\n\n        // 先尝试从IndexedDB读取\n        try {\n            const db = await initDB();\n            const tx = db.transaction('summaries', 'readonly');\n            const store = tx.objectStore('summaries');\n            const request = store.get(url);\n\n            const cachedData = await new Promise((resolve) => {\n                request.onsuccess = () => resolve(request.result);\n                request.onerror = () => resolve(null);\n            });\n\n            if (cachedData?.summary) {\n                // 检查缓存是否过期（7天有效期）\n\n                const isExpired = Date.now() - cachedData.timestamp > sparkLite_localCacheTime;\n                if (!isExpired) {\n                    return cachedData.summary;\n                }\n            }\n        } catch (e) {\n            console.log('【AI 摘要前端】读取 IndexedDB 缓存失败', e);\n        }\n\n        const requestDataToProxy = {post_url: url};// {content: content, title: title};\n        const timeout = 30000;\n\n        try {\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n            const response = await fetch(PROXY_API_URL, {\n                method: 'POST',\n                headers: {'Content-Type': 'application/json'},\n                body: JSON.stringify(requestDataToProxy),\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n            const data = await response.json();\n\n            if (response.ok) {\n                // 成功获取摘要后存入IndexedDB\n                try {\n                    const db = await initDB();\n                    const tx = db.transaction('summaries', 'readwrite');\n                    tx.objectStore('summaries').put({\n                        url: url,\n                        summary: data.summary,\n                        timestamp: Date.now()\n                    });\n                } catch (e) {\n                    console.log('【AI 摘要前端】IndexedDB 写入失败', e);\n                }\n                return data.summary;\n            } else {\n                console.error(`【AI 摘要前端】代理或 API 错误: ${data.error || response.statusText}`);\n                return `【AI 摘要前端】获取摘要失败: ${data.error || `HTTP 状态码: ${response.status}`}`;\n            }\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                console.error('【AI 摘要前端】Spark Lite 请求超时 (通过代理)');\n                return '【AI 摘要前端】获取文章摘要超时，请稍后刷新重试。';\n            } else {\n                console.error('【AI 摘要前端】Spark Lite 请求失败 (通过代理)：', error);\n                if (error instanceof SyntaxError) {\n                    return '【AI 摘要前端】获取文章摘要失败：代理服务器响应格式错误。';\n                }\n                return '【AI 摘要前端】获取文章摘要失败，请检查网络连接或代理服务器状态。';\n            }\n        }\n    },\n\n    // --- aiShowAnimation 函数 ---\n    // 可以修改 console.error 和 element.innerHTML 中的 \"TianliGPT\" 为 \"Spark Lite\"\n    aiShowAnimation: function (text) {\n        const element = document.querySelector(\".sparkLite-explanation\"); // 修改选择器\n        if (!element) {\n            return;\n        }\n\n        if (sparkLiteIsRunning) { // 修改变量名\n            return;\n        }\n\n        // 检查用户是否已定义 sparkLite_typingAnimate\n        if (typeof sparkLite_typingAnimate !== \"undefined\" && !sparkLite_typingAnimate) { // 修改变量名\n            element.innerHTML = text;\n            return;\n        }\n\n        sparkLiteIsRunning = true; // 修改变量名\n        const typingDelay = 25;\n        const waitingTime = 1000;\n        const punctuationDelayMultiplier = 6;\n\n        element.style.display = \"block\";\n        element.innerHTML = `生成中...<span class='blinking-cursor'></span>`;\n\n        let animationRunning = true;\n        let currentIndex = 0;\n        let initialAnimation = true;\n        let lastUpdateTime = performance.now();\n\n        const animate = () => {\n            if (currentIndex < text.length && animationRunning) {\n                const currentTime = performance.now();\n                const timeDiff = currentTime - lastUpdateTime;\n\n                const letter = text.slice(currentIndex, currentIndex + 1);\n                const isPunctuation = /[，。！、？,.!?]/.test(letter);\n                const delay = isPunctuation ? typingDelay * punctuationDelayMultiplier : typingDelay;\n\n                if (timeDiff >= delay) {\n                    element.innerText = text.slice(0, currentIndex + 1);\n                    lastUpdateTime = currentTime;\n                    currentIndex++;\n\n                    if (currentIndex < text.length) {\n                        element.innerHTML =\n                            text.slice(0, currentIndex) +\n                            '<span class=\"blinking-cursor\"></span>';\n                    } else {\n                        element.innerHTML = text;\n                        element.style.display = \"block\";\n                        sparkLiteIsRunning = false; // 修改变量名\n                        observer.disconnect();// 暂停监听\n                    }\n                }\n                requestAnimationFrame(animate);\n            }\n        }\n\n        // 使用IntersectionObserver对象优化ai离开视口后暂停的业务逻辑，提高性能\n        const observer = new IntersectionObserver((entries) => {\n            animationRunning = entries[0].isIntersecting; // 标志变量更新\n            if (animationRunning && initialAnimation) {\n                setTimeout(() => {\n                    requestAnimationFrame(animate);\n                }, 200);\n            }\n        }, {threshold: 0});\n        let post_ai = document.querySelector('.post-SparkLite'); // 修改选择器\n        observer.observe(post_ai);//启动新监听\n    },\n};\n\n// --- runSparkLite 函数 (保持不变) ---\nfunction runSparkLite() { // 重命名函数\n    // 确保在运行前移除可能存在的旧div，防止重复添加\n    removeExistingAIDiv();\n    // 插入新的占位符\n    insertAIDiv(sparkLite_postSelector);\n    // const content = sparkLite.getTitleAndContent(); // 调用重命名后的对象和方法\n    // if (content) {\n    //     // console.log('Spark Lite 本次提交的内容为：' + content); // 修改日志文本\n    // } else {\n    //     // 如果没有获取到内容，可能需要移除占位符或显示错误\n    //     const aiExplanationDiv = document.querySelector(\".sparkLite-explanation\");\n    //     if (aiExplanationDiv) {\n    //         aiExplanationDiv.textContent = '未能获取到文章内容，无法生成摘要。';\n    //     }\n    //     return; // 提前退出，不进行 fetch\n    // }\n    sparkLite.fetchSparkLiteSummary().then(summary => { // 调用重命名后的方法\n        sparkLite.aiShowAnimation(summary); // 调用重命名后的方法\n    });\n}\n\n// --- checkURLAndRun 函数 (稍微调整，主要负责URL检查) ---\nfunction checkURLAndRun() {\n    // 检查 AI 是否已在运行，防止重复启动动画等\n    if (sparkLiteIsRunning) {\n        return false; // 返回 false 表示不应继续执行\n    }\n    // 检查 AI 容器是否已存在 (如果存在，理论上不应再次运行完整流程，除非是内容更新)\n    // 为简化逻辑，我们允许它继续，runSparkLite内部会处理移除和重新插入\n    // if (document.querySelector(\".post-SparkLite\")) {\n    //     return false;\n    // }\n\n    // URL 检查逻辑\n    if (typeof sparkLite_postURLs === \"undefined\" && typeof sparkLite_postURLs_regex === \"undefined\") {\n        console.log(\"【AI 摘要前端】没有设置页面链接模板，所以我为每个页面都生成ai摘要.\");\n        return true; // 返回 true 表示检查通过，可以运行\n    }\n\n    try {\n        const regExpEscape = (s) => {\n            return s.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n        };\n        const wildcardToRegExp = (s) => {\n            return new RegExp('^' + s.split(/\\*+/).map(regExpEscape).join('.*') + '$');\n        };\n\n        const currentURL = window.location.href;\n\n        const customPattern = sparkLite_postURLs.map(wildcardToRegExp);\n        const urlPattern = [...customPattern, ...(sparkLite_postURLs_regex)];\n\n        // 测试某个 URL 是否匹配任意一个规则\n        const testURL = (url) => {\n            return urlPattern.some(re => re.test(url));\n        };\n\n        if (testURL(currentURL)) {\n            console.log(\"【AI 摘要前端】匹配到了页面URL，将在此页面生成摘要\");\n            return true; // URL匹配，检查通过\n        } else {\n            console.log(\"【AI 摘要前端】因为不符合自定义的链接规则，我决定不执行摘要功能。\");\n            removeExistingAIDiv(); // 如果URL不匹配了，移除可能存在的旧AI框\n            return false; // URL不匹配，检查不通过\n        }\n    } catch (error) {\n        console.error(\"【AI 摘要前端】我没有看懂你编写的自定义链接规则...\", error);\n        return false; // 出错，检查不通过\n    }\n}\n\n// --- 新增：统一的初始化入口函数 ---\nfunction initializeSparkLite() {\n    // 1. 检查文章容器是否存在\n    const targetElement = document.querySelector(sparkLite_postSelector);\n    if (!targetElement) {\n        // console.log(\"Spark Lite: Target post selector not found.\");\n        removeExistingAIDiv(); // 确保目标容器不在时，AI框也被移除\n        return;\n    }\n\n    // 2. 执行URL和运行状态检查\n    if (checkURLAndRun()) {\n        // 3. 如果检查通过，执行核心逻辑\n        // console.log(\"Spark Lite: Initialization checks passed, running...\");\n        runSparkLite();\n    } else {\n        // console.log(\"Spark Lite: Initialization checks failed (URL mismatch or already running).\");\n    }\n}\n\n\n// --- Event Listeners (使用新的初始化函数) ---\n\n// 确保在移除旧监听器（如果可能）后添加新的\n// （在简单脚本场景下通常不需要移除，但这是良好实践）\n\n// --- 增强路由变化监听 ---\n\n// 保存原始的 pushState 和 replaceState 方法\nconst originalPushState = history.pushState;\nconst originalReplaceState = history.replaceState;\n\n// 包装 pushState\nhistory.pushState = function () {\n    // 调用原始方法\n    const result = originalPushState.apply(this, arguments);\n    // 创建并触发自定义事件，表明 URL 可能已更改\n    window.dispatchEvent(new Event('pushstate'));\n    // 触发我们的初始化函数\n    // 使用 setTimeout 确保在 DOM 更新后执行\n    setTimeout(initializeSparkLite, 100);\n    return result;\n};\n\n// 包装 replaceState\nhistory.replaceState = function () {\n    // 调用原始方法\n    const result = originalReplaceState.apply(this, arguments);\n    // 创建并触发自定义事件，表明 URL 可能已更改\n    window.dispatchEvent(new Event('replacestate'));\n    // 触发我们的初始化函数\n    // 使用 setTimeout 确保在 DOM 更新后执行\n    setTimeout(initializeSparkLite, 100);\n    return result;\n};\n\n// 监听 popstate 事件 (浏览器前进/后退按钮)\nwindow.addEventListener('popstate', () => {\n    // 触发我们的初始化函数\n    // 使用 setTimeout 确保在 DOM 更新后执行\n    setTimeout(initializeSparkLite, 100);\n});\n\n// --- (确保之前的事件监听器仍然存在) ---\n// 初始加载\ndocument.removeEventListener(\"DOMContentLoaded\", initializeSparkLite); // 避免重复添加\ndocument.addEventListener(\"DOMContentLoaded\", initializeSparkLite);\n\n\n"},"api":"api/pages/unused.json"}