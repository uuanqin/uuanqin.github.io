{"data":{"title":"线段树模板的理解和使用","slug":"算法与数据结构/线段树模板的理解和使用","description":"想好了再用，不然浪费时间。","date":"2025-01-01T19:08:58.000Z","updated":"2025-08-27T14:50:54.772Z","language":"zh-CN","comments":true,"url":"p/10ab676/","cover":"https://cdn.gallery.uuanqin.top/img/202508270057686.webp","images":[],"content":"<h1 id=\"线段树简述\"><a class=\"markdownIt-Anchor\" href=\"#线段树简述\"></a> 线段树简述</h1>\n<p>线段树是用来维护 区间信息 的数据结构。<strong>线段树的每个节点代表一个区间</strong>。</p>\n<p>线段树可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>\n<h1 id=\"线段树的模板\"><a class=\"markdownIt-Anchor\" href=\"#线段树的模板\"></a> 线段树的模板</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">模板题：求给定区间的区间和（多次询问）</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>线段树中，区间的范围给定之后，树的结点就固定了。</p>\n<h2 id=\"使用链表表示线段树\"><a class=\"markdownIt-Anchor\" href=\"#使用链表表示线段树\"></a> 使用链表表示线段树</h2>\n<p>预先定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> val,add;</span><br><span class=\"line\">\tNode left,right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Node</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(); <span class=\"comment\">// 预先定义好树根</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> <span class=\"number\">1000000000</span>;     <span class=\"comment\">// 题目中可能出现的范围</span></span><br></pre></td></tr></table></figure>\n<p>线段树的构建模板写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildTree</span><span class=\"params\">(Node node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 到达叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">        node.val = arr[start];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.left==<span class=\"literal\">null</span>)node.left=<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.right==<span class=\"literal\">null</span>)node.right=<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start + end) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    buildTree(node.left, start, mid);</span><br><span class=\"line\">    buildTree(node.right, mid + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">    <span class=\"comment\">// 向上更新</span></span><br><span class=\"line\">    pushUp(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 向上更新</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushUp</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">    node.val = node.left.val + node.right.val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线段树动态开点模板写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 动态开点</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SegmentTreeDynamic</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 结点表示</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        Node left, right; <span class=\"comment\">// 左右指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> val; <span class=\"comment\">// 结点的值，意思为此节点锁表示区间的区间和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> add; <span class=\"comment\">// 懒惰标记，意思是此节点的子结点的每个元素的值都要加上 add</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) <span class=\"number\">1e9</span>; <span class=\"comment\">// 区间范围，一般由题目给出</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Node</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(); <span class=\"comment\">// 根结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 区间更新</span></span><br><span class=\"line\">\t<span class=\"comment\">// 将[start,end]当前结点的所有元素加上 val</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Node node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前结点已经满足更新范围</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class=\"line\">            node.val += (end - start + <span class=\"number\">1</span>) * val;</span><br><span class=\"line\">            node.add += val;</span><br><span class=\"line\">            <span class=\"comment\">// 子节点就不再递归，实现了「懒惰」</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start + end) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        pushDown(node, mid - start + <span class=\"number\">1</span>, end - mid); <span class=\"comment\">// 清空当前结点懒惰标记</span></span><br><span class=\"line\">        <span class=\"comment\">// 表明查询区间和左子区间有交集</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt;= mid) update(node.left, start, mid, l, r, val);</span><br><span class=\"line\">        <span class=\"comment\">// 表明查询区间和右子区间有交集</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mid + <span class=\"number\">1</span> &lt;= r) update(node.right, mid + <span class=\"number\">1</span>, end, l, r, val);</span><br><span class=\"line\">        pushUp(node); <span class=\"comment\">// 更新当前结点的区间值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">query</span><span class=\"params\">(Node node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class=\"keyword\">return</span> node.val;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start + end) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        pushDown(node, mid - start + <span class=\"number\">1</span>, end - mid);</span><br><span class=\"line\">        <span class=\"comment\">// 表明查询区间和左子区间有交集</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt;= mid) ans += query(node.left, start, mid, l, r); </span><br><span class=\"line\">        <span class=\"comment\">// 表明查询区间和右子区间有交集</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mid + <span class=\"number\">1</span> &lt;= r) ans += query(node.right, mid + <span class=\"number\">1</span>, end, l, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushUp</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">        node.val = node.left.val + node.right.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 结点下推</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushDown</span><span class=\"params\">(Node node, <span class=\"type\">int</span> leftNum, <span class=\"type\">int</span> rightNum)</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 子节点建立检查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) node.left = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) node.right = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.add == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ; <span class=\"comment\">// 没有懒惰标记，无需处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理懒惰标记</span></span><br><span class=\"line\">        node.left.val += node.add * leftNum;</span><br><span class=\"line\">        node.right.val += node.add * rightNum;</span><br><span class=\"line\">        node.left.add += node.add;  <span class=\"comment\">// 累积懒惰标记</span></span><br><span class=\"line\">        node.right.add += node.add;</span><br><span class=\"line\">        node.add = <span class=\"number\">0</span>;               <span class=\"comment\">// 清空懒惰标记，表示处理完毕</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，不管是 <code>update</code>，还是 <code>query</code>，在进行下层递归时都是使用 <code>[start, mid]</code> 和 <code>[mid + 1, end]</code>。它表示数的当前结点表示的区间范围。</p>\n<p>递归时，不管是 <code>update</code>，还是 <code>query</code>，<code>[l,r]</code> 表示查询区间，参数传递时是不变的。不要自行分割区间，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (l &lt;= mid) update(node.left, start, mid, l, mid, val);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid + <span class=\"number\">1</span> &lt;= r) update(node.right, mid + <span class=\"number\">1</span>, end, mid+<span class=\"number\">1</span>, r, val);</span><br><span class=\"line\"><span class=\"comment\">// 更正写法（按照自行分割的思路）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (l &lt;= mid) update(node.left,start,mid,l,r&gt;=mid?mid:r,val);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mid + <span class=\"number\">1</span> &lt;= r) update(node.right,mid+<span class=\"number\">1</span>,end,l&lt;=mid+<span class=\"number\">1</span>?mid+<span class=\"number\">1</span>:l,r,val);</span><br></pre></td></tr></table></figure>\n<p>上面的做法是错误的，因为你可能会把查询的区间扩大了，也就是说，上面的代码没有考虑到 <code>r&lt;mid</code> 或 <code>l&gt;mid+1</code> 的情况。</p>\n<p>递归时的终止条件中，我们并没有检查 <code>start &lt;= end</code>，即不考虑 <code>start &gt; end</code> 的情况，那么 <code>update</code>，还是 <code>query</code> 在递归过程中传入的参数会出现 <code>start &gt; end</code> 吗？答案是不会的。推导 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 如下：</p>\n<ul>\n<li>因为本层传入 <code>start &gt; end</code> 只有在上一层有 <code>start==end</code> 并计算 <code>mid=(start+end)/2;</code> 时，对右子区间递归时才可能出现。</li>\n<li>然而如果上一层传入的参数 <code>start==end</code>，那么必有 <code>l &lt;= start &amp;&amp; end &lt;= r</code>，它只会在第一个条件判断语句（边界条件）中跳出递归，不会进行后续的 <code>mid</code> 计算，更无下一层的递归。</li>\n<li>因此不会出现传过来的参数 <code>start &gt; end</code>。</li>\n</ul>\n<p>对于终止条件的风格，还有以下这种，两者是等价的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Node node, <span class=\"type\">int</span> start,<span class=\"type\">int</span> end,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> val)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r&lt;start || l&gt; end)<span class=\"keyword\">return</span>; <span class=\"comment\">// 查询区间与当前区间无交集</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;= start &amp;&amp; end &lt;= r)&#123;</span><br><span class=\"line\">\t\tnode.val += val * ( end-start+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tnode.add += val;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start+end)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\tpushDown(node,mid-start+<span class=\"number\">1</span>,end-mid);</span><br><span class=\"line\">\tupdate(node.left,start,mid,l,r,val);   <span class=\"comment\">// 移除了前面的判断条件</span></span><br><span class=\"line\">\tupdate(node.right,mid+<span class=\"number\">1</span>,end,l,r,val);  <span class=\"comment\">// 移除了前面的判断条件</span></span><br><span class=\"line\">\tpushUp(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在不同的题目中，<code>val</code> 和 <code>add</code> 可以扮演不同的角色，比如区间和或者区间最值。这时候就需要根据题目要求修改 <code>val</code> 和 <code>add</code> 的计算代码。</p>\n<h2 id=\"使用数组表示线段树\"><a class=\"markdownIt-Anchor\" href=\"#使用数组表示线段树\"></a> 使用数组表示线段树</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202501070206417.webp\" alt=\"image.png\" width=\"350px\" /></p>\n\n<div class=\"callout\" data-callout=\"node\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">堆式存储</div>\n</div>\n<div class=\"callout-content\"><p>我们知道，（二叉）堆的逻辑结构是树形的，但其存储结构是数组。树根编号为 1。假设某结点的编号为 <code>p</code>，则其左孩子的编号为 <code>2p</code>，右孩子编号为 <code>2p+1</code>。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202501070213296.webp\" alt=\"image.png\" width=\"250px\" /></p>\n<p>代码写法：父结点编号 p，左子节点编号 <code>p&lt;&lt;1</code>，右子节点编号 <code>p&lt;&lt;1|1</code>。注意，不建议使用移位运算配合加号使用，因为加号优先级更高，因此需要引入额外的括号。</p>\n</div></div>\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">优先级的记忆口诀：<strong>单算移关与，异或逻条赋</strong></div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>括号级别最高，逗号级别最低，单目 &gt; 算术 &gt; 位移 &gt; 关系 &gt; 逻辑 &gt; 三目 &gt; 赋值。</p>\n</div></details><p>就是把原先在链式结构中 <code>Node</code> 的属性值变为数组即可。注意取的数组大小至少为 <code>4N</code>，如果题目中所需的 <code>N</code> 过大可能会导致内存超限。</p>\n\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">关于使用堆式存储时数组大小设置成 <code>4N</code> 的原因</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>关于线段树的空间：如果采用堆式存储，若有 n 个叶子结点，则 d 数组的范围最大为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{\\left\\lceil\\log{n}\\right\\rceil+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p>分析：容易知道线段树的深度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\left\\lceil\\log{n}\\right\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⌈</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⌉</span></span></span></span></span> 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{\\left\\lceil\\log{n}\\right\\rceil}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span></span></span></span></span></span></span></span></span></span></span></span> 个，又由于其为一棵完全二叉树，则其总节点个数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9713299999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。当然如果你懒得计算的话可以直接把数组长度设为 4n，因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><msup><mn>2</mn><mrow><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1}{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.4157em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0707em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9667142857142857em;\"><span style=\"top:-2.966714285714285em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5357142857142856em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.24533333333333335em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 的最大值在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>x</mi></msup><mo>+</mo><mn>1</mn><mo stretchy=\"false\">(</mo><mi>x</mi><mo>∈</mo><msub><mi>N</mi><mo lspace=\"0em\" rspace=\"0em\">+</mo></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n=2^{x}+1(x\\in N_{+})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.747722em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">+</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 时取到，此时节点数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mrow><mi>x</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>4</mn><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1=2^{x+2}-1=4n-5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9713299999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span>。</p>\n<p>而堆式存储存在无用的叶子节点，可以考虑使用内存池管理线段树节点，每当需要新建节点时从池中获取。自底向上考虑，必有每两个底层节点合并为一个上层节点，因此可以类似哈夫曼树地证明，如果有 n 个叶子节点，这样的线段树总共有 2n-1 个节点。其空间效率优于堆式存储，并且是可能的最优情况。</p>\n</div></details><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> N;</span><br><span class=\"line\"><span class=\"type\">int</span>[] vals ,adds; <span class=\"comment\">// 大小为 4 N</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">build</span><span class=\"params\">(<span class=\"type\">int</span> nodeId,<span class=\"type\">int</span> start,<span class=\"type\">int</span> end)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(start==end)&#123;</span><br><span class=\"line\">\t\tvals[nodeId]=nums[start];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid= (start+end)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\tbuild(nodeId&lt;&lt;<span class=\"number\">1</span>,start,mid);</span><br><span class=\"line\">\tbuild(nodeId&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,end);</span><br><span class=\"line\">\tpushUp(nodeId);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"type\">int</span> nodeId, <span class=\"type\">int</span> start,<span class=\"type\">int</span> end,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> val)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;= start &amp;&amp; end &lt;= r)&#123;</span><br><span class=\"line\">\t\tvals[nodeId] += val * ( end-start+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tadds[nodeId] += val;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start+end)/<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpushDown(nodeId,mid-start+<span class=\"number\">1</span>,end-mid);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=mid)update(nodeId&lt;&lt;<span class=\"number\">1</span>,start,mid,l,r,val);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span>&lt;=r)update(nodeId&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,end,l,r,val);</span><br><span class=\"line\">\tpushUp(nodeId);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushUp</span><span class=\"params\">(<span class=\"type\">int</span> nodeId)</span>&#123;</span><br><span class=\"line\">\tvals[nodeId] = vals[nodeId&lt;&lt;<span class=\"number\">1</span>]+ vals[nodeId&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushDown</span><span class=\"params\">(<span class=\"type\">int</span> nodeId,<span class=\"type\">int</span> leftNum,<span class=\"type\">int</span> rightNum)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(adds[nodeId]==<span class=\"number\">0</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tvals[nodeId&lt;&lt;<span class=\"number\">1</span>]+=adds[nodeId]*leftNum;</span><br><span class=\"line\">\tvals[nodeId&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+=adds[nodeId]*rightNum;</span><br><span class=\"line\">\tadds[nodeId&lt;&lt;<span class=\"number\">1</span>]+=adds[nodeId];</span><br><span class=\"line\">\tadds[nodeId&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+=adds[nodeId];</span><br><span class=\"line\">\tadds[nodeId]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">query</span><span class=\"params\">(<span class=\"type\">int</span> nodeId,<span class=\"type\">int</span> start , <span class=\"type\">int</span> end,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> vals[nodeId];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start+end)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tpushDown(nodeId,mid-start+<span class=\"number\">1</span>,end-mid);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=mid)ans+=query(nodeId&lt;&lt;<span class=\"number\">1</span>,start,mid,l,r);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span>&lt;=r)ans+=query(nodeId&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,end,l,r);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>相关题目：🟨 <a href=\"https://leetcode.cn/problems/range-sum-query-mutable/\">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></p>\n</blockquote>\n<h1 id=\"什么情况下用动态开点线段树\"><a class=\"markdownIt-Anchor\" href=\"#什么情况下用动态开点线段树\"></a> 什么情况下用动态开点线段树？</h1>\n<p>如果只是需要一次构建并求出结果，就使用一次归并的思路解决（写 <code>build</code> 函数即可）。</p>\n<p>如果是多次更新与查询混合交替（在 LeetCode 中这种题目一般是叫你补充完整一个类），那就使用动态开点和懒惰标记模板，写一个完整的线段树。</p>\n<p>根据题目实际情况，两个模板按需默写。比如在这些题目中：</p>\n<ul>\n<li>只需要默写动态开点模板\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/my-calendar-i/description/\">729. 我的日程安排表 I - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/my-calendar-ii/\">731. 我的日程安排表 II - 力扣（LeetCode）</a></li>\n<li>🟥 <a href=\"https://leetcode.cn/problems/my-calendar-iii/\">732. 我的日程安排表 III - 力扣（LeetCode）</a></li>\n</ul>\n</li>\n<li>需要从头到尾构建一棵完整的线段树\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/maximum-subarray/description/\">53. 最大子数组和 - 力扣（LeetCode）</a>。题解可参考 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/19c8c246/\"><span class=\"bilink-pop-up\">站内文章</span>本文</a> 中线段树的解法。</li>\n</ul>\n</li>\n<li>需要从头到尾构建一棵完整的线段树，再动态更新\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/range-sum-query-mutable/description/\">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>⭐主要参考/推荐阅读：<a href=\"https://lfool.github.io/LFool-Notes/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3.html\">线段树详解 - Lfool</a></li>\n<li>我的 408 笔记</li>\n<li><a href=\"https://oiwiki.org/ds/seg/\">线段树 - OI Wiki</a></li>\n<li><a href=\"https://blog.csdn.net/feifuzeng/article/details/108862001\">Java运算符及运算符的优先级_java运算符优先级-CSDN博客</a></li>\n</ul>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>尝试将上面的话抽象为命题并用形式语言证明？一点点参考：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/cd939534/\"><span class=\"bilink-pop-up\">站内文章</span>你真的弄懂假言判断（条件命题）了吗？</a>。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","raw":"---\ntitle: 线段树模板的理解和使用\ntags:\n  - Java\n  - 线段树\n  - 递归\ncover: 'https://cdn.gallery.uuanqin.top/img/202508270057686.webp'\ndescription: 想好了再用，不然浪费时间。\ncategories:\n  - 算法与数据结构\nabbrlink: 10ab676\ndate: 2025-01-02 03:08:58\ntop_img:\nkatex: true\n---\n\n# 线段树简述\n\n线段树是用来维护 区间信息 的数据结构。**线段树的每个节点代表一个区间**。\n\n线段树可以在 $O(\\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。\n\n# 线段树的模板\n\n> [!example] 模板题：求给定区间的区间和（多次询问）\n\n线段树中，区间的范围给定之后，树的结点就固定了。\n\n## 使用链表表示线段树\n\n预先定义：\n\n```java\nclass Node{\n\tint val,add;\n\tNode left,right;\n}\nNode root = new Node(); // 预先定义好树根\nint N = 1000000000;     // 题目中可能出现的范围\n```\n\n线段树的构建模板写法：\n\n```java\npublic void buildTree(Node node, int start, int end) {\n    // 到达叶子节点\n    if (start == end) {\n        node.val = arr[start];\n        return ;\n    }\n    if(node.left==null)node.left=new Node();\n    if(node.right==null)node.right=new Node();\n    int mid = (start + end) >> 1;\n    buildTree(node.left, start, mid);\n    buildTree(node.right, mid + 1, end);\n    // 向上更新\n    pushUp(node);\n}\n// 向上更新\nprivate void pushUp(Node node) {\n    node.val = node.left.val + node.right.val;\n}\n```\n\n线段树动态开点模板写法：\n\n```java\n// 动态开点\npublic class SegmentTreeDynamic {\n\t// 结点表示\n    class Node {\n        Node left, right; // 左右指针\n        int val; // 结点的值，意思为此节点锁表示区间的区间和\n        int add; // 懒惰标记，意思是此节点的子结点的每个元素的值都要加上 add\n    }\n    private int N = (int) 1e9; // 区间范围，一般由题目给出\n    private Node root = new Node(); // 根结点\n\n\t// 区间更新\n\t// 将[start,end]当前结点的所有元素加上 val\n    public void update(Node node, int start, int end, int l, int r, int val) {\n        // 当前结点已经满足更新范围\n        if (l <= start && end <= r) {\n            node.val += (end - start + 1) * val;\n            node.add += val;\n            // 子节点就不再递归，实现了「懒惰」\n            return ;\n        }\n        int mid = (start + end) >> 1;\n        pushDown(node, mid - start + 1, end - mid); // 清空当前结点懒惰标记\n        // 表明查询区间和左子区间有交集\n        if (l <= mid) update(node.left, start, mid, l, r, val);\n        // 表明查询区间和右子区间有交集\n        if (mid + 1 <= r) update(node.right, mid + 1, end, l, r, val);\n        pushUp(node); // 更新当前结点的区间值\n    }\n    public int query(Node node, int start, int end, int l, int r) {\n        if (l <= start && end <= r) return node.val;\n        int mid = (start + end) >> 1;\n        int ans = 0;\n        pushDown(node, mid - start + 1, end - mid);\n        // 表明查询区间和左子区间有交集\n        if (l <= mid) ans += query(node.left, start, mid, l, r); \n        // 表明查询区间和右子区间有交集\n        if (mid + 1 <= r) ans += query(node.right, mid + 1, end, l, r);\n        return ans;\n    }\n    private void pushUp(Node node) {\n        node.val = node.left.val + node.right.val;\n    }\n\n\t// 结点下推\n    private void pushDown(Node node, int leftNum, int rightNum) {\n\t    // 子节点建立检查\n        if (node.left == null) node.left = new Node();\n        if (node.right == null) node.right = new Node();\n        if (node.add == 0) return ; // 没有懒惰标记，无需处理\n\n\t\t// 处理懒惰标记\n        node.left.val += node.add * leftNum;\n        node.right.val += node.add * rightNum;\n        node.left.add += node.add;  // 累积懒惰标记\n        node.right.add += node.add;\n        node.add = 0;               // 清空懒惰标记，表示处理完毕\n    }\n}\n```\n\n从上面的代码可以看出，不管是 `update`，还是 `query`，在进行下层递归时都是使用 `[start, mid]` 和 `[mid + 1, end]`。它表示数的当前结点表示的区间范围。\n\n递归时，不管是 `update`，还是 `query`，`[l,r]` 表示查询区间，参数传递时是不变的。不要自行分割区间，如：\n\n```java\n// 错误写法\nif (l <= mid) update(node.left, start, mid, l, mid, val);\nif (mid + 1 <= r) update(node.right, mid + 1, end, mid+1, r, val);\n// 更正写法（按照自行分割的思路）\nif (l <= mid) update(node.left,start,mid,l,r>=mid?mid:r,val);\nif (mid + 1 <= r) update(node.right,mid+1,end,l<=mid+1?mid+1:l,r,val);\n```\n\n上面的做法是错误的，因为你可能会把查询的区间扩大了，也就是说，上面的代码没有考虑到 `r<mid` 或 `l>mid+1` 的情况。\n\n递归时的终止条件中，我们并没有检查 `start <= end`，即不考虑 `start > end` 的情况，那么 `update`，还是 `query` 在递归过程中传入的参数会出现 `start > end` 吗？答案是不会的。推导 [^ls] 如下：\n\n- 因为本层传入 `start > end` 只有在上一层有 `start==end` 并计算 `mid=(start+end)/2;` 时，对右子区间递归时才可能出现。\n- 然而如果上一层传入的参数 `start==end`，那么必有 `l <= start && end <= r`，它只会在第一个条件判断语句（边界条件）中跳出递归，不会进行后续的 `mid` 计算，更无下一层的递归。\n- 因此不会出现传过来的参数 `start > end`。\n\n[^ls]: 尝试将上面的话抽象为命题并用形式语言证明？一点点参考：[[你真的弄懂假言判断（条件命题）了吗？]]。\n\n对于终止条件的风格，还有以下这种，两者是等价的：\n\n```java\npublic void update(Node node, int start,int end,int l,int r,int val){\n\tif(r<start || l> end)return; // 查询区间与当前区间无交集\n\tif(l<= start && end <= r){\n\t\tnode.val += val * ( end-start+1);\n\t\tnode.add += val;\n\t\treturn ;\n\t}\n\tint mid = (start+end)/2;\n\tpushDown(node,mid-start+1,end-mid);\n\tupdate(node.left,start,mid,l,r,val);   // 移除了前面的判断条件\n\tupdate(node.right,mid+1,end,l,r,val);  // 移除了前面的判断条件\n\tpushUp(node);\n}\n```\n\n在不同的题目中，`val` 和 `add` 可以扮演不同的角色，比如区间和或者区间最值。这时候就需要根据题目要求修改 `val` 和 `add` 的计算代码。\n\n## 使用数组表示线段树\n\n![image.png|350](https://cdn.gallery.uuanqin.top/img/202501070206417.webp)\n\n> [!node] 堆式存储\n> 我们知道，（二叉）堆的逻辑结构是树形的，但其存储结构是数组。树根编号为 1。假设某结点的编号为 `p`，则其左孩子的编号为 `2p`，右孩子编号为 `2p+1`。\n>\n> ![image.png|250](https://cdn.gallery.uuanqin.top/img/202501070213296.webp)\n>\n>\n> 代码写法：父结点编号 p，左子节点编号 `p<<1`，右子节点编号 `p<<1|1`。注意，不建议使用移位运算配合加号使用，因为加号优先级更高，因此需要引入额外的括号。\n\n> [!note]- 优先级的记忆口诀：**单算移关与，异或逻条赋**\n> 括号级别最高，逗号级别最低，单目 > 算术 > 位移 > 关系 > 逻辑 > 三目 > 赋值。\n\n就是把原先在链式结构中 `Node` 的属性值变为数组即可。注意取的数组大小至少为 `4N`，如果题目中所需的 `N` 过大可能会导致内存超限。\n\n> [!note]- 关于使用堆式存储时数组大小设置成 `4N` 的原因\n> 关于线段树的空间：如果采用堆式存储，若有 n 个叶子结点，则 d 数组的范围最大为 $2^{\\left\\lceil\\log{n}\\right\\rceil+1}$。\n>\n> 分析：容易知道线段树的深度是 $\\left\\lceil\\log{n}\\right\\rceil$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^{\\left\\lceil\\log{n}\\right\\rceil}$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1$。当然如果你懒得计算的话可以直接把数组长度设为 4n，因为 $\\frac{2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1}{n}$ 的最大值在 $n=2^{x}+1(x\\in N_{+})$ 时取到，此时节点数为 $2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1=2^{x+2}-1=4n-5$。\n>\n> 而堆式存储存在无用的叶子节点，可以考虑使用内存池管理线段树节点，每当需要新建节点时从池中获取。自底向上考虑，必有每两个底层节点合并为一个上层节点，因此可以类似哈夫曼树地证明，如果有 n 个叶子节点，这样的线段树总共有 2n-1 个节点。其空间效率优于堆式存储，并且是可能的最优情况。\n\n```java\nint N;\nint[] vals ,adds; // 大小为 4 N\n\npublic void build(int nodeId,int start,int end){\n\tif(start==end){\n\t\tvals[nodeId]=nums[start];\n\t\treturn;\n\t}\n\tint mid= (start+end)/2;\n\tbuild(nodeId<<1,start,mid);\n\tbuild(nodeId<<1|1,mid+1,end);\n\tpushUp(nodeId);\n}\n\npublic void update(int nodeId, int start,int end,int l,int r,int val){\n\tif(l<= start && end <= r){\n\t\tvals[nodeId] += val * ( end-start+1);\n\t\tadds[nodeId] += val;\n\t\treturn ;\n\t}\n\tint mid = (start+end)/2;\n\n\tpushDown(nodeId,mid-start+1,end-mid);\n\tif(l<=mid)update(nodeId<<1,start,mid,l,r,val);\n\tif(mid+1<=r)update(nodeId<<1|1,mid+1,end,l,r,val);\n\tpushUp(nodeId);\n}\n\npublic void pushUp(int nodeId){\n\tvals[nodeId] = vals[nodeId<<1]+ vals[nodeId<<1|1];\n}\n\npublic void pushDown(int nodeId,int leftNum,int rightNum){\n\tif(adds[nodeId]==0)return;\n\tvals[nodeId<<1]+=adds[nodeId]*leftNum;\n\tvals[nodeId<<1|1]+=adds[nodeId]*rightNum;\n\tadds[nodeId<<1]+=adds[nodeId];\n\tadds[nodeId<<1|1]+=adds[nodeId];\n\tadds[nodeId]=0;\n}\n\npublic int query(int nodeId,int start , int end,int l,int r){\n\tif(l<=start&&end<=r){ \n\t\treturn vals[nodeId];\n\t}\n\tint mid = (start+end)/2;\n\tint ans=0;\n\tpushDown(nodeId,mid-start+1,end-mid);\n\tif(l<=mid)ans+=query(nodeId<<1,start,mid,l,r);\n\tif(mid+1<=r)ans+=query(nodeId<<1|1,mid+1,end,l,r);\n\treturn ans;\n}\n```\n\n> 相关题目：🟨 [307. 区域和检索 - 数组可修改 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-mutable/)\n\n# 什么情况下用动态开点线段树？\n\n如果只是需要一次构建并求出结果，就使用一次归并的思路解决（写 `build` 函数即可）。\n\n如果是多次更新与查询混合交替（在 LeetCode 中这种题目一般是叫你补充完整一个类），那就使用动态开点和懒惰标记模板，写一个完整的线段树。\n\n根据题目实际情况，两个模板按需默写。比如在这些题目中：\n\n- 只需要默写动态开点模板\n\t- 🟨 [729. 我的日程安排表 I - 力扣（LeetCode）](https://leetcode.cn/problems/my-calendar-i/description/)\n\t- 🟨 [731. 我的日程安排表 II - 力扣（LeetCode）](https://leetcode.cn/problems/my-calendar-ii/)\n\t- 🟥 [732. 我的日程安排表 III - 力扣（LeetCode）](https://leetcode.cn/problems/my-calendar-iii/)\n- 需要从头到尾构建一棵完整的线段树\n\t- 🟨 [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)。题解可参考 [[最大子数组问题|本文]] 中线段树的解法。\n- 需要从头到尾构建一棵完整的线段树，再动态更新\n\t- 🟨 [307. 区域和检索 - 数组可修改 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-mutable/description/)\n\n# 本文参考\n\n- ⭐主要参考/推荐阅读：[线段树详解 - Lfool](https://lfool.github.io/LFool-Notes/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3.html)\n- 我的 408 笔记\n- [线段树 - OI Wiki](https://oiwiki.org/ds/seg/)\n- [Java运算符及运算符的优先级_java运算符优先级-CSDN博客](https://blog.csdn.net/feifuzeng/article/details/108862001)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"线段树","api":"api/tags/线段树.json"},{"name":"递归","api":"api/tags/递归.json"}]},"api":"api/posts/p/10ab676.json"}