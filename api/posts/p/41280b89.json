{"data":{"title":"买卖股票的最佳时机","slug":"算法与数据结构/买卖股票的最佳时机","description":"掌握一次遍历与动态规划。","date":"2024-09-11T17:35:51.000Z","updated":"2026-02-01T08:24:46.536Z","language":"zh-CN","comments":true,"url":"p/41280b89/","cover":"https://cdn.gallery.uuanqin.top/img/202409030402919.webp","images":[],"content":"<p>今天带来的是 LeetCode 的所有买卖股票最佳时机的系列题，这些题目也是「状态机动态规划」的经典题目。</p>\n<p>在这篇文章中，可以熟练一次遍历思想以及单维、多维动态规划。</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">基本题干：买卖股票的最佳时机</div>\n</div>\n<div class=\"callout-content\"><p>给定一个数组 <code>prices</code> ，它的第 i 个元素 <code>prices[i]</code> 表示一支给定股票第 i 天的价格。</p>\n<p>1 次股票买卖定义为：选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。</p>\n<p>你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n<p>设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>\n<p>提示：<code>prices.length&gt;=1</code></p>\n</div></div><p>下文中出现的买卖股票的问题都是基于此题干进行条件设置。</p>\n<h1 id=\"允许-0-1-次买卖\"><a class=\"markdownIt-Anchor\" href=\"#允许-0-1-次买卖\"></a> 允许 0-1 次买卖</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟩 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/\">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>要求：至多允许 1 次买卖。求最大利润。</p>\n</div></div><p>我们需要找出给定数组中两个数字之间的最大差值（即最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。</p>\n<p>形式上，对于每组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span>（其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">j&gt;i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>）我们需要找出 <code>max(prices[j]-prices[i])</code>。</p>\n<h2 id=\"暴力方法\"><a class=\"markdownIt-Anchor\" href=\"#暴力方法\"></a> 暴力方法</h2>\n\n<div class=\"callout\" data-callout=\"error\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-zap\"><polygon points=\"13 2 3 14 12 14 11 22 21 10 12 10 13 2\"/></svg>\n</div>\n<div class=\"callout-title-inner\">此方法时间复杂度过高，将导致超时。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; prices.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class=\"line\">\t\t\tres = Math.max(res,prices[j] - prices[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。循环运行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n(n-1)/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span></span></span></span>​ 次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。只使用了常数个变量。</li>\n</ul>\n<h2 id=\"一次遍历\"><a class=\"markdownIt-Anchor\" href=\"#一次遍历\"></a> 一次遍历</h2>\n<p>思考：假设我们要在第 <code>i</code> 卖股票，那么我们能赚多少钱呢？最好的愿望就是，我们是在在第 i 天之前的历史最低点买入的股票！</p>\n<p>我们只要用一个变量记录一个历史最低价格 <code>minprice</code>，我们就可以假设自己的股票是在那天买的。那么我们在第 <code>i</code> 天卖出股票能得到的利润就是 <code>prices[i] - minprice</code>。</p>\n<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">minprice</span> <span class=\"operator\">=</span> prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">\t\tres = Math.max(res,prices[i]-minprice);</span><br><span class=\"line\">\t\tminprice = Math.min(min,prices[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，只需要遍历一次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，只使用了常数个变量。</li>\n</ul>\n<p>这种一次遍历的做法基于了 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/59af443f/\"><span class=\"bilink-pop-up\">站内文章</span>前后缀分解的思想</a>。</p>\n<h2 id=\"转换为最大子数组问题\"><a class=\"markdownIt-Anchor\" href=\"#转换为最大子数组问题\"></a> 转换为最大子数组问题</h2>\n<p>这个题目还可以转变为 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/19c8c246/\"><span class=\"bilink-pop-up\">站内文章</span>最大子数组问题</a>，从而转为使用本文列举的动态规划、分治法等多种方案（点击链接即可直达本站文章查看解法）。我们可以从每日价格变化考察输入数据。第 i 天的价格变化定义为第 <code>i-1</code> 天的价格差，生成表 A’。问题求解变为求 A’ 的最大子数组。</p>\n<p>例如：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20231120200602.webp\" alt=\"image.png\" /></p>\n<h1 id=\"允许任意次买卖系列\"><a class=\"markdownIt-Anchor\" href=\"#允许任意次买卖系列\"></a> 允许任意次买卖系列</h1>\n<h2 id=\"允许任意次买卖无约束\"><a class=\"markdownIt-Anchor\" href=\"#允许任意次买卖无约束\"></a> 允许任意次买卖（无约束）</h2>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>要求：允许任意次买卖。求最大利润。</p>\n</div></div><h3 id=\"贪心算法\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法\"></a> 贪心算法</h3>\n<p>思路：反正无限次买，薅住一个<strong>历史</strong>最低点卖出股票就行了。实际算出的数，就是第 i 天相较于第 i-1 天涨出的价格。注意，这个历史最低点是指从左到右遍历的历史最低点，不是全局历史最低点。</p>\n<p>具体严格的贪心证明请看 LeetCode 题解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">\t\tres += Math.max(<span class=\"number\">0</span>,prices[i]-prices[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要说明的是，贪心算法只能用于计算最大利润，计算的过程并不是实际的交易过程。</p>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的长度。我们只需要遍历一次数组即可。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。只需要常数空间存放若干变量。</li>\n</ul>\n<h3 id=\"动态规划\"><a class=\"markdownIt-Anchor\" href=\"#动态规划\"></a> 动态规划</h3>\n<p><strong>请务必弄懂此处动态规划算法，为后续题目的解决打好基础。</strong></p>\n<p>题目要求每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>\n<p>定义状态 <code>dp0[i]</code> 表示第 i 天交易完后手里没有股票的最大利润，<code>dp1[i]</code> 表示第 <code>i</code> 天交易完后手里持有一支股票的最大利润（<code>i</code> 从 0 开始）。</p>\n<p>状态转移方程：</p>\n<ul>\n<li><code>dp0[i]=max&#123;dp0[i-1],dp1[i-1]+prices[i]&#125;</code>：前一天不持有股票和前一天持有股票并今天卖出比较。</li>\n<li><code>dp1[i]=max&#123;dp1[i-1],dp0[i-1]-prices[i]&#125;</code>：前一天持有股票和前一天不持有股票但今天买入。</li>\n</ul>\n<p>初始条件：状态定义我们可以知道第 0 天交易结束的时候 <code>dp0[0]=0</code>，<code>dp1[0]=-prices[0]</code>。</p>\n<p>答案的选择：最后一天不持有股票的利润肯定比持有股票的多。所以答案返回 <code>dp0[n-1]</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本DP</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp0 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">\tdp0[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tdp1[<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\tdp0[i] = Math.max(dp0[i - <span class=\"number\">1</span>], dp1[i - <span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">\t\tdp1[i] = Math.max(dp1[i - <span class=\"number\">1</span>], dp0[i - <span class=\"number\">1</span>] - prices[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp0[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的长度。一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span> 个状态，每次状态转移的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，因此时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2n)=O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。我们需要开辟 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>下面给出一种更好理解的空间压缩算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空间压缩</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp0_old=<span class=\"number\">0</span>,dp1_old=-prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp0,dp1;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">\t\tdp0 = Math.max(dp0_old,dp1_old+prices[i]);</span><br><span class=\"line\">\t\tdp1 = Math.max(dp1_old,dp0_old-prices[i]);</span><br><span class=\"line\">\t\tdp0_old = dp0;</span><br><span class=\"line\">\t\tdp1_old = dp1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp0_old;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"允许任意次买卖-手续费\"><a class=\"markdownIt-Anchor\" href=\"#允许任意次买卖-手续费\"></a> 允许任意次买卖 + 手续费</h2>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/\">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>要求：你可以无限次地完成交易，但是你每笔交易都需要付固定手续费 <code>fee</code> 。求最大利润。</p>\n</div></div><p>思路：根据「买股票的最佳时机 II」的动态规划思路进行变动，稍微修改状态转移方程即可，至于什么时候进行缴费都行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 买下股票时缴费（dp1缴费）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices, <span class=\"type\">int</span> fee)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp0_old=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp1_old=-prices[<span class=\"number\">0</span>]-fee;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp0,dp1;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">\t\tdp0 = Math.max(dp0_old,dp1_old+prices[i]);</span><br><span class=\"line\">\t\tdp1 = Math.max(dp1_old,dp0_old-prices[i]-fee);</span><br><span class=\"line\">\t\tdp0_old = dp0;</span><br><span class=\"line\">\t\tdp1_old = dp1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp0_old;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 卖出股票时缴费（回归到dp0时缴费）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices, <span class=\"type\">int</span> fee)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp0_old=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp1_old=-prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> dp0,dp1;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">\t\tdp0 = Math.max(dp0_old,dp1_old+prices[i]-fee);</span><br><span class=\"line\">\t\tdp1 = Math.max(dp1_old,dp0_old-prices[i]);</span><br><span class=\"line\">\t\tdp0_old = dp0;</span><br><span class=\"line\">\t\tdp1_old = dp1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp0_old;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"允许任意次买卖-冷冻期\"><a class=\"markdownIt-Anchor\" href=\"#允许任意次买卖-冷冻期\"></a> 允许任意次买卖 + 冷冻期</h2>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/\">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>要求：你可以无限次地完成交易，但是卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。求最大利润。</p>\n</div></div><p>思路：根据「买股票的最佳时机 II」的动态规划思路进行变动，在状态转移方程中 <code>dp1[i]=max&#123;dp1[i-1],dp0[i-2]-prices[i]&#125;</code> 的变化为，从原来的昨天未持有股票的最大利润 <code>dp0[i-1]</code>，改为 <code>dp0[i-2]</code>。这是因为如果选择 <code>dp0[i-1]</code>，你无法保证 <code>dp0[i-1]</code> 当天有没有卖出过股票（因为昨天卖出股票后今天就不能买）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len==<span class=\"number\">2</span>)<span class=\"keyword\">return</span> Math.max(<span class=\"number\">0</span>,prices[<span class=\"number\">1</span>]-prices[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp0 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len];</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len];</span><br><span class=\"line\">\tdp0[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tdp0[<span class=\"number\">1</span>] = Math.max(<span class=\"number\">0</span>,prices[<span class=\"number\">1</span>]-prices[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tdp1[<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tdp1[<span class=\"number\">1</span>] = Math.max(-prices[<span class=\"number\">0</span>],-prices[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">\t\tdp0[i] = Math.max(dp0[i-<span class=\"number\">1</span>],dp1[i-<span class=\"number\">1</span>]+prices[i]);</span><br><span class=\"line\">\t\tdp1[i] = Math.max(dp1[i-<span class=\"number\">1</span>],dp0[i-<span class=\"number\">2</span>]-prices[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp0[len-<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">思考题：上面的代码还能进行空间压缩吗？</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h1 id=\"允许-0-2-次买卖\"><a class=\"markdownIt-Anchor\" href=\"#允许-0-2-次买卖\"></a> 允许 0-2 次买卖</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟥 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/\">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>要求：至多 2 次买卖。求最大利润。</p>\n</div></div><p>由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p>\n<ul>\n<li>未进行过任何操作；</li>\n<li>只进行过一次买操作；</li>\n<li>进行了一次买操作和一次卖操作，即完成了一笔交易；</li>\n<li>在完成了一笔交易的前提下，进行了第二次买操作；</li>\n<li>完成了全部两笔交易。</li>\n</ul>\n<p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 <code>buy1</code>，<code>sell1</code>，<code>buy2</code> 以及 <code>sell2</code>。</p>\n<p>状态转移方程：</p>\n<ul>\n<li><code>buy1​=max&#123;buy1′​,-prices[i]&#125;</code></li>\n<li><code>sell1​=max&#123;sell1′​,buy1′​+prices[i]&#125;</code></li>\n<li><code>buy2​=max&#123;buy2′​,sell1′​-prices[i]&#125;</code></li>\n<li><code>sell2​=max&#123;sell2′​,buy2′​+prices[i]&#125;​</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> buy1p=-prices[<span class=\"number\">0</span>],buy2p=-prices[<span class=\"number\">0</span>],sell1p=<span class=\"number\">0</span>,sell2p=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> buy1,buy2,sell1,sell2;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">\t\tbuy1 = Math.max(buy1p,-prices[i]);</span><br><span class=\"line\">\t\tsell1= Math.max(sell1p,buy1p+prices[i]);</span><br><span class=\"line\">\t\tbuy2 = Math.max(buy2p,sell1p-prices[i]);</span><br><span class=\"line\">\t\tsell2 = Math.max(sell2p,buy2p+prices[i]);</span><br><span class=\"line\">\t\tbuy1p = buy1;</span><br><span class=\"line\">\t\tsell1p = sell1;</span><br><span class=\"line\">\t\tbuy2p = buy2;</span><br><span class=\"line\">\t\tsell2p = sell2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Math.max(<span class=\"number\">0</span>,sell2p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是数组 prices 的长度。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">思考题：在上述代码中，还能不能简化掉 <code>buy1</code>,<code>buy2</code>,<code>sell1</code>,<code>sell2</code> 变量？为什么？</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h1 id=\"允许指定次数-k-次买卖\"><a class=\"markdownIt-Anchor\" href=\"#允许指定次数-k-次买卖\"></a> 允许指定次数 k 次买卖</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟥 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/\">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>要求：你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。求最大利润。</p>\n</div></div><p>思路：就是把「买股票的最佳时机 III」的动态规划扩展而已。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// k 取值的简化</span></span><br><span class=\"line\">\tk=Math.min(k,len/<span class=\"number\">2</span>);</span><br><span class=\"line\">\tk = k==<span class=\"number\">0</span> ? <span class=\"number\">1</span> : k; <span class=\"comment\">// k 不能为 0</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] buyp= <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">\t\tbuyp[i] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] sellp= <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] buy = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] sell = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;k;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 处理初始情况</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tbuy[j] = Math.max(buyp[j],-prices[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tbuy[j] = Math.max(buyp[j],sellp[j-<span class=\"number\">1</span>]-prices[i]);</span><br><span class=\"line\">\t\t\tsell[j] = Math.max(sellp[j],buyp[j]+prices[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;k;j++)&#123;</span><br><span class=\"line\">\t\t\tbuyp[j] = buy[j];</span><br><span class=\"line\">\t\t\tsellp[j] = sell[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Math.max(<span class=\"number\">0</span>,sellp[k-<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中出现了对 <code>k</code> 的简化，因为 n 天最多只能进行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">⌊n/2⌋</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">⌋</span></span></span></span> 笔交易。因此我们可以将 <code>k</code> 对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">⌊n/2⌋</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">⌋</span></span></span></span> 取较小值之后再进行动态规划。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">思考题：上面的代码还能进行空间压缩吗？</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>min</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\min (n,k))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是数组 prices 的大小，即我们使用二重循环进行动态规划需要的时间。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>min</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\min(n,k))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> 或 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\min (n,k))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，取决于我们使用二维数组还是一维数组进行动态规划。</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《算法导论》</li>\n<li>LeetCode 相关题目的题解</li>\n<li><a href=\"https://leetcode.cn/circle/discuss/tXLS3i/\">分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化） - 力扣（LeetCode）</a></li>\n</ul>\n","raw":"---\ntitle: 买卖股票的最佳时机\ntags:\n  - 动态规划\n  - 贪心算法\n  - LeetCode\n  - Java\n  - 前缀和\n  - 状态机\ncover: https://cdn.gallery.uuanqin.top/img/202409030402919.webp\ndescription: 掌握一次遍历与动态规划。\ncategories:\n  - 算法与数据结构\nabbrlink: 41280b89\nkatex: true\nsummary: >-\n  本文介绍了 LeetCode 上关于买卖股票最佳时机的系列题目，包括一次遍历、动态规划和最大子数组问题等解法。文章首先讲解了一次遍历方法，通过记录历史最低价格来计算最大利润，时间复杂度为 O(n)。接着介绍了动态规划方法，定义了两个状态数组 dp0 和 dp1 分别表示不持有股票和持有股票的最大利润，并给出了状态转移方程和初始条件。文章还提到了贪心算法和空间压缩算法的应用。最后，文章扩展了题目，讨论了允许任意次买卖、含手续费和冷冻期的情况，分别采用了不同的策略来解决这些问题。\ndate: 2024-09-12 01:35:51\ntop_img:\n---\n\n今天带来的是 LeetCode 的所有买卖股票最佳时机的系列题，这些题目也是「状态机动态规划」的经典题目。\n\n在这篇文章中，可以熟练一次遍历思想以及单维、多维动态规划。\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n> [!example] 基本题干：买卖股票的最佳时机\n> 给定一个数组 `prices` ，它的第 i 个元素 `prices[i]` 表示一支给定股票第 i 天的价格。\n>\n> 1 次股票买卖定义为：选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。\n>\n> 你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n>\n> 设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n>\n> 提示：`prices.length>=1`\n\n下文中出现的买卖股票的问题都是基于此题干进行条件设置。\n\n# 允许 0-1 次买卖\n\n> [!example] 🟩 [121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)\n> 要求：至多允许 1 次买卖。求最大利润。\n\n我们需要找出给定数组中两个数字之间的最大差值（即最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。\n\n形式上，对于每组 $i$ 和 $j$（其中 $j>i$）我们需要找出 `max(prices[j]-prices[i])`。\n\n## 暴力方法\n\n> [!error] 此方法时间复杂度过高，将导致超时。\n\n```java\npublic int maxProfit(int[] prices) {\n\tint res = 0;\n\tfor (int i = 0; i < prices.length - 1; i++) {\n\t\tfor (int j = i + 1; j < prices.length; j++) {\n\t\t\tres = Math.max(res,prices[j] - prices[i]);\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n^2)$。循环运行 $n(n-1)/2$​ 次。\n- 空间复杂度：$O(1)$。只使用了常数个变量。\n\n## 一次遍历\n\n思考：假设我们要在第 `i` 卖股票，那么我们能赚多少钱呢？最好的愿望就是，我们是在在第 i 天之前的历史最低点买入的股票！\n\n我们只要用一个变量记录一个历史最低价格 `minprice`，我们就可以假设自己的股票是在那天买的。那么我们在第 `i` 天卖出股票能得到的利润就是 `prices[i] - minprice`。\n\n因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。\n\n```java\npublic int maxProfit(int[] prices) {\n\tint len = prices.length;\n\tint minprice = prices[0];\n\tint res = 0;\n\tfor(int i=1;i<len;i++){\n\t\tres = Math.max(res,prices[i]-minprice);\n\t\tminprice = Math.min(min,prices[i]);\n\t}\n\treturn res;\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，只需要遍历一次。\n- 空间复杂度：$O(1)$，只使用了常数个变量。\n\n这种一次遍历的做法基于了 [[前后缀分解的应用|前后缀分解的思想]]。\n\n## 转换为最大子数组问题\n\n这个题目还可以转变为 [[最大子数组问题|最大子数组问题]]，从而转为使用本文列举的动态规划、分治法等多种方案（点击链接即可直达本站文章查看解法）。我们可以从每日价格变化考察输入数据。第 i 天的价格变化定义为第 `i-1` 天的价格差，生成表 A'。问题求解变为求 A' 的最大子数组。\n\n例如：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20231120200602.webp)\n\n# 允许任意次买卖系列\n\n## 允许任意次买卖（无约束）\n\n> [!example] 🟨 [122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)\n> 要求：允许任意次买卖。求最大利润。\n\n### 贪心算法\n\n思路：反正无限次买，薅住一个**历史**最低点卖出股票就行了。实际算出的数，就是第 i 天相较于第 i-1 天涨出的价格。注意，这个历史最低点是指从左到右遍历的历史最低点，不是全局历史最低点。\n\n具体严格的贪心证明请看 LeetCode 题解。\n\n```java\npublic int maxProfit(int[] prices) {\n\tint res = 0;\n\tfor(int i=1;i<prices.length;i++){\n\t\tres += Math.max(0,prices[i]-prices[i-1]);\n\t}\n\treturn res;\n}\n```\n\n需要说明的是，贪心算法只能用于计算最大利润，计算的过程并不是实际的交易过程。\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 为数组的长度。我们只需要遍历一次数组即可。\n- 空间复杂度：$O(1)$。只需要常数空间存放若干变量。\n\n### 动态规划\n\n**请务必弄懂此处动态规划算法，为后续题目的解决打好基础。**\n\n题目要求每天交易结束后只可能存在手里有一支股票或者没有股票的状态。\n\n定义状态 `dp0[i]` 表示第 i 天交易完后手里没有股票的最大利润，`dp1[i]` 表示第 `i` 天交易完后手里持有一支股票的最大利润（`i` 从 0 开始）。\n\n状态转移方程：\n\n- `dp0[i]=max{dp0[i-1],dp1[i-1]+prices[i]}`：前一天不持有股票和前一天持有股票并今天卖出比较。\n- `dp1[i]=max{dp1[i-1],dp0[i-1]-prices[i]}`：前一天持有股票和前一天不持有股票但今天买入。\n\n初始条件：状态定义我们可以知道第 0 天交易结束的时候 `dp0[0]=0`，`dp1[0]=-prices[0]`。\n\n答案的选择：最后一天不持有股票的利润肯定比持有股票的多。所以答案返回 `dp0[n-1]`。\n\n```java\n// 基本DP\npublic int maxProfit(int[] prices) {\n\tint n = prices.length;\n\tint[] dp0 = new int[n];\n\tint[] dp1 = new int[n];\n\tdp0[0] = 0;\n\tdp1[0] = -prices[0];\n\tfor (int i = 1; i < n; ++i) {\n\t\tdp0[i] = Math.max(dp0[i - 1], dp1[i - 1] + prices[i]);\n\t\tdp1[i] = Math.max(dp1[i - 1], dp0[i - 1] - prices[i]);\n\t}\n\treturn dp0[n - 1];\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 为数组的长度。一共有 $2n$ 个状态，每次状态转移的时间复杂度为 $O(1)$，因此时间复杂度为 $O(2n)=O(n)$。\n- 空间复杂度：$O(n)$。我们需要开辟 $O(n)$ 空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 $O(1)$。\n\n下面给出一种更好理解的空间压缩算法：\n\n```java\n// 空间压缩\npublic int maxProfit(int[] prices) {\n\tint dp0_old=0,dp1_old=-prices[0];\n\tint dp0,dp1;\n\tfor(int i=1;i<prices.length;i++){\n\t\tdp0 = Math.max(dp0_old,dp1_old+prices[i]);\n\t\tdp1 = Math.max(dp1_old,dp0_old-prices[i]);\n\t\tdp0_old = dp0;\n\t\tdp1_old = dp1;\n\t}\n\treturn dp0_old;\n}\n```\n\n## 允许任意次买卖 + 手续费\n\n> [!example] 🟨 [714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)\n> 要求：你可以无限次地完成交易，但是你每笔交易都需要付固定手续费 `fee` 。求最大利润。\n\n思路：根据「买股票的最佳时机 II」的动态规划思路进行变动，稍微修改状态转移方程即可，至于什么时候进行缴费都行。\n\n```java\n// 买下股票时缴费（dp1缴费）\npublic int maxProfit(int[] prices, int fee) {\n\tint dp0_old=0;\n\tint dp1_old=-prices[0]-fee;\n\tint dp0,dp1;\n\tfor(int i=1;i<prices.length;i++){\n\t\tdp0 = Math.max(dp0_old,dp1_old+prices[i]);\n\t\tdp1 = Math.max(dp1_old,dp0_old-prices[i]-fee);\n\t\tdp0_old = dp0;\n\t\tdp1_old = dp1;\n\t}\n\treturn dp0_old;\n}\n\n// 卖出股票时缴费（回归到dp0时缴费）\npublic int maxProfit(int[] prices, int fee) {\n\tint dp0_old=0;\n\tint dp1_old=-prices[0];\n\tint dp0,dp1;\n\tfor(int i=1;i<prices.length;i++){\n\t\tdp0 = Math.max(dp0_old,dp1_old+prices[i]-fee);\n\t\tdp1 = Math.max(dp1_old,dp0_old-prices[i]);\n\t\tdp0_old = dp0;\n\t\tdp1_old = dp1;\n\t}\n\treturn dp0_old;\n}\n```\n\n## 允许任意次买卖 + 冷冻期\n\n> [!example] 🟨 [309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)\n> 要求：你可以无限次地完成交易，但是卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。求最大利润。\n\n思路：根据「买股票的最佳时机 II」的动态规划思路进行变动，在状态转移方程中 `dp1[i]=max{dp1[i-1],dp0[i-2]-prices[i]}` 的变化为，从原来的昨天未持有股票的最大利润 `dp0[i-1]`，改为 `dp0[i-2]`。这是因为如果选择 `dp0[i-1]`，你无法保证 `dp0[i-1]` 当天有没有卖出过股票（因为昨天卖出股票后今天就不能买）。\n\n```java\n public int maxProfit(int[] prices) {\n\tint len = prices.length;\n\tif(len==1)return 0;\n\tif(len==2)return Math.max(0,prices[1]-prices[0]);\n\tint[] dp0 = new int[len];\n\tint[] dp1 = new int[len];\n\tdp0[0] = 0;\n\tdp0[1] = Math.max(0,prices[1]-prices[0]);\n\tdp1[0] = -prices[0];\n\tdp1[1] = Math.max(-prices[0],-prices[1]);\n\tfor(int i=2;i<len;i++){\n\t\tdp0[i] = Math.max(dp0[i-1],dp1[i-1]+prices[i]);\n\t\tdp1[i] = Math.max(dp1[i-1],dp0[i-2]-prices[i]);\n\t}\n\treturn dp0[len-1];\n}\n```\n\n> [!example] 思考题：上面的代码还能进行空间压缩吗？\n\n# 允许 0-2 次买卖\n\n> [!example] 🟥 [123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)\n> 要求：至多 2 次买卖。求最大利润。\n\n由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：\n\n- 未进行过任何操作；\n- 只进行过一次买操作；\n- 进行了一次买操作和一次卖操作，即完成了一笔交易；\n- 在完成了一笔交易的前提下，进行了第二次买操作；\n- 完成了全部两笔交易。\n\n由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 `buy1`，`sell1`，`buy2` 以及 `sell2`。\n\n状态转移方程：\n\n- `buy1​=max{buy1′​,-prices[i]}`\n- `sell1​=max{sell1′​,buy1′​+prices[i]}`\n- `buy2​=max{buy2′​,sell1′​-prices[i]}`\n- `sell2​=max{sell2′​,buy2′​+prices[i]}​`\n\n```java\npublic int maxProfit(int[] prices) {\n\tint buy1p=-prices[0],buy2p=-prices[0],sell1p=0,sell2p=0;\n\tint buy1,buy2,sell1,sell2;\n\tfor(int i=1;i<prices.length;i++){\n\t\tbuy1 = Math.max(buy1p,-prices[i]);\n\t\tsell1= Math.max(sell1p,buy1p+prices[i]);\n\t\tbuy2 = Math.max(buy2p,sell1p-prices[i]);\n\t\tsell2 = Math.max(sell2p,buy2p+prices[i]);\n\t\tbuy1p = buy1;\n\t\tsell1p = sell1;\n\t\tbuy2p = buy2;\n\t\tsell2p = sell2;\n\t}\n\treturn Math.max(0,sell2p);\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 是数组 prices 的长度。\n- 空间复杂度：$O(1)$。\n\n> [!example] 思考题：在上述代码中，还能不能简化掉 `buy1`,`buy2`,`sell1`,`sell2` 变量？为什么？\n\n# 允许指定次数 k 次买卖\n\n> [!example] 🟥 [188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)\n> 要求：你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。求最大利润。\n\n思路：就是把「买股票的最佳时机 III」的动态规划扩展而已。\n\n```java\npublic int maxProfit(int k, int[] prices) {\n\tint len = prices.length;\n\n\t// k 取值的简化\n\tk=Math.min(k,len/2);\n\tk = k==0 ? 1 : k; // k 不能为 0\n\t\n\tint[] buyp= new int[k];\n\tfor(int i=0;i<k;i++){\n\t\tbuyp[i] = -prices[0];\n\t}\n\tint[] sellp= new int[k];\n\tint[] buy = new int[k];\n\tint[] sell = new int[k];\n\tfor(int i=1;i<len;i++){\n\t\tfor(int j=0;j<k;j++){\n\t\t\t// 处理初始情况\n\t\t\tif(j==0)\n\t\t\t\tbuy[j] = Math.max(buyp[j],-prices[i]);\n\t\t\telse\n\t\t\t\tbuy[j] = Math.max(buyp[j],sellp[j-1]-prices[i]);\n\t\t\tsell[j] = Math.max(sellp[j],buyp[j]+prices[i]);\n\t\t}\n\t\tfor(int j=0;j<k;j++){\n\t\t\tbuyp[j] = buy[j];\n\t\t\tsellp[j] = sell[j];\n\t\t}\n\t}\n\treturn Math.max(0,sellp[k-1]);\n}\n```\n\n上面的代码中出现了对 `k` 的简化，因为 n 天最多只能进行 $⌊n/2⌋$ 笔交易。因此我们可以将 `k` 对 $⌊n/2⌋$ 取较小值之后再进行动态规划。\n\n> [!example] 思考题：上面的代码还能进行空间压缩吗？\n\n复杂度分析：\n\n- 时间复杂度：$O(n\\min (n,k))$，其中 n 是数组 prices 的大小，即我们使用二重循环进行动态规划需要的时间。\n- 空间复杂度：$O(n\\min(n,k))$ 或 $O(\\min (n,k))$，取决于我们使用二维数组还是一维数组进行动态规划。\n\n\n# 本文参考\n- 《算法导论》\n- LeetCode 相关题目的题解\n- [分享丨【题单】动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化） - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/tXLS3i/)","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"动态规划","api":"api/tags/动态规划.json"},{"name":"贪心算法","api":"api/tags/贪心算法.json"},{"name":"前缀和","api":"api/tags/前缀和.json"},{"name":"状态机","api":"api/tags/状态机.json"}]},"api":"api/posts/p/41280b89.json"}