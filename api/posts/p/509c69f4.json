{"data":{"title":"一些特殊的栈：单调栈、最小栈","slug":"算法与数据结构/一些特殊的栈：单调栈、最小栈","description":"栈也能弄出这样的花样？","date":"2024-11-17T10:34:53.000Z","updated":"2025-10-16T16:26:12.381Z","language":"zh-CN","comments":true,"url":"p/509c69f4/","cover":"https://cdn.gallery.uuanqin.top/img/202510170022670.webp","images":[],"content":"<h1 id=\"单调栈\"><a class=\"markdownIt-Anchor\" href=\"#单调栈\"></a> 单调栈</h1>\n<p>单调栈即满足单调性的栈结构。</p>\n<p>将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子</div>\n</div>\n<div class=\"callout-content\"><p>栈中自顶向下的元素为 <code>[0,11,45,81]</code><br />\n插入元素 14 时为了保证单调性需要依次弹出元素 0, 11<br />\n操作后栈变为 <code>[14,45,81]</code></p>\n</div></div><h2 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\"></a> 实现</h2>\n<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设数组A从左到右遍历</span></span><br><span class=\"line\">insert x <span class=\"comment\">// x 为数组中某一个元素</span></span><br><span class=\"line\"><span class=\"comment\">// 假设维护的是一个单调递增的栈（自栈顶向下单调递增）</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> !stack.empty() &amp;&amp; stack.top()&lt;x</span><br><span class=\"line\">    y = stack.pop() <span class=\"comment\">// 这也意味着y右侧第一个比y大的元素是x</span></span><br><span class=\"line\">stack.push(x)</span><br></pre></td></tr></table></figure>\n<p>有时候，单调栈或单调队列中不一定存的是实际数字的值，有可能存的是指向实际数字的指针或下标，毕竟有时候实际数字的值可以通过下标访问数组获得，存储下标能保存更多利于计算的信息。比如这些题：</p>\n<ul>\n<li>🟥 <a href=\"https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked\">239. 滑动窗口最大值 - 力扣（LeetCode）</a></li>\n<li>🟥 <a href=\"https://leetcode.cn/problems/largest-rectangle-in-histogram/description/\">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></li>\n</ul>\n<h2 id=\"应用\"><a class=\"markdownIt-Anchor\" href=\"#应用\"></a> 应用</h2>\n<h3 id=\"下一个更大元素原型题\"><a class=\"markdownIt-Anchor\" href=\"#下一个更大元素原型题\"></a> 下一个更大元素（原型题）</h3>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟩 <a href=\"https://leetcode.cn/problems/next-greater-element-i/description/\">496. 下一个更大元素 I - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>或者前一个更小元素。</p>\n<p>在线性时间内求出数组 <code>A</code> 中某元素 <code>x</code> 的下一个更大的元素，即 <code>x</code> 右侧第一个比 <code>x</code> 大的元素的值或下标。</p>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/next-greater-element-ii/description/\">503. 下一个更大元素 II - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/sum-of-subarray-minimums/description/\">907. 子数组的最小值之和 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/sum-of-subarray-ranges/description/\">2104. 子数组范围和 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/beautiful-towers-i/description/\">2865. 美丽塔 I - 力扣（LeetCode）</a></li>\n</ul>\n<h3 id=\"保存关键字符\"><a class=\"markdownIt-Anchor\" href=\"#保存关键字符\"></a> 保存关键字符</h3>\n<p>首先考虑一个简单的问题：给定一个字符串 s，如何去掉其中的一个字符 ch，使得得到的字符串字典序最小呢？答案是：找出最小的满足 <code>s[i]&gt;s[i+1]</code> 的下标 <code>i</code>，并去除字符 <code>s[i]</code>。我们称这样的字符为「关键字符」。</p>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/remove-duplicate-letters/description/\">316. 去除重复字母 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"最小栈\"><a class=\"markdownIt-Anchor\" href=\"#最小栈\"></a> 最小栈</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/min-stack/description/\">155. 最小栈 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>请你设计一个 <strong>最小栈</strong> 。它提供 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n</div></div><p>暴力做法就是每次获取辗转最小值时二分查找最小值，或者另外维护堆结构。但是这样的话，查找的时间复杂度或维护堆的时间复杂度较高。</p>\n<p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p>\n<h2 id=\"基本做法双栈\"><a class=\"markdownIt-Anchor\" href=\"#基本做法双栈\"></a> 基本做法：双栈</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    Deque&lt;Integer&gt; m_stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MinStack</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        min = Math.min(min,x);</span><br><span class=\"line\">        stack.push(x);</span><br><span class=\"line\">        m_stack.push(min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        stack.pop();</span><br><span class=\"line\">        m_stack.pop();</span><br><span class=\"line\">        min = m_stack.peek()==<span class=\"literal\">null</span>?min = Integer.MAX_VALUE:m_stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你觉得上面的代码还不够简洁，你可以去掉全局 <code>min</code>，并在栈初始化时，提前将 <code>Integer.MAX_VALUE</code> 哨兵放入 <code>m_stack</code> 中。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202510170021537.webp\" alt=\"image.png\" width=\"400px\" /></p>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：对于题目中的所有操作，时间复杂度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。因为栈的插入、删除与读取操作都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，我们定义的每个操作最多调用栈操作两次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<h2 id=\"常数优化辅助栈维护更少的元素\"><a class=\"markdownIt-Anchor\" href=\"#常数优化辅助栈维护更少的元素\"></a> 常数优化：辅助栈维护更少的元素</h2>\n<p>在基本的做法中，每个 <code>stack</code> 中的元素都对应 <code>m_stack</code> 中一个元素。其实 <code>m_stack</code> 中会有重复的元素放入。</p>\n<p>改进后，双栈分工：</p>\n<ul>\n<li>数据栈 A ： 栈 A 用于存储所有元素，保证入栈 <code>push()</code> 函数、出栈 <code>pop()</code> 函数、获取栈顶 <code>top()</code> 函数的正常逻辑。</li>\n<li>辅助栈 B ： 栈 B 中存储栈 A 中所有 非严格降序 元素的子序列，则栈 A 中的最小元素始终对应栈 B 的栈顶元素。此时，<code>getMin()</code> 函数只需返回栈 B 的栈顶元素即可。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202510170006421.webp\" alt=\"image.png\" width=\"375px\" /></p>\n<p>辅助栈中元素以「非严格降序」进行排序，防止辅助栈提前弹出最小值：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202510170009538.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p>参考实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    Deque&lt;Integer&gt; m_stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MinStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        m_stack.push(Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        stack.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&lt;=m_stack.peek())&#123;</span><br><span class=\"line\">            m_stack.push(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o==m_stack.peek())&#123;</span><br><span class=\"line\">            m_stack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常数优化只使用一个栈\"><a class=\"markdownIt-Anchor\" href=\"#常数优化只使用一个栈\"></a> 常数优化：只使用一个栈</h2>\n<p>我们取消辅助栈，引入全局变量 <code>min</code>，实时维护当前栈中最小值。而唯一的栈结构用来保存入栈时的元素与当前 <code>min</code> 的差值。因此我们最需要关注的地方为：</p>\n<ul>\n<li>弹栈时，如何维护好 <code>min</code></li>\n<li>弹栈时，并返回正确的初始元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\">    Deque&lt;Long&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">long</span> min;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MinStack</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stack.isEmpty())&#123;</span><br><span class=\"line\">            min = x;</span><br><span class=\"line\">            stack.push(<span class=\"number\">0L</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">delta</span> <span class=\"operator\">=</span> x-min;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(delta&lt;<span class=\"number\">0L</span>)&#123;</span><br><span class=\"line\">            min = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack.push(delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> stack.peek();</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            min = min-o;</span><br><span class=\"line\">        &#125;       </span><br><span class=\"line\">        stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> stack.peek();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)(o&gt;<span class=\"number\">0</span>?o+min:min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://oi-wiki.org/ds/monotonous-stack/\">单调栈 - OI Wiki (oi-wiki.org)</a> 除应用与习题部分</li>\n<li><a href=\"https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solutions/133760/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/\">LCR 147. 最小栈 - @Krahets 的题解 - 力扣（LeetCode）</a></li>\n</ul>\n","raw":"---\ntitle: 一些特殊的栈：单调栈、最小栈\ntags:\n  - 单调栈\n  - 最小栈\n  - Java\n  - 栈\ncover: 'https://cdn.gallery.uuanqin.top/img/202510170022670.webp'\ndescription: 栈也能弄出这样的花样？\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: 509c69f4\ndate: 2024-11-17 18:34:53\ntop_img:\n---\n\n# 单调栈\n\n单调栈即满足单调性的栈结构。\n\n将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。\n\n> [!example] 例子\n> 栈中自顶向下的元素为 `[0,11,45,81]`\n> 插入元素 14 时为了保证单调性需要依次弹出元素 0, 11\n> 操作后栈变为 `[14,45,81]`\n\n## 实现\n\n```pascal\n// 假设数组A从左到右遍历\ninsert x // x 为数组中某一个元素\n// 假设维护的是一个单调递增的栈（自栈顶向下单调递增）\nwhile !stack.empty() && stack.top()<x\n    y = stack.pop() // 这也意味着y右侧第一个比y大的元素是x\nstack.push(x)\n```\n\n有时候，单调栈或单调队列中不一定存的是实际数字的值，有可能存的是指向实际数字的指针或下标，毕竟有时候实际数字的值可以通过下标访问数组获得，存储下标能保存更多利于计算的信息。比如这些题：\n\n- 🟥 [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)\n- 🟥 [84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)\n\n## 应用\n\n### 下一个更大元素（原型题）\n\n> [!example] 🟩 [496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/description/)\n\n或者前一个更小元素。\n\n在线性时间内求出数组 `A` 中某元素 `x` 的下一个更大的元素，即 `x` 右侧第一个比 `x` 大的元素的值或下标。\n\n相关题目：\n\n* 🟨 [503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/description/)\n* 🟨 [907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/description/)\n* 🟨 [2104. 子数组范围和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-ranges/description/)\n* 🟨 [2865. 美丽塔 I - 力扣（LeetCode）](https://leetcode.cn/problems/beautiful-towers-i/description/)\n\n### 保存关键字符\n\n首先考虑一个简单的问题：给定一个字符串 s，如何去掉其中的一个字符 ch，使得得到的字符串字典序最小呢？答案是：找出最小的满足 `s[i]>s[i+1]` 的下标 `i`，并去除字符 `s[i]`。我们称这样的字符为「关键字符」。\n\n相关题目：\n\n- 🟨 [316. 去除重复字母 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicate-letters/description/)\n\n# 最小栈\n\n> [!example] 🟨 [155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/description/)\n> 请你设计一个 **最小栈** 。它提供 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n\n暴力做法就是每次获取辗转最小值时二分查找最小值，或者另外维护堆结构。但是这样的话，查找的时间复杂度或维护堆的时间复杂度较高。\n\n对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。\n\n## 基本做法：双栈\n\n```java\nclass MinStack {\n    Deque<Integer> stack = new LinkedList<>();\n    Deque<Integer> m_stack = new LinkedList<>();\n    int min = Integer.MAX_VALUE;\n\n    /** initialize your data structure here. */\n    public MinStack() {}\n    \n    public void push(int x) {\n        min = Math.min(min,x);\n        stack.push(x);\n        m_stack.push(min);\n    }\n    \n    public void pop() {\n        stack.pop();\n        m_stack.pop();\n        min = m_stack.peek()==null?min = Integer.MAX_VALUE:m_stack.peek();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return m_stack.peek();\n    }\n}\n```\n\n如果你觉得上面的代码还不够简洁，你可以去掉全局 `min`，并在栈初始化时，提前将 `Integer.MAX_VALUE` 哨兵放入 `m_stack` 中。\n\n![image.png|400](https://cdn.gallery.uuanqin.top/img/202510170021537.webp)\n\n复杂度分析：\n\n- 时间复杂度：对于题目中的所有操作，时间复杂度均为 $O(1)$。因为栈的插入、删除与读取操作都是 $O(1)$，我们定义的每个操作最多调用栈操作两次。\n- 空间复杂度：$O(n)$，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 $O(n)$。\n\n## 常数优化：辅助栈维护更少的元素\n\n在基本的做法中，每个 `stack` 中的元素都对应 `m_stack` 中一个元素。其实 `m_stack` 中会有重复的元素放入。\n\n改进后，双栈分工：\n\n- 数据栈 A ： 栈 A 用于存储所有元素，保证入栈 `push()` 函数、出栈 `pop()` 函数、获取栈顶 `top()` 函数的正常逻辑。\n- 辅助栈 B ： 栈 B 中存储栈 A 中所有 非严格降序 元素的子序列，则栈 A 中的最小元素始终对应栈 B 的栈顶元素。此时，`getMin()` 函数只需返回栈 B 的栈顶元素即可。\n\n![image.png|375](https://cdn.gallery.uuanqin.top/img/202510170006421.webp)\n\n辅助栈中元素以「非严格降序」进行排序，防止辅助栈提前弹出最小值：\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202510170009538.webp)\n\n参考实现：\n\n```java\nclass MinStack {\n    Deque<Integer> stack = new LinkedList<>();\n    Deque<Integer> m_stack = new LinkedList<>();\n\n    public MinStack() {\n        m_stack.push(Integer.MAX_VALUE);\n    }\n    \n    public void push(int x) {\n        stack.push(x);\n        if(x<=m_stack.peek()){\n            m_stack.push(x);\n        }\n    }\n    \n    public void pop() {\n        int o = stack.pop();\n       \n        if(o==m_stack.peek()){\n            m_stack.pop();\n        }\n        \n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return m_stack.peek();\n    }\n}\n```\n\n## 常数优化：只使用一个栈\n\n我们取消辅助栈，引入全局变量 `min`，实时维护当前栈中最小值。而唯一的栈结构用来保存入栈时的元素与当前 `min` 的差值。因此我们最需要关注的地方为：\n\n- 弹栈时，如何维护好 `min`\n- 弹栈时，并返回正确的初始元素\n\n```java\nclass MinStack {\n    Deque<Long> stack = new LinkedList<>();\n    long min;\n\n    public MinStack() {}\n    \n    public void push(int x) {\n        if(stack.isEmpty()){\n            min = x;\n            stack.push(0L);\n            return;\n        }\n        long delta = x-min;\n        if(delta<0L){\n            min = x;\n        }\n        stack.push(delta);\n    }\n    \n    public void pop() {\n        Long o = stack.peek();\n       \n        if(o<0){\n            min = min-o;\n        }       \n        stack.pop();\n    }\n    \n    public int top() {\n        Long o = stack.peek();\n        \n        return (int)(o>0?o+min:min);\n    }\n    \n    public int getMin() {\n        return (int)min;\n    }\n}\n```\n\n# 本文参考\n\n- [单调栈 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/monotonous-stack/) 除应用与习题部分\n- [LCR 147. 最小栈 - @Krahets 的题解 - 力扣（LeetCode）](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solutions/133760/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"单调栈","api":"api/tags/单调栈.json"},{"name":"最小栈","api":"api/tags/最小栈.json"},{"name":"栈","api":"api/tags/栈.json"}]},"api":"api/posts/p/509c69f4.json"}