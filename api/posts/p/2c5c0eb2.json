{"data":{"title":"Java 8 中的函数式编程","slug":"计算机语言/Java 8 中的函数式编程","description":"函数式编程为我们打开了一扇大门","date":"2025-08-12T16:05:41.000Z","updated":"2025-08-12T16:05:25.120Z","language":"zh-CN","comments":true,"url":"p/2c5c0eb2/","cover":"https://cdn.gallery.uuanqin.top/img/202508120100998.webp","images":[],"content":"<p>函数式编程的核心特点是，函数作为一段功能代码，可以像变量一样进行引用和传递，以便在有需要的时候进行调用。</p>\n<h1 id=\"函数类型与-functionalinterface\"><a class=\"markdownIt-Anchor\" href=\"#函数类型与-functionalinterface\"></a> 函数类型与 <code>@FunctionalInterface</code></h1>\n<p>Java 对函数式编程的支持，本质是通过接口机制来实现的。首先定义一个<strong>仅声明一个方法</strong>的接口，然后对接口冠以 <code>@FunctionalInterface</code> 注解，那么这个接口就可以作为「函数类型」，可以接收一段以 <strong>Lambda 表达式</strong>，或者<strong>方法引用</strong>予以承载的逻辑代码。</p>\n<p>被 <code>@FunctionalInterface</code> 标注的接口仅声明一个方法，一旦这个函数定义好，它能执行的功能是确定的，就是调用和不调用的区别。显然，这个方法可以用来代表「函数类型」所能执行的功能，接口中声明的方法就是和函数体定义一一对应的。</p>\n<p><code>@FunctionalInterface</code> 下只能声明一个未实现的方法，多一个、少一个都不能编译通过。但有以下例外：</p>\n<ul>\n<li>覆写 <code>Object</code> 中 <code>toString/equals</code> 的方法不受此个数限制。</li>\n<li><code>default</code> 方法和 <code>static</code> 方法因为带有实现体，所以也不受此限制。</li>\n</ul>\n<p><code>@FunctionalInterface</code> 注解不是必须的，不加这个注解的接口（前提是只包含一个方法）一样可以作为函数类型。不过，显而易见的是，加了这个注解表意更明确、更直观，是更被推荐的做法。</p>\n<h2 id=\"jdk-提供的函数类型\"><a class=\"markdownIt-Anchor\" href=\"#jdk-提供的函数类型\"></a> JDK 提供的函数类型</h2>\n<p><code>java.util.function</code> 包下预定义了常用的函数类型，包括：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Consumer</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(T t)</span>; <span class=\"comment\">//接收一个类型为T（泛型）的参数，无返回值；所以叫消费者</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(T t, U u)</span>;<span class=\"comment\">//接收2个参数，无返回值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Supplier</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    T <span class=\"title function_\">get</span><span class=\"params\">()</span>;<span class=\"comment\">//无参数，有返回值（所以叫提供者）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意没有BiSupplier，因为返回值只能有1个，不会有2个</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Function</span>&lt;T, R&gt; &#123;</span><br><span class=\"line\">    R <span class=\"title function_\">apply</span><span class=\"params\">(T t)</span>;<span class=\"comment\">//一个输入（参数），一个输出（返回值）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class=\"line\">    R <span class=\"title function_\">apply</span><span class=\"params\">(T t, U u)</span>;<span class=\"comment\">//两个输入T和U，一个输出R</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UnaryOperator</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span>&lt;T, T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class=\"title function_\">identity</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//一元操作，输入原样返回给输出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> t -&gt; t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BinaryOperator</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">BiFunction</span>&lt;T,T,T&gt; &#123;<span class=\"comment\">//二元操作，输入输出类型相同</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class=\"title function_\">minBy</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(comparator);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a, b) -&gt; comparator.compare(a, b) &lt;= <span class=\"number\">0</span> ? a : b;<span class=\"comment\">//传入比较器，返回较小者</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class=\"title function_\">maxBy</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(comparator);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class=\"number\">0</span> ? a : b;<span class=\"comment\">//传入比较器，返回较大者</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些个定义，都是在参数个数（0、1、2 个）和有无返回值上做文章。另外还有一些将泛型类型具体化的衍生接口，比如 <code>Predicate</code>、<code>LongSupplier</code> 等等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Predicate</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(T t)</span>;<span class=\"comment\">//输入1个参数，返回boolean，就好比是预言家，预言你这个输入是真还是假</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">LongSupplier</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">getAsLong</span><span class=\"params\">()</span>;<span class=\"comment\">//没有输入，输出long类型（long类型的提供者）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"lambda-表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式\"></a> Lambda 表达式</h1>\n<h2 id=\"lambda-表达式写法\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式写法\"></a> Lambda 表达式写法</h2>\n<p>遍历集合除了 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>基本的方式</a> 以外，还可以使用 Lambda 表达式。Lambda 表达式又称函数式表达，是 Java 中典型的语法糖。</p>\n<p>Lambda 表达式语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Type parameter, ... ) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>\n<p><code>parameters</code> 是参数列表， <code>&#123; statements; &#125;</code> 是 Lambda 表达式的主体。</p>\n<p>简化写法：</p>\n<ul>\n<li>参数简化：\n<ul>\n<li><code>parameters</code> 如果只有一个参数，可以省略小括号 <code>()</code>；如果没有参数，也需要空括号 <code>()</code>。</li>\n<li><code>parameters</code> 可以省略参数类型。</li>\n</ul>\n</li>\n<li>语句简化：\n<ul>\n<li>无返回值：<code>statements;</code> 只包含一条语句，无返回值，可省略大括号 <code>&#123;&#125;</code>、分号 <code>;</code></li>\n<li>有返回值：\n<ul>\n<li>一般写法：<code>(int x)-&gt;&#123;return x*x;&#125;</code></li>\n<li>普通的表达式：<code>(int i,int j)-&gt;(i*j+2)</code></li>\n<li>可省略括号：<code>x-&gt;x*x</code></li>\n<li>❌错误写法：<code>x-&gt;return x*x</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"lambda-表达式代替匿名内部类\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式代替匿名内部类\"></a> Lambda 表达式代替匿名内部类</h2>\n<p><code>@FunctionalInterface</code> 声明了函数类型，Lambda 表达式就用来定义函数类型的实现体。在介绍 Lambda 简化原理之前，首先回忆以下关于 Java 接口的知识。</p>\n<p>Java 的 <code>interface</code> 接口有以下特点：</p>\n<ul>\n<li>接口不能被实例化，只能通过它的实现类来实现。</li>\n<li>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量引用实现了这个接口类的实例。如：<code>Photographable t=new Camera();</code>，其中 <code>Photographable</code> 为接口类型，<code>Camera</code> 为实现了这个接口的类。</li>\n<li>可以使用匿名内部类创建接口类型的引用变量。匿名内部类中必须实现接口的所有方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Flyable 为接口类型</span></span><br><span class=\"line\"><span class=\"type\">Flyable</span> <span class=\"variable\">fly</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Flyable</span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">laugh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在没有 Lambda 之前，有些方法要求传入接口类型的参数。我们需要先用匿名内部类创建接口类型的引用变量，再把它传进去。现在 Java 8 中可以通过 Lambda 语法糖快速实现一个<strong>单方法</strong>的匿名内部类。</p>\n<p>更详细地说，Lambda 表达式只能赋值给声明为函数式接口的 Java 类型的变量（注解 <code>@FunctionalInterface</code>）。下文例子中的 <code>Runnable</code>、<code>Consumer</code>、<code>Comparator</code> 都是被 <code>@FunctionalInterface</code> 标注的函数式接口，因此可以接受 Lambda 表达式。</p>\n<h3 id=\"例子-1线程的创建\"><a class=\"markdownIt-Anchor\" href=\"#例子-1线程的创建\"></a> 例子 1：线程的创建</h3>\n<p>详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>Java 并发编程</a></p>\n<h3 id=\"例子-2foreach\"><a class=\"markdownIt-Anchor\" href=\"#例子-2foreach\"></a> 例子 2：foreach</h3>\n<p>Java 集合都实现了 <code>java.util.Iterable</code> 接口。<code>forEach()</code> 方法有一个 <code>Consumer</code> 接口类型的 <code>action</code> 参数，它包含了对集合中每个元素的具体操作行为。<code>action</code> 参数所引用的 <code>Consumer</code> 实例必须实现 <code>Consumer</code> 接口的 <code>accept(T t)</code> 方法，在该方法中指定对参数 <code>t</code> 所执行的具体操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java Iterable 接口源代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (T t : <span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            action.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    List&lt;Person&gt; persons = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Person&gt;()&#123;  </span><br><span class=\"line\">      &#123;  <span class=\"comment\">//匿名类初始化代码  </span></span><br><span class=\"line\">        add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">21</span>)); </span><br><span class=\"line\">        add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Mike&quot;</span>,<span class=\"number\">32</span>));  </span><br><span class=\"line\">        add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Linda&quot;</span>,<span class=\"number\">19</span>));</span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    persons.forEach( (Person p) -&gt;&#123;  <span class=\"comment\">//Lambda表达式，相当于是Consumer类型的匿名对象</span></span><br><span class=\"line\">\t\t\t <span class=\"comment\">//指定对每个元素的具体操作</span></span><br><span class=\"line\">\t\t\t p.setAge(p.getAge()+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t System.out.println(p.getName()+<span class=\"string\">&quot;:&quot;</span>+p.getAge()); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    );        </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以上 Lambda 表达式相当于创建了一个 <code>Consumer</code> 类型的匿名对象，并实现了 <code>Consumer</code> 接口的 <code>accept(T t)</code> 方法，此处传给 <code>accept(T t)</code> 方法的参数为 <code>Person</code> 对象。在 Lambda 表达式中符号 <code>-&gt;</code> 后的可执行语句块相当于 <code>accept(T t)</code> 方法的方法体。</p>\n<h3 id=\"例子-3排序\"><a class=\"markdownIt-Anchor\" href=\"#例子-3排序\"></a> 例子 3：排序</h3>\n<p>详看文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/72156dd2/\"><span class=\"yukari\">站内文章</span>Java 中的排序</a>。</p>\n<h3 id=\"例-4与-stream-api-连用\"><a class=\"markdownIt-Anchor\" href=\"#例-4与-stream-api-连用\"></a> 例 4：与 Stream API 连用</h3>\n<p><code>Collection</code> 接口的 <code>stream()</code> 方法返回一个 <code>Stream</code> 对象，程序可以通过这个 <code>Stream</code> 对象操纵集合中的元素。</p>\n<h2 id=\"lambda-表达式可操纵的变量作用域\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式可操纵的变量作用域\"></a> Lambda 表达式可操纵的变量作用域</h2>\n<p><code>this</code> 关键字实际上引用的是外部类的实例。</p>\n<p>在 Lambda 表达式中访问的局部变量必须符合以下两个条件之一：</p>\n<ul>\n<li>条件一：最终局部变量，即用 <code>final</code> 修饰的局部变量。</li>\n<li>条件二：实际上的最终局部变量，即虽然没有被 <code>final</code> 修饰，但在程序中不会改变局部变量的值。</li>\n</ul>\n<h1 id=\"方法引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用\"></a> 方法引用</h1>\n<p>在编译器能根据上下文来推断 Lambda 表达式的参数的场合，可以在 Lambda 表达式中省略参数，直接通过 <code>::</code> 符号来引用方法。</p>\n<p>方法引用就是对一个类中已经存在的方法加以引用，分以下类型：</p>\n<ol>\n<li>引用类的静态方法\n<ul>\n<li>对类构造方法的引用，如 <code>ClassName::new</code>。</li>\n<li>对类静态方法的引用，如 <code>ClassName::staticMethodName</code>。编译器会根据上下文推断到底用哪个对象的实例方法。</li>\n</ul>\n</li>\n<li>引用实例方法\n<ul>\n<li><code>objectName::instanceMethod</code>，或者 <code>new Test()::instanceMethod</code></li>\n<li><code>ClassName::instanceMethod</code>。编译器会根据上下文推断到底用哪个对象的实例方法。</li>\n</ul>\n</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(x) <span class=\"comment\">// 等同于 BigDecimal::new</span></span><br><span class=\"line\">x-&gt;System.out.println(x) <span class=\"comment\">// 引用实例方法 相当于 System.out::println</span></span><br><span class=\"line\">(x,y)-&gt;Math.max(x,y)     <span class=\"comment\">// 引用静态方法 相当于 Math::max</span></span><br><span class=\"line\">x-&gt;x.toLowerCase()       <span class=\"comment\">// 引用实例方法 相当于 String::toLowerCase </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下两种 Lambda 表达式等价：</span></span><br><span class=\"line\">names.forEach((name)-&gt;System.out.println(name));</span><br><span class=\"line\">names.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.runoob.com/java/java8-lambda-expressions.html\">Java Lambda 表达式 | 菜鸟教程 (runoob.com)</a></li>\n<li>《Java 面向对象编程》孙卫琴</li>\n<li><a href=\"https://blog.csdn.net/linysuccess/article/details/104751843\">彻底弄懂@FunctionalInterface、Lambda表达式和方法引用_functionalinterface 可以额外定义static方法-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/MeatLoveJK/article/details/95891087\">实例化接口的几种方式_接口实例化-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/wuhenzhidu/p/anonymous.html\">JAVA匿名内部类(Anonymous Classes) - 无恨之都 - 博客园</a></li>\n</ul>\n","raw":"---\ntitle: Java 8 中的函数式编程\ntags:\n  - Java\n  - Lambda\ncover: 'https://cdn.gallery.uuanqin.top/img/202508120100998.webp'\ndescription: 函数式编程为我们打开了一扇大门\nkatex: false\ncategories:\n  - 计算机语言\nabbrlink: 2c5c0eb2\ndate: 2025-08-13 00:05:41\ntop_img:\n---\n\n函数式编程的核心特点是，函数作为一段功能代码，可以像变量一样进行引用和传递，以便在有需要的时候进行调用。\n\n# 函数类型与 `@FunctionalInterface`\n\nJava 对函数式编程的支持，本质是通过接口机制来实现的。首先定义一个**仅声明一个方法**的接口，然后对接口冠以 `@FunctionalInterface` 注解，那么这个接口就可以作为「函数类型」，可以接收一段以 **Lambda 表达式**，或者**方法引用**予以承载的逻辑代码。\n\n被 `@FunctionalInterface` 标注的接口仅声明一个方法，一旦这个函数定义好，它能执行的功能是确定的，就是调用和不调用的区别。显然，这个方法可以用来代表「函数类型」所能执行的功能，接口中声明的方法就是和函数体定义一一对应的。\n\n`@FunctionalInterface` 下只能声明一个未实现的方法，多一个、少一个都不能编译通过。但有以下例外：\n\n- 覆写 `Object` 中 `toString/equals` 的方法不受此个数限制。\n- `default` 方法和 `static` 方法因为带有实现体，所以也不受此限制。\n\n`@FunctionalInterface` 注解不是必须的，不加这个注解的接口（前提是只包含一个方法）一样可以作为函数类型。不过，显而易见的是，加了这个注解表意更明确、更直观，是更被推荐的做法。\n\n## JDK 提供的函数类型\n\n`java.util.function` 包下预定义了常用的函数类型，包括：\n\n```java\n@FunctionalInterface\npublic interface Consumer<T> {\n    void accept(T t); //接收一个类型为T（泛型）的参数，无返回值；所以叫消费者\n}\n\n@FunctionalInterface\npublic interface BiConsumer<T, U> {\n    void accept(T t, U u);//接收2个参数，无返回值\n}\n\n@FunctionalInterface\npublic interface Supplier<T> {\n    T get();//无参数，有返回值（所以叫提供者）\n}\n\n//注意没有BiSupplier，因为返回值只能有1个，不会有2个\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);//一个输入（参数），一个输出（返回值）\n}\n\n@FunctionalInterface\npublic interface BiFunction<T, U, R> {\n    R apply(T t, U u);//两个输入T和U，一个输出R\n}\n\n@FunctionalInterface\npublic interface UnaryOperator<T> extends Function<T, T> {\n    static <T> UnaryOperator<T> identity() {//一元操作，输入原样返回给输出\n        return t -> t;\n    }\n}\n\n@FunctionalInterface\npublic interface BinaryOperator<T> extends BiFunction<T,T,T> {//二元操作，输入输出类型相同\n    public static <T> BinaryOperator<T> minBy(Comparator<? super T> comparator) {\n        Objects.requireNonNull(comparator);\n        return (a, b) -> comparator.compare(a, b) <= 0 ? a : b;//传入比较器，返回较小者\n    }\n    public static <T> BinaryOperator<T> maxBy(Comparator<? super T> comparator) {\n        Objects.requireNonNull(comparator);\n        return (a, b) -> comparator.compare(a, b) >= 0 ? a : b;//传入比较器，返回较大者\n    }\n}\n```\n\n这些个定义，都是在参数个数（0、1、2 个）和有无返回值上做文章。另外还有一些将泛型类型具体化的衍生接口，比如 `Predicate`、`LongSupplier` 等等。\n\n```java\n@FunctionalInterface\npublic interface Predicate<T> {\n    boolean test(T t);//输入1个参数，返回boolean，就好比是预言家，预言你这个输入是真还是假\n}\n\n@FunctionalInterface\npublic interface LongSupplier {\n    long getAsLong();//没有输入，输出long类型（long类型的提供者）\n}\n```\n\n# Lambda 表达式\n\n## Lambda 表达式写法\n\n遍历集合除了 [[1 迭代器模式  Iterator|基本的方式]] 以外，还可以使用 Lambda 表达式。Lambda 表达式又称函数式表达，是 Java 中典型的语法糖。\n\nLambda 表达式语法：\n\n```java\n(Type parameter, ... ) ->{ statements; }\n```\n\n`parameters` 是参数列表， `{ statements; }` 是 Lambda 表达式的主体。\n\n简化写法：\n\n- 参数简化：\n\t- `parameters` 如果只有一个参数，可以省略小括号 `()`；如果没有参数，也需要空括号 `()`。\n\t- `parameters` 可以省略参数类型。\n- 语句简化：\n\t- 无返回值：`statements;` 只包含一条语句，无返回值，可省略大括号 `{}`、分号 `;`\n\t- 有返回值：\n\t\t- 一般写法：`(int x)->{return x*x;}`\n\t\t- 普通的表达式：`(int i,int j)->(i*j+2)`\n\t\t- 可省略括号：`x->x*x`\n\t\t- ❌错误写法：`x->return x*x`\n\n## Lambda 表达式代替匿名内部类\n\n`@FunctionalInterface` 声明了函数类型，Lambda 表达式就用来定义函数类型的实现体。在介绍 Lambda 简化原理之前，首先回忆以下关于 Java 接口的知识。\n\nJava 的 `interface` 接口有以下特点：\n\n- 接口不能被实例化，只能通过它的实现类来实现。\n- 不允许创建接口的实例，但允许定义接口类型的引用变量，该变量引用实现了这个接口类的实例。如：`Photographable t=new Camera();`，其中 `Photographable` 为接口类型，`Camera` 为实现了这个接口的类。\n- 可以使用匿名内部类创建接口类型的引用变量。匿名内部类中必须实现接口的所有方法。\n\n```java\n// Flyable 为接口类型\nFlyable fly = new Flyable() {\n\t@Override\n\tpublic void shit() {\n\t\t// TODO Auto-generated method stub\n\t}\n\t\n\t@Override\n\tpublic void laugh() {\n\t\t// TODO Auto-generated method stub\n\t}\n\t\n\t@Override\n\tpublic void fly() {\n\t\t// TODO Auto-generated method stub\n\t}\n};\n```\n\n在没有 Lambda 之前，有些方法要求传入接口类型的参数。我们需要先用匿名内部类创建接口类型的引用变量，再把它传进去。现在 Java 8 中可以通过 Lambda 语法糖快速实现一个**单方法**的匿名内部类。\n\n更详细地说，Lambda 表达式只能赋值给声明为函数式接口的 Java 类型的变量（注解 `@FunctionalInterface`）。下文例子中的 `Runnable`、`Consumer`、`Comparator` 都是被 `@FunctionalInterface` 标注的函数式接口，因此可以接受 Lambda 表达式。\n\n### 例子 1：线程的创建\n\n详看：[[Java 并发编程]]\n\n### 例子 2：foreach\n\nJava 集合都实现了 `java.util.Iterable` 接口。`forEach()` 方法有一个 `Consumer` 接口类型的 `action` 参数，它包含了对集合中每个元素的具体操作行为。`action` 参数所引用的 `Consumer` 实例必须实现 `Consumer` 接口的 `accept(T t)` 方法，在该方法中指定对参数 `t` 所执行的具体操作。\n\n```java\n// Java Iterable 接口源代码\npublic interface Iterable<T> {\n    default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n    \n    // ...\n}\n```\n\n示例：\n\n```java\npublic static void main(String[] args) {\n  \n    List<Person> persons = new ArrayList<Person>(){  \n      {  //匿名类初始化代码  \n        add(new Person(\"Tom\",21)); \n        add(new Person(\"Mike\",32));  \n        add(new Person(\"Linda\",19));\n      }  \n    };\n\n    persons.forEach( (Person p) ->{  //Lambda表达式，相当于是Consumer类型的匿名对象\n\t\t\t //指定对每个元素的具体操作\n\t\t\t p.setAge(p.getAge()+1);\n\t\t\t System.out.println(p.getName()+\":\"+p.getAge()); \n\t\t}\n    );        \n  }\n```\n\n以上 Lambda 表达式相当于创建了一个 `Consumer` 类型的匿名对象，并实现了 `Consumer` 接口的 `accept(T t)` 方法，此处传给 `accept(T t)` 方法的参数为 `Person` 对象。在 Lambda 表达式中符号 `->` 后的可执行语句块相当于 `accept(T t)` 方法的方法体。\n\n### 例子 3：排序\n\n详看文章：[[Java 中的排序]]。\n\n### 例 4：与 Stream API 连用\n\n`Collection` 接口的 `stream()` 方法返回一个 `Stream` 对象，程序可以通过这个 `Stream` 对象操纵集合中的元素。\n\n## Lambda 表达式可操纵的变量作用域\n\n`this` 关键字实际上引用的是外部类的实例。\n\n在 Lambda 表达式中访问的局部变量必须符合以下两个条件之一：\n\n- 条件一：最终局部变量，即用 `final` 修饰的局部变量。\n- 条件二：实际上的最终局部变量，即虽然没有被 `final` 修饰，但在程序中不会改变局部变量的值。\n\n# 方法引用\n\n在编译器能根据上下文来推断 Lambda 表达式的参数的场合，可以在 Lambda 表达式中省略参数，直接通过 `::` 符号来引用方法。\n\n方法引用就是对一个类中已经存在的方法加以引用，分以下类型：\n\n1. 引用类的静态方法\n\t- 对类构造方法的引用，如 `ClassName::new`。\n\t- 对类静态方法的引用，如 `ClassName::staticMethodName`。编译器会根据上下文推断到底用哪个对象的实例方法。\n2. 引用实例方法\n\t- `objectName::instanceMethod`，或者 `new Test()::instanceMethod`\n\t- `ClassName::instanceMethod`。编译器会根据上下文推断到底用哪个对象的实例方法。\n\n示例：\n\n```java\nx -> new BigDecimal(x) // 等同于 BigDecimal::new\nx->System.out.println(x) // 引用实例方法 相当于 System.out::println\n(x,y)->Math.max(x,y)     // 引用静态方法 相当于 Math::max\nx->x.toLowerCase()       // 引用实例方法 相当于 String::toLowerCase \n\n\n// 以下两种 Lambda 表达式等价：\nnames.forEach((name)->System.out.println(name));\nnames.forEach(System.out::println);\n```\n\n\n# 本文参考\n\n- [Java Lambda 表达式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java8-lambda-expressions.html)\n- 《Java 面向对象编程》孙卫琴\n- [彻底弄懂@FunctionalInterface、Lambda表达式和方法引用_functionalinterface 可以额外定义static方法-CSDN博客](https://blog.csdn.net/linysuccess/article/details/104751843)\n- [实例化接口的几种方式_接口实例化-CSDN博客](https://blog.csdn.net/MeatLoveJK/article/details/95891087)\n- [JAVA匿名内部类(Anonymous Classes) - 无恨之都 - 博客园](https://www.cnblogs.com/wuhenzhidu/p/anonymous.html)","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"Lambda","api":"api/tags/Lambda.json"}]},"api":"api/posts/p/2c5c0eb2.json"}