{"data":{"title":"字符串的匹配算法（单模式串）","slug":"算法与数据结构/字符串的匹配算法（单模式串）","description":"Needle in a Haystack. 大海捞针","date":"2024-09-04T15:58:39.000Z","updated":"2025-09-13T11:16:08.100Z","language":"zh-CN","comments":true,"url":"p/53501b47/","cover":"https://cdn.gallery.uuanqin.top/img/202409020200851.webp","images":[],"content":"<p>KMP 算法真的是…看了忘，忘了看…每次看时都要从盘古开天辟地开始看…从大一看到现在，真·从小看到大！</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟩 <a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/\">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 -1 。</p>\n</div></div><p>模式匹配指的是求子串（模式串）在主串中的位置。常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等。</p>\n<p>下文中，有时候将题目中的主串 <code>haystack</code> 称为 <code>S</code>，模式串 <code>needle</code> 称为 <code>T</code>。</p>\n<h1 id=\"暴力算法brute-force-bf\"><a class=\"markdownIt-Anchor\" href=\"#暴力算法brute-force-bf\"></a> 暴力算法（Brute Force, BF）</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408282329815.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408282330496.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p>每次匹配失败，T 串向前走。直到匹配成功或返回 -1。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408282331682.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p>我们发现，指向 S 和 T 串的指针，在出现失配时需要进行回溯。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">strStr</span><span class=\"params\">(String haystack, String needle)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> haystack.length(), m = needle.length();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 加速点：发生不匹配时立即终止。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度（最坏）：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n×m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是字符串 <code>haystack</code> 的长度，m 是字符串 <code>needle</code> 的长度。最坏情况下我们需要将字符串 <code>needle</code> 与字符串 <code>haystack</code> 的所有长度为 m 的子串均匹配一次。</p>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。我们只需要常数的空间保存若干变量。</p>\n<h1 id=\"rk-算法rabin-karp\"><a class=\"markdownIt-Anchor\" href=\"#rk-算法rabin-karp\"></a> RK 算法（Rabin-Karp）</h1>\n<p>RK 算法是 BF 算法的升级版。</p>\n<p>具体思路为：长度为 m 的主串有 n-m+1 个长度为 m 的子串，通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后与模式串的哈希值进行比较。</p>\n<ul>\n<li>如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身。</li>\n<li>如果某个子串的哈希值等于模式串的哈希值，再进一步对比一下子串和模式串本身，判断是否真的匹配。</li>\n</ul>\n<p>对于使用哈希算法计算 n-m+1 个长度为 m 的子串的哈希值的过程，我们要控制其时间复杂度在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，之内。这样的哈希算法有一个特点，在主串中，相邻两个子串哈希值的计算公式有一定的关系。</p>\n<p>例如，要处理的字符串只包含 a 到 z 这 26 个小写字母，那么我们就用 26 进制来表示一个子串，我们把 a 到 z 这 26 个字符映射到 0 到 25 这 26 个数字：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506042148357.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p>相邻子串计算方法（下图中子串大小为 m=3）：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506042148097.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p>通过上图，你可以轻松得出前后相邻两个子串哈希值的推导公式。</p>\n<blockquote>\n<p>小技巧，对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><msup><mn>6</mn><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">26^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><msup><mn>6</mn><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">26^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><msup><mn>6</mn><mn>2</mn></msup><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mn>2</mn><msup><mn>6</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">26^2...26^{m-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 这些数，我们可以事先存值减小时间复杂度。</p>\n</blockquote>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。如果存在大量的哈希冲突，时间复杂度会退化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n×m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h1 id=\"kmp-算法knuth-morris-pratt\"><a class=\"markdownIt-Anchor\" href=\"#kmp-算法knuth-morris-pratt\"></a> KMP 算法（Knuth-Morris-Pratt）</h1>\n<blockquote>\n<p>不正经简记：👁️🎩🎬</p>\n</blockquote>\n<p>Knuth-Morris-Pratt 算法，简称 KMP 算法，由 Donald Knuth、James H. Morris 和 Vaughan Pratt 三人于 1977 年联合发表。</p>\n<p>一些定义：</p>\n<ul>\n<li>真前缀：除最后一个字符以外，字符串的所有头部子串</li>\n<li>真后缀：除第一个字符以外，字符串的所有尾部子串</li>\n<li>部分匹配值（Partial Match）：字符串的前缀和后缀的最长相等前后缀长度</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408282334168.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<p>上图中：</p>\n<ul>\n<li>上一串表示 S 串，下一串表示 T 串</li>\n<li>红色表示失配点</li>\n<li>蓝色和绿色表示匹配成功的部分</li>\n<li>蓝色表示前后缀相同的部分</li>\n</ul>\n<p>失配后将子串这样移，再进行后续的比较：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408282336538.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<p>我们发现整个过程中主串指针 i 不需要回退。</p>\n<p>Knuth-Morris-Pratt 算法的核心为前缀函数，记作 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">π(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>，其定义如下：对于长度为 L 的字符串 s，其前缀函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>L</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">π(i)(0≤i&lt;L)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span> 表示 s 的子串 <code>s[0:i]</code> 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">π(i)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<table>\n<thead>\n<tr>\n<th>字符串</th>\n<th colspan=\"2\">a</th>\n<th>b</th>\n<th colspan=\"3\">a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>index</code></td>\n<td rowspan=\"2\">0</td>\n<td rowspan=\"2\">1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n<td>6</td>\n</tr>\n<tr>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">π(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 、<code>next</code></td>\n<td>0</td>\n<td>1</td>\n<td colspan=\"2\">2</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">π(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 构成的表项我们也可以称为前缀表 <code>next</code>，含义在于当出现失配时，T 串需要回退的位置。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408282346145.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<p>在子串的某一个字符 <code>t[j]</code> 处匹配失败时，我们需要查找该字符前面的那个子串的最大相等前后缀的长度，即 <code>next[j-1]</code>，然后使 j 指针退回到 <code>next[j-1]</code>，i 指针不变，继续匹配，不断重复这个操作直到匹配成功或者 j 指针大于等于子串长度。</p>\n<p>在理解了前缀表及其作用之后，KMP 算法就可以整体上分为两步：</p>\n<ol>\n<li>计算前缀表。我们可以一边读入字符串，一边求解当前读入位的前缀函数。</li>\n<li>根据前缀表移动两个指针进行匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">strStr</span><span class=\"params\">(String haystack, String needle)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> strStr1(haystack.toCharArray(),needle.toCharArray());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数对字符串s进行预处理得到next数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">get_Next</span><span class=\"params\">(<span class=\"type\">char</span>[] s, <span class=\"type\">int</span>[] next)</span>\t\t</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tnext[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"comment\">// i指针指向的是后缀末尾，j指针指向的是前缀末尾</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i&lt;s.length; i++)&#123;\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span> &amp;&amp; s[i]!=s[j])\t</span><br><span class=\"line\">\t\t\tj = next[j-<span class=\"number\">1</span>];\t<span class=\"comment\">//前后缀不相同，循环找j前一位的最长相等前后缀</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==s[j])\tj++;\t<span class=\"comment\">//前后缀相同，j指针后移</span></span><br><span class=\"line\">\t\tnext[i] = j;\t<span class=\"comment\">//更新 next 数组</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数是从s中找到t，如果存在返回t出现的位置，如果不存在返回-1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">strStr1</span><span class=\"params\">(<span class=\"type\">char</span>[] s, <span class=\"type\">char</span>[] t)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[t.length];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t.length==<span class=\"number\">0</span>)\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tget_Next(t, next);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j = <span class=\"number\">0</span>; i &lt; s.length; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(j&gt;<span class=\"number\">0</span> &amp;&amp; s[i]!=t[j])</span><br><span class=\"line\">\t\t\tj = next[j-<span class=\"number\">1</span>];\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==t[j])\tj++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j==t.length)\t<span class=\"keyword\">return</span> i - t.length + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是字符串 <code>haystack</code> 的长度，m 是字符串 <code>needle</code> 的长度。我们至多需要遍历两字符串一次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中 m 是字符串 <code>needle</code> 的长度。我们只需要保存字符串 <code>needle</code> 的前缀函数。</li>\n</ul>\n<h1 id=\"boyer-moore-算法\"><a class=\"markdownIt-Anchor\" href=\"#boyer-moore-算法\"></a> Boyer Moore 算法</h1>\n<blockquote>\n<p>KMP 算法将前缀匹配的信息用到了极致，而 BM 算法背后的基本思想是通过后缀匹配获得比前缀匹配更多的信息来实现更快的字符跳转。</p>\n</blockquote>\n<p>⭐推荐阅读：<a href=\"https://writings.sh/post/algorithm-string-searching-boyer-moore\">字符串匹配 - Boyer–Moore 算法原理和实现 | 春水煎茶 (writings.sh)</a></p>\n<p>Boyer-Moore 的核心概念：坏字符和好后缀。坏字符办法和好后缀办法，可以综合使用，也可以单独使用一种，其中坏字符的办法实现更简单一些。</p>\n<h1 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h1>\n<p>在一般情况下。普通模式匹配的实际执行时间近似为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m+n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，因此至今仍被采用。KMP 算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快得多，其主要优点是主串不用回溯。</p>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<p>这篇文章写完后，遇到相关题目又忘了！</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>2023 王道 《408 数据结构》</li>\n<li>极客时间 - 王争 - 数据结构与算法之美</li>\n<li><a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/732236/shi-xian-strstr-by-leetcode-solution-ds6y/?envType=study-plan-v2&amp;envId=top-interview-150\">28. 找出字符串中第一个匹配项的下标题解 - 力扣（LeetCode）</a></li>\n<li><a href=\"https://blog.csdn.net/m0_70897036/article/details/138016245\">字符串——单模匹配算法_字符串单模匹配-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/qq_43869106/article/details/128753527\">图解KMP算法，带你彻底吃透KMP-CSDN博客</a></li>\n<li>【⭐推荐】<a href=\"https://writings.sh/post/algorithm-string-searching-kmp\">字符串匹配 - KMP 算法原理和实现 | 春水煎茶 (writings.sh)</a>（优质文章，附有大量精美图片）</li>\n<li><a href=\"https://blog.csdn.net/weixin_46272350/article/details/120671730\">一看就懂的字符串匹配算法 之 RK算法-CSDN博客</a></li>\n<li><a href=\"https://oi-wiki.org/string/bm/\">Boyer–Moore 算法 - OI Wiki</a></li>\n</ul>\n","raw":"---\ntitle: 字符串的匹配算法（单模式串）\ntags:\n  - LeetCode\n  - KMP\n  - String\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202409020200851.webp'\ndescription: Needle in a Haystack. 大海捞针\ncategories:\n  - 算法与数据结构\nabbrlink: 53501b47\nkatex: true\ndate: 2024-09-04 23:58:39\ntop_img:\n---\n\nKMP 算法真的是......看了忘，忘了看......每次看时都要从盘古开天辟地开始看......从大一看到现在，真·从小看到大！\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n> [!example] 题目：🟩 [28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)\n> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 -1 。\n\n模式匹配指的是求子串（模式串）在主串中的位置。常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等。\n\n下文中，有时候将题目中的主串 `haystack` 称为 `S`，模式串 `needle` 称为 `T`。\n\n# 暴力算法（Brute Force, BF）\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/202408282329815.webp)\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/202408282330496.webp)\n\n每次匹配失败，T 串向前走。直到匹配成功或返回 -1。\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/202408282331682.webp)\n\n我们发现，指向 S 和 T 串的指针，在出现失配时需要进行回溯。\n\n```java\npublic int strStr(String haystack, String needle) {\n\tint n = haystack.length(), m = needle.length();\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tboolean flag = true;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\t// 加速点：发生不匹配时立即终止。\n\t\t\tif (haystack.charAt(i + j) != needle.charAt(j)) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n\n时间复杂度（最坏）：$O(n×m)$，其中 n 是字符串 `haystack` 的长度，m 是字符串 `needle` 的长度。最坏情况下我们需要将字符串 `needle` 与字符串 `haystack` 的所有长度为 m 的子串均匹配一次。\n\n空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。\n\n# RK 算法（Rabin-Karp）\n\nRK 算法是 BF 算法的升级版。\n\n具体思路为：长度为 m 的主串有 n-m+1 个长度为 m 的子串，通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后与模式串的哈希值进行比较。\n\n- 如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身。\n- 如果某个子串的哈希值等于模式串的哈希值，再进一步对比一下子串和模式串本身，判断是否真的匹配。\n\n对于使用哈希算法计算 n-m+1 个长度为 m 的子串的哈希值的过程，我们要控制其时间复杂度在 $O(n)$，之内。这样的哈希算法有一个特点，在主串中，相邻两个子串哈希值的计算公式有一定的关系。\n\n例如，要处理的字符串只包含 a 到 z 这 26 个小写字母，那么我们就用 26 进制来表示一个子串，我们把 a 到 z 这 26 个字符映射到 0 到 25 这 26 个数字：\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202506042148357.webp)\n\n相邻子串计算方法（下图中子串大小为 m=3）：\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202506042148097.webp)\n\n通过上图，你可以轻松得出前后相邻两个子串哈希值的推导公式。\n\n> 小技巧，对于 $26^0$、$26^1$、$26^2...26^{m-1}$ 这些数，我们可以事先存值减小时间复杂度。\n\n时间复杂度：$O(n)$。如果存在大量的哈希冲突，时间复杂度会退化为 $O(n×m)$。\n\n# KMP 算法（Knuth-Morris-Pratt）\n\n> 不正经简记：👁️🎩🎬\n\nKnuth-Morris-Pratt 算法，简称 KMP 算法，由 Donald Knuth、James H. Morris 和 Vaughan Pratt 三人于 1977 年联合发表。\n\n一些定义：\n\n- 真前缀：除最后一个字符以外，字符串的所有头部子串\n- 真后缀：除第一个字符以外，字符串的所有尾部子串\n- 部分匹配值（Partial Match）：字符串的前缀和后缀的最长相等前后缀长度\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202408282334168.webp)\n\n上图中：\n\n- 上一串表示 S 串，下一串表示 T 串\n- 红色表示失配点\n- 蓝色和绿色表示匹配成功的部分\n- 蓝色表示前后缀相同的部分\n\n失配后将子串这样移，再进行后续的比较：\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202408282336538.webp)\n\n我们发现整个过程中主串指针 i 不需要回退。\n\nKnuth-Morris-Pratt 算法的核心为前缀函数，记作 $π(i)$，其定义如下：对于长度为 L 的字符串 s，其前缀函数 $π(i)(0≤i<L)$ 表示 s 的子串 `s[0:i]` 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么 $π(i)=0$。\n\n| 字符串            | a   | a   | b   | a   | a   | a   | b   |\n| -------------- | --- | --- | --- | --- | --- | --- | --- |\n| `index`        | 0   | 1   | 2   | 3   | 4   | 5   | 6   |\n| $π(i)$ 、`next` | 0   | 1   | 0   | 1   | 2   | 2   | 3   |\n\n由 $π(i)$ 构成的表项我们也可以称为前缀表 `next`，含义在于当出现失配时，T 串需要回退的位置。\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202408282346145.webp)\n\n在子串的某一个字符 `t[j]` 处匹配失败时，我们需要查找该字符前面的那个子串的最大相等前后缀的长度，即 `next[j-1]`，然后使 j 指针退回到 `next[j-1]`，i 指针不变，继续匹配，不断重复这个操作直到匹配成功或者 j 指针大于等于子串长度。\n\n在理解了前缀表及其作用之后，KMP 算法就可以整体上分为两步：\n\n1. 计算前缀表。我们可以一边读入字符串，一边求解当前读入位的前缀函数。\n2. 根据前缀表移动两个指针进行匹配。\n\n```java\npublic int strStr(String haystack, String needle) {\n\treturn strStr1(haystack.toCharArray(),needle.toCharArray());\n}\n\n//这个函数对字符串s进行预处理得到next数组\npublic static void get_Next(char[] s, int[] next)\t\t\n{\n\tint j = 0;\n\tnext[0] = 0;\t//初始化\n\t// i指针指向的是后缀末尾，j指针指向的是前缀末尾\n\tfor(int i = 1; i<s.length; i++){\t\n\t\twhile (j>0 && s[i]!=s[j])\t\n\t\t\tj = next[j-1];\t//前后缀不相同，循环找j前一位的最长相等前后缀\n\t\tif(s[i]==s[j])\tj++;\t//前后缀相同，j指针后移\n\t\tnext[i] = j;\t//更新 next 数组\n\t}\n}\n\n//这个函数是从s中找到t，如果存在返回t出现的位置，如果不存在返回-1\npublic int strStr1(char[] s, char[] t) {\n\tint[] next = new int[t.length];\n\tif(t.length==0)\treturn 0;\n\tget_Next(t, next);\n\tfor(int i = 0,j = 0; i < s.length; i++){\n\t\twhile(j>0 && s[i]!=t[j])\n\t\t\tj = next[j-1];\t\n\t\tif(s[i]==t[j])\tj++;\n\t\tif(j==t.length)\treturn i - t.length + 1;\n\t}\n\treturn -1;\n}\n\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n+m)$，其中 n 是字符串 `haystack` 的长度，m 是字符串 `needle` 的长度。我们至多需要遍历两字符串一次。\n- 空间复杂度：$O(m)$，其中 m 是字符串 `needle` 的长度。我们只需要保存字符串 `needle` 的前缀函数。\n\n# Boyer Moore 算法\n\n> KMP 算法将前缀匹配的信息用到了极致，而 BM 算法背后的基本思想是通过后缀匹配获得比前缀匹配更多的信息来实现更快的字符跳转。\n\n⭐推荐阅读：[字符串匹配 - Boyer–Moore 算法原理和实现 | 春水煎茶 (writings.sh)](https://writings.sh/post/algorithm-string-searching-boyer-moore)\n\nBoyer-Moore 的核心概念：坏字符和好后缀。坏字符办法和好后缀办法，可以综合使用，也可以单独使用一种，其中坏字符的办法实现更简单一些。\n\n# 小结\n\n在一般情况下。普通模式匹配的实际执行时间近似为 $O(m+n)$，因此至今仍被采用。KMP 算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快得多，其主要优点是主串不用回溯。\n\n# 后记\n\n这篇文章写完后，遇到相关题目又忘了！\n\n# 本文参考\n\n- 2023 王道 《408 数据结构》\n- 极客时间 - 王争 - 数据结构与算法之美\n- [28. 找出字符串中第一个匹配项的下标题解 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/732236/shi-xian-strstr-by-leetcode-solution-ds6y/?envType=study-plan-v2&envId=top-interview-150)\n- [字符串——单模匹配算法_字符串单模匹配-CSDN博客](https://blog.csdn.net/m0_70897036/article/details/138016245)\n- [图解KMP算法，带你彻底吃透KMP-CSDN博客](https://blog.csdn.net/qq_43869106/article/details/128753527)\n- 【⭐推荐】[字符串匹配 - KMP 算法原理和实现 | 春水煎茶 (writings.sh)](https://writings.sh/post/algorithm-string-searching-kmp)（优质文章，附有大量精美图片）\n- [一看就懂的字符串匹配算法 之 RK算法-CSDN博客](https://blog.csdn.net/weixin_46272350/article/details/120671730)\n- [Boyer–Moore 算法 - OI Wiki](https://oi-wiki.org/string/bm/)","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"KMP","api":"api/tags/KMP.json"},{"name":"String","api":"api/tags/String.json"}]},"api":"api/posts/p/53501b47.json"}