{"data":{"title":"EventBus 框架的简易实现","slug":"技术学习/EventBus 框架的简易实现","description":"观察者模式的框架实现","date":"2025-08-26T13:38:30.000Z","updated":"2025-08-26T16:18:00.710Z","language":"zh-CN","comments":true,"url":"p/2c61e522/","cover":"https://cdn.gallery.uuanqin.top/img/202508262351038.webp","images":[],"content":"<p>Google Guava 是 Google 公司内部 Java 开发工具库的开源版本，它提供了一些新功能或对 JDK 已有功能的增强功能。其中就包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I/O、事件总线（EventBus）等等。</p>\n<p>在 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/d1e2262f/\"><span class=\"bilink-pop-up\">站内文章</span>观察者模式：订阅与推送</a> 文章中，我们介绍了观察者模式的同步阻塞的实现方式和异步非阻塞实现方式。本文将介绍使用 Google Guava EventBus 让观察者模式的实现过程更加灵活和简易，并亲自动手写一个简易版的 EventBus。</p>\n<h1 id=\"从观察者模式开始\"><a class=\"markdownIt-Anchor\" href=\"#从观察者模式开始\"></a> 从观察者模式开始</h1>\n<p>使用 Google Guava EventBus 的观察者模式代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">registerObserver</span><span class=\"params\">(Object observer)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">removeObserver</span><span class=\"params\">(Object observer)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">notifyObservers</span><span class=\"params\">(Object message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Object&gt; observers = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> EventBus eventBus;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ConcreteSubject</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同步阻塞模式</span></span><br><span class=\"line\">        eventBus = <span class=\"keyword\">new</span> <span class=\"title class_\">EventBus</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 异步非阻塞模式</span></span><br><span class=\"line\">        <span class=\"comment\">// eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerObserver</span><span class=\"params\">(Object observer)</span> &#123;</span><br><span class=\"line\">        eventBus.register(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeObserver</span><span class=\"params\">(Object observer)</span> &#123;</span><br><span class=\"line\">        observers.remove(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyObservers</span><span class=\"params\">(Object message)</span> &#123;</span><br><span class=\"line\">        eventBus.post(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用 EventBus 框架实现的观察者模式，跟经典的同步阻塞观察者模式的代码相比，实现思路大致一样，都需要定义 <code>Observer</code>，并且通过 <code>registerObserver()</code> 函数注册 <code>Observer</code>，也都需要通过调用某个函数（比如，EventBus 中的 <code>post()</code> 函数）来给 <code>Observer</code> 发送消息（在 EventBus 中消息被称作事件 <code>event</code>）。</p>\n<p>但在实现细节方面，它们又有些区别。基于 EventBus，我们不需要定义 <code>Observer</code> 接口，任意类型的对象都可以注册到 EventBus 中，通过 <code>@Subscribe</code> 注解来标明类中哪个函数可以接收被观察者发送的消息。</p>\n<h1 id=\"guava-eventbus-的结构与功能\"><a class=\"markdownIt-Anchor\" href=\"#guava-eventbus-的结构与功能\"></a> Guava EventBus 的结构与功能</h1>\n<p>Guava EventBus 对外暴露的所有可调用接口，都封装在 <code>EventBus</code> 类中。其中，<code>EventBus</code> 实现了同步阻塞的观察者模式，<code>AsyncEventBus</code> 继承自 <code>EventBus</code>，提供了异步非阻塞的观察者模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">EventBus</span> <span class=\"variable\">eventBus</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EventBus</span>(); <span class=\"comment\">// 同步阻塞模式</span></span><br><span class=\"line\"><span class=\"type\">EventBus</span> <span class=\"variable\">eventBus</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncEventBus</span>(Executors.newFixedThreadPool(<span class=\"number\">8</span>))；<span class=\"comment\">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure>\n<p>EventBus 类提供了 <code>register()</code> 函数用来注册观察者。它可以接受任何类型（<code>Object</code>）的观察者。而在经典的观察者模式的实现中，<code>register()</code> 函数必须接受实现了同一 <code>Observer</code> 接口的类对象。<code>post()</code> 函数，用来给观察者发送消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Object object)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unregister</span><span class=\"params\">(Object object)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">post</span><span class=\"params\">(Object event)</span>;</span><br></pre></td></tr></table></figure>\n<p>跟经典的观察者模式的不同之处在于，当我们调用 <code>post()</code> 函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（<code>post</code> 函数定义中的 <code>event</code>）类型的父类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。</span></span><br><span class=\"line\"><span class=\"type\">XMsg</span> <span class=\"variable\">xMsg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XMsg</span>();</span><br><span class=\"line\"><span class=\"type\">YMsg</span> <span class=\"variable\">yMsg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">YMsg</span>(); <span class=\"comment\">// XMsg是YMsg的父类。</span></span><br><span class=\"line\"><span class=\"type\">ZMsg</span> <span class=\"variable\">zMsg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ZMsg</span>();</span><br><span class=\"line\">post(xMsg); <span class=\"comment\">// =&gt; AObserver接收到消息</span></span><br><span class=\"line\">post(yMsg); <span class=\"comment\">// =&gt; AObserver、BObserver接收到消息</span></span><br><span class=\"line\">post(zMsg); <span class=\"comment\">// =&gt; CObserver接收到消息</span></span><br></pre></td></tr></table></figure>\n<p>EventBus 通过 <code>@Subscribe</code> 注解来标明，某个函数能接收哪种类型的消息。比如在下面的代码中，当通过 <code>register()</code> 函数将 <code>DObserver</code> 类对象注册到 EventBus 的时候，EventBus 会根据 <code>@Subscribe</code> 注解找到 <code>f1()</code> 和 <code>f2()</code>，并且将两个函数能接收的消息类型记录下来（<code>PMsg</code>-&gt;<code>f1</code>，<code>QMsg</code>-&gt;<code>f2</code>）。当我们通过 <code>post()</code> 函数发送消息（比如 <code>QMsg</code> 消息）的时候，EventBus 会通过之前的记录调用相应的函数 <code>f2()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DObserver &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">(PMsg event)</span> &#123; <span class=\"comment\">/*...*/</span> &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">(QMsg event)</span> &#123; <span class=\"comment\">/*...*/</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"项目地址\"><a class=\"markdownIt-Anchor\" href=\"#项目地址\"></a> 项目地址</h1>\n<p>示例项目：<a href=\"https://github.com/uuanqin/Simple-EvenBus\">uuanqin/Simple-EvenBus: EvenBus 框架的简单实现</a></p>\n<p><a href=\"https://github.com/uuanqin/Simple-EvenBus\"><img src= \"/image/loading.gif\" data-lazy-src=\"https://github-readme-stats.uuanqin.top/api/pin/?username=uuanqin&amp;repo=Simple-EvenBus\" alt=\"Readme Card\" /></a></p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/docs/211239.md\">设计模式之美 - 王争 - 极客时间专栏：观察者模式（下）</a></li>\n</ul>\n","raw":"---\ntitle: EventBus 框架的简易实现\ntags:\n  - Java\n  - Google Guava EventBus\n  - 框架\n  - 反射\n  - 设计模式\ndescription: 观察者模式的框架实现\nkatex: false\ncategories:\n  - 技术学习\nabbrlink: 2c61e522\ndate: 2025-08-26 21:38:30\ncover: https://cdn.gallery.uuanqin.top/img/202508262351038.webp\ntop_img:\n---\n\nGoogle Guava 是 Google 公司内部 Java 开发工具库的开源版本，它提供了一些新功能或对 JDK 已有功能的增强功能。其中就包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I/O、事件总线（EventBus）等等。\n\n在 [[观察者模式：订阅与推送]] 文章中，我们介绍了观察者模式的同步阻塞的实现方式和异步非阻塞实现方式。本文将介绍使用 Google Guava EventBus 让观察者模式的实现过程更加灵活和简易，并亲自动手写一个简易版的 EventBus。\n\n# 从观察者模式开始\n\n使用 Google Guava EventBus 的观察者模式代码：\n\n```java\npublic interface Subject {\n  void registerObserver(Object observer);\n  void removeObserver(Object observer);\n  void notifyObservers(Object message);\n}\n\npublic class ConcreteSubject implements Subject {\n    private List<Object> observers = new ArrayList<Object>();\n    private EventBus eventBus;\n\n\n    public ConcreteSubject() {\n        // 同步阻塞模式\n        eventBus = new EventBus();\n        // 异步非阻塞模式\n        // eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE));\n    }\n\n    @Override\n    public void registerObserver(Object observer) {\n        eventBus.register(observer);\n    }\n\n    @Override\n    public void removeObserver(Object observer) {\n        observers.remove(observer);\n    }\n\n    @Override\n    public void notifyObservers(Object message) {\n        eventBus.post(message);\n    }\n}\n```\n\n利用 EventBus 框架实现的观察者模式，跟经典的同步阻塞观察者模式的代码相比，实现思路大致一样，都需要定义 `Observer`，并且通过 `registerObserver()` 函数注册 `Observer`，也都需要通过调用某个函数（比如，EventBus 中的 `post()` 函数）来给 `Observer` 发送消息（在 EventBus 中消息被称作事件 `event`）。\n\n但在实现细节方面，它们又有些区别。基于 EventBus，我们不需要定义 `Observer` 接口，任意类型的对象都可以注册到 EventBus 中，通过 `@Subscribe` 注解来标明类中哪个函数可以接收被观察者发送的消息。\n\n# Guava EventBus 的结构与功能\n\nGuava EventBus 对外暴露的所有可调用接口，都封装在 `EventBus` 类中。其中，`EventBus` 实现了同步阻塞的观察者模式，`AsyncEventBus` 继承自 `EventBus`，提供了异步非阻塞的观察者模式。\n\n```java\nEventBus eventBus = new EventBus(); // 同步阻塞模式\nEventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式\n```\n\nEventBus 类提供了 `register()` 函数用来注册观察者。它可以接受任何类型（`Object`）的观察者。而在经典的观察者模式的实现中，`register()` 函数必须接受实现了同一 `Observer` 接口的类对象。`post()` 函数，用来给观察者发送消息。\n\n```java\npublic void register(Object object);\npublic void unregister(Object object);\npublic void post(Object event);\n```\n\n跟经典的观察者模式的不同之处在于，当我们调用 `post()` 函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（`post` 函数定义中的 `event`）类型的父类。\n\n```java\n// AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。\nXMsg xMsg = new XMsg();\nYMsg yMsg = new YMsg(); // XMsg是YMsg的父类。\nZMsg zMsg = new ZMsg();\npost(xMsg); // => AObserver接收到消息\npost(yMsg); // => AObserver、BObserver接收到消息\npost(zMsg); // => CObserver接收到消息\n```\n\nEventBus 通过 `@Subscribe` 注解来标明，某个函数能接收哪种类型的消息。比如在下面的代码中，当通过 `register()` 函数将 `DObserver` 类对象注册到 EventBus 的时候，EventBus 会根据 `@Subscribe` 注解找到 `f1()` 和 `f2()`，并且将两个函数能接收的消息类型记录下来（`PMsg`->`f1`，`QMsg`->`f2`）。当我们通过 `post()` 函数发送消息（比如 `QMsg` 消息）的时候，EventBus 会通过之前的记录调用相应的函数 `f2()`。\n\n```java\npublic DObserver {\n  //...省略其他属性和方法...\n  \n  @Subscribe\n  public void f1(PMsg event) { /*...*/ }\n  \n  @Subscribe\n  public void f2(QMsg event) { /*...*/ }\n}\n```\n\n# 项目地址\n\n示例项目：[uuanqin/Simple-EvenBus: EvenBus 框架的简单实现](https://github.com/uuanqin/Simple-EvenBus)\n\n[![Readme Card](https://github-readme-stats.uuanqin.top/api/pin/?username=uuanqin&repo=Simple-EvenBus)](https://github.com/uuanqin/Simple-EvenBus)\n\n# 本文参考\n\n- [设计模式之美 - 王争 - 极客时间专栏：观察者模式（下）](https://gitee.com/buxsren/design-pattern-books/blob/master/docs/211239.md)\n\n","categories":[{"name":"技术学习","api":"api/categories/技术学习.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"Google Guava EventBus","api":"api/tags/Google-Guava-EventBus.json"},{"name":"框架","api":"api/tags/框架.json"},{"name":"反射","api":"api/tags/反射.json"},{"name":"设计模式","api":"api/tags/设计模式.json"}]},"api":"api/posts/p/2c61e522.json"}