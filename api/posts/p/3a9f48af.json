{"data":{"title":"类的工厂","slug":"高质量代码及设计模式/类的工厂","description":"辨析各种工厂别混淆","date":"2025-06-12T13:37:37.000Z","updated":"2025-09-26T16:05:50.956Z","language":"zh-CN","comments":true,"url":"p/3a9f48af/","cover":"https://cdn.gallery.uuanqin.top/img/202506122213473.webp","images":[],"content":"<p>工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。</p>\n<p>通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。</p>\n<p>工厂模式的类型与简介：</p>\n<ul>\n<li><strong>简单工厂模式（Simple Factory）</strong>：它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。\n<ul>\n<li>它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。</li>\n<li>简单工厂模式不是一个正式的设计模式，但它是工厂方法模式、抽象工厂的中间步骤。</li>\n<li>它属于创建型模式，但不属于 GoF 23 设计模式。</li>\n<li>不符合开闭原则，简单工厂中每一次扩展都需要对工厂类进行修改</li>\n</ul>\n</li>\n<li><strong>静态工厂模式</strong>：将工厂类中的创建对象的功能定义为静态的，就是静态工厂模式。\n<ul>\n<li>它同样不是一种设计模式。</li>\n<li>有时候，此模式归类为简单工厂模式的另一种实现方式。</li>\n</ul>\n</li>\n<li><strong>工厂方法模式（Factory Method Pattern）</strong>，又称多态性工厂模式：工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。</li>\n<li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。</li>\n</ul>\n\n<details class=\"callout\" data-callout=\"hint\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">关于以上分类方法的一些提醒</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>在 GoF 的《设计模式》一书中，作者将简单工厂模式看作是工厂方法模式的一种特例。</li>\n<li>《图解设计模式》一书中沿用 GoF《设计模式》中的分类方法。书中关于工厂模式介绍的是 Factory Method 模式和 Abstract Factory 模式。</li>\n<li>有些观点认为上面的简单工厂模式（Simple Factory）和静态工厂模式是「简单工厂模式」的两种实现。</li>\n</ul>\n</div></details><p>更多相似术语的比较，可见后文的详细章节。</p>\n<p>为了内容编排清晰，本文已将案例和理论分节处理。</p>\n<h1 id=\"一个简易计算器的案例\"><a class=\"markdownIt-Anchor\" href=\"#一个简易计算器的案例\"></a> 一个简易计算器的案例</h1>\n<p>我们先从案例讲起。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">代码演示：简单工厂模式</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>通过代码实现一个简单计算器，具有加减乘除的运算功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Operation <span class=\"title function_\">createOperation</span><span class=\"params\">(<span class=\"type\">char</span> operator)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Operation</span> <span class=\"variable\">operation</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (operator) &#123; <span class=\"comment\">//可以看到简单工厂将运算类的实例放在工厂类中实现</span></span><br><span class=\"line\">\t<span class=\"comment\">//通过分支选择具体的实现类</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSub</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationMul</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationDiv</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;unsupported operation&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> operation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationAdd</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Operation</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">result</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//具体的操作子类只需要实现具体运算</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> numberA + numberB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tOperation operation;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> operator;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\toperator = <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用过程中，在客户端提供具体实例的参数，传入工厂类实现</span></span><br><span class=\"line\">\t\toperation = OperationFactory.createOperation(operator);</span><br><span class=\"line\">\t\toperation.numberA = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">\t\toperation.numberB = <span class=\"number\">2.3</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 具体的运算过程，客户端不可见</span></span><br><span class=\"line\">\t\tSystem.out.println(operation.result());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们不使用简单工厂模式，我们的代码会是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tOperation operation;</span><br><span class=\"line\">\t<span class=\"type\">char</span> <span class=\"variable\">operator</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 不使用工厂模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSub</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationMul</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationDiv</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，简单工厂模式将一个复杂的类的创建过程，抽象为一个工厂类去做这个事情。</p>\n<p>大部分工厂类都是以「Factory」这个单词结尾的，但也不是必须的，比如 Java 中的 <code>DateFormat</code>、<code>Calender</code>。除此之外，工厂类中创建对象的方法一般都是 <code>create</code> 开头，比如代码中的 <code>createOperation()</code>，但有的也命名为 <code>getInstance()</code>、<code>createInstance()</code>、<code>newInstance()</code>，有的甚至命名为 <code>valueOf()</code>（比如 Java <code>String</code> 类的 <code>valueOf()</code> 函数）等等。</p>\n<p>在上面的代码中，我们可以发现每次调用 <code>createOperation()</code> 函数都会 <code>new</code> 一个新的实例。如果这个实例可以复用，我们可以将它缓存起来，这就是后面使用到的静态工厂模式。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">代码演示：静态工厂模式</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>针对上一小节简单工厂模式的 <code>OperationFactory</code>，我们可以将其改造为静态工厂模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Character, Operation&gt; cachedOperations = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;+&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>());</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;-&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSub</span>());</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;*&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationMul</span>());</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationDiv</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Operation <span class=\"title function_\">createOperation</span><span class=\"params\">(<span class=\"type\">char</span> operator)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 初步检查</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (operator == <span class=\"string\">&#x27;&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//或抛异常</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">Operation</span> <span class=\"variable\">operation</span> <span class=\"operator\">=</span> cachedOperations.get(operator);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> operation;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中如果我们需要新增操作运算，就必须改动 <code>OperationFactory</code> 的代码，似乎有点违反开闭原则。如果「新增操作运算」这件事情很少发生，上面的代码也是可以接受的。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">代码演示：工厂方法模式</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>在这个模式中，我们把 <code>OperationAdd</code>、<code>OperationSub</code> 这些看成是工厂方法模式中的「具体产品」角色；其抽象类 <code>Operation</code> 即为「产品」角色。每个具体的产品，都有各自对应的具体工厂而创建；各自的具体工厂，都继承着工厂接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相较于简单工厂模式 OperationFactory 并不直接创建具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationAddFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要新增产品时，另外定义具体工厂以及具体产品即可。符合开闭原则。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationAddFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationSqrtFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSqrt</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationSqrt</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Operation</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。</p>\n<h1 id=\"各种工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#各种工厂模式\"></a> 各种「工厂模式」</h1>\n<h2 id=\"简单工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#简单工厂模式\"></a> 简单工厂模式</h2>\n<p>简单工厂「模式」是对于工厂最基础的应用，但它其实不能算作「工厂模式」，它不是一个设计模式，像是一种编程习惯。</p>\n<p>应用层传参数给工厂就行，不需要关心如何创建。但是工厂类的职责相对过重，增加新的产品，需要修改工厂类的判断逻辑，违背了开闭原则。</p>\n<h2 id=\"静态工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#静态工厂模式\"></a> 静态工厂模式</h2>\n<p>创建类的实例的最常见的方式是用 <code>new</code> 语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条 <code>new</code> 语句，都会导致 Java 虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。</p>\n<p>静态工厂方法的特点：</p>\n<ol>\n<li>不需要使用创建对象的方法实例化对象</li>\n<li>不能通过继承来改变创建方法的行为</li>\n</ol>\n<p>代码上的特点就是类的构造函数使用 <code>private</code> 修饰。</p>\n<blockquote>\n<p>在有些情况下，一个类可以同时提供 <code>public</code> 的构造方法和静态工厂方法。用户可按需使用获取类的方式。</p>\n</blockquote>\n<p>例子：</p>\n<ul>\n<li><code>Class.forName</code></li>\n<li><code>Integer.valueOf</code></li>\n<li><code>Foo.getInstance</code></li>\n</ul>\n<p>静态工厂方法与用 <code>new</code> 语句调用构造方法的区别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>静态工厂模式</th>\n<th><code>new</code> 语句</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>构造方法名字</td>\n<td>方法名任意，提高代码可读性。但和其他的静态方法没有明显区别，我们可以通过约定命名的方式使用户区分一些静态方法专门负责返回类的示例，比如 <code>valueOf</code>、<code>getInstance</code>。</td>\n<td>必须与类名相同。但不能从名字上区分每个被重载的构造方法。</td>\n</tr>\n<tr>\n<td>调用时生成的对象数</td>\n<td>每次调用创建对象数目取决于方法的具体实现。</td>\n<td>每次调用都会生成一个新的对象。</td>\n</tr>\n<tr>\n<td>能否返回子类的实例</td>\n<td>可以。这一特性可以实现松耦合的系统接口。具体详看：工厂（方法）模式 Factory 章节</td>\n<td>不能，只能返回当前类的实例。</td>\n</tr>\n</tbody>\n</table>\n<p>静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"bilink-pop-up\">站内文章</span>单例（Singleton）类</a>：只有唯一的实例的类。详看：饿汉模式。</li>\n<li>枚举类：实例的数量有限的类。自定义枚举类而不是简单的定义 0,1 之类的数字在提高代码可读性的同时，还可以引入 Java 编译器的检查。JDK5 开始，有专门的 <code>java.lang.Enum</code> 枚举类型的语法。</li>\n<li>具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。</li>\n<li>具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。</li>\n</ul>\n<h3 id=\"静态工厂方法的优缺点\"><a class=\"markdownIt-Anchor\" href=\"#静态工厂方法的优缺点\"></a> 静态工厂方法的优缺点</h3>\n<blockquote>\n<p>Consider static factory methods instead of constructors.</p>\n</blockquote>\n<p>创建对象时尽量考虑静态工厂方法，从而你可能见到以下场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Lists.newArrayList(); <span class=\"comment\">// 明明可以写成list = new ArrayList() </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Lists.newArrayList(); 源码</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lists</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList <span class=\"title function_\">newArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>静态工厂方法可以通过方法名字来表示创建了什么对象</li>\n<li>创建对象时不需要每次都创建一个新的。这也叫做实例控制（instance-controlled），比如 <code>Boolean</code> 的 <code>valueOf</code> 方法。</li>\n<li>静态工厂方法可以返回该类的子类。如果 <code>new</code> 的话就只能返回某个类，但是静态工厂方法可以返回其子类。比如有个静态对象的返回值是 <code>Set</code>，那么方法返回 <code>HashSet</code>。</li>\n<li>可以返回 <code>private class</code> 的对象。</li>\n<li>静态工厂方法可以根据参数来调整返回的子类</li>\n<li>静态工厂方法创建的对象可以暂时不存在。典型的例子就是通过 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c8dc9bbd/\"><span class=\"bilink-pop-up\">站内文章</span>反射</a> 来创建对象，给一个对象的全路径为参数（比如 <code>java.uril.ArrayList</code>）然后通过反射的方式创建之后返回。那么在这种情况下 <code>new</code> 肯定是不行了（类都没有根本没办法 <code>new</code>）。</li>\n</ol>\n<p>缺点：由于没有 <code>public</code> 的构造函数，那么这个类就没办法被继承，也就没法重写其方法。缺点中的优点就是鼓励程序员用组合而不是继承。</p>\n<h2 id=\"工厂方法模式-factory-method\"><a class=\"markdownIt-Anchor\" href=\"#工厂方法模式-factory-method\"></a> 工厂方法模式 Factory Method</h2>\n<p>将实例的生成交给子类。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311358856.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p>如果我们将 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e165ad61/\"><span class=\"bilink-pop-up\">站内文章</span>模板方法模式</a> 用于生成实例，他就演变为工厂方法模式。</p>\n<p>在模板方法模式中，父类规定处理的流程，子类实现具体的处理；在工厂方法模式中，父类（工厂）决定实例的生成方式，但并不决定所要生成的具体的类，具体处理全部交给子类（工厂）负责。这样可以将生成实例的框架和实际负责生成实例的类解耦。</p>\n<p>在工厂模式中，核心的工厂类不再负责所有的产品的创建，而是将具体的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品应当被实例化这种细节。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506122159180.webp\" alt=\"image.png\" width=\"300px\" /></p>\n<p>抽象类 <code>Creator</code> 中的 <code>create</code> 方法使用 <code>final</code> 关键字修饰，表明不应该重写模板方法，这是模板方法模式的一个特点。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> framework;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 父类工厂定义了创建产品的主要流程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Product <span class=\"title function_\">create</span><span class=\"params\">(String owner)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Product</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> createProduct(owner);</span><br><span class=\"line\">        registerProduct(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//createProduct的任务交给了具体工厂，由具体工厂负责new。</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(String owner)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerProduct</span><span class=\"params\">(Product product)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>登场角色：</p>\n<ul>\n<li><code>Product</code>（产品）：框架，抽象类，定义该模式下生成实例所持有的接口。具体的处理由 <code>ConcreteProduct</code> 角色决定。</li>\n<li><code>Creator</code>（创建者）：框架，负责生成 <code>Product</code> 角色的抽象类。不用 <code>new</code> 关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类耦合。</li>\n<li><code>ConcreteProduct</code>（具体的产品）：加工方，决定具体的产品。</li>\n<li><code>ConcreteCreator</code>（具体的创建者）：加工方，负责生成具体的产品。</li>\n</ul>\n<p>拓展思路：</p>\n<ul>\n<li>如果要创建其他产品，直接引入 <code>framework</code>（框架）包。</li>\n<li>生成实例的方法，<code>Creator</code> 里的 <code>create</code> 方法，可以有三种实现方式：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式1：在Creator里指定create为抽象方法</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(Params params)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2：create中可以进行默认处理的实现。如果子类没有实现这个方法，将会进行默认处理。但这时可能会使用new关键字创建出实例，所以Product不能为抽象类。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(Params params)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Product</span>(Params params)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式3：在create中实现仅抛出异常的方法。当开发人员没有在子类实现这个方法时会抛出异常，并告知开发人员没有实现这个方法。需要另外编写异常类。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(Params params)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FactoryMethodRuntimeException</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>解耦。创建者和具体产品之间的解耦。</td>\n<td>应用该模式时需要引入许多新的子类。最好的情况是将该模式引入创建者类的现有层次结构中。</td>\n</tr>\n<tr>\n<td>单一职责原则。产品创建的代码放在程序的单一位置。</td>\n<td>每新增一个新产品时就需要增加两个类（具体的产品类和与之对应的具体工厂）。</td>\n</tr>\n<tr>\n<td>开闭原则。不更改原有代码，直接引入新的产品类型。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"与其他设计模式的关系\"><a class=\"markdownIt-Anchor\" href=\"#与其他设计模式的关系\"></a> 与其他设计模式的关系</h3>\n<p>工厂方法模式和简单工厂模式的区别：</p>\n<ul>\n<li>简单工厂把有关实例化的全部事情，都在工厂类中处理（没有抽象工厂类），然而工厂方法模式创建了一个框架，让工厂子类决定要如何实现。</li>\n<li>克服了简单工厂违背“开放 - 封闭原则”的缺点，又保持了封装对象创建过程的优点，对简单工厂的进一步抽象和推广</li>\n</ul>\n<p>工厂方法模式和抽象工厂模式：</p>\n<ul>\n<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>\n</ul>\n<p>相关的设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"bilink-pop-up\">站内文章</span>单例模式</a>：在多数情况下我们都可以将单例模式用于扮演 <code>Creator</code> 角色（或是 <code>ConcreteCreator</code> 角色）的类。这是因为在程序中没有必要存在多个 <code>Creator</code> 角色（或是 ConcreteCreator 角色）的实例。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>组合模式</a>：有时可以将组合模式用于 <code>Product</code> 角色（或是 <code>ConcreteProduct</code> 角色）。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e165ad61/\"><span class=\"bilink-pop-up\">站内文章</span>模板方法模式</a>：工厂方法模式是模板方法的典型应用，是模板方法的特殊形式。在示例程序中，<code>create</code> 方法就是模板方法。同时，工厂方法可以作为一个大型模板方法中的一个步骤。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/61ade5c3/\"><span class=\"bilink-pop-up\">站内文章</span>迭代器模式</a>：有时，在迭代器模式模式中使用 <code>iterator</code> 方法生成 <code>Iterator</code> 的实例时会使用工厂方法模式。这可以让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"bilink-pop-up\">站内文章</span>原型模式</a>：原型并不基于继承， 因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承， 但是它不需要初始化步骤。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408021703496.webp\" alt=\"image.png\" width=\"275px\" /></p>\n<h2 id=\"抽象工厂-abstract-factory\"><a class=\"markdownIt-Anchor\" href=\"#抽象工厂-abstract-factory\"></a> 抽象工厂 Abstract Factory</h2>\n<p>将关联零件组装成产品。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240731150817.webp\" alt=\"image.png\" width=\"252px\" /></p>\n<p>抽象工厂模式（Abstract Factory Pattern）的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>\n<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂的工作是将「抽象零件」组装为「抽象产品」。</p>\n<blockquote>\n<p>抽象：不考虑具体实现，而是仅关注接口（API）的状态。<br />\n依赖倒置原则：要依赖抽象，不要依赖具体的类。</p>\n</blockquote>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506122200060.webp\" alt=\"image.png\" width=\"450px\" /></p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311418704.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<p>登场角色：</p>\n<ul>\n<li><code>AbstractProduct</code>（抽象产品）：定义 <code>AbstractFactory</code> 角色所生成的抽象零件和产品接口（API）。</li>\n<li><code>AbstractFactory</code>（抽象工厂）：定义用于生成抽象产品的接口（API）。</li>\n<li><code>ConcreteProduct</code>（具体产品）：负责实现 <code>AbstractProduct</code> 角色的接口（API）。是抽象产品的多种不同类型实现。</li>\n<li><code>ConcreteFactory</code>（具体工厂）：负责实现 <code>AbstractFactory</code> 角色的接口。</li>\n<li><code>Client</code>（委托者）：调用 <code>AbstractFactory</code> 角色和 <code>AbstractProduct</code> 角色的接口（API）来进行工作，对于具体的零件、产品和工厂一无所知。比如示例程序中的 Main，根据 Factory 接口构造一篇 HTML。</li>\n</ul>\n<p>使用抽象工厂模式一般要满足以下条件：</p>\n<ul>\n<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>\n<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311413563.webp\" alt=\"image.png\" width=\"375px\" /></p>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>确保同一工厂生成的产品相互匹配，将一个系列的产品族统一到一起创建。</td>\n<td>采用该模式需要向应用中引入众多接口和类。</td>\n</tr>\n<tr>\n<td>解耦。客户端代码和具体产品代码解耦。</td>\n<td>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。</td>\n</tr>\n<tr>\n<td>单一职责原则。</td>\n<td>增加了系统的抽象性和理解难度。</td>\n</tr>\n<tr>\n<td>「开闭原则」倾斜性。增加一个新的产品族容易。</td>\n<td>「开闭原则」倾斜性。增加一个新种类的产品困难。</td>\n</tr>\n</tbody>\n</table>\n<p>抽象工厂模式的扩展有一定的「开闭原则」倾斜性：</p>\n<ul>\n<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>\n<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>\n</ul>\n<h3 id=\"与其他设计模式对比\"><a class=\"markdownIt-Anchor\" href=\"#与其他设计模式对比\"></a> 与其他设计模式对比</h3>\n<p>抽象工厂模式和工厂方法模式的异同：</p>\n<ul>\n<li>创建对象时：\n<ul>\n<li>工厂方法模式：继承。通过工厂子类创建对象，客户端只需要知道具体的抽象类型，由工厂子类决定具体类型，只负责将客户从具体类型中解耦。</li>\n<li>抽象工厂模式：对象的组合。提供用来创建一个产品家族的抽象类，这个类型的子类定义产品被创建的方法，使用时通过实例化具体工厂类，并将工厂类传入针对抽象类型写的代码中，把客户从所使用的实际具体产品中解耦。</li>\n</ul>\n</li>\n<li>抽象工厂集合了一群相关的产品类，而工厂方法只需要创建一个产品。抽象工厂中的每一个方法创建一个具体类，实际是利用工厂方法实现。可以使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"bilink-pop-up\">站内文章</span>原型模式</a> 来生成这些类的方法。</li>\n</ul>\n<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>\n<p>相关设计模式：</p>\n<ul>\n<li>工厂（方法）模式：有时抽象工厂模式中零件和产品的生成会使用到工厂方法模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>组合模式</a>：有时抽象工厂模式在制作产品时会使用组合模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"bilink-pop-up\">站内文章</span>单例模式</a>：有时抽象工厂模式中的具体工厂会使用单例模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>门面模式</a>：当只需对客户端代码隐藏子系统创建对象的方式时，可以使用抽象工厂来代替外观模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/d9cc7566/\"><span class=\"bilink-pop-up\">站内文章</span>桥接模式</a>：如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。</li>\n</ul>\n<h2 id=\"工厂模式比较与各式术语辨析\"><a class=\"markdownIt-Anchor\" href=\"#工厂模式比较与各式术语辨析\"></a> 工厂模式比较与各式术语辨析</h2>\n<table>\n<thead>\n<tr>\n<th>工厂模式</th>\n<th>开闭原则</th>\n<th>GoF 23 设计模式</th>\n<th>简记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简单工厂模式</td>\n<td>❌</td>\n<td rowspan=\"2\">❌</td>\n<td>一个具体工厂</td>\n</tr>\n<tr>\n<td>静态工厂模式</td>\n<td rowspan=\"2\">✅</td>\n<td>带缓存的具体工厂</td>\n</tr>\n<tr>\n<td>工厂方法模式</td>\n<td rowspan=\"2\">✅创建型</td>\n<td>抽象工厂生产抽象产品</td>\n</tr>\n<tr>\n<td>抽象工厂模式</td>\n<td>🟡</td>\n<td>超级工厂</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"工厂一个模糊的概念\"><a class=\"markdownIt-Anchor\" href=\"#工厂一个模糊的概念\"></a> 工厂——一个模糊的概念</h3>\n<p><strong>工厂</strong>是一个含义模糊的术语，表示可以创建一些东西的函数、 方法或类。最常见的情况下，工厂创建的是对象。 但是它们也可以创建文件和数据库记录等其他东西。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">下面这些东西都可以非正式地被称为「工厂」</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>创建程序 GUI 的函数或方法；</li>\n<li>创建用户的类；</li>\n<li>以特定方式调用类构造函数的静态方法。</li>\n<li>一种创建型设计模式。</li>\n</ul>\n</div></div><h3 id=\"构建方法把构造函数封装一下\"><a class=\"markdownIt-Anchor\" href=\"#构建方法把构造函数封装一下\"></a> 构建方法——把构造函数封装一下</h3>\n<p><strong>构建方法</strong>在《重构与模式》中被定义为「创建对象的方法」。这意味着每个工厂方法模式的结果都是 「构建方法」，但反过来则并非如此。这也意味着你可以用「构建方法」来替代马丁·福勒在 <em>重构</em> 中使用的「工厂方法」和乔斯华·布洛克在《Effective Java》中使用的「静态工厂方法」。</p>\n<p>在实际中，构建方法只是构造函数调用的封装器。它可能只是一个能更好地表达意图的名称。此外， 它可以让你的代码独立于构造函数的改动，甚至还可以包含一些特殊的逻辑，返回已有对象以而不是创建新对象。</p>\n<p>许多人会仅仅因为这些方法创建了新对象而称之为「工厂方法」。 其中的逻辑很直接：所有的工厂都会创建对象，而该方法会创建对象，所以显然它是一个工厂方法。当遇到真正的工厂方法时，这自然会造成许多混淆。</p>\n<p>下面的示例中 <code>next</code> 是一个构建方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"variable\">$value</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"><span class=\"variable\">$value</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;value = <span class=\"variable\">$value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span> (<span class=\"variable language_\">$this</span>-&gt;value + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态构建方法构建方法声明-static\"><a class=\"markdownIt-Anchor\" href=\"#静态构建方法构建方法声明-static\"></a> 静态构建方法——构建方法声明 <code>static</code></h3>\n<p>静态构建方法是被声明为 <code>static</code> 的构建方法。 换句话说， 你无需创建对象就能在某个类上调用该方法。当静态构建方法返回一个新对象时，它就成为了构造函数的替代品。</p>\n\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">有些资料认为「静态工厂方法」的称呼是坏习惯</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>原因：</p>\n<ul>\n<li>「工厂方法」是 GoF 23 设计模式之一，别来沾边！</li>\n<li>「静态 <code>static</code>」和「工厂方法」不能搭配，不要碰瓷！工厂方法是一种依赖于继承的设计模式。如果将它设置为 <code>static</code> ，就不能在子类中对其进行扩展，这就破坏了该模式的目的。</li>\n</ul>\n<p>但其实，不管是静态构建方法、静态工厂方法还是静态工厂模式指的东西都差不多，大家都会知道这是什么。</p>\n</div></details><p>绝大多数编程语言的构造函数必须都返回一个新的类实例。静态构建方法是应对该限制的变通方法。 在静态方法内部，你的代码会决定是调用构造函数创建一个全新实例，还是返回一个在缓存中已有的对象。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"variable\">$id</span>, <span class=\"variable\">$name</span>, <span class=\"variable\">$email</span>, <span class=\"variable\">$phone</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"><span class=\"variable\">$id</span>, <span class=\"variable\">$name</span>, <span class=\"variable\">$email</span>, <span class=\"variable\">$phone</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;id = <span class=\"variable\">$id</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;name = <span class=\"variable\">$name</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;email = <span class=\"variable\">$email</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">$this</span>-&gt;phone = <span class=\"variable\">$phone</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"><span class=\"variable\">$id</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">list</span>(<span class=\"variable\">$id</span>, <span class=\"variable\">$name</span>, <span class=\"variable\">$email</span>, <span class=\"variable\">$phone</span>) = DB::<span class=\"title function_ invoke__\">load_data</span>(<span class=\"string\">&#x27;users&#x27;</span>, <span class=\"string\">&#x27;id&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;email&#x27;</span>, <span class=\"string\">&#x27;phone&#x27;</span>);</span><br><span class=\"line\">        <span class=\"variable\">$user</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"variable\">$id</span>, <span class=\"variable\">$name</span>, <span class=\"variable\">$email</span>, <span class=\"variable\">$phone</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable\">$user</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单工厂模式有很多-if-else-的孤零零工厂\"><a class=\"markdownIt-Anchor\" href=\"#简单工厂模式有很多-if-else-的孤零零工厂\"></a> 简单工厂模式——有很多 <code>if-else</code> 的孤零零工厂</h3>\n<p><strong>简单工厂模式</strong>描述了一个类， 它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。</p>\n<p>在绝大多数情况下，简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。</p>\n<p>简单工厂通常没有子类。但当从一个简单工厂中抽取出子类后，它看上去就会更像经典的工厂方法模式了。</p>\n\n<div class=\"callout\" data-callout=\"warning\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-alert-triangle\"><path d=\"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z\"/><path d=\"M12 9v4\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">在简单工厂模式的基础上，仅仅加个 <code>abstract</code> 关键字后并不会变成抽象工厂模式！</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h3 id=\"工厂方法模式gof-23-设计模式之一\"><a class=\"markdownIt-Anchor\" href=\"#工厂方法模式gof-23-设计模式之一\"></a> 工厂方法模式——GoF 23 设计模式之一</h3>\n<p><strong>工厂方法</strong>是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p>\n<p>如果在基类及其扩展的子类中都有一个构建方法的话，那它可能就是工厂方法。</p>\n<h3 id=\"抽象工厂模式gof-23-设计模式之一\"><a class=\"markdownIt-Anchor\" href=\"#抽象工厂模式gof-23-设计模式之一\"></a> 抽象工厂模式——GoF 23 设计模式之一</h3>\n<p><strong>抽象工厂</strong>是一种创建型设计模式，它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">系列对象</div>\n</div>\n<div class=\"callout-content\"><p>有这样一组的对象：运输工具 + 引擎 + 控制器。它可能会有几个变体：</p>\n<ul>\n<li>汽车 + 内燃机 + 方向盘</li>\n<li>飞机 + 喷气式发动机 + 操纵杆</li>\n</ul>\n</div></div><p>如果你的程序中并不涉及产品系列的话，那就不需要抽象工厂。</p>\n<h1 id=\"java-生成实例的方式\"><a class=\"markdownIt-Anchor\" href=\"#java-生成实例的方式\"></a> Java 生成实例的方式</h1>\n<h2 id=\"new-方法\"><a class=\"markdownIt-Anchor\" href=\"#new-方法\"></a> <code>new</code> 方法</h2>\n<p>通过 <code>new</code> 的方法方式可以生成实例，这种方法类名会出现在代码中，形成强耦合关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new关键字</span></span><br><span class=\"line\"><span class=\"type\">Something</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Something</span>();</span><br></pre></td></tr></table></figure>\n<p>在开发过程中，我们可能有「在不指定类名的前提下生成实例」的需求，这时候可以尝试使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"bilink-pop-up\">站内文章</span>原型模式</a>。原型模式包含三种实例创建方法：<code>clone</code> 方法、反序列化方法以及反射方法。</p>\n<h2 id=\"clone-方法\"><a class=\"markdownIt-Anchor\" href=\"#clone-方法\"></a> <code>clone</code> 方法</h2>\n<p>我们可以通过 <code>clone</code> 方法，根据现有实例复制出一个新实例。这个过程中不会调用构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// clone方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Something</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Something <span class=\"title function_\">createClone</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Something</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tobj = (Something)clone();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class=\"line\">\t\t\te.printStackTrace() ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用反射\"><a class=\"markdownIt-Anchor\" href=\"#使用反射\"></a> 使用反射</h2>\n<p>我们还可以使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c8dc9bbd/\"><span class=\"bilink-pop-up\">站内文章</span>反射</a>，通过 <code>newInstance</code> 的方法生成实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java.lang.Class类的newInstance方法。通过Class类的实例生成出Class类所表示的类（即Something类）的实例（会调用无参构造函数）。</span></span><br><span class=\"line\"><span class=\"comment\">// 假设someobj是Something类的实例：</span></span><br><span class=\"line\">someobj.getClass().newInstance()</span><br><span class=\"line\"><span class=\"comment\">// 注意异常的捕捉。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他 newInstance 方式</span></span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">emp1</span> <span class=\"operator\">=</span> (Person) Class.forName(<span class=\"string\">&quot;org.pro.com.Person&quot;</span>).newInstance();</span><br><span class=\"line\"><span class=\"type\">Persone</span> <span class=\"variable\">emp2</span> <span class=\"operator\">=</span> Person.class.newInstance();</span><br><span class=\"line\">Constructor&lt;Person&gt; constructor = Person.class.getConstructor();</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">emp3</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>\n<p><code>class.loadClass</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassLoader cl; </span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> cl.loadClass(<span class=\"string\">&quot;com.rain.B&quot;</span>); <span class=\"comment\">// 使用第一步得到的ClassLoader来载入B</span></span><br><span class=\"line\"><span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> (B)cls.newInstance(); <span class=\"comment\">// 有B的类得到一个B的实例</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"反序列化\"><a class=\"markdownIt-Anchor\" href=\"#反序列化\"></a> 反序列化</h2>\n<p>反序列化方式。即通过 I/O 流（包括反序列化），如运用反序列化手段，调用 <code>java.io.ObjectInputStream</code> 对象的 <code>readObject()</code> 方法。</p>\n<h1 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\"></a> 结尾</h1>\n<h2 id=\"后续计划\"><a class=\"markdownIt-Anchor\" href=\"#后续计划\"></a> 后续计划</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 补充「抽象工厂模式」的案例学习</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 语言风格需要统一、逻辑需要清晰</li>\n</ul>\n<h2 id=\"本文-plantuml-归档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-归档\"></a> 本文 PlantUML 归档</h2>\n<p>工厂方法模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package frame&#123;</span><br><span class=\"line\">\tabstract class Creator&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; create</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; factoryMethod</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tabstract class Product&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; method1</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; method2</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; method3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tCreator -&gt; Product : Creates</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package products&#123;</span><br><span class=\"line\">\tclass ConcreteCreator&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; factoryMethod</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclass ConcreteProduct&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; method1</span><br><span class=\"line\">\t\t&#123;method&#125; method2</span><br><span class=\"line\">\t\t&#123;method&#125; method3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tConcreteCreator -&gt; ConcreteProduct : Creates</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Creator &lt;|-- ConcreteCreator</span><br><span class=\"line\">Product &lt;|-- ConcreteProduct</span><br></pre></td></tr></table></figure>\n<p>抽象工厂模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package factory&#123;</span><br><span class=\"line\">\tabstract class AbstractProduct1&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; executeA</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; executeA</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tabstract class AbstractProduct2&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; doAlpha</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; doBeta</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tabstract class AbstractProduct3&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; performOne</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; performTwo</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass Hide1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tabstract class AbstractFactory&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; createProduct1</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; createProduct2</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; createProduct3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAbstractProduct1 &lt;-- AbstractFactory</span><br><span class=\"line\">\tAbstractProduct2 &lt;-- AbstractFactory</span><br><span class=\"line\">\tAbstractProduct3 &lt;-- AbstractFactory</span><br><span class=\"line\">\tHide1 &lt;-- AbstractFactory</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hide factory.Hide1</span><br><span class=\"line\"></span><br><span class=\"line\">package concretefactory&#123;</span><br><span class=\"line\">\tclass ConcreteProduct1&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; executeA</span><br><span class=\"line\">\t\t&#123;method&#125; executeA</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass ConcreteProduct2&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; doAlpha</span><br><span class=\"line\">\t\t&#123;method&#125; doBeta</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass ConcreteProduct3&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; performOne</span><br><span class=\"line\">\t\t&#123;method&#125; performTwo</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclass ConcreteFactory&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; createProduct1</span><br><span class=\"line\">\t\t&#123;method&#125; createProduct2</span><br><span class=\"line\">\t\t&#123;method&#125; createProduct3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tConcreteProduct1 &lt;-- ConcreteFactory</span><br><span class=\"line\">\tConcreteProduct2 &lt;-- ConcreteFactory</span><br><span class=\"line\">\tConcreteProduct3 &lt;-- ConcreteFactory</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AbstractFactory &lt;|-- ConcreteFactory</span><br><span class=\"line\">AbstractProduct1 &lt;|-- ConcreteProduct1</span><br><span class=\"line\">AbstractProduct2 &lt;|-- ConcreteProduct2</span><br><span class=\"line\">AbstractProduct3 &lt;|-- ConcreteProduct3</span><br><span class=\"line\">AbstractFactory -[hidden]down- ConcreteProduct2</span><br></pre></td></tr></table></figure>\n<h2 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h2>\n<ul>\n<li>《图解设计模式》</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li>极客时间专栏 - 设计模式之美 - 王争</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/476420041\">设计模式辨析——工厂篇（简单工厂、静态工厂、工厂方法、抽象工厂） - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/157099580\">还在new对象吗？试试静态工厂方法–Effective Java第二章 - 知乎</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/factory-pattern.html\">工厂模式 | 菜鸟教程 (runoob.com)</a></li>\n<li><a href=\"https://www.cnblogs.com/jing99/p/12595494.html\">设计模式之工厂模式(3种)详解及代码示例 - kosamino - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/u012524415/article/details/80327705\">实例化类的五种方法-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/penriver/article/details/118571991\">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解_gof23-CSDN博客</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/factory-method\">建造者设计模式（生成器模式）</a></li>\n</ul>\n","raw":"---\ntitle: 类的工厂\ntags:\n  - 设计模式\n  - 工厂模式\n  - 单例模式\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202506122213473.webp'\ndescription: 辨析各种工厂别混淆\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: 3a9f48af\ndate: 2025-06-12 21:37:37\ntop_img:\n---\n\n工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。\n\n通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。\n\n工厂模式的类型与简介：\n\n- **简单工厂模式（Simple Factory）**：它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。\n\t- 它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。\n\t- 简单工厂模式不是一个正式的设计模式，但它是工厂方法模式、抽象工厂的中间步骤。\n\t- 它属于创建型模式，但不属于 GoF 23 设计模式。\n\t- 不符合开闭原则，简单工厂中每一次扩展都需要对工厂类进行修改\n- **静态工厂模式**：将工厂类中的创建对象的功能定义为静态的，就是静态工厂模式。\n\t- 它同样不是一种设计模式。\n\t- 有时候，此模式归类为简单工厂模式的另一种实现方式。\n- **工厂方法模式（Factory Method Pattern）**，又称多态性工厂模式：工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。\n- **抽象工厂模式（Abstract Factory Pattern）**：抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。\n\n> [!hint]- 关于以上分类方法的一些提醒\n>\n> - 在 GoF 的《设计模式》一书中，作者将简单工厂模式看作是工厂方法模式的一种特例。\n> - 《图解设计模式》一书中沿用 GoF《设计模式》中的分类方法。书中关于工厂模式介绍的是 Factory Method 模式和 Abstract Factory 模式。\n> - 有些观点认为上面的简单工厂模式（Simple Factory）和静态工厂模式是「简单工厂模式」的两种实现。\n\n更多相似术语的比较，可见后文的详细章节。\n\n为了内容编排清晰，本文已将案例和理论分节处理。\n\n# 一个简易计算器的案例\n\n我们先从案例讲起。\n\n> [!example] 代码演示：简单工厂模式\n\n通过代码实现一个简单计算器，具有加减乘除的运算功能：\n\n```java\npublic class OperationFactory {\n    public static Operation createOperation(char operator) {\n\t\tOperation operation = null;\n\t\n\t\tswitch (operator) { //可以看到简单工厂将运算类的实例放在工厂类中实现\n\t//通过分支选择具体的实现类\n\t\tcase '+':\n\t\t    operation = new OperationAdd();\n\t\t    break;\n\t\tcase '-':\n\t\t    operation = new OperationSub();\n\t\t    break;\n\t\tcase '*':\n\t\t    operation = new OperationMul();\n\t\t    break;\n\t\tcase '/':\n\t\t    operation = new OperationDiv();\n\t\t    break;\n\t\tdefault:\n\t\t    throw new RuntimeException(\"unsupported operation\");\n\t\t}\n\t\treturn operation;\n    }\n}\n\npublic class OperationAdd extends Operation {\n    @Override\n    public double result() { //具体的操作子类只需要实现具体运算\n\t\treturn numberA + numberB;\n    }\n}\n\npublic class Calculator {\n    public static void main(String[] args) {\n\t\tOperation operation;\n\t\tchar operator;\n\t\n\t\toperator = '+';\n\t\t// 使用过程中，在客户端提供具体实例的参数，传入工厂类实现\n\t\toperation = OperationFactory.createOperation(operator);\n\t\toperation.numberA = 1.2;\n\t\toperation.numberB = 2.3;\n\t\t// 具体的运算过程，客户端不可见\n\t\tSystem.out.println(operation.result());\n    }\n}\n```\n\n如果我们不使用简单工厂模式，我们的代码会是这样的：\n\n```java\npublic static void main(String[] args) {\n\tOperation operation;\n\tchar operator = '+';\n\t// 不使用工厂模式\n\tif(operator == '+')\n\t\toperation = new OperationAdd();\n\telse if(operator == '-')\n\t\toperation = new OperationSub();\n\telse if(operator == '*')\n\t\toperation = new OperationMul();\n\telse if(operator == '/')\n\t\toperation = new OperationDiv();\n\t// ...\n}\n```\n\n也就是说，简单工厂模式将一个复杂的类的创建过程，抽象为一个工厂类去做这个事情。\n\n大部分工厂类都是以「Factory」这个单词结尾的，但也不是必须的，比如 Java 中的 `DateFormat`、`Calender`。除此之外，工厂类中创建对象的方法一般都是 `create` 开头，比如代码中的 `createOperation()`，但有的也命名为 `getInstance()`、`createInstance()`、`newInstance()`，有的甚至命名为 `valueOf()`（比如 Java `String` 类的 `valueOf()` 函数）等等。\n\n在上面的代码中，我们可以发现每次调用 `createOperation()` 函数都会 `new` 一个新的实例。如果这个实例可以复用，我们可以将它缓存起来，这就是后面使用到的静态工厂模式。\n\n> [!example] 代码演示：静态工厂模式\n\n针对上一小节简单工厂模式的 `OperationFactory`，我们可以将其改造为静态工厂模式：\n\n```java\npublic class OperationFactory {\n\tprivate static final Map<Character, Operation> cachedOperations = new HashMap<>();\n\t\n\tstatic {\n\t\tcachedOperations.put('+', new OperationAdd());\n\t\tcachedOperations.put('-', new OperationSub());\n\t\tcachedOperations.put('*', new OperationMul());\n\t\tcachedOperations.put('/', new OperationDiv());\n\t}\n\t\n\tpublic static Operation createOperation(char operator) {\n\t\t// 初步检查\n\t\tif (operator == '') {\n\t\t  return null;//或抛异常\n\t\t}\n\t\tOperation operation = cachedOperations.get(operator);\n\t\treturn operation;\n\t}\n}\n```\n\n在上面的代码中如果我们需要新增操作运算，就必须改动 `OperationFactory` 的代码，似乎有点违反开闭原则。如果「新增操作运算」这件事情很少发生，上面的代码也是可以接受的。\n\n> [!example] 代码演示：工厂方法模式\n\n在这个模式中，我们把 `OperationAdd`、`OperationSub` 这些看成是工厂方法模式中的「具体产品」角色；其抽象类 `Operation` 即为「产品」角色。每个具体的产品，都有各自对应的具体工厂而创建；各自的具体工厂，都继承着工厂接口：\n\n```java\n// 相较于简单工厂模式 OperationFactory 并不直接创建具体产品\npublic abstract class OperationFactory {\n    public abstract Operation getOperation();\n}\n\npublic class OperationAddFactory extends OperationFactory {\n    @Override\n    public Operation getOperation() {\n        return new OperationAdd();\n    }\n}\n\n// 需要新增产品时，另外定义具体工厂以及具体产品即可。符合开闭原则。\n\npublic class OperationAddFactory extends OperationFactory {\n    @Override\n    public Operation getOperation() {\n        return new OperationAdd();\n    }\n}\n\npublic class OperationSqrtFactory extends OperationFactory {\n    @Override\n    public Operation getOperation() {\n        return new OperationSqrt();\n    }\n}\n\npublic class OperationSqrt extends Operation{\n\t// ...\n}\n```\n\n当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。\n\n# 各种「工厂模式」\n\n## 简单工厂模式\n\n简单工厂「模式」是对于工厂最基础的应用，但它其实不能算作「工厂模式」，它不是一个设计模式，像是一种编程习惯。\n\n应用层传参数给工厂就行，不需要关心如何创建。但是工厂类的职责相对过重，增加新的产品，需要修改工厂类的判断逻辑，违背了开闭原则。\n\n## 静态工厂模式\n\n创建类的实例的最常见的方式是用 `new` 语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条 `new` 语句，都会导致 Java 虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。\n\n静态工厂方法的特点：\n\n1. 不需要使用创建对象的方法实例化对象\n2. 不能通过继承来改变创建方法的行为\n\n代码上的特点就是类的构造函数使用 `private` 修饰。\n\n> 在有些情况下，一个类可以同时提供 `public` 的构造方法和静态工厂方法。用户可按需使用获取类的方式。\n\n例子：\n\n- `Class.forName`\n- `Integer.valueOf`\n- `Foo.getInstance`\n\n静态工厂方法与用 `new` 语句调用构造方法的区别：\n\n|           | 静态工厂模式                                                                                       | `new` 语句                     |\n| --------- | -------------------------------------------------------------------------------------------- | ---------------------------- |\n| 构造方法名字    | 方法名任意，提高代码可读性。但和其他的静态方法没有明显区别，我们可以通过约定命名的方式使用户区分一些静态方法专门负责返回类的示例，比如 `valueOf`、`getInstance`。 | 必须与类名相同。但不能从名字上区分每个被重载的构造方法。 |\n| 调用时生成的对象数 | 每次调用创建对象数目取决于方法的具体实现。                                                                        | 每次调用都会生成一个新的对象。              |\n| 能否返回子类的实例 | 可以。这一特性可以实现松耦合的系统接口。具体详看：工厂（方法）模式 Factory 章节                                                 | 不能，只能返回当前类的实例。               |\n\n静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例：\n\n- [[单例模式：保持唯一|单例（Singleton）类]]：只有唯一的实例的类。详看：饿汉模式。\n- 枚举类：实例的数量有限的类。自定义枚举类而不是简单的定义 0,1 之类的数字在提高代码可读性的同时，还可以引入 Java 编译器的检查。JDK5 开始，有专门的 `java.lang.Enum` 枚举类型的语法。\n- 具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。\n- 具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。\n\n### 静态工厂方法的优缺点\n\n> Consider static factory methods instead of constructors.\n\n创建对象时尽量考虑静态工厂方法，从而你可能见到以下场景：\n\n```java\nList<String> list = Lists.newArrayList(); // 明明可以写成list = new ArrayList() \n\n// Lists.newArrayList(); 源码\nclass Lists{\n   public static ArrayList newArrayList() {\n       return new ArrayList();\n   } \n}\n```\n\n优点：\n\n1. 静态工厂方法可以通过方法名字来表示创建了什么对象\n2. 创建对象时不需要每次都创建一个新的。这也叫做实例控制（instance-controlled），比如 `Boolean` 的 `valueOf` 方法。\n3. 静态工厂方法可以返回该类的子类。如果 `new` 的话就只能返回某个类，但是静态工厂方法可以返回其子类。比如有个静态对象的返回值是 `Set`，那么方法返回 `HashSet`。\n4. 可以返回 `private class` 的对象。\n5. 静态工厂方法可以根据参数来调整返回的子类\n6. 静态工厂方法创建的对象可以暂时不存在。典型的例子就是通过 [[Java 中的反射|反射]] 来创建对象，给一个对象的全路径为参数（比如 `java.uril.ArrayList`）然后通过反射的方式创建之后返回。那么在这种情况下 `new` 肯定是不行了（类都没有根本没办法 `new`）。\n\n缺点：由于没有 `public` 的构造函数，那么这个类就没办法被继承，也就没法重写其方法。缺点中的优点就是鼓励程序员用组合而不是继承。\n\n## 工厂方法模式 Factory Method\n\n将实例的生成交给子类。\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202508311358856.webp)\n\n如果我们将 [[模板方法模式与回调|模板方法模式]] 用于生成实例，他就演变为工厂方法模式。\n\n在模板方法模式中，父类规定处理的流程，子类实现具体的处理；在工厂方法模式中，父类（工厂）决定实例的生成方式，但并不决定所要生成的具体的类，具体处理全部交给子类（工厂）负责。这样可以将生成实例的框架和实际负责生成实例的类解耦。\n\n在工厂模式中，核心的工厂类不再负责所有的产品的创建，而是将具体的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品应当被实例化这种细节。\n\n![image.png|300](https://cdn.gallery.uuanqin.top/img/202506122159180.webp)\n\n抽象类 `Creator` 中的 `create` 方法使用 `final` 关键字修饰，表明不应该重写模板方法，这是模板方法模式的一个特点。\n\n例子：\n\n```java\npackage framework;\npublic abstract class Factory {\n\t// 父类工厂定义了创建产品的主要流程\n    public final Product create(String owner) {\n        Product p = createProduct(owner);\n        registerProduct(p);\n        return p;\n    }\n    //createProduct的任务交给了具体工厂，由具体工厂负责new。\n    protected abstract Product createProduct(String owner);\n    protected abstract void registerProduct(Product product);\n}\n```\n\n登场角色：\n\n- `Product`（产品）：框架，抽象类，定义该模式下生成实例所持有的接口。具体的处理由 `ConcreteProduct` 角色决定。\n- `Creator`（创建者）：框架，负责生成 `Product` 角色的抽象类。不用 `new` 关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类耦合。\n- `ConcreteProduct`（具体的产品）：加工方，决定具体的产品。\n- `ConcreteCreator`（具体的创建者）：加工方，负责生成具体的产品。\n\n拓展思路：\n\n- 如果要创建其他产品，直接引入 `framework`（框架）包。\n- 生成实例的方法，`Creator` 里的 `create` 方法，可以有三种实现方式：\n\n```java\n// 方式1：在Creator里指定create为抽象方法\nabstract class Factory{\n\tpublic abstract Product createProduct(Params params);\n\t// ...\n}\n\n// 方式2：create中可以进行默认处理的实现。如果子类没有实现这个方法，将会进行默认处理。但这时可能会使用new关键字创建出实例，所以Product不能为抽象类。\nclass Factory{\n\tpublic Product createProduct(Params params){\n\t\treturn new Product(Params params)\n\t}\n\t// ...\n}\n\n// 方式3：在create中实现仅抛出异常的方法。当开发人员没有在子类实现这个方法时会抛出异常，并告知开发人员没有实现这个方法。需要另外编写异常类。\n\nclass Factory{\n\tpublic Product createProduct(Params params){\n\t\tthrow new FactoryMethodRuntimeException();\n\t}\n\t// ...\n}\n```\n\n| 优点                       | 缺点                                         |\n| ------------------------ | ------------------------------------------ |\n| 解耦。创建者和具体产品之间的解耦。        | 应用该模式时需要引入许多新的子类。最好的情况是将该模式引入创建者类的现有层次结构中。 |\n| 单一职责原则。产品创建的代码放在程序的单一位置。 | 每新增一个新产品时就需要增加两个类（具体的产品类和与之对应的具体工厂）。       |\n| 开闭原则。不更改原有代码，直接引入新的产品类型。 |                                            |\n\n### 与其他设计模式的关系\n\n工厂方法模式和简单工厂模式的区别：\n\n- 简单工厂把有关实例化的全部事情，都在工厂类中处理（没有抽象工厂类），然而工厂方法模式创建了一个框架，让工厂子类决定要如何实现。\n- 克服了简单工厂违背“开放 - 封闭原则”的缺点，又保持了封装对象创建过程的优点，对简单工厂的进一步抽象和推广\n\n工厂方法模式和抽象工厂模式：\n\n- 抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。\n\n相关的设计模式：\n\n- [[单例模式：保持唯一|单例模式]]：在多数情况下我们都可以将单例模式用于扮演 `Creator` 角色（或是 `ConcreteCreator` 角色）的类。这是因为在程序中没有必要存在多个 `Creator` 角色（或是 ConcreteCreator 角色）的实例。\n- [[组合模式：树形结构|组合模式]]：有时可以将组合模式用于 `Product` 角色（或是 `ConcreteProduct` 角色）。\n- [[模板方法模式与回调|模板方法模式]]：工厂方法模式是模板方法的典型应用，是模板方法的特殊形式。在示例程序中，`create` 方法就是模板方法。同时，工厂方法可以作为一个大型模板方法中的一个步骤。\n- [[迭代器模式：游标|迭代器模式]]：有时，在迭代器模式模式中使用 `iterator` 方法生成 `Iterator` 的实例时会使用工厂方法模式。这可以让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n- [[原型模式及深浅拷贝|原型模式]]：原型并不基于继承， 因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承， 但是它不需要初始化步骤。\n\n![image.png|275](https://cdn.gallery.uuanqin.top/img/202408021703496.webp)\n\n## 抽象工厂 Abstract Factory\n\n将关联零件组装成产品。\n\n![image.png|252](https://cdn.gallery.uuanqin.top/img/20240731150817.webp)\n\n抽象工厂模式（Abstract Factory Pattern）的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂的工作是将「抽象零件」组装为「抽象产品」。\n\n> 抽象：不考虑具体实现，而是仅关注接口（API）的状态。\n> 依赖倒置原则：要依赖抽象，不要依赖具体的类。\n\n![image.png|450](https://cdn.gallery.uuanqin.top/img/202506122200060.webp)\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202508311418704.webp)\n\n登场角色：\n\n- `AbstractProduct`（抽象产品）：定义 `AbstractFactory` 角色所生成的抽象零件和产品接口（API）。\n- `AbstractFactory`（抽象工厂）：定义用于生成抽象产品的接口（API）。\n- `ConcreteProduct`（具体产品）：负责实现 `AbstractProduct` 角色的接口（API）。是抽象产品的多种不同类型实现。\n- `ConcreteFactory`（具体工厂）：负责实现 `AbstractFactory` 角色的接口。\n- `Client`（委托者）：调用 `AbstractFactory` 角色和 `AbstractProduct` 角色的接口（API）来进行工作，对于具体的零件、产品和工厂一无所知。比如示例程序中的 Main，根据 Factory 接口构造一篇 HTML。\n\n使用抽象工厂模式一般要满足以下条件：\n\n- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。\n- 系统一次只可能消费其中某一族产品，即同族的产品一起使用。\n\n![image.png|375](https://cdn.gallery.uuanqin.top/img/202508311413563.webp)\n\n| 优点                                | 缺点                                        |\n| --------------------------------- | ----------------------------------------- |\n| 确保同一工厂生成的产品相互匹配，将一个系列的产品族统一到一起创建。 | 采用该模式需要向应用中引入众多接口和类。                      |\n| 解耦。客户端代码和具体产品代码解耦。                | 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。 |\n| 单一职责原则。                           | 增加了系统的抽象性和理解难度。                           |\n| 「开闭原则」倾斜性。增加一个新的产品族容易。            | 「开闭原则」倾斜性。增加一个新种类的产品困难。                   |\n\n抽象工厂模式的扩展有一定的「开闭原则」倾斜性：\n\n- 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。\n- 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。\n\n### 与其他设计模式对比\n\n抽象工厂模式和工厂方法模式的异同：\n\n- 创建对象时：\n\t- 工厂方法模式：继承。通过工厂子类创建对象，客户端只需要知道具体的抽象类型，由工厂子类决定具体类型，只负责将客户从具体类型中解耦。\n\t- 抽象工厂模式：对象的组合。提供用来创建一个产品家族的抽象类，这个类型的子类定义产品被创建的方法，使用时通过实例化具体工厂类，并将工厂类传入针对抽象类型写的代码中，把客户从所使用的实际具体产品中解耦。\n- 抽象工厂集合了一群相关的产品类，而工厂方法只需要创建一个产品。抽象工厂中的每一个方法创建一个具体类，实际是利用工厂方法实现。可以使用 [[原型模式及深浅拷贝|原型模式]] 来生成这些类的方法。\n\n另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。\n\n相关设计模式：\n\n- 工厂（方法）模式：有时抽象工厂模式中零件和产品的生成会使用到工厂方法模式。\n- [[组合模式：树形结构|组合模式]]：有时抽象工厂模式在制作产品时会使用组合模式。\n- [[单例模式：保持唯一|单例模式]]：有时抽象工厂模式中的具体工厂会使用单例模式。\n- [[门面模式：点击即用|门面模式]]：当只需对客户端代码隐藏子系统创建对象的方式时，可以使用抽象工厂来代替外观模式。\n- [[桥接模式可以沟通功能层次与实现层次|桥接模式]]：如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。\n\n## 工厂模式比较与各式术语辨析\n\n| 工厂模式   | 开闭原则 | GoF 23 设计模式 | 简记         |\n| ------ | ---- | ----------- | ---------- |\n| 简单工厂模式 | ❌    | ❌           | 一个具体工厂     |\n| 静态工厂模式 | ✅    | ❌           | 带缓存的具体工厂   |\n| 工厂方法模式 | ✅    | ✅创建型        | 抽象工厂生产抽象产品 |\n| 抽象工厂模式 | 🟡   | ✅创建型        | 超级工厂       |\n\n### 工厂——一个模糊的概念\n\n**工厂**是一个含义模糊的术语，表示可以创建一些东西的函数、 方法或类。最常见的情况下，工厂创建的是对象。 但是它们也可以创建文件和数据库记录等其他东西。\n\n> [!example] 下面这些东西都可以非正式地被称为「工厂」\n> - 创建程序 GUI 的函数或方法；\n> - 创建用户的类；\n> - 以特定方式调用类构造函数的静态方法。\n> - 一种创建型设计模式。\n\n### 构建方法——把构造函数封装一下\n\n**构建方法**在《重构与模式》中被定义为「创建对象的方法」。这意味着每个工厂方法模式的结果都是 「构建方法」，但反过来则并非如此。这也意味着你可以用「构建方法」来替代马丁·福勒在 *重构* 中使用的「工厂方法」和乔斯华·布洛克在《Effective Java》中使用的「静态工厂方法」。\n\n在实际中，构建方法只是构造函数调用的封装器。它可能只是一个能更好地表达意图的名称。此外， 它可以让你的代码独立于构造函数的改动，甚至还可以包含一些特殊的逻辑，返回已有对象以而不是创建新对象。\n\n许多人会仅仅因为这些方法创建了新对象而称之为「工厂方法」。 其中的逻辑很直接：所有的工厂都会创建对象，而该方法会创建对象，所以显然它是一个工厂方法。当遇到真正的工厂方法时，这自然会造成许多混淆。\n\n下面的示例中 `next` 是一个构建方法：\n\n```php\nclass Number {\n    private $value;\n\n    public function __construct($value) {\n        $this->value = $value;\n    }\n\n    public function next() {\n        return new Number ($this->value + 1);\n    }\n}\n```\n\n### 静态构建方法——构建方法声明 `static`\n\n静态构建方法是被声明为 `static` 的构建方法。 换句话说， 你无需创建对象就能在某个类上调用该方法。当静态构建方法返回一个新对象时，它就成为了构造函数的替代品。\n\n> [!note]- 有些资料认为「静态工厂方法」的称呼是坏习惯\n> 原因：\n>\n> - 「工厂方法」是 GoF 23 设计模式之一，别来沾边！\n> - 「静态 `static`」和「工厂方法」不能搭配，不要碰瓷！工厂方法是一种依赖于继承的设计模式。如果将它设置为 `static` ，就不能在子类中对其进行扩展，这就破坏了该模式的目的。\n> \n> 但其实，不管是静态构建方法、静态工厂方法还是静态工厂模式指的东西都差不多，大家都会知道这是什么。\n\n绝大多数编程语言的构造函数必须都返回一个新的类实例。静态构建方法是应对该限制的变通方法。 在静态方法内部，你的代码会决定是调用构造函数创建一个全新实例，还是返回一个在缓存中已有的对象。\n\n```php\nclass User {\n    private $id, $name, $email, $phone;\n\n    public function __construct($id, $name, $email, $phone) {\n        $this->id = $id;\n        $this->name = $name;\n        $this->email = $email;\n        $this->phone = $phone;\n    }\n\n    public static function load($id) {\n        list($id, $name, $email, $phone) = DB::load_data('users', 'id', 'name', 'email', 'phone');\n        $user = new User($id, $name, $email, $phone);\n        return $user;\n    }\n}\n```\n\n### 简单工厂模式——有很多 `if-else` 的孤零零工厂\n\n**简单工厂模式**描述了一个类， 它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。\n\n在绝大多数情况下，简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。\n\n简单工厂通常没有子类。但当从一个简单工厂中抽取出子类后，它看上去就会更像经典的工厂方法模式了。\n\n> [!warning] 在简单工厂模式的基础上，仅仅加个 `abstract` 关键字后并不会变成抽象工厂模式！\n\n### 工厂方法模式——GoF 23 设计模式之一\n\n**工厂方法**是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。\n\n如果在基类及其扩展的子类中都有一个构建方法的话，那它可能就是工厂方法。\n\n### 抽象工厂模式——GoF 23 设计模式之一\n\n**抽象工厂**是一种创建型设计模式，它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。\n\n> [!example] 系列对象\n> 有这样一组的对象：运输工具 + 引擎 + 控制器。它可能会有几个变体：\n> - 汽车 + 内燃机 + 方向盘\n> - 飞机 + 喷气式发动机 + 操纵杆\n\n如果你的程序中并不涉及产品系列的话，那就不需要抽象工厂。\n\n# Java 生成实例的方式\n\n## `new` 方法\n\n通过 `new` 的方法方式可以生成实例，这种方法类名会出现在代码中，形成强耦合关系。\n\n```java\n// new关键字\nSomething obj = new Something();\n```\n\n在开发过程中，我们可能有「在不指定类名的前提下生成实例」的需求，这时候可以尝试使用 [[原型模式及深浅拷贝|原型模式]]。原型模式包含三种实例创建方法：`clone` 方法、反序列化方法以及反射方法。\n\n## `clone` 方法\n\n我们可以通过 `clone` 方法，根据现有实例复制出一个新实例。这个过程中不会调用构造函数。\n\n```java\n// clone方法\nclass Something {\n\t...\n\tpublic Something createClone(){\n\t\tSomething obj = null;\n\t\ttry {\n\t\t\tobj = (Something)clone();\n\t\t} catch (CloneNotSupportedException e){\n\t\t\te.printStackTrace() ;\n\t\t}\n\t\treturn obj;\n\t}\n}\n```\n\n## 使用反射\n\n我们还可以使用 [[Java 中的反射|反射]]，通过 `newInstance` 的方法生成实例：\n\n```java\n// java.lang.Class类的newInstance方法。通过Class类的实例生成出Class类所表示的类（即Something类）的实例（会调用无参构造函数）。\n// 假设someobj是Something类的实例：\nsomeobj.getClass().newInstance()\n// 注意异常的捕捉。\n\n// 其他 newInstance 方式\nPerson emp1 = (Person) Class.forName(\"org.pro.com.Person\").newInstance();\nPersone emp2 = Person.class.newInstance();\nConstructor<Person> constructor = Person.class.getConstructor();\nPerson emp3 = constructor.newInstance();\n```\n\n`class.loadClass` 方法：\n\n```java\nClassLoader cl; \nClass cls = cl.loadClass(\"com.rain.B\"); // 使用第一步得到的ClassLoader来载入B\nB b = (B)cls.newInstance(); // 有B的类得到一个B的实例\n```\n\n## 反序列化\n\n反序列化方式。即通过 I/O 流（包括反序列化），如运用反序列化手段，调用 `java.io.ObjectInputStream` 对象的 `readObject()` 方法。\n\n# 结尾\n\n## 后续计划\n\n- [ ] 补充「抽象工厂模式」的案例学习\n- [ ] 语言风格需要统一、逻辑需要清晰\n\n## 本文 PlantUML 归档\n\n工厂方法模式：\n\n```plantuml\npackage frame{\n\tabstract class Creator{\n\t\t{method} create\n\t\t{method} {abstract} factoryMethod\n\t}\n\n\tabstract class Product{\n\t\t{method} {abstract} method1\n\t\t{method} {abstract} method2\n\t\t{method} {abstract} method3\n\t}\n\tCreator -> Product : Creates\n}\n\npackage products{\n\tclass ConcreteCreator{\n\t\t{method} factoryMethod\n\t}\n\n\tclass ConcreteProduct{\n\t\t{method} method1\n\t\t{method} method2\n\t\t{method} method3\n\t}\n\tConcreteCreator -> ConcreteProduct : Creates\n}\nCreator <|-- ConcreteCreator\nProduct <|-- ConcreteProduct\n```\n\n抽象工厂模式：\n\n```plantuml\npackage factory{\n\tabstract class AbstractProduct1{\n\t\t{method} {abstract} executeA\n\t\t{method} {abstract} executeA\n\t}\n\t\n\tabstract class AbstractProduct2{\n\t\t{method} {abstract} doAlpha\n\t\t{method} {abstract} doBeta\n\t}\n\n\t\n\tabstract class AbstractProduct3{\n\t\t{method} {abstract} performOne\n\t\t{method} {abstract} performTwo\n\t}\n\t\n\tclass Hide1\n\t\n\tabstract class AbstractFactory{\n\t\t{method} {abstract} createProduct1\n\t\t{method} {abstract} createProduct2\n\t\t{method} {abstract} createProduct3\n\t}\n\n\tAbstractProduct1 <-- AbstractFactory\n\tAbstractProduct2 <-- AbstractFactory\n\tAbstractProduct3 <-- AbstractFactory\n\tHide1 <-- AbstractFactory\n\n}\n\nhide factory.Hide1\n\npackage concretefactory{\n\tclass ConcreteProduct1{\n\t\t{method} executeA\n\t\t{method} executeA\n\t}\n\t\n\tclass ConcreteProduct2{\n\t\t{method} doAlpha\n\t\t{method} doBeta\n\t}\n\t\n\tclass ConcreteProduct3{\n\t\t{method} performOne\n\t\t{method} performTwo\n\t}\n\n\tclass ConcreteFactory{\n\t\t{method} createProduct1\n\t\t{method} createProduct2\n\t\t{method} createProduct3\n\t}\n\n\tConcreteProduct1 <-- ConcreteFactory\n\tConcreteProduct2 <-- ConcreteFactory\n\tConcreteProduct3 <-- ConcreteFactory\n}\n\nAbstractFactory <|-- ConcreteFactory\nAbstractProduct1 <|-- ConcreteProduct1\nAbstractProduct2 <|-- ConcreteProduct2\nAbstractProduct3 <|-- ConcreteProduct3\nAbstractFactory -[hidden]down- ConcreteProduct2\n```\n\n## 本文参考\n\n- 《图解设计模式》\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- 极客时间专栏 - 设计模式之美 - 王争\n- [设计模式辨析——工厂篇（简单工厂、静态工厂、工厂方法、抽象工厂） - 知乎](https://zhuanlan.zhihu.com/p/476420041)\n- [还在new对象吗？试试静态工厂方法--Effective Java第二章 - 知乎](https://zhuanlan.zhihu.com/p/157099580)\n- [工厂模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/factory-pattern.html)\n- [设计模式之工厂模式(3种)详解及代码示例 - kosamino - 博客园](https://www.cnblogs.com/jing99/p/12595494.html)\n- [实例化类的五种方法-CSDN博客](https://blog.csdn.net/u012524415/article/details/80327705)\n- [万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解_gof23-CSDN博客](https://blog.csdn.net/penriver/article/details/118571991)\n- [建造者设计模式（生成器模式）](https://refactoringguru.cn/design-patterns/factory-method)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"单例模式","api":"api/tags/单例模式.json"},{"name":"工厂模式","api":"api/tags/工厂模式.json"}]},"api":"api/posts/p/3a9f48af.json"}