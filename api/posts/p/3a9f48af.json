{"data":{"title":"工厂模式（简单工厂、静态工厂、抽象工厂）","slug":"高质量代码及设计模式/工厂模式（简单工厂、静态工厂、抽象工厂）","description":"辨析各种工厂别混淆","date":"2025-06-12T13:37:37.000Z","updated":"2025-07-10T16:07:52.209Z","language":"zh-CN","comments":true,"url":"p/3a9f48af/","cover":"https://cdn.gallery.uuanqin.top/img/202506122213473.webp","images":[],"content":"<p>工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。</p>\n<p>通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。</p>\n<p>工厂模式的类型与简介：</p>\n<ul>\n<li><strong>简单工厂模式（Simple Factory）</strong>：它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。\n<ul>\n<li>简单工厂模式不是一个正式的设计模式，但它是工厂模式的基础。</li>\n<li>它属于创建型模式，但不属于 GoF 23 设计模式。</li>\n<li>不符合“开放—封闭原则”，简单工厂中每一次扩展都需要对工厂类进行修改</li>\n</ul>\n</li>\n<li><strong>静态工厂模式</strong>：将工厂类中的创建对象的功能定义为静态的，就是静态工厂模式。\n<ul>\n<li>它同样不是一种设计模式。</li>\n<li>有时候，此模式归类为简单工厂模式的另一种实现方式。</li>\n</ul>\n</li>\n<li><strong>工厂方法模式（Factory Method Pattern）</strong>，又称多态性工厂模式：工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。\n<ul>\n<li>针对接口编程，不针对实现编程，代码更具弹性，扩展性更好</li>\n<li>符合开放 - 封闭原则：客户端决定实例化哪一个工厂来创建类，在扩展时不需要修改工厂类</li>\n<li>解耦合：把创建对象的具体实现移到具体的工厂子类，在工厂接口类并不需要知道实际创建的对象是哪一个类，解耦了客户端中关于超类的代码和子类对象创建代码。</li>\n</ul>\n</li>\n<li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。</li>\n</ul>\n<p>关于以上分类方法的一些提醒：</p>\n<ul>\n<li>在 GoF 的《设计模式》一书中，作者将简单工厂模式看作是工厂方法模式的一种特例。</li>\n<li>《图解设计模式》一书中沿用 GoF《设计模式》中的分类方法。书中关于工厂模式介绍的是 Factory Method 模式和 Abstract Factory 模式。</li>\n<li>有些观点认为上面的简单工厂模式（Simple Factory）和静态工厂模式是「简单工厂模式」的两种实现。</li>\n</ul>\n<p>为了内容编排清晰，已将案例和理论分节处理。</p>\n<h1 id=\"一个简易计算器的案例\"><a class=\"markdownIt-Anchor\" href=\"#一个简易计算器的案例\"></a> 一个简易计算器的案例</h1>\n<p>我们先从案例讲起。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">代码演示：简单工厂模式</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>通过代码实现一个简单计算器，具有加减乘除的运算功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Operation <span class=\"title function_\">createOperation</span><span class=\"params\">(<span class=\"type\">char</span> operator)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Operation</span> <span class=\"variable\">operation</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (operator) &#123; <span class=\"comment\">//可以看到简单工厂将运算类的实例放在工厂类中实现</span></span><br><span class=\"line\">\t<span class=\"comment\">//通过分支选择具体的实现类</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSub</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationMul</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">\t\t    operation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationDiv</span>();</span><br><span class=\"line\">\t\t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;unsupported operation&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> operation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationAdd</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Operation</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">result</span><span class=\"params\">()</span> &#123; <span class=\"comment\">//具体的操作子类只需要实现具体运算</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> numberA + numberB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tOperation operation;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> operator;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\toperator = <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 使用过程中，在客户端提供具体实例的参数，传入工厂类实现</span></span><br><span class=\"line\">\t\toperation = OperationFactory.createOperation(operator);</span><br><span class=\"line\">\t\toperation.numberA = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">\t\toperation.numberB = <span class=\"number\">2.3</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 具体的运算过程，客户端不可见</span></span><br><span class=\"line\">\t\tSystem.out.println(operation.result());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们不使用简单工厂模式，我们的代码会是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tOperation operation;</span><br><span class=\"line\">\t<span class=\"type\">char</span> <span class=\"variable\">operator</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 不使用工厂模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSub</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationMul</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(operator == <span class=\"string\">&#x27;/&#x27;</span>)</span><br><span class=\"line\">\t\toperation = <span class=\"keyword\">new</span> <span class=\"title class_\">OperationDiv</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，简单工厂模式将一个复杂的类的创建过程，抽象为一个工厂类去做这个事情。</p>\n<p>大部分工厂类都是以「Factory」这个单词结尾的，但也不是必须的，比如 Java 中的 <code>DateFormat</code>、<code>Calender</code>。除此之外，工厂类中创建对象的方法一般都是 <code>create</code> 开头，比如代码中的 <code>createOperation()</code>，但有的也命名为 <code>getInstance()</code>、<code>createInstance()</code>、<code>newInstance()</code>，有的甚至命名为 <code>valueOf()</code>（比如 Java <code>String</code> 类的 <code>valueOf()</code> 函数）等等。</p>\n<p>在上面的代码中，我们可以发现每次调用 <code>createOperation()</code> 函数都会 <code>new</code> 一个新的实例。如果这个实例可以复用，我们可以将它缓存起来，这就是后面使用到的静态工厂模式。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">代码演示：静态工厂模式</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>针对上一小节简单工厂模式的 <code>OperationFactory</code>，我们可以将其改造为静态工厂模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Character, Operation&gt; cachedOperations = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;+&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>());</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;-&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSub</span>());</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;*&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationMul</span>());</span><br><span class=\"line\">\t\tcachedOperations.put(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">OperationDiv</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Operation <span class=\"title function_\">createOperation</span><span class=\"params\">(<span class=\"type\">char</span> operator)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 初步检查</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (operator == <span class=\"string\">&#x27;&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//或抛异常</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">Operation</span> <span class=\"variable\">operation</span> <span class=\"operator\">=</span> cachedOperations.get(operator);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> operation;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中如果我们需要新增操作运算，就必须改动 <code>OperationFactory</code> 的代码，似乎有点违反开闭原则。如果「新增操作运算」这件事情很少发生，上面的代码也是可以接受的。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">代码演示：工厂方法模式</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>在这个模式中，我们把 <code>OperationAdd</code>、<code>OperationSub</code> 这些看成是工厂方法模式中的「具体产品」角色；其抽象类 <code>Operation</code> 即为「产品」角色。每个具体的产品，都有各自对应的具体工厂而创建；各自的具体工厂，都继承着工厂接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相较于简单工厂模式 OperationFactory 并不直接创建具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationAddFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要新增产品时，另外定义具体工厂以及具体产品即可。符合开闭原则。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationAddFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OperationAdd</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationSqrtFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OperationFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Operation <span class=\"title function_\">getOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OperationSqrt</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OperationSqrt</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Operation</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。</p>\n<h1 id=\"各种工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#各种工厂模式\"></a> 各种「工厂模式」</h1>\n<table>\n<thead>\n<tr>\n<th>工厂模式</th>\n<th>开闭原则</th>\n<th>GoF 23 设计模式</th>\n<th>简记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简单工厂模式</td>\n<td>❌</td>\n<td rowspan=\"2\">❌</td>\n<td>一个具体工厂</td>\n</tr>\n<tr>\n<td>静态工厂模式</td>\n<td rowspan=\"2\">✅</td>\n<td>带缓存的具体工厂</td>\n</tr>\n<tr>\n<td>工厂方法模式</td>\n<td rowspan=\"2\">✅创建型</td>\n<td>抽象工厂生产抽象产品</td>\n</tr>\n<tr>\n<td>抽象工厂模式</td>\n<td>🟡</td>\n<td>超级工厂</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"简单工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#简单工厂模式\"></a> 简单工厂模式</h2>\n<p>简单工厂「模式」是对于工厂最基础的应用，但它其实不能算作「工厂模式」，它不是一个设计模式，像是一种编程习惯。</p>\n<p>应用层传参数给工厂就行，不需要关心如何创建。但是工厂类的职责相对过重，增加新的产品，需要修改工厂类的判断逻辑，违背了开闭原则。</p>\n<h2 id=\"静态工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#静态工厂模式\"></a> 静态工厂模式</h2>\n<p>创建类的实例的最常见的方式是用 <code>new</code> 语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条 <code>new</code> 语句，都会导致 Java 虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。</p>\n<p>静态工厂方法的特点：</p>\n<ol>\n<li>不需要使用创建对象的方法实例化对象</li>\n<li>不能通过继承来改变创建方法的行为</li>\n</ol>\n<p>代码上的特点就是类的构造函数使用 <code>private</code> 修饰。</p>\n<blockquote>\n<p>在有些情况下，一个类可以同时提供 <code>public</code> 的构造方法和静态工厂方法。用户可按需使用获取类的方式。</p>\n</blockquote>\n<p>例子：</p>\n<ul>\n<li><code>Class.forName</code></li>\n<li><code>Integer.valueOf</code></li>\n<li><code>Foo.getInstance</code></li>\n</ul>\n<p>静态工厂方法与用 <code>new</code> 语句调用构造方法的区别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>静态工厂模式</th>\n<th><code>new</code> 语句</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>构造方法名字</td>\n<td>方法名任意，提高代码可读性。但和其他的静态方法没有明显区别，我们可以通过约定命名的方式使用户区分一些静态方法专门负责返回类的示例，比如 <code>valueOf</code>、<code>getInstance</code>。</td>\n<td>必须与类名相同。但不能从名字上区分每个被重载的构造方法。</td>\n</tr>\n<tr>\n<td>调用时生成的对象数</td>\n<td>每次调用创建对象数目取决于方法的具体实现。</td>\n<td>每次调用都会生成一个新的对象。</td>\n</tr>\n<tr>\n<td>能否返回子类的实例</td>\n<td>可以。这一特性可以实现松耦合的系统接口。具体详看：工厂（方法）模式 Factory 章节</td>\n<td>不能，只能返回当前类的实例。</td>\n</tr>\n</tbody>\n</table>\n<p>静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"yukari\">站内文章</span>单例（Singleton）类</a>：只有唯一的实例的类。详看：饿汉模式。</li>\n<li>枚举类：实例的数量有限的类。自定义枚举类而不是简单的定义 0,1 之类的数字在提高代码可读性的同时，还可以引入 Java 编译器的检查。JDK5 开始，有专门的 <code>java.lang.Enum</code> 枚举类型的语法。</li>\n<li>具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。</li>\n<li>具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。</li>\n</ul>\n<h3 id=\"静态工厂方法的优缺点\"><a class=\"markdownIt-Anchor\" href=\"#静态工厂方法的优缺点\"></a> 静态工厂方法的优缺点</h3>\n<blockquote>\n<p>Consider static factory methods instead of constructors.</p>\n</blockquote>\n<p>创建对象时尽量考虑静态工厂方法，从而你可能见到以下场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Lists.newArrayList(); <span class=\"comment\">// 明明可以写成list = new ArrayList() </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Lists.newArrayList(); 源码</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lists</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList <span class=\"title function_\">newArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>静态工厂方法可以通过方法名字来表示创建了什么对象</li>\n<li>创建对象时不需要每次都创建一个新的。这也叫做实例控制（instance-controlled），比如 <code>Boolean</code> 的 <code>valueOf</code> 方法。</li>\n<li>静态工厂方法可以返回该类的子类。如果 <code>new</code> 的话就只能返回某个类，但是静态工厂方法可以返回其子类。比如有个静态对象的返回值是 <code>Set</code>，那么方法返回 <code>HashSet</code>。</li>\n<li>可以返回 <code>private class</code> 的对象。</li>\n<li>静态工厂方法可以根据参数来调整返回的子类</li>\n<li>静态工厂方法创建的对象可以暂时不存在。典型的例子就是通过反射来创建对象，给一个对象的全路径为参数（比如 <code>java.uril.ArrayList</code>）然后通过反射的方式创建之后返回。那么在这种情况下 <code>new</code> 肯定是不行了（类都没有根本没办法 <code>new</code>）。</li>\n</ol>\n<p>缺点：由于没有 <code>public</code> 的构造函数，那么这个类就没办法被继承，也就没法重写其方法。缺点中的优点就是鼓励程序员用组合而不是继承。</p>\n<h2 id=\"工厂方法模式-factory-method\"><a class=\"markdownIt-Anchor\" href=\"#工厂方法模式-factory-method\"></a> 工厂方法模式 Factory Method</h2>\n<p>将实例的生成交给子类</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408021703496.webp\" alt=\"image.png\" width=\"275px\" /></p>\n<p>如果我们将 Template Method 模式用于生成实例，他就演变为 Factory Method 模式。</p>\n<p>在 Template Method 模式中，父类规定处理的流程，子类实现具体的处理；在 Factory Method 模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类，具体处理全部交给子类负责。这样可以将生成实例的框架和实际负责生成实例的类解耦。</p>\n<p>在工厂模式中，核心的工厂类不再负责所有的产品的创建，而是将具体的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品应当被实例化这种细节。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506122159180.webp\" alt=\"image.png\" width=\"300px\" /></p>\n<p>抽象类 <code>Creator</code> 中的 <code>create</code> 方法使用 <code>final</code> 关键字修饰，表明不应该重写模板方法。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> framework;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Product <span class=\"title function_\">create</span><span class=\"params\">(String owner)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Product</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> createProduct(owner);</span><br><span class=\"line\">        registerProduct(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//createProduct的任务交给了具体工厂，由具体工厂负责new。</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(String owner)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerProduct</span><span class=\"params\">(Product product)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>登场角色：</p>\n<ul>\n<li><code>Product</code>（产品）：框架，抽象类，定义该模式下生成实例所持有的接口。具体的处理由 <code>ConcreteProduct</code> 角色决定。</li>\n<li><code>Creator</code>（创建者）：框架，负责生成 <code>Product</code> 角色的抽象类。不用 <code>new</code> 关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类耦合。</li>\n<li><code>ConcreteProduct</code>（具体的产品）：加工方，决定具体的产品。</li>\n<li><code>ConcreteCreator</code>（具体的创建者）：加工方，负责生成具体的产品。</li>\n</ul>\n<p>拓展思路：</p>\n<ul>\n<li>如果要创建其他产品，直接引入 <code>framework</code>（框架）包。</li>\n<li>生成实例的方法，<code>Creator</code> 里的 <code>create</code> 方法，可以有三种实现方式：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式1：在Creator里指定create为抽象方法</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(Params params)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2：create中可以进行默认处理的实现。如果子类没有实现这个方法，将会进行默认处理。但这时可能会使用new关键字创建出实例，所以Product不能为抽象类。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(Params params)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Product</span>(Params params)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式3：在create中实现仅抛出异常的方法。当开发人员没有在子类实现这个方法时会抛出异常，并告知开发人员没有实现这个方法。需要另外编写异常类。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Product <span class=\"title function_\">createProduct</span><span class=\"params\">(Params params)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FactoryMethodRuntimeException</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>工厂方法模式非常符合“开闭原则”，当需要增加一个新产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必就会导致系统的复杂度增加。</p>\n<p>工厂方法模式和简单工厂模式的区别：</p>\n<ul>\n<li>简单工厂把有关实例化的全部事情，都在工厂类中处理（没有抽象工厂类），然而工厂方法模式创建了一个框架，让工厂子类决定要如何实现。</li>\n<li>克服了简单工厂违背“开放 - 封闭原则”的缺点，又保持了封装对象创建过程的优点，对简单工厂的进一步抽象和推广</li>\n</ul>\n<p>相关的设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"yukari\">站内文章</span>单例模式 Singleton</a>：在多数情况下我们都可以将 Singleton 模式用于扮演 Creator 角色（或是 ConcreteCreator 角色）的类。这是因为在程序中没有必要存在多个 Creator 角色（或是 ConcreteCreator 角色）的实例。不过在示例程序中，我们并没有使用 Singleton 模式。</li>\n<li>Composite 模式 (第 11 章)：有时可以将 Composite 模式用于 Product 角色（或是 ConcreteProduct 角色）。</li>\n<li>模板方法模式 Template Method：Factory Method 模式是 Template Method 的典型应用。在示例程序中，create 方法就是模板方法。</li>\n<li>迭代器模式 Iterator：有时，在 Iterator 模式中使用 iterator 方法生成 Iterator 的实例时会使用 Factory Method 模式。</li>\n</ul>\n<h2 id=\"抽象工厂-abstract-factory\"><a class=\"markdownIt-Anchor\" href=\"#抽象工厂-abstract-factory\"></a> 抽象工厂 Abstract Factory</h2>\n<p>将关联零件组装成产品。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240731150817.webp\" alt=\"image.png\" width=\"252px\" /></p>\n<p>抽象工厂模式（Abstract Factory Pattern）的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>\n<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂的工作是将“抽象零件”组装为“抽象产品”。</p>\n<blockquote>\n<p>抽象：不考虑具体实现，而是仅关注接口（API）的状态。<br />\n依赖倒置原则：要依赖抽象，不要依赖具体的类。</p>\n</blockquote>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506122200060.webp\" alt=\"image.png\" width=\"450px\" /></p>\n<p>登场角色：</p>\n<ul>\n<li>AbstractProduct（抽象产品）：定义 AbstractFactory 角色所生成的抽象零件和产品接口（API）。</li>\n<li>AbstractFactory（抽象工厂）：定义用于生成抽象产品的接口（API）。</li>\n<li>Client（委托者）：调用 AbstractFactory 角色和 AbstractProduct 角色的接口（API）来进行工作，对于具体的零件、产品和工厂一无所知。比如示例程序中的 Main，根据 Factory 接口构造一篇 HTML。</li>\n<li>ConcreteProduct（具体产品）：负责实现 AbstractProduct 角色的接口（API）。</li>\n<li>ConcreteFactory（具体工厂）：负责实现 AbstractFactory 角色的接口。</li>\n</ul>\n<p>使用抽象工厂模式一般要满足以下条件：</p>\n<ul>\n<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>\n<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>\n</ul>\n<p>抽象工厂模式和工厂方法模式的异同：</p>\n<ul>\n<li>创建对象时：\n<ul>\n<li>工厂方法模式：继承。通过工厂子类创建对象，客户端只需要知道具体的抽象类型，由工厂子类决定具体类型，只负责将客户从具体类型中解耦。</li>\n<li>抽象工厂模式：对象的组合。提供用来创建一个产品家族的抽象类，这个类型的子类定义产品被创建的方法，使用时通过实例化具体工厂类，并将工厂类传入针对抽象类型写的代码中，把客户从所使用的实际具体产品中解耦。</li>\n</ul>\n</li>\n<li>抽象工厂集合了一群相关的产品类，而工厂方法只需要创建一个产品。抽象工厂中的每一个方法创建一个具体类，实际是利用工厂方法实现。</li>\n</ul>\n<p>优缺点：</p>\n<ul>\n<li>优点：具体产品在应用层代码隔离，无须关心创建细节；将一个系列的产品族统一到一起创建。</li>\n<li>缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；增加了系统的抽象性和理解难度。</li>\n</ul>\n<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>\n<ul>\n<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>\n<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>\n</ul>\n<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>\n<p>相关设计模式：</p>\n<ul>\n<li>工厂（方法）模式 Factory：有时 Abstract Factory 模式中零件和产品的生成会使用到 Factory Method 模式。</li>\n<li>Composite 模式（第 11 章）：有时 Abstract Factory 模式在制作产品时会使用 Composite 模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"yukari\">站内文章</span>单例模式 Singleton</a>：有时 Abstract Factory 模式中的具体工厂会使用 Singleton 模式。</li>\n</ul>\n<h1 id=\"其他内容\"><a class=\"markdownIt-Anchor\" href=\"#其他内容\"></a> 其他内容</h1>\n<h2 id=\"java-生成实例的方式\"><a class=\"markdownIt-Anchor\" href=\"#java-生成实例的方式\"></a> Java 生成实例的方式</h2>\n<p>在介绍工厂模式之前，先介绍一下 Java 生成实例有哪些方式。</p>\n<p>通过 <code>new</code> 的方法方式可以生成实例，这种方法类名会出现在代码中，形成强耦合关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new关键字</span></span><br><span class=\"line\"><span class=\"type\">Something</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Something</span>();</span><br></pre></td></tr></table></figure>\n<p>我们可以通过 <code>clone</code> 方法，根据现有实例复制出一个新实例。这个过程中不会调用构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// clone方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Something</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Something <span class=\"title function_\">createClone</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Something</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tobj = (Something)clone();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class=\"line\">\t\t\te.printStackTrace() ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以通过 <code>newInstance</code> 的方法生成实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java.lang.Class类的newInstance方法。通过Class类的实例生成出Class类所表示的类（即Something类）的实例（会调用无参构造函数）。</span></span><br><span class=\"line\"><span class=\"comment\">// 假设someobj是Something类的实例：</span></span><br><span class=\"line\">someobj.getClass().newInstance()</span><br><span class=\"line\"><span class=\"comment\">// 注意异常的捕捉。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他 newInstance 方式</span></span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">emp1</span> <span class=\"operator\">=</span> (Person) Class.forName(<span class=\"string\">&quot;org.pro.com.Person&quot;</span>).newInstance();</span><br><span class=\"line\"><span class=\"type\">Persone</span> <span class=\"variable\">emp2</span> <span class=\"operator\">=</span> Person.class.newInstance();</span><br><span class=\"line\">Constructor&lt;Person&gt; constructor = Person.class.getConstructor();</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">emp3</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>\n<p><code>class.loadClass</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassLoader cl; </span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> cl.loadClass(<span class=\"string\">&quot;com.rain.B&quot;</span>); <span class=\"comment\">// 使用第一步得到的ClassLoader来载入B</span></span><br><span class=\"line\"><span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> (B)cls.newInstance(); <span class=\"comment\">// 有B的类得到一个B的实例</span></span><br></pre></td></tr></table></figure>\n<p>反序列化方式。即通过 I/O 流（包括反序列化），如运用反序列化手段，调用 <code>java.io.ObjectInputStream</code> 对象的 <code>readObject()</code> 方法。</p>\n<h1 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\"></a> 结尾</h1>\n<p>1995 年，Gang of Four（四人<strong>组</strong>）合作出版了《Design Patterns: Elements of Reusable Object-Oriented Software》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF 设计模式」。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506132249993.webp\" alt=\"image.png\" width=\"250px\" /></p>\n<h2 id=\"后续计划\"><a class=\"markdownIt-Anchor\" href=\"#后续计划\"></a> 后续计划</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 补充「抽象工厂模式」的案例学习</li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 语言风格需要统一、逻辑需要清晰</li>\n</ul>\n<h2 id=\"本文-plantuml-归档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-归档\"></a> 本文 PlantUML 归档</h2>\n<p>工厂方法模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package frame&#123;</span><br><span class=\"line\">\tabstract class Creator&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; create</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; factoryMethod</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tabstract class Product&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; method1</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; method2</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; method3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tCreator -&gt; Product : Creates</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package products&#123;</span><br><span class=\"line\">\tclass ConcreteCreator&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; factoryMethod</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclass ConcreteProduct&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; method1</span><br><span class=\"line\">\t\t&#123;method&#125; method2</span><br><span class=\"line\">\t\t&#123;method&#125; method3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tConcreteCreator -&gt; ConcreteProduct : Creates</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Creator &lt;|-- ConcreteCreator</span><br><span class=\"line\">Product &lt;|-- ConcreteProduct</span><br></pre></td></tr></table></figure>\n<p>抽象工厂模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package factory&#123;</span><br><span class=\"line\">\tabstract class AbstractProduct1&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; executeA</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; executeA</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tabstract class AbstractProduct2&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; doAlpha</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; doBeta</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tabstract class AbstractProduct3&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; performOne</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; performTwo</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass Hide1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tabstract class AbstractFactory&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; createProduct1</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; createProduct2</span><br><span class=\"line\">\t\t&#123;method&#125; &#123;abstract&#125; createProduct3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAbstractProduct1 &lt;-- AbstractFactory</span><br><span class=\"line\">\tAbstractProduct2 &lt;-- AbstractFactory</span><br><span class=\"line\">\tAbstractProduct3 &lt;-- AbstractFactory</span><br><span class=\"line\">\tHide1 &lt;-- AbstractFactory</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hide factory.Hide1</span><br><span class=\"line\"></span><br><span class=\"line\">package concretefactory&#123;</span><br><span class=\"line\">\tclass ConcreteProduct1&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; executeA</span><br><span class=\"line\">\t\t&#123;method&#125; executeA</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass ConcreteProduct2&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; doAlpha</span><br><span class=\"line\">\t\t&#123;method&#125; doBeta</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass ConcreteProduct3&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; performOne</span><br><span class=\"line\">\t\t&#123;method&#125; performTwo</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclass ConcreteFactory&#123;</span><br><span class=\"line\">\t\t&#123;method&#125; createProduct1</span><br><span class=\"line\">\t\t&#123;method&#125; createProduct2</span><br><span class=\"line\">\t\t&#123;method&#125; createProduct3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tConcreteProduct1 &lt;-- ConcreteFactory</span><br><span class=\"line\">\tConcreteProduct2 &lt;-- ConcreteFactory</span><br><span class=\"line\">\tConcreteProduct3 &lt;-- ConcreteFactory</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AbstractFactory &lt;|-- ConcreteFactory</span><br><span class=\"line\">AbstractProduct1 &lt;|-- ConcreteProduct1</span><br><span class=\"line\">AbstractProduct2 &lt;|-- ConcreteProduct2</span><br><span class=\"line\">AbstractProduct3 &lt;|-- ConcreteProduct3</span><br><span class=\"line\">AbstractFactory -[hidden]down- ConcreteProduct2</span><br></pre></td></tr></table></figure>\n<h2 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h2>\n<ul>\n<li>《图解设计模式》</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li>极客时间专栏 - 设计模式之美 - 王争</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/476420041\">设计模式辨析——工厂篇（简单工厂、静态工厂、工厂方法、抽象工厂） - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/157099580\">还在new对象吗？试试静态工厂方法–Effective Java第二章 - 知乎</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/factory-pattern.html\">工厂模式 | 菜鸟教程 (runoob.com)</a></li>\n<li><a href=\"https://www.cnblogs.com/jing99/p/12595494.html\">设计模式之工厂模式(3种)详解及代码示例 - kosamino - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/u012524415/article/details/80327705\">实例化类的五种方法-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/penriver/article/details/118571991\">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解_gof23-CSDN博客</a></li>\n</ul>\n","raw":"---\ntitle: 工厂模式（简单工厂、静态工厂、抽象工厂）\ntags:\n  - 设计模式\n  - 工厂模式\n  - 单例模式\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202506122213473.webp'\ndescription: 辨析各种工厂别混淆\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: 3a9f48af\ndate: 2025-06-12 21:37:37\ntop_img:\n---\n\n工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。\n\n通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。\n\n工厂模式的类型与简介：\n\n- **简单工厂模式（Simple Factory）**：它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。\n\t- 简单工厂模式不是一个正式的设计模式，但它是工厂模式的基础。\n\t- 它属于创建型模式，但不属于 GoF 23 设计模式。\n\t- 不符合“开放—封闭原则”，简单工厂中每一次扩展都需要对工厂类进行修改\n- **静态工厂模式**：将工厂类中的创建对象的功能定义为静态的，就是静态工厂模式。\n\t- 它同样不是一种设计模式。\n\t- 有时候，此模式归类为简单工厂模式的另一种实现方式。\n- **工厂方法模式（Factory Method Pattern）**，又称多态性工厂模式：工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。\n\t- 针对接口编程，不针对实现编程，代码更具弹性，扩展性更好\n\t- 符合开放 - 封闭原则：客户端决定实例化哪一个工厂来创建类，在扩展时不需要修改工厂类\n\t- 解耦合：把创建对象的具体实现移到具体的工厂子类，在工厂接口类并不需要知道实际创建的对象是哪一个类，解耦了客户端中关于超类的代码和子类对象创建代码。\n- **抽象工厂模式（Abstract Factory Pattern）**：抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。\n\n关于以上分类方法的一些提醒：\n\n- 在 GoF 的《设计模式》一书中，作者将简单工厂模式看作是工厂方法模式的一种特例。\n- 《图解设计模式》一书中沿用 GoF《设计模式》中的分类方法。书中关于工厂模式介绍的是 Factory Method 模式和 Abstract Factory 模式。\n- 有些观点认为上面的简单工厂模式（Simple Factory）和静态工厂模式是「简单工厂模式」的两种实现。\n\n为了内容编排清晰，已将案例和理论分节处理。\n\n# 一个简易计算器的案例\n\n我们先从案例讲起。\n\n> [!example] 代码演示：简单工厂模式\n\n通过代码实现一个简单计算器，具有加减乘除的运算功能：\n\n```java\npublic class OperationFactory {\n    public static Operation createOperation(char operator) {\n\t\tOperation operation = null;\n\t\n\t\tswitch (operator) { //可以看到简单工厂将运算类的实例放在工厂类中实现\n\t//通过分支选择具体的实现类\n\t\tcase '+':\n\t\t    operation = new OperationAdd();\n\t\t    break;\n\t\tcase '-':\n\t\t    operation = new OperationSub();\n\t\t    break;\n\t\tcase '*':\n\t\t    operation = new OperationMul();\n\t\t    break;\n\t\tcase '/':\n\t\t    operation = new OperationDiv();\n\t\t    break;\n\t\tdefault:\n\t\t    throw new RuntimeException(\"unsupported operation\");\n\t\t}\n\t\treturn operation;\n    }\n}\n\npublic class OperationAdd extends Operation {\n    @Override\n    public double result() { //具体的操作子类只需要实现具体运算\n\t\treturn numberA + numberB;\n    }\n}\n\npublic class Calculator {\n    public static void main(String[] args) {\n\t\tOperation operation;\n\t\tchar operator;\n\t\n\t\toperator = '+';\n\t\t// 使用过程中，在客户端提供具体实例的参数，传入工厂类实现\n\t\toperation = OperationFactory.createOperation(operator);\n\t\toperation.numberA = 1.2;\n\t\toperation.numberB = 2.3;\n\t\t// 具体的运算过程，客户端不可见\n\t\tSystem.out.println(operation.result());\n    }\n}\n```\n\n如果我们不使用简单工厂模式，我们的代码会是这样的：\n\n```java\npublic static void main(String[] args) {\n\tOperation operation;\n\tchar operator = '+';\n\t// 不使用工厂模式\n\tif(operator == '+')\n\t\toperation = new OperationAdd();\n\telse if(operator == '-')\n\t\toperation = new OperationSub();\n\telse if(operator == '*')\n\t\toperation = new OperationMul();\n\telse if(operator == '/')\n\t\toperation = new OperationDiv();\n\t// ...\n}\n```\n\n也就是说，简单工厂模式将一个复杂的类的创建过程，抽象为一个工厂类去做这个事情。\n\n大部分工厂类都是以「Factory」这个单词结尾的，但也不是必须的，比如 Java 中的 `DateFormat`、`Calender`。除此之外，工厂类中创建对象的方法一般都是 `create` 开头，比如代码中的 `createOperation()`，但有的也命名为 `getInstance()`、`createInstance()`、`newInstance()`，有的甚至命名为 `valueOf()`（比如 Java `String` 类的 `valueOf()` 函数）等等。\n\n在上面的代码中，我们可以发现每次调用 `createOperation()` 函数都会 `new` 一个新的实例。如果这个实例可以复用，我们可以将它缓存起来，这就是后面使用到的静态工厂模式。\n\n> [!example] 代码演示：静态工厂模式\n\n针对上一小节简单工厂模式的 `OperationFactory`，我们可以将其改造为静态工厂模式：\n\n```java\npublic class OperationFactory {\n\tprivate static final Map<Character, Operation> cachedOperations = new HashMap<>();\n\t\n\tstatic {\n\t\tcachedOperations.put('+', new OperationAdd());\n\t\tcachedOperations.put('-', new OperationSub());\n\t\tcachedOperations.put('*', new OperationMul());\n\t\tcachedOperations.put('/', new OperationDiv());\n\t}\n\t\n\tpublic static Operation createOperation(char operator) {\n\t\t// 初步检查\n\t\tif (operator == '') {\n\t\t  return null;//或抛异常\n\t\t}\n\t\tOperation operation = cachedOperations.get(operator);\n\t\treturn operation;\n\t}\n}\n```\n\n在上面的代码中如果我们需要新增操作运算，就必须改动 `OperationFactory` 的代码，似乎有点违反开闭原则。如果「新增操作运算」这件事情很少发生，上面的代码也是可以接受的。\n\n> [!example] 代码演示：工厂方法模式\n\n在这个模式中，我们把 `OperationAdd`、`OperationSub` 这些看成是工厂方法模式中的「具体产品」角色；其抽象类 `Operation` 即为「产品」角色。每个具体的产品，都有各自对应的具体工厂而创建；各自的具体工厂，都继承着工厂接口：\n\n```java\n// 相较于简单工厂模式 OperationFactory 并不直接创建具体产品\npublic abstract class OperationFactory {\n    public abstract Operation getOperation();\n}\n\npublic class OperationAddFactory extends OperationFactory {\n    @Override\n    public Operation getOperation() {\n        return new OperationAdd();\n    }\n}\n\n// 需要新增产品时，另外定义具体工厂以及具体产品即可。符合开闭原则。\n\npublic class OperationAddFactory extends OperationFactory {\n    @Override\n    public Operation getOperation() {\n        return new OperationAdd();\n    }\n}\n\npublic class OperationSqrtFactory extends OperationFactory {\n    @Override\n    public Operation getOperation() {\n        return new OperationSqrt();\n    }\n}\n\npublic class OperationSqrt extends Operation{\n\t// ...\n}\n```\n\n当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。\n\n# 各种「工厂模式」\n\n| 工厂模式   | 开闭原则 | GoF 23 设计模式 | 简记         |\n| ------ | ---- | ----------- | ---------- |\n| 简单工厂模式 | ❌    | ❌           | 一个具体工厂     |\n| 静态工厂模式 | ✅    | ❌           | 带缓存的具体工厂   |\n| 工厂方法模式 | ✅    | ✅创建型        | 抽象工厂生产抽象产品 |\n| 抽象工厂模式 | 🟡   | ✅创建型        | 超级工厂       |\n\n## 简单工厂模式\n\n简单工厂「模式」是对于工厂最基础的应用，但它其实不能算作「工厂模式」，它不是一个设计模式，像是一种编程习惯。\n\n应用层传参数给工厂就行，不需要关心如何创建。但是工厂类的职责相对过重，增加新的产品，需要修改工厂类的判断逻辑，违背了开闭原则。\n\n## 静态工厂模式\n\n创建类的实例的最常见的方式是用 `new` 语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条 `new` 语句，都会导致 Java 虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。\n\n静态工厂方法的特点：\n\n1. 不需要使用创建对象的方法实例化对象\n2. 不能通过继承来改变创建方法的行为\n\n代码上的特点就是类的构造函数使用 `private` 修饰。\n\n> 在有些情况下，一个类可以同时提供 `public` 的构造方法和静态工厂方法。用户可按需使用获取类的方式。\n\n例子：\n\n- `Class.forName`\n- `Integer.valueOf`\n- `Foo.getInstance`\n\n静态工厂方法与用 `new` 语句调用构造方法的区别：\n\n|           | 静态工厂模式                                                                                       | `new` 语句                     |\n| --------- | -------------------------------------------------------------------------------------------- | ---------------------------- |\n| 构造方法名字    | 方法名任意，提高代码可读性。但和其他的静态方法没有明显区别，我们可以通过约定命名的方式使用户区分一些静态方法专门负责返回类的示例，比如 `valueOf`、`getInstance`。 | 必须与类名相同。但不能从名字上区分每个被重载的构造方法。 |\n| 调用时生成的对象数 | 每次调用创建对象数目取决于方法的具体实现。                                                                        | 每次调用都会生成一个新的对象。              |\n| 能否返回子类的实例 | 可以。这一特性可以实现松耦合的系统接口。具体详看：工厂（方法）模式 Factory 章节                                                 | 不能，只能返回当前类的实例。               |\n\n静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例：\n\n- [[单例模式一文通|单例（Singleton）类]]：只有唯一的实例的类。详看：饿汉模式。\n- 枚举类：实例的数量有限的类。自定义枚举类而不是简单的定义 0,1 之类的数字在提高代码可读性的同时，还可以引入 Java 编译器的检查。JDK5 开始，有专门的 `java.lang.Enum` 枚举类型的语法。\n- 具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。\n- 具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。\n\n\n### 静态工厂方法的优缺点\n\n> Consider static factory methods instead of constructors.\n\n创建对象时尽量考虑静态工厂方法，从而你可能见到以下场景：\n\n```java\nList<String> list = Lists.newArrayList(); // 明明可以写成list = new ArrayList() \n\n// Lists.newArrayList(); 源码\nclass Lists{\n   public static ArrayList newArrayList() {\n       return new ArrayList();\n   } \n}\n```\n\n优点：\n\n1. 静态工厂方法可以通过方法名字来表示创建了什么对象\n2. 创建对象时不需要每次都创建一个新的。这也叫做实例控制（instance-controlled），比如 `Boolean` 的 `valueOf` 方法。\n3. 静态工厂方法可以返回该类的子类。如果 `new` 的话就只能返回某个类，但是静态工厂方法可以返回其子类。比如有个静态对象的返回值是 `Set`，那么方法返回 `HashSet`。\n4. 可以返回 `private class` 的对象。\n5. 静态工厂方法可以根据参数来调整返回的子类\n6. 静态工厂方法创建的对象可以暂时不存在。典型的例子就是通过反射来创建对象，给一个对象的全路径为参数（比如 `java.uril.ArrayList`）然后通过反射的方式创建之后返回。那么在这种情况下 `new` 肯定是不行了（类都没有根本没办法 `new`）。\n\n缺点：由于没有 `public` 的构造函数，那么这个类就没办法被继承，也就没法重写其方法。缺点中的优点就是鼓励程序员用组合而不是继承。\n\n## 工厂方法模式 Factory Method\n\n将实例的生成交给子类\n\n![image.png|275](https://cdn.gallery.uuanqin.top/img/202408021703496.webp)\n\n如果我们将 Template Method 模式用于生成实例，他就演变为 Factory Method 模式。\n\n在 Template Method 模式中，父类规定处理的流程，子类实现具体的处理；在 Factory Method 模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类，具体处理全部交给子类负责。这样可以将生成实例的框架和实际负责生成实例的类解耦。\n\n在工厂模式中，核心的工厂类不再负责所有的产品的创建，而是将具体的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品应当被实例化这种细节。\n\n![image.png|300](https://cdn.gallery.uuanqin.top/img/202506122159180.webp)\n\n抽象类 `Creator` 中的 `create` 方法使用 `final` 关键字修饰，表明不应该重写模板方法。\n\n例子：\n\n```java\npackage framework;\npublic abstract class Factory {\n    public final Product create(String owner) {\n        Product p = createProduct(owner);\n        registerProduct(p);\n        return p;\n    }\n    //createProduct的任务交给了具体工厂，由具体工厂负责new。\n    protected abstract Product createProduct(String owner);\n    protected abstract void registerProduct(Product product);\n}\n```\n\n登场角色：\n\n- `Product`（产品）：框架，抽象类，定义该模式下生成实例所持有的接口。具体的处理由 `ConcreteProduct` 角色决定。\n- `Creator`（创建者）：框架，负责生成 `Product` 角色的抽象类。不用 `new` 关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类耦合。\n- `ConcreteProduct`（具体的产品）：加工方，决定具体的产品。\n- `ConcreteCreator`（具体的创建者）：加工方，负责生成具体的产品。\n\n拓展思路：\n\n- 如果要创建其他产品，直接引入 `framework`（框架）包。\n- 生成实例的方法，`Creator` 里的 `create` 方法，可以有三种实现方式：\n\n```java\n// 方式1：在Creator里指定create为抽象方法\nabstract class Factory{\n\tpublic abstract Product createProduct(Params params);\n\t// ...\n}\n\n// 方式2：create中可以进行默认处理的实现。如果子类没有实现这个方法，将会进行默认处理。但这时可能会使用new关键字创建出实例，所以Product不能为抽象类。\nclass Factory{\n\tpublic Product createProduct(Params params){\n\t\treturn new Product(Params params)\n\t}\n\t// ...\n}\n\n// 方式3：在create中实现仅抛出异常的方法。当开发人员没有在子类实现这个方法时会抛出异常，并告知开发人员没有实现这个方法。需要另外编写异常类。\n\nclass Factory{\n\tpublic Product createProduct(Params params){\n\t\tthrow new FactoryMethodRuntimeException();\n\t}\n\t// ...\n}\n```\n\n工厂方法模式非常符合“开闭原则”，当需要增加一个新产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必就会导致系统的复杂度增加。\n\n工厂方法模式和简单工厂模式的区别：\n\n- 简单工厂把有关实例化的全部事情，都在工厂类中处理（没有抽象工厂类），然而工厂方法模式创建了一个框架，让工厂子类决定要如何实现。\n- 克服了简单工厂违背“开放 - 封闭原则”的缺点，又保持了封装对象创建过程的优点，对简单工厂的进一步抽象和推广\n\n相关的设计模式：\n\n- [[单例模式一文通|单例模式 Singleton]]：在多数情况下我们都可以将 Singleton 模式用于扮演 Creator 角色（或是 ConcreteCreator 角色）的类。这是因为在程序中没有必要存在多个 Creator 角色（或是 ConcreteCreator 角色）的实例。不过在示例程序中，我们并没有使用 Singleton 模式。\n- Composite 模式 (第 11 章)：有时可以将 Composite 模式用于 Product 角色（或是 ConcreteProduct 角色）。\n- 模板方法模式 Template Method：Factory Method 模式是 Template Method 的典型应用。在示例程序中，create 方法就是模板方法。\n- 迭代器模式 Iterator：有时，在 Iterator 模式中使用 iterator 方法生成 Iterator 的实例时会使用 Factory Method 模式。\n\n## 抽象工厂 Abstract Factory\n\n将关联零件组装成产品。\n\n![image.png|252](https://cdn.gallery.uuanqin.top/img/20240731150817.webp)\n\n抽象工厂模式（Abstract Factory Pattern）的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂的工作是将“抽象零件”组装为“抽象产品”。\n\n> 抽象：不考虑具体实现，而是仅关注接口（API）的状态。\n> 依赖倒置原则：要依赖抽象，不要依赖具体的类。\n\n![image.png|450](https://cdn.gallery.uuanqin.top/img/202506122200060.webp)\n\n登场角色：\n\n- AbstractProduct（抽象产品）：定义 AbstractFactory 角色所生成的抽象零件和产品接口（API）。\n- AbstractFactory（抽象工厂）：定义用于生成抽象产品的接口（API）。\n- Client（委托者）：调用 AbstractFactory 角色和 AbstractProduct 角色的接口（API）来进行工作，对于具体的零件、产品和工厂一无所知。比如示例程序中的 Main，根据 Factory 接口构造一篇 HTML。\n- ConcreteProduct（具体产品）：负责实现 AbstractProduct 角色的接口（API）。\n- ConcreteFactory（具体工厂）：负责实现 AbstractFactory 角色的接口。\n\n使用抽象工厂模式一般要满足以下条件：\n\n- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。\n- 系统一次只可能消费其中某一族产品，即同族的产品一起使用。\n\n抽象工厂模式和工厂方法模式的异同：\n\n- 创建对象时：\n\t- 工厂方法模式：继承。通过工厂子类创建对象，客户端只需要知道具体的抽象类型，由工厂子类决定具体类型，只负责将客户从具体类型中解耦。\n\t- 抽象工厂模式：对象的组合。提供用来创建一个产品家族的抽象类，这个类型的子类定义产品被创建的方法，使用时通过实例化具体工厂类，并将工厂类传入针对抽象类型写的代码中，把客户从所使用的实际具体产品中解耦。\n- 抽象工厂集合了一群相关的产品类，而工厂方法只需要创建一个产品。抽象工厂中的每一个方法创建一个具体类，实际是利用工厂方法实现。\n\n优缺点：\n\n- 优点：具体产品在应用层代码隔离，无须关心创建细节；将一个系列的产品族统一到一起创建。\n- 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；增加了系统的抽象性和理解难度。\n\n抽象工厂模式的扩展有一定的“开闭原则”倾斜性：\n\n- 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。\n- 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。\n\n另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。\n\n相关设计模式：\n\n- 工厂（方法）模式 Factory：有时 Abstract Factory 模式中零件和产品的生成会使用到 Factory Method 模式。\n- Composite 模式（第 11 章）：有时 Abstract Factory 模式在制作产品时会使用 Composite 模式。\n- [[单例模式一文通|单例模式 Singleton]]：有时 Abstract Factory 模式中的具体工厂会使用 Singleton 模式。\n\n\n# 其他内容\n\n## Java 生成实例的方式\n\n在介绍工厂模式之前，先介绍一下 Java 生成实例有哪些方式。\n\n通过 `new` 的方法方式可以生成实例，这种方法类名会出现在代码中，形成强耦合关系。\n\n```java\n// new关键字\nSomething obj = new Something();\n```\n\n我们可以通过 `clone` 方法，根据现有实例复制出一个新实例。这个过程中不会调用构造函数。\n\n```java\n// clone方法\nclass Something {\n\t...\n\tpublic Something createClone(){\n\t\tSomething obj = null;\n\t\ttry {\n\t\t\tobj = (Something)clone();\n\t\t} catch (CloneNotSupportedException e){\n\t\t\te.printStackTrace() ;\n\t\t}\n\t\treturn obj;\n\t}\n}\n```\n\n我们还可以通过 `newInstance` 的方法生成实例：\n\n```java\n// java.lang.Class类的newInstance方法。通过Class类的实例生成出Class类所表示的类（即Something类）的实例（会调用无参构造函数）。\n// 假设someobj是Something类的实例：\nsomeobj.getClass().newInstance()\n// 注意异常的捕捉。\n\n// 其他 newInstance 方式\nPerson emp1 = (Person) Class.forName(\"org.pro.com.Person\").newInstance();\nPersone emp2 = Person.class.newInstance();\nConstructor<Person> constructor = Person.class.getConstructor();\nPerson emp3 = constructor.newInstance();\n```\n\n`class.loadClass` 方法：\n\n```java\nClassLoader cl; \nClass cls = cl.loadClass(\"com.rain.B\"); // 使用第一步得到的ClassLoader来载入B\nB b = (B)cls.newInstance(); // 有B的类得到一个B的实例\n```\n\n反序列化方式。即通过 I/O 流（包括反序列化），如运用反序列化手段，调用 `java.io.ObjectInputStream` 对象的 `readObject()` 方法。\n\n# 结尾\n\n1995 年，Gang of Four（四人**组**）合作出版了《Design Patterns: Elements of Reusable Object-Oriented Software》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF 设计模式」。\n\n![image.png|250](https://cdn.gallery.uuanqin.top/img/202506132249993.webp)\n\n## 后续计划\n\n- [ ] 补充「抽象工厂模式」的案例学习\n- [ ] 语言风格需要统一、逻辑需要清晰\n\n## 本文 PlantUML 归档\n\n工厂方法模式：\n\n```plantuml\npackage frame{\n\tabstract class Creator{\n\t\t{method} create\n\t\t{method} {abstract} factoryMethod\n\t}\n\n\tabstract class Product{\n\t\t{method} {abstract} method1\n\t\t{method} {abstract} method2\n\t\t{method} {abstract} method3\n\t}\n\tCreator -> Product : Creates\n}\n\npackage products{\n\tclass ConcreteCreator{\n\t\t{method} factoryMethod\n\t}\n\n\tclass ConcreteProduct{\n\t\t{method} method1\n\t\t{method} method2\n\t\t{method} method3\n\t}\n\tConcreteCreator -> ConcreteProduct : Creates\n}\nCreator <|-- ConcreteCreator\nProduct <|-- ConcreteProduct\n```\n\n抽象工厂模式：\n\n```plantuml\npackage factory{\n\tabstract class AbstractProduct1{\n\t\t{method} {abstract} executeA\n\t\t{method} {abstract} executeA\n\t}\n\t\n\tabstract class AbstractProduct2{\n\t\t{method} {abstract} doAlpha\n\t\t{method} {abstract} doBeta\n\t}\n\n\t\n\tabstract class AbstractProduct3{\n\t\t{method} {abstract} performOne\n\t\t{method} {abstract} performTwo\n\t}\n\t\n\tclass Hide1\n\t\n\tabstract class AbstractFactory{\n\t\t{method} {abstract} createProduct1\n\t\t{method} {abstract} createProduct2\n\t\t{method} {abstract} createProduct3\n\t}\n\n\tAbstractProduct1 <-- AbstractFactory\n\tAbstractProduct2 <-- AbstractFactory\n\tAbstractProduct3 <-- AbstractFactory\n\tHide1 <-- AbstractFactory\n\n}\n\nhide factory.Hide1\n\npackage concretefactory{\n\tclass ConcreteProduct1{\n\t\t{method} executeA\n\t\t{method} executeA\n\t}\n\t\n\tclass ConcreteProduct2{\n\t\t{method} doAlpha\n\t\t{method} doBeta\n\t}\n\t\n\tclass ConcreteProduct3{\n\t\t{method} performOne\n\t\t{method} performTwo\n\t}\n\n\tclass ConcreteFactory{\n\t\t{method} createProduct1\n\t\t{method} createProduct2\n\t\t{method} createProduct3\n\t}\n\n\tConcreteProduct1 <-- ConcreteFactory\n\tConcreteProduct2 <-- ConcreteFactory\n\tConcreteProduct3 <-- ConcreteFactory\n}\n\nAbstractFactory <|-- ConcreteFactory\nAbstractProduct1 <|-- ConcreteProduct1\nAbstractProduct2 <|-- ConcreteProduct2\nAbstractProduct3 <|-- ConcreteProduct3\nAbstractFactory -[hidden]down- ConcreteProduct2\n```\n\n## 本文参考\n- 《图解设计模式》\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- 极客时间专栏 - 设计模式之美 - 王争\n- [设计模式辨析——工厂篇（简单工厂、静态工厂、工厂方法、抽象工厂） - 知乎](https://zhuanlan.zhihu.com/p/476420041)\n- [还在new对象吗？试试静态工厂方法--Effective Java第二章 - 知乎](https://zhuanlan.zhihu.com/p/157099580)\n- [工厂模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/factory-pattern.html)\n- [设计模式之工厂模式(3种)详解及代码示例 - kosamino - 博客园](https://www.cnblogs.com/jing99/p/12595494.html)\n- [实例化类的五种方法-CSDN博客](https://blog.csdn.net/u012524415/article/details/80327705)\n- [万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解_gof23-CSDN博客](https://blog.csdn.net/penriver/article/details/118571991)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"单例模式","api":"api/tags/单例模式.json"},{"name":"工厂模式","api":"api/tags/工厂模式.json"}]},"api":"api/posts/p/3a9f48af.json"}