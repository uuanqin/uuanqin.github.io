{"title":"快速幂算法","tags":["矩阵","分治","Pascal","模运算"],"cover":"https://cdn.gallery.uuanqin.top/img/202505210015505.webp","description":"分治算法的一种应用","katex":true,"categories":["算法与数据结构"],"abbrlink":"9e8183d2","date":"2025-05-21T00:18:47.000Z","top_img":null,"summary":"快速幂算法 > [!example] 问题：如何快速计算 $x^n$，$x^{-n}$？ 提示： $$ x^{-n} = (\\frac{1}{x})^n $$ 算法实现 快速幂，二进制取幂（Binary Exponentiation，也称平方法）是一个在 $O(\\log n)$ 时间内计算 $x^n$ 的技巧性算法。快速幂算法的本质是分治算法。 递归版本 这个版本能直观理解计算过程。 复杂度分析： 时间复杂度：$O(\\log n)$，即为递归的层数。 空间复杂度：$O(\\log n)$，即为递归的层数。这是由于递归的函数调用会使用栈空间。 迭代版本 假设要计算 $x^9$： 形式化来讲： $$ \\begin{aligned} n&=2^{i_{0}}+2^{i_{1}}+\\dots+2^{i_{k}} \\\\ x^n&=x^{2^{i_{0}}}\\times x^{2^{i_{1}}}\\times\\dots \\times x^{2^{i_{k}}} \\end{aligned} $$ 因此算法可以这样写，把 n 看成一个二进制数，从 n 的低位开始依次检查二进制位，如果为 1，则把当前 x 乘到结果中。每次检查下一位时，x 自身翻一番。 复杂度分析： 时间复杂度：$O(\\log n)$，即为对 n 进行二进制拆分的时间复杂度。 空间复杂度：$O(1)$。 快速幂的应用 模指数运算（模意义下的取幂） > [!tldr] 分配律：m 是正整数且 a 和 b 是整数，那么有 > - $(a + b) \\bmod m = ((a \\bmod m) + (b \\bmod m)) \\bmod m$ > - $a\\cdot b \\bmod m = ((a \\bmod m)(b \\bmod m)) \\bmod m$ > > 这个定理其实也解释了为什么在一些算法题中，当题目要求给出最终计算结果取模时，即便我们在过程中取模也不会出错的原因。..."}