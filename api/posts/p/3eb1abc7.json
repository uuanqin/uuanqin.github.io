{"data":{"title":"CSAPP LAB-5 手写动态存储分配器","slug":"CSAPP LABS/CSAPP LAB-5 手写动态存储分配器","description":"课本案例实践","date":"2024-06-13T04:01:31.000Z","updated":"2024-06-19T11:29:12.531Z","language":"zh-CN","comments":true,"url":"p/3eb1abc7/","cover":"https://cdn.gallery.uuanqin.top/img/20240617204205.webp","images":[],"content":"<p>我也大概察觉到我们课程的实验是挑着 CSAPP 中原版实验去做的，并进行了简化，所以和网上的实验顺序不太一样，但内容是大致相同的。</p>\n\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">CSAPP LAB 实验</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c5970284/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-1 位操作</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/d1f3cf37/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-2 二进制炸弹实验</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/67787353/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-3 缓冲区溢出炸弹</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/9d6b717/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-4 代码优化</a></li>\n<li>CSAPP LAB-5 手写动态存储分配器（本文）</li>\n</ul>\n</div></div><p>这次的实验<strong>建议先看课本的第九章的 9.9 部分</strong>（《CSAPP》第三版），理解其中的内容后进行实现。而且大部分代码课本上都有。不管你现在《CSAPP》学到哪一个部分，都可以直接看 9.9 章，不用担心没有铺垫内容。</p>\n<p>本文将介绍一个动态存储分配器的简单实现：隐式空闲链表 + 立即边界标记合并方式 + 首次匹配/下次匹配算法。更高级的实现可以看文末参考文章。</p>\n<blockquote>\n<p>这是我 CSAPP 课程的最后一个实验了，每次专挑👩助教验收，温柔贴心给分高😍！</p>\n</blockquote>\n<h1 id=\"实验介绍和要求\"><a class=\"markdownIt-Anchor\" href=\"#实验介绍和要求\"></a> 实验介绍和要求</h1>\n<p>本实验需要用 c 语言实现一个动态的存储分配器，也就是你自己版本的 <code>malloc</code>，<code>free</code>，<code>realloc</code> 函数。</p>\n<p>解压文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xvf malloclab-handout.tar</span><br></pre></td></tr></table></figure>\n<p>我们需要修改的唯一文件是 <code>mm.c</code>，包含如下几个需要实现的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">mm_init:在调用mm_malloc，mm_realloc或mm_free之前，调用mm_init进行初始化，正确返回0。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mm_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">mm_malloc：在堆区域分配指定大小的块，分配的空间，返回的指针应该是8字节对齐的</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">mm_malloc</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">mm_free:释放指针指向的block</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mm_free</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">返回指向一个大小为size的区域指针，满足一下条件：</span></span><br><span class=\"line\"><span class=\"comment\">* if ptr is NULL, the call is equivalent to mm_malloc(size); </span></span><br><span class=\"line\"><span class=\"comment\">* if size is equal to zero, the call is equivalent to mm_free(ptr); </span></span><br><span class=\"line\"><span class=\"comment\">* if ptr is not NULL：先按照size指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来ptr所指内存区域</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">mm_realloc</span><span class=\"params\">(<span class=\"type\">void</span> *ptr, <span class=\"type\">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>\n<p>记住哦，本次实验的任务要求之一是指针是 8 字节对齐的。</p>\n<p>我们可以调用实验提供给我们的函数，这些函数定义在 <code>memory.c</code> 中：</p>\n<ul>\n<li><code>void *mem_sbrk(int incr)</code>: Expands the heap by incr bytes, where incr is a positive non-zero integer and returns a generic pointer to the first byte of the newly allocated heap area.</li>\n<li><code>void *mem_heap_lo(void)</code>: Returns a generic pointer to the first byte in the heap.</li>\n<li><code>void *mem_heap_hi(void)</code>: Returns a generic pointer to the last byte in the heap.</li>\n<li><code>size_t mem_heapsize(void)</code>: Returns the current size of the heap in bytes.</li>\n<li><code>size_t mem_pagesize(void)</code>: Returns the system’s page size in bytes (4K onLinux systems).</li>\n</ul>\n<p>在这篇文章的实现方式中，只需要使用 <code>void *mem_sbrk(int incr)</code>，与标准实现不同的是，这个函数拒绝收缩堆的请求，也就是不能输入负数。<code>mem_sbrk</code> 的作用可以结合课本 9.9 章进行理解。</p>\n<p>验证我们的动态的存储分配器：</p>\n<ul>\n<li><code>mdriver.c</code>：负责测试 <code>mm.c</code> 的正确性,空间利用率和吞吐量</li>\n<li>执行 <code>make</code> 指令生成 <code>mdriver</code> 可执行文件</li>\n<li><code>mdriver</code> 的使用：\n<ul>\n<li><code>-f &lt;tracefile&gt;</code>:  <code>-f</code> 后添加一些 trace file 来测试我们实现的函数</li>\n<li><code>-V</code>: 打印出诊断信息。</li>\n<li>例如：<code>./mdriver -V  -f short1-bal.rep</code></li>\n</ul>\n</li>\n</ul>\n<p>一些编程规则：</p>\n<ul>\n<li>不能改变 <code>mm.c</code> 中函数接口</li>\n<li>不能直接调用任何内存管理的库函数和系统函数 <code>malloc</code>, <code>calloc</code>, <code>free</code>, <code>realloc</code>, <code>sbrk</code>, <code>brk</code></li>\n<li>不能定义任何全局或者静态复合数据结构如 <code>arrays</code>, <code>structs</code>, <code>trees</code>，允许使用 <code>integers</code>, <code>floats</code> 以及 <code>pointers</code> 等简单数据类型</li>\n<li>返回的指针需要 8 字节对齐</li>\n</ul>\n<h1 id=\"关键概念\"><a class=\"markdownIt-Anchor\" href=\"#关键概念\"></a> 关键概念</h1>\n<p>我把课本涉及到的关键概念模型简要介绍一下。</p>\n<p>本文介绍的是隐式空闲链表 + 立即边界标记合并方式 + 首次匹配/下次匹配算法。</p>\n<p>更多详细内容理解就看下一节的代码注释咯！</p>\n<h2 id=\"隐式空闲链表的恒定形式\"><a class=\"markdownIt-Anchor\" href=\"#隐式空闲链表的恒定形式\"></a> 隐式空闲链表的恒定形式</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240617202828.webp\" alt=\"image.png\" /></p>\n<p>一个正方形表示 4 字节（一个字），虚线表示双字对齐标志。正方形中的头部尾部标记为 <code>size/is_alloc</code>。</p>\n<h2 id=\"标记边界合并\"><a class=\"markdownIt-Anchor\" href=\"#标记边界合并\"></a> 标记边界合并</h2>\n<p>Knuth 提出了边界标记技术，允许在常数时间内进行对前面的块的合并。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240617001201.webp\" alt=\"image.png\" /></p>\n<p>这种思想，是在每个块的结尾处添加一个脚部（footer，边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。</p>\n<p>考虑当分配器释放当前块时所有可能存在的情况：</p>\n<ol>\n<li>前面的块和后面的块都是已分配的。</li>\n<li>前面的块是已分配的，后面的块是空闲的。</li>\n<li>前面的块是空闲的，而后面的块是已分配的。</li>\n<li>前面的和后面的块都是空闲的。</li>\n</ol>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240617001349.webp\" alt=\"image.png\" /></p>\n<h2 id=\"匹配算法\"><a class=\"markdownIt-Anchor\" href=\"#匹配算法\"></a> 匹配算法</h2>\n<p>匹配算法：</p>\n<ul>\n<li>首次匹配（First Fit）。从头开始搜索空闲链表，选择第一个合适的空闲块。\n<ul>\n<li>优点：趋向于将大的空闲块保留在链表的后面。</li>\n<li>缺点：它趋向于在靠近链表起始处留下小空闲块的「碎片」，增大了对较大块的搜索时间。</li>\n</ul>\n</li>\n<li>下一次适配（Next Fit）。和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。由 Donald Knuth 提出。基于思想：如果上一次在某个空闲块里发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。\n<ul>\n<li>优点：比首次适配运行起来明显快一些。</li>\n<li>缺点：内存利用率比首次匹配低。</li>\n</ul>\n</li>\n<li>最佳适配（Best Fit）。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。\n<ul>\n<li>优点：内存利用率较高。</li>\n<li>缺点：在简单空闲链表组织结构中（比如上面提到的隐式空闲链表），需要对堆进行彻底搜索。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"mmc-文件\"><a class=\"markdownIt-Anchor\" href=\"#mmc-文件\"></a> <code>mm.c</code> 文件</h1>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class=\"line\"><span class=\"comment\"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class=\"line\"><span class=\"comment\"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class=\"line\"><span class=\"comment\"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class=\"line\"><span class=\"comment\"> * comment that gives a high level description of your solution.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mm.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;memlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class=\"line\"><span class=\"comment\"> * provide your team information in the following struct.</span></span><br><span class=\"line\"><span class=\"comment\"> ********************************************************/</span></span><br><span class=\"line\"><span class=\"type\">team_t</span> team = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Team name */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;SA23xxxxxx&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">/* First member&#x27;s full name */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;uuanqin&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">/* First member&#x27;s email address */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;uuanqin@uuanqin.top&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"comment\">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********  一些必要的宏 ***************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* single word (4) or double word (8) alignment */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ALIGNMENT 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基本常量</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WSIZE 4       <span class=\"comment\">// 字的大小（头部、脚部大小）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DSIZE 8       <span class=\"comment\">// 双字大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CHUNKSIZE (1 &lt;&lt; 12)  <span class=\"comment\">// 每次扩展堆时使用这个大小</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PACK(size, is_alloc) ((size) | (is_alloc))   <span class=\"comment\">// 将大小和分配位打包组装</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取/写入 指定位置的值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GET(p) (*(unsigned int *)(p))                </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取头部的信息</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给定块的指针bp，获取其头部和脚部的指针（注意，bp指向有效载荷的第一个字节）</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) <span class=\"comment\">// 依赖与头部已分配好大小</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给定块的指针bp，计算前后块的指针（注意，bp指向有效载荷的第一个字节）</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆的起始位置</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *heap_listp; <span class=\"comment\">// 总是指向序言块，我们可以小小优化为指向下一个块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数注册</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">coalesce</span><span class=\"params\">(<span class=\"type\">void</span> *bp)</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">extend_heap</span><span class=\"params\">(<span class=\"type\">size_t</span> words)</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">find_fit</span><span class=\"params\">(<span class=\"type\">size_t</span> asize)</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">place</span><span class=\"params\">(<span class=\"type\">void</span> *bp,<span class=\"type\">size_t</span> asize)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否启动下次适配</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NEXT_FIT</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">algo_first_fit</span><span class=\"params\">(<span class=\"type\">size_t</span> asize)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> NEXT_FIT</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">algo_next_fit</span><span class=\"params\">(<span class=\"type\">size_t</span> asize)</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * mm_init - initialize the malloc package.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mm_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个空的空闲链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((heap_listp = mem_sbrk(<span class=\"number\">4</span> * WSIZE)) == (<span class=\"type\">void</span> *)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为序言块+结尾块只需要三个字节。我们又必须保证堆的开始位置是双字对齐的。</span></span><br><span class=\"line\">    <span class=\"comment\">// PUT(heap_listp, 0);  // 课本中加了这一条，主要是为了占位，没有什么含义。</span></span><br><span class=\"line\">    PUT(heap_listp + (<span class=\"number\">1</span> * WSIZE), PACK(DSIZE, <span class=\"number\">1</span>)); <span class=\"comment\">// 序言块头部</span></span><br><span class=\"line\">    PUT(heap_listp + (<span class=\"number\">2</span> * WSIZE), PACK(DSIZE, <span class=\"number\">1</span>)); <span class=\"comment\">// 序言块脚部</span></span><br><span class=\"line\">    PUT(heap_listp + (<span class=\"number\">3</span> * WSIZE), PACK(<span class=\"number\">0</span>, <span class=\"number\">1</span>));     <span class=\"comment\">// 结尾块头部</span></span><br><span class=\"line\">    heap_listp += (<span class=\"number\">2</span> * WSIZE);                     <span class=\"comment\">// 移动堆指针到序言块中间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用空闲块扩展堆</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">extend_heap</span><span class=\"params\">(<span class=\"type\">size_t</span> words)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *bp;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size;</span><br><span class=\"line\">    size = (words % <span class=\"number\">2</span>) ? (words + <span class=\"number\">1</span>) * WSIZE : words * WSIZE; <span class=\"comment\">// 保证size是奇数个字节，因为有一个字节用来放空闲块的头部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">long</span>)(bp = mem_sbrk(size)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PUT(HDRP(bp), PACK(size, <span class=\"number\">0</span>));           <span class=\"comment\">// 空闲块的头部</span></span><br><span class=\"line\">    PUT(FTRP(bp), PACK(size, <span class=\"number\">0</span>));           <span class=\"comment\">// 空闲块的尾部</span></span><br><span class=\"line\">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class=\"number\">0</span>, <span class=\"number\">1</span>));  <span class=\"comment\">// 新的结尾块</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> coalesce(bp); <span class=\"comment\">// 合并块</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * mm_free - Freeing a block does nothing.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mm_free</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class=\"line\">    <span class=\"comment\">// 对当前块的标记位进行改变</span></span><br><span class=\"line\">    PUT(HDRP(ptr), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">    PUT(FTRP(ptr), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">    coalesce(ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并块</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">coalesce</span><span class=\"params\">(<span class=\"type\">void</span> *bp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));  <span class=\"comment\">// 检查块前面是否被分配</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));  <span class=\"comment\">// 检查块后面是否被分配</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class=\"line\">    <span class=\"comment\">// 因为序言块和结尾块的设计，使得边界情况的检查变得简单</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class=\"line\">        PUT(HDRP(bp), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">        PUT(FTRP(bp), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class=\"line\">        PUT(FTRP(bp), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">        bp = PREV_BLKP(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class=\"line\">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class=\"number\">0</span>));</span><br><span class=\"line\">        bp = PREV_BLKP(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class=\"line\"><span class=\"comment\"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">mm_malloc</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> asize; <span class=\"comment\">// 预留了头部和脚部的大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> extend_size;</span><br><span class=\"line\">    <span class=\"type\">char</span> *bp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 由于边界双字对齐的情况，最小的分配大小是DSIZE。头部4+尾部4+最小的内容为1-&gt;对齐边界后为16（CSAPP 课本练习题9.7）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= DSIZE)</span><br><span class=\"line\">        asize = <span class=\"number\">2</span> * DSIZE;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要分配的大小+头部+尾部</span></span><br><span class=\"line\">        asize = ALIGN(size+DSIZE); <span class=\"comment\">// ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class=\"line\">        <span class=\"comment\">// 课本：asize = DSIZE * ((size + (DSIZE) + (DSIZE - 1)) / DSIZE); </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用适配算法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((bp = find_fit(asize)) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        place(bp, asize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 找不到合适的匹配就扩展</span></span><br><span class=\"line\">    extend_size = MAX(asize, CHUNKSIZE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((bp = extend_heap(extend_size / WSIZE)) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    place(bp, asize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">mm_realloc</span><span class=\"params\">(<span class=\"type\">void</span> *ptr, <span class=\"type\">size_t</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *oldptr = ptr;</span><br><span class=\"line\">    <span class=\"type\">void</span> *newptr;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> copySize;</span><br><span class=\"line\"></span><br><span class=\"line\">    newptr = mm_malloc(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newptr == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt; copySize)</span><br><span class=\"line\">        copySize = size;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(newptr, oldptr, copySize);</span><br><span class=\"line\">    mm_free(oldptr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newptr;</span><br><span class=\"line\">    <span class=\"comment\">// return NULL;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 放置块（课本练习9.9）</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">place</span><span class=\"params\">(<span class=\"type\">void</span> *bp,<span class=\"type\">size_t</span> asize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> free_block_size = GET_SIZE(HDRP(bp));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 空闲块减去需要分配的大小，得到的碎片必须至少能容纳一个最小的可分配的块（2*DSIZE，也就是头部4+尾部4+最小的内容为1-&gt;对齐边界后为16）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((free_block_size - asize)&gt;=<span class=\"number\">2</span>*DSIZE)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 裁剪</span></span><br><span class=\"line\">        PUT(HDRP(bp),PACK(asize,<span class=\"number\">1</span>));</span><br><span class=\"line\">        PUT(FTRP(bp),PACK(asize,<span class=\"number\">1</span>));</span><br><span class=\"line\">        bp = NEXT_BLKP(bp);</span><br><span class=\"line\">        PUT(HDRP(bp),PACK(free_block_size-asize,<span class=\"number\">0</span>));</span><br><span class=\"line\">        PUT(FTRP(bp),PACK(free_block_size-asize,<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        PUT(HDRP(bp),PACK(free_block_size,<span class=\"number\">1</span>));</span><br><span class=\"line\">        PUT(FTRP(bp),PACK(free_block_size,<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/***** 适配算法  ******/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">find_fit</span><span class=\"params\">(<span class=\"type\">size_t</span> asize)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// asize 预留了头部和脚部的大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> NEXT_FIT</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> algo_next_fit(asize);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> algo_first_fit(asize);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次匹配算法（课本练习9.8）</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">algo_first_fit</span><span class=\"params\">(<span class=\"type\">size_t</span> asize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span>* bp =heap_listp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(GET_SIZE(HDRP(bp))&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize&lt;=GET_SIZE(HDRP(bp))))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bp = NEXT_BLKP(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下次适配算法</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> NEXT_FIT</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">void</span>* last_heap_listp = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 上次遍历的指针</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">algo_next_fit</span><span class=\"params\">(<span class=\"type\">size_t</span> asize)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">void</span>* bp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(last_heap_listp!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            bp =last_heap_listp;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            bp =heap_listp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(GET_SIZE(HDRP(bp))&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize&lt;=GET_SIZE(HDRP(bp))))&#123;</span><br><span class=\"line\">                last_heap_listp=bp;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            bp = NEXT_BLKP(bp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        last_heap_listp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从头再搜索一遍</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> algo_first_fit(asize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<p>这个实验，手打代码，bug 真多。真不能相信肉眼对照，只能信 CV 大法。</p>\n<p>限于教学安排和本人时间，CSAPP LABS 就更新到这里。其实这些实验要基本完成也并不困难，在操作的同时可以学到许多 C 语言的知识，积累编程经验，对后续理解计算机都有帮助。</p>\n<p>希望大家在知识的海洋里、在存储器山中收获满满！🥳🥳🥳</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《CSAPP》第三版第九章内容</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/672618494\">CSAPP课程Lab6 Malloc Lab - 知乎 (zhihu.com)</a></li>\n<li><a href=\"https://www.jianshu.com/p/6e59fde0e6c0\">CSAPP之详解MollocLab - 简书 (jianshu.com)</a></li>\n</ul>\n","raw":"---\ntitle: CSAPP LAB-5 手写动态存储分配器\ntags:\n  - CSAPP\n  - C\n  - malloc\n  - 内存分配\ncover: 'https://cdn.gallery.uuanqin.top/img/20240617204205.webp'\ncategories:\n  - CSAPP LABS\nabbrlink: 3eb1abc7\ndate: 2024-06-13 12:01:31\ndescription: 课本案例实践\ntop_img:\n---\n\n我也大概察觉到我们课程的实验是挑着 CSAPP 中原版实验去做的，并进行了简化，所以和网上的实验顺序不太一样，但内容是大致相同的。\n\n> [!notice] CSAPP LAB 实验\n>\n> - [[CSAPP LAB-1 位操作]]\n> - [[CSAPP LAB-2 二进制炸弹实验]]\n> - [[CSAPP LAB-3 缓冲区溢出炸弹]]\n> - [[CSAPP LAB-4 代码优化]]\n> - CSAPP LAB-5 手写动态存储分配器（本文）\n\n这次的实验**建议先看课本的第九章的 9.9 部分**（《CSAPP》第三版），理解其中的内容后进行实现。而且大部分代码课本上都有。不管你现在《CSAPP》学到哪一个部分，都可以直接看 9.9 章，不用担心没有铺垫内容。\n\n本文将介绍一个动态存储分配器的简单实现：隐式空闲链表 + 立即边界标记合并方式 + 首次匹配/下次匹配算法。更高级的实现可以看文末参考文章。\n\n> 这是我 CSAPP 课程的最后一个实验了，每次专挑👩助教验收，温柔贴心给分高😍！\n\n# 实验介绍和要求\n\n本实验需要用 c 语言实现一个动态的存储分配器，也就是你自己版本的 `malloc`，`free`，`realloc` 函数。\n\n解压文件：\n\n```sh\ntar xvf malloclab-handout.tar\n```\n\n我们需要修改的唯一文件是 `mm.c`，包含如下几个需要实现的函数：\n\n```c\n/*\nmm_init:在调用mm_malloc，mm_realloc或mm_free之前，调用mm_init进行初始化，正确返回0。\n*/\nint mm_init(void); \n\n/*\nmm_malloc：在堆区域分配指定大小的块，分配的空间，返回的指针应该是8字节对齐的\n*/\nvoid *mm_malloc(size_t size); \n\n/*\nmm_free:释放指针指向的block\n*/\nvoid mm_free(void *ptr); \n\n/*\n返回指向一个大小为size的区域指针，满足一下条件：\n* if ptr is NULL, the call is equivalent to mm_malloc(size); \n* if size is equal to zero, the call is equivalent to mm_free(ptr); \n* if ptr is not NULL：先按照size指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来ptr所指内存区域\n*/\nvoid *mm_realloc(void *ptr, size_t size);\n```\n\n记住哦，本次实验的任务要求之一是指针是 8 字节对齐的。\n\n我们可以调用实验提供给我们的函数，这些函数定义在 `memory.c` 中：\n\n- `void *mem_sbrk(int incr)`: Expands the heap by incr bytes, where incr is a positive non-zero integer and returns a generic pointer to the first byte of the newly allocated heap area.\n- `void *mem_heap_lo(void)`: Returns a generic pointer to the first byte in the heap.\n- `void *mem_heap_hi(void)`: Returns a generic pointer to the last byte in the heap.\n- `size_t mem_heapsize(void)`: Returns the current size of the heap in bytes.\n- `size_t mem_pagesize(void)`: Returns the system’s page size in bytes (4K onLinux systems).\n\n在这篇文章的实现方式中，只需要使用 `void *mem_sbrk(int incr)`，与标准实现不同的是，这个函数拒绝收缩堆的请求，也就是不能输入负数。`mem_sbrk` 的作用可以结合课本 9.9 章进行理解。\n\n验证我们的动态的存储分配器：\n\n- `mdriver.c`：负责测试 `mm.c` 的正确性,空间利用率和吞吐量\n- 执行 `make` 指令生成 `mdriver` 可执行文件\n-  `mdriver` 的使用：\n\t- `-f <tracefile>`:  `-f` 后添加一些 trace file 来测试我们实现的函数\n\t- `-V`: 打印出诊断信息。\n\t- 例如：`./mdriver -V  -f short1-bal.rep`\n\n一些编程规则：\n\n- 不能改变 `mm.c` 中函数接口\n- 不能直接调用任何内存管理的库函数和系统函数 `malloc`, `calloc`, `free`, `realloc`, `sbrk`, `brk`\n - 不能定义任何全局或者静态复合数据结构如 `arrays`, `structs`, `trees`，允许使用 `integers`, `floats` 以及 `pointers` 等简单数据类型\n- 返回的指针需要 8 字节对齐\n\n\n# 关键概念\n\n我把课本涉及到的关键概念模型简要介绍一下。\n\n本文介绍的是隐式空闲链表 + 立即边界标记合并方式 + 首次匹配/下次匹配算法。\n\n更多详细内容理解就看下一节的代码注释咯！\n\n## 隐式空闲链表的恒定形式\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240617202828.webp)\n\n一个正方形表示 4 字节（一个字），虚线表示双字对齐标志。正方形中的头部尾部标记为 `size/is_alloc`。\n\n## 标记边界合并\n\nKnuth 提出了边界标记技术，允许在常数时间内进行对前面的块的合并。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240617001201.webp)\n\n这种思想，是在每个块的结尾处添加一个脚部（footer，边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。\n\n考虑当分配器释放当前块时所有可能存在的情况：\n\n1) 前面的块和后面的块都是已分配的。\n2) 前面的块是已分配的，后面的块是空闲的。\n3) 前面的块是空闲的，而后面的块是已分配的。\n4) 前面的和后面的块都是空闲的。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240617001349.webp)\n\n## 匹配算法\n\n匹配算法：\n\n- 首次匹配（First Fit）。从头开始搜索空闲链表，选择第一个合适的空闲块。\n\t- 优点：趋向于将大的空闲块保留在链表的后面。\n\t- 缺点：它趋向于在靠近链表起始处留下小空闲块的「碎片」，增大了对较大块的搜索时间。\n- 下一次适配（Next Fit）。和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。由 Donald Knuth 提出。基于思想：如果上一次在某个空闲块里发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。\n\t- 优点：比首次适配运行起来明显快一些。\n\t- 缺点：内存利用率比首次匹配低。\n- 最佳适配（Best Fit）。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。\n\t- 优点：内存利用率较高。\n\t- 缺点：在简单空闲链表组织结构中（比如上面提到的隐式空闲链表），需要对堆进行彻底搜索。\n\n\n# `mm.c` 文件\n\n```c\n/*\n * mm-naive.c - The fastest, least memory-efficient malloc package.\n *\n * In this naive approach, a block is allocated by simply incrementing\n * the brk pointer.  A block is pure payload. There are no headers or\n * footers.  Blocks are never coalesced or reused. Realloc is\n * implemented directly using mm_malloc and mm_free.\n *\n * NOTE TO STUDENTS: Replace this header comment with your own header\n * comment that gives a high level description of your solution.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"mm.h\"\n#include \"memlib.h\"\n\n/*********************************************************\n * NOTE TO STUDENTS: Before you do anything else, please\n * provide your team information in the following struct.\n ********************************************************/\nteam_t team = {\n    /* Team name */\n    \"SA23xxxxxx\",\n    /* First member's full name */\n    \"uuanqin\",\n    /* First member's email address */\n    \"uuanqin@uuanqin.top\",\n    /* Second member's full name (leave blank if none) */\n    \"\",\n    /* Second member's email address (leave blank if none) */\n    \"\"};\n\n/*********  一些必要的宏 ***************/\n\n/* single word (4) or double word (8) alignment */\n#define ALIGNMENT 8\n\n/* rounds up to the nearest multiple of ALIGNMENT */\n#define ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~0x7)\n\n#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))\n\n\n// 基本常量\n#define WSIZE 4       // 字的大小（头部、脚部大小）\n#define DSIZE 8       // 双字大小\n#define CHUNKSIZE (1 << 12)  // 每次扩展堆时使用这个大小\n\n\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n\n#define PACK(size, is_alloc) ((size) | (is_alloc))   // 将大小和分配位打包组装\n\n// 读取/写入 指定位置的值\n#define GET(p) (*(unsigned int *)(p))                \n#define PUT(p, val) (*(unsigned int *)(p) = (val))\n\n// 获取头部的信息\n#define GET_SIZE(p) (GET(p) & ~0x7)\n#define GET_ALLOC(p) (GET(p) & 0x1)\n\n// 给定块的指针bp，获取其头部和脚部的指针（注意，bp指向有效载荷的第一个字节）\n#define HDRP(bp) ((char *)(bp) - WSIZE)\n#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) // 依赖与头部已分配好大小\n\n// 给定块的指针bp，计算前后块的指针（注意，bp指向有效载荷的第一个字节）\n#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))\n#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))\n\n// 堆的起始位置\nstatic void *heap_listp; // 总是指向序言块，我们可以小小优化为指向下一个块\n\n// 函数注册\nstatic void *coalesce(void *bp);\nstatic void *extend_heap(size_t words);\nstatic void *find_fit(size_t asize);\nstatic void place(void *bp,size_t asize);\n\n// 是否启动下次适配\n#define NEXT_FIT\n\nstatic void *algo_first_fit(size_t asize);\n\n#ifdef NEXT_FIT\n    static void *algo_next_fit(size_t asize);\n#endif\n\n\n/*\n * mm_init - initialize the malloc package.\n */\nint mm_init(void)\n{\n    // 创建一个空的空闲链表\n    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)\n    {\n        return -1;\n    }\n    // 因为序言块+结尾块只需要三个字节。我们又必须保证堆的开始位置是双字对齐的。\n    // PUT(heap_listp, 0);  // 课本中加了这一条，主要是为了占位，没有什么含义。\n    PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); // 序言块头部\n    PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); // 序言块脚部\n    PUT(heap_listp + (3 * WSIZE), PACK(0, 1));     // 结尾块头部\n    heap_listp += (2 * WSIZE);                     // 移动堆指针到序言块中间\n\n    // 使用空闲块扩展堆\n    if (extend_heap(CHUNKSIZE / WSIZE) == NULL)\n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void *extend_heap(size_t words)\n{\n    char *bp;\n    size_t size;\n    size = (words % 2) ? (words + 1) * WSIZE : words * WSIZE; // 保证size是奇数个字节，因为有一个字节用来放空闲块的头部\n    if ((long)(bp = mem_sbrk(size)) == -1)\n    {\n        return NULL;\n    }\n    PUT(HDRP(bp), PACK(size, 0));           // 空闲块的头部\n    PUT(FTRP(bp), PACK(size, 0));           // 空闲块的尾部\n    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));  // 新的结尾块\n\n    return coalesce(bp); // 合并块\n}\n\n/*\n * mm_free - Freeing a block does nothing.\n */\nvoid mm_free(void *ptr)\n{\n    size_t size = GET_SIZE(HDRP(ptr));\n    // 对当前块的标记位进行改变\n    PUT(HDRP(ptr), PACK(size, 0));\n    PUT(FTRP(ptr), PACK(size, 0));\n    coalesce(ptr);\n}\n\n// 合并块\nstatic void *coalesce(void *bp)\n{\n    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));  // 检查块前面是否被分配\n    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));  // 检查块后面是否被分配\n    size_t size = GET_SIZE(HDRP(bp));\n    // 因为序言块和结尾块的设计，使得边界情况的检查变得简单\n    if (prev_alloc && next_alloc)\n    {\n        return bp;\n    }\n    else if (prev_alloc && !next_alloc)\n    {\n        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));\n        PUT(HDRP(bp), PACK(size, 0));\n        PUT(FTRP(bp), PACK(size, 0));\n    }\n    else if (!prev_alloc && next_alloc)\n    {\n        size += GET_SIZE(HDRP(PREV_BLKP(bp)));\n        PUT(FTRP(bp), PACK(size, 0));\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\n        bp = PREV_BLKP(bp);\n    }\n    else\n    {\n        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\n        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));\n        bp = PREV_BLKP(bp);\n    }\n    return bp;\n}\n\n\n\n/*\n * mm_malloc - Allocate a block by incrementing the brk pointer.\n *     Always allocate a block whose size is a multiple of the alignment.\n */\nvoid *mm_malloc(size_t size)\n{\n    size_t asize; // 预留了头部和脚部的大小\n    size_t extend_size;\n    char *bp;\n    if (size <= 0)\n        return NULL;\n\n    // 由于边界双字对齐的情况，最小的分配大小是DSIZE。头部4+尾部4+最小的内容为1->对齐边界后为16（CSAPP 课本练习题9.7）\n    if (size <= DSIZE)\n        asize = 2 * DSIZE;\n    else\n        // 需要分配的大小+头部+尾部\n        asize = ALIGN(size+DSIZE); // ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~0x7)\n        // 课本：asize = DSIZE * ((size + (DSIZE) + (DSIZE - 1)) / DSIZE); \n\n    // 使用适配算法\n    if ((bp = find_fit(asize)) != NULL)\n    {\n        place(bp, asize);\n        return bp;\n    }\n\n    // 找不到合适的匹配就扩展\n    extend_size = MAX(asize, CHUNKSIZE);\n    if ((bp = extend_heap(extend_size / WSIZE)) == NULL)\n    {\n        return NULL;\n    }\n    place(bp, asize);\n    return bp;\n}\n\n\n\n/*\n * mm_realloc - Implemented simply in terms of mm_malloc and mm_free\n */\nvoid *mm_realloc(void *ptr, size_t size)\n{\n    void *oldptr = ptr;\n    void *newptr;\n    size_t copySize;\n\n    newptr = mm_malloc(size);\n    if (newptr == NULL)\n        return NULL;\n    if (ptr == NULL)\n    {\n        return newptr;\n    }\n\n    copySize = GET_SIZE(HDRP(oldptr));\n    if (size < copySize)\n        copySize = size;\n    memcpy(newptr, oldptr, copySize);\n    mm_free(oldptr);\n    return newptr;\n    // return NULL;\n}\n\n// 放置块（课本练习9.9）\nstatic void place(void *bp,size_t asize){\n    size_t free_block_size = GET_SIZE(HDRP(bp));\n\n    // 空闲块减去需要分配的大小，得到的碎片必须至少能容纳一个最小的可分配的块（2*DSIZE，也就是头部4+尾部4+最小的内容为1->对齐边界后为16）\n    if((free_block_size - asize)>=2*DSIZE){\n        // 裁剪\n        PUT(HDRP(bp),PACK(asize,1));\n        PUT(FTRP(bp),PACK(asize,1));\n        bp = NEXT_BLKP(bp);\n        PUT(HDRP(bp),PACK(free_block_size-asize,0));\n        PUT(FTRP(bp),PACK(free_block_size-asize,0));\n    }else{\n        PUT(HDRP(bp),PACK(free_block_size,1));\n        PUT(FTRP(bp),PACK(free_block_size,1));\n    }\n\n}\n\n/***** 适配算法  ******/\n\nstatic void *find_fit(size_t asize){\n    // asize 预留了头部和脚部的大小\n#ifdef NEXT_FIT\n    return algo_next_fit(asize);\n#else\n    return algo_first_fit(asize);\n#endif\n}\n\n// 首次匹配算法（课本练习9.8）\nstatic void *algo_first_fit(size_t asize){\n    void* bp =heap_listp;\n    while(GET_SIZE(HDRP(bp))>0){\n        if(!GET_ALLOC(HDRP(bp)) && (asize<=GET_SIZE(HDRP(bp)))){\n            return bp;\n        }\n        bp = NEXT_BLKP(bp);\n    }\n    return NULL;\n}\n\n// 下次适配算法\n#ifdef NEXT_FIT\n    static void* last_heap_listp = NULL; // 上次遍历的指针\n    static void *algo_next_fit(size_t asize){\n        void* bp;\n        if(last_heap_listp!=NULL){\n            bp =last_heap_listp;\n        }else{\n            bp =heap_listp;\n        }\n        \n        while(GET_SIZE(HDRP(bp))>0){\n            if(!GET_ALLOC(HDRP(bp)) && (asize<=GET_SIZE(HDRP(bp)))){\n                last_heap_listp=bp;\n                return bp;\n            }\n            bp = NEXT_BLKP(bp);\n        }\n        last_heap_listp = NULL;\n\n        // 从头再搜索一遍\n        return algo_first_fit(asize);\n    }\n#endif\n\n```\n\n# 后记\n\n这个实验，手打代码，bug 真多。真不能相信肉眼对照，只能信 CV 大法。\n\n限于教学安排和本人时间，CSAPP LABS 就更新到这里。其实这些实验要基本完成也并不困难，在操作的同时可以学到许多 C 语言的知识，积累编程经验，对后续理解计算机都有帮助。\n\n希望大家在知识的海洋里、在存储器山中收获满满！🥳🥳🥳\n\n# 本文参考\n- 《CSAPP》第三版第九章内容\n- [CSAPP课程Lab6 Malloc Lab - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/672618494)\n- [CSAPP之详解MollocLab - 简书 (jianshu.com)](https://www.jianshu.com/p/6e59fde0e6c0)\n","categories":[{"name":"CSAPP LABS","api":"api/categories/CSAPP-LABS.json"}],"tags":[{"name":"CSAPP","api":"api/tags/CSAPP.json"},{"name":"C","api":"api/tags/C.json"},{"name":"malloc","api":"api/tags/malloc.json"},{"name":"内存分配","api":"api/tags/内存分配.json"}]},"api":"api/posts/p/3eb1abc7.json"}