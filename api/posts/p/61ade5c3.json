{"data":{"title":"迭代器模式：游标","slug":"高质量代码及设计模式/迭代器模式：游标","description":"规范化的方式遍历集合元素","date":"2025-08-17T14:07:34.000Z","updated":"2026-02-01T08:42:41.702Z","language":"zh-CN","comments":true,"url":"p/61ade5c3/","cover":"https://cdn.gallery.uuanqin.top/img/202601201955312.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727230456.webp\" alt=\"image.png\" width=\"200px\" /></p>\n<p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern），用于遍历集合对象。集合对象，又叫容器或聚合对象，实际上就是包含一组对象的对象，如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>\n<p>我们在 Java 中写一个 for 循环是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">\tSystem.out.println(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>i</code> 的作用抽象化、通用化后形成的模式称为迭代器模式。</p>\n<p>登场角色：</p>\n<ul>\n<li><code>Iterator</code>（迭代器）：负责定义按这个顺序逐个遍历元素的接口（API）。比如定义了 <code>hasNext</code> 和 <code>next</code> 两个方法。</li>\n<li><code>Concretelterator</code>（具体的迭代器）：负责实现 <code>Iterator</code> 角色所定义的接口（API）。该角色包含了遍历集合所必须的信息。</li>\n<li><code>Aggregate</code>（集合）：负责定义创建 <code>Iterator</code> 角色的接口（API）。这个接口（API）是一个方法，会创建出「按顺序访问保存在我内部元素的人」。</li>\n<li><code>ConcreteAggregate</code>（具体的集合）：负责实现 <code>Aggregate</code> 角色所定义的接口（API）。他会创建出具体的 <code>Iterator</code> 角色，即 <code>ConcreteIterator</code> 角色。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508172152370.webp\" alt=\"image.png\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Aggregate接口：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Aggregate</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Iterator <span class=\"title function_\">Iterator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Iterator接口：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterator</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Object <span class=\"title function_\">next</span><span class=\"params\">()</span>;<span class=\"comment\">// 返回集合中的一个元素。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>Iterator</code> 接口方法解析：</p>\n<ul>\n<li><code>hasNext</code> 方法理解成：确认接下来是否可以调用 <code>next</code> 方法</li>\n<li><code>next</code> 方法指的是「返回当前元素，并指向下一个元素」。为了下次调用 <code>next</code> 能正确返回下一个元素，一般在 <code>next</code> 中隐含实现了将迭代器移动到下一个元素的逻辑。由于这里接口中的定义，使用 <code>next</code> 方法记得强制类型转换。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311732956.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p>从上面的 UML 图我们发现，迭代器本身需要聚合一个 <code>Aggregate</code> 容器。为了封装迭代器的创建细节，<code>ConcreteAggregate</code> 的创建迭代器 <code>Iterator()</code> 中会把自身作为参数，作为迭代器的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteAggregate</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Aggregate</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Iterator <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteIterator</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用迭代器模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ConcreteAggregate</span> <span class=\"variable\">foos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcreAggregate</span>(<span class=\"comment\">/* params */</span>);<span class=\"comment\">// 创建一个集合</span></span><br><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">it</span> <span class=\"operator\">=</span> foos.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">Foo</span> <span class=\"variable\">foo</span> <span class=\"operator\">=</span> (Foo) it.next(); <span class=\"comment\">// 记得强制类型转换</span></span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>while</code> 循环中不依赖于聚合类的具体实现。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子</div>\n</div>\n<div class=\"callout-content\"><p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727230743.webp\" alt=\"image.png\" width=\"425px\" /><br />\n<code>BookShelfIterator</code> 类知道 <code>BookShelf</code> 是如何实现的。也就是说，如果 <code>BookShelf</code> 的实现发生了改变，即 <code>getBookAt</code> 方法这个接口（API）发生变化时，我们必须修改 <code>BookshelfIterator</code> 类。正如 <code>Aggregate</code> 和 <code>Iterator</code> 这两个接口是对应的一样，<code>concreteAggregate</code> 和 <code>concreteIterator</code> 这两个类也是对应的。</p>\n</div></div><table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单一职责原则。通过将体积庞大的遍历算法代码抽取为独立的类，可对客户端代码和集合进行整理。</td>\n<td>如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正。</td>\n</tr>\n<tr>\n<td>开闭原则。可实现新型的集合和迭代器并将其传递给现有代码，无需修改现有代码。</td>\n<td>对于某些特殊集合，使用迭代器可能比直接遍历的效率低。</td>\n</tr>\n<tr>\n<td>可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。</td>\n<td rowspan=\"2\"></td>\n</tr>\n<tr>\n<td>可以暂停遍历并在需要时继续。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"引入迭代器的目的\"><a class=\"markdownIt-Anchor\" href=\"#引入迭代器的目的\"></a> 引入迭代器的目的</h1>\n<p>引入迭代器这一复杂的设计模式在于可以将遍历和实现分离开，提高代码的可复用性。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311732990.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<h2 id=\"应对复杂性\"><a class=\"markdownIt-Anchor\" href=\"#应对复杂性\"></a> 应对复杂性</h2>\n<p>对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/eca34904/\"><span class=\"bilink-pop-up\">站内文章</span>前中后序、按层遍历</a>，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。</p>\n<p>应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义 <code>DFSIterator</code>、<code>BFSIterator</code> 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。</p>\n<h2 id=\"游标信息存储\"><a class=\"markdownIt-Anchor\" href=\"#游标信息存储\"></a> 游标信息存储</h2>\n<p>将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p>\n<h2 id=\"易于切换迭代器\"><a class=\"markdownIt-Anchor\" href=\"#易于切换迭代器\"></a> 易于切换迭代器</h2>\n<p>容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 <code>LinkedIterator</code> 切换为 <code>ReversedLinkedIterator</code> 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</p>\n<h1 id=\"拓展思路与相关设计模式\"><a class=\"markdownIt-Anchor\" href=\"#拓展思路与相关设计模式\"></a> 拓展思路与相关设计模式</h1>\n<p>拓展思路：</p>\n<ul>\n<li>难以理解抽象类和接口的人常常使用 <code>ConcreteAggregate</code> 角色和 <code>ConcreteIterator</code> 角色编程，而不使用 <code>Aggregate</code> 接口和 <code>Iterator</code> 接口，他们总想用具体的类来解决所有的问题。但是如果只使用具体的类来解决问题，很容易导致类之间的强耦合，这些类也难以作为组件被再次利用。为了弱化类之间的耦合，进而使得类更加容易作为组件被再次利用，我们需要引入抽象类和接口。（面向抽象编程）</li>\n<li>「将遍历功能置于 <code>Aggregate</code> 角色之外」是 <code>Iterator</code> 模式的一个特征。根据这个特征，可以针对一个 <code>ConcreteAggregate</code> 角色编写多个 <code>ConcreteIterator</code> 角色。</li>\n<li>自己写多种迭代器，比如从最后向前遍历，前后遍历，跳跃式遍历等。</li>\n</ul>\n<p>相关的设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/b6ca7c41/\"><span class=\"bilink-pop-up\">站内文章</span>访问者模式</a>：迭代器模式是从集合中一个一个取出元素进行遍历，但是并没有在 <code>Iterator</code> 接口中声明对取出的元素进行何种处理。访问者模式则是在遍历元素集合的过程中，对元素进行相同的处理。钦注：在课本的例子中，<code>ConcreteVisitor</code> 角色中 <code>visit(Directory directory)</code> 方法使用了迭代器（<code>ArrayList</code> 迭代器）。在遍历集合的过程中对元素进行固定的处理是常有的需求。访问者模式正是为了应对这种需求而出现的。在访问元素集合的过程中对元素进行相同的处理，这种模式就是访问者模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>组合模式</a>：组合模式是具有递归结构的模式，在其中使用 <code>Iterator</code> 模式比较困难。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"bilink-pop-up\">站内文章</span>工厂（方法）模式</a>：在 <code>iterator</code> 方法中生成 <code>Iterator</code> 的实例时可能会使用工厂方法模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>备忘录模式</a>：可以同时使用备忘录模式和迭代器来获取当前迭代器的状态，并且在需要的时候进行回滚。</li>\n</ul>\n<h1 id=\"java-中的迭代器\"><a class=\"markdownIt-Anchor\" href=\"#java-中的迭代器\"></a> Java 中的迭代器</h1>\n<p>很多编程语言都将迭代器作为一个基础的类库，直接提供，比如 Java。</p>\n<p>Java 中遍历集合的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, len = strings.size(); i &lt; len; i++) &#123;</span><br><span class=\"line\">    System.out.println(strings.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foreach（实际为语法糖，底层基于迭代器实现，即下面的 Iterator 方法）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String <span class=\"keyword\">var</span> : strings) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"keyword\">var</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Iterator</span></span><br><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> strings.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.println(iterator.next());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c5c0eb2/\"><span class=\"bilink-pop-up\">站内文章</span>函数式编程与 Java 中的 Lambda 表达式</a> 遍历的方法，详看下面的 <code>Iterable</code> 接口中的 <code>forEach</code> 的默认实现。</p>\n<p>Java 中有垃圾回收（GC），不需要 <code>deleteIterator</code> 方法。</p>\n<p>Java 迭代器是一种单向遍历机制，即只能从前往后遍历集合中的元素，不能往回遍历。</p>\n<p>使用迭代器遍历集合时，如果在遍历过程中对集合进行了修改（例如添加或删除元素），可能会导致 <code>ConcurrentModificationException</code> 异常，为了避免这个问题，可以使用迭代器自身的 <code>remove()</code> 方法进行删除操作。</p>\n<h2 id=\"iterable-接口\"><a class=\"markdownIt-Anchor\" href=\"#iterable-接口\"></a> Iterable 接口</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240728150603.webp\" alt=\"image.png\" /></p>\n<p>实现 <code>Iterable</code> 接口可以为集合类提供 for-each 循环的支持。源代码中，<code>Iterable</code> 接口定义了三个方法，其中两个提供了默认实现，只有 <code>iterator()</code> 是要求实现类必须实现的方法。那么当某个类实现了 <code>Iterable</code> 接口就可以使用 foreach 进行迭代。同时 <code>Iterable</code> 中又封装了 <code>Iterator</code> 接口，那么这个类也可以使用 <code>Iterator</code> 迭代器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java Iterable 接口源代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    Iterator&lt;T&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (T t : <span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            action.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">default</span> Spliterator&lt;T&gt; <span class=\"title function_\">spliterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"iterator-接口\"><a class=\"markdownIt-Anchor\" href=\"#iterator-接口\"></a> Iterator 接口</h2>\n<p><code>Iterator</code> 主要是为了方便遍历集合中的所有元素（相当于是定义了遍历元素的范式）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java Iterator 接口源代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    E <span class=\"title function_\">next</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>(<span class=\"string\">&quot;remove&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">forEachRemaining</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> E&gt; action)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (hasNext())</span><br><span class=\"line\">            action.accept(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"遍历集合的同时不能删改集合元素\"><a class=\"markdownIt-Anchor\" href=\"#遍历集合的同时不能删改集合元素\"></a> 遍历集合的同时不能删改集合元素</h1>\n<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历。这种行为称为结果不可预期行为或者未决行为。</p>\n<h2 id=\"应对遍历时改变集合所导致的未决行为\"><a class=\"markdownIt-Anchor\" href=\"#应对遍历时改变集合所导致的未决行为\"></a> 应对遍历时改变集合所导致的未决行为</h2>\n<p>「不可预期」比直接出错更加可怕。为了避免出现不可预期的结果，有两种直接的解决方案：</p>\n<ul>\n<li>遍历的时候不允许增删元素</li>\n<li>增删元素之后让遍历报错。Java 语言采用了这种解决方案。</li>\n</ul>\n<p>Java 的 <code>ArrayList</code> 中定义一个成员变量 <code>modCount</code>，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 <code>modCount</code> 加 1。当通过调用集合上的 <code>iterator()</code> 函数来创建迭代器的时候，我们把 <code>modCount</code> 值传递给迭代器的 <code>expectedModCount</code> 成员变量，之后每次调用迭代器上的 <code>hasNext()</code>、<code>next()</code>、<code>currentItem()</code> 函数，我们都会检查集合上的 <code>modCount</code> 是否等于 <code>expectedModCount</code>，也就是看，在创建完迭代器之后，<code>modCount</code> 是否改变过。</p>\n<h2 id=\"在遍历的同时安全地删除集合元素\"><a class=\"markdownIt-Anchor\" href=\"#在遍历的同时安全地删除集合元素\"></a> 在遍历的同时安全地删除集合元素</h2>\n<p>像 Java 语言 <code>ArrayList</code>，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 <code>remove()</code> 方法，能够在遍历集合的同时，安全地删除集合中的元素。但是作用有限，它只能删除游标指向的前一个元素，而且一个 <code>next()</code> 函数之后，只能跟着最多一个 <code>remove()</code> 操作，多次调用 <code>remove()</code> 操作会报错。</p>\n<blockquote>\n<p>Java <code>ArrayList</code> 并没有提供遍历过程中添加元素的方法。</p>\n</blockquote>\n<p>部分源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Itr</span>();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cursor;       <span class=\"comment\">// index of next element to return</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">lastRet</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>; <span class=\"comment\">// index of last element returned; -1 if no such</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">expectedModCount</span> <span class=\"operator\">=</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    Itr() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span> &#123;<span class=\"keyword\">return</span> cursor != size;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      checkForComodification();</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> cursor;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt;= size)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchElementException</span>();</span><br><span class=\"line\">      Object[] elementData = ArrayList.<span class=\"built_in\">this</span>.elementData;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt;= elementData.length)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentModificationException</span>();</span><br><span class=\"line\">      cursor = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (E) elementData[lastRet = i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>();</span><br><span class=\"line\">      checkForComodification();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ArrayList.<span class=\"built_in\">this</span>.remove(lastRet);</span><br><span class=\"line\">        cursor = lastRet;</span><br><span class=\"line\">        lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentModificationException</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面的代码实现中，迭代器类新增了一个 <code>lastRet</code> 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 <code>lastRet</code> 值，来保证不会因为删除元素而导致某个元素遍历不到。</p>\n<h2 id=\"实现一个支持快照功能的-iterator\"><a class=\"markdownIt-Anchor\" href=\"#实现一个支持快照功能的-iterator\"></a> 实现一个支持「快照」功能的 <code>iterator</code></h2>\n<blockquote>\n<p>本节仅供发散思考，当作一个小小的思维训练。</p>\n</blockquote>\n<p>所谓「快照」，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p>\n<p>一种简单的解决方案为在迭代器类中定义一个成员变量 <code>snapshot</code> 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"bilink-pop-up\">站内文章</span>浅拷贝</a>，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p>\n<p>第二种解决方案为，我们可以在容器中为每个元素保存两个时间戳，一个是添加时间戳 <code>addTimestamp</code>，一个是删除时间戳 <code>delTimestamp</code>。当元素被加入到集合中的时候，我们将 <code>addTimestamp</code> 设置为当前时间，将 <code>delTimestamp</code> 设置成最大长整型值（<code>Long.MAX_VALUE</code>）。当元素被删除时，我们将 <code>delTimestamp</code> 更新为当前时间，表示已经被删除。注意，这里只是标记删除，而非真正将它从容器中删除。</p>\n<p>同时，每个迭代器也保存一个迭代器创建时间戳 <code>snapshotTimestamp</code>，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 <code>addTimestamp&lt;snapshotTimestamp&lt;delTimestamp</code> 的元素，才是属于这个迭代器的快照。</p>\n<p>如果元素的 <code>addTimestamp&gt;snapshotTimestamp</code>，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 <code>delTimestamp&lt;snapshotTimestamp</code>，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>\n<p>这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。注意，这里我们没有考虑 <code>ArrayList</code> 的扩容问题。</p>\n<p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层依赖数组这种数据结构，原本可以支持快速的随机访问，在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间复杂度内获取下标为 <code>i</code> 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。</p>\n<p>解决随机访问的方法也不难，我们可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。</p>\n<h1 id=\"本文-plantuml-归档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-归档\"></a> 本文 PlantUML 归档</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Aggregate&#123;</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; iterator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Iterator&#123;</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; hasNext</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; next</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ConcreteAggregate&#123;</span><br><span class=\"line\">\t&#123;method&#125; iterator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ConcreteIterator&#123;</span><br><span class=\"line\">\taggregate</span><br><span class=\"line\">\t&#123;method&#125; hasNext</span><br><span class=\"line\">\t&#123;method&#125; next</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Aggregate -&gt; Iterator : Creates</span><br><span class=\"line\">Aggregate &lt;|.. ConcreteAggregate</span><br><span class=\"line\">ConcreteAggregate -o ConcreteIterator</span><br><span class=\"line\">Iterator &lt;|.. ConcreteIterator</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》第 1 章 Iterator 模式</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://www.runoob.com/java/java-iterator.html\">Java Iterator（迭代器） | 菜鸟教程 (runoob.com)</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43848614/article/details/114601737\">【Java】Iterable接口的使用-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_45663027/article/details/134135420\">Java集合系列 Iterable、Iterator这俩兄弟细致解读（超通俗易懂）_java iterable-CSDN博客</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/iterator\">迭代器设计模式</a></li>\n</ul>\n","raw":"---\ntitle: 迭代器模式：游标\ntags:\n  - Java\n  - 设计模式\ncover: https://cdn.gallery.uuanqin.top/img/202601201955312.webp\ndescription: 规范化的方式遍历集合元素\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: 61ade5c3\nsummary: >-\n  迭代器模式，也称游标模式，是一种设计模式，用于遍历集合对象。它将集合的遍历操作与集合本身分离，提高了代码的可复用性和灵活性。迭代器模式定义了Iterator接口，包含hasNext和next方法，以及Aggregate接口，用于创建迭代器。ConcreteAggregate类实现了Aggregate接口，负责创建具体的迭代器ConcreteIterator。通过这种方式，可以对同一集合进行多种不同的遍历，而无需修改集合类或迭代器类的代码，符合开闭原则。迭代器的引入解决了复杂数据结构的遍历问题，将遍历逻辑与容器类分离，降低了开发和维护成本。此外，迭代器模式还支持多种遍历方式，如深度优先搜索和广度优先搜索，以及自定义遍历算法。在Java中，迭代器作为集合类的内置组件，提供了for-each循环和Iterator接口的支持。迭代器模式通过封装遍历细节，使得客户端代码可以与具体实现解耦，便于扩展和维护。\ndate: 2025-08-17 22:07:34\ntop_img:\n---\n\n![image.png|200](https://cdn.gallery.uuanqin.top/img/20240727230456.webp)\n\n迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern），用于遍历集合对象。集合对象，又叫容器或聚合对象，实际上就是包含一组对象的对象，如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。\n\n我们在 Java 中写一个 for 循环是这样的：\n\n```java\nfor(int i=0;i<arr.length;i++){\n\tSystem.out.println(arr[i]);\n}\n```\n\n把 `i` 的作用抽象化、通用化后形成的模式称为迭代器模式。\n\n登场角色：\n\n- `Iterator`（迭代器）：负责定义按这个顺序逐个遍历元素的接口（API）。比如定义了 `hasNext` 和 `next` 两个方法。\n- `Concretelterator`（具体的迭代器）：负责实现 `Iterator` 角色所定义的接口（API）。该角色包含了遍历集合所必须的信息。\n- `Aggregate`（集合）：负责定义创建 `Iterator` 角色的接口（API）。这个接口（API）是一个方法，会创建出「按顺序访问保存在我内部元素的人」。\n- `ConcreteAggregate`（具体的集合）：负责实现 `Aggregate` 角色所定义的接口（API）。他会创建出具体的 `Iterator` 角色，即 `ConcreteIterator` 角色。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202508172152370.webp)\n\n```java\n// Aggregate接口：\npublic interface Aggregate{\n\tpublic Iterator Iterator();\n}\n\n// Iterator接口：\npublic interface Iterator{\n\tpublic boolean hasNext();\n\tpublic Object next();// 返回集合中的一个元素。\n}\n\n```\n\n`Iterator` 接口方法解析：\n\n- `hasNext` 方法理解成：确认接下来是否可以调用 `next` 方法\n- `next` 方法指的是「返回当前元素，并指向下一个元素」。为了下次调用 `next` 能正确返回下一个元素，一般在 `next` 中隐含实现了将迭代器移动到下一个元素的逻辑。由于这里接口中的定义，使用 `next` 方法记得强制类型转换。\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202508311732956.webp)\n\n从上面的 UML 图我们发现，迭代器本身需要聚合一个 `Aggregate` 容器。为了封装迭代器的创建细节，`ConcreteAggregate` 的创建迭代器 `Iterator()` 中会把自身作为参数，作为迭代器的构造函数：\n\n```java\npublic class ConcreteAggregate implements Aggregate {\n  public Iterator iterator() {\n    return new ConcreteIterator(this);\n  }\n  //...省略其他代码\n}\n```\n\n使用迭代器模式：\n\n```java\nConcreteAggregate foos = new ConcreAggregate(/* params */);// 创建一个集合\nIterator it = foos.iterator();\nwhile(it.hasNext()){\n    Foo foo = (Foo) it.next(); // 记得强制类型转换\n   // do something\n}\n```\n\n上面的 `while` 循环中不依赖于聚合类的具体实现。\n\n> [!example] 例子\n> ![image.png|425](https://cdn.gallery.uuanqin.top/img/20240727230743.webp)\n> `BookShelfIterator` 类知道 `BookShelf` 是如何实现的。也就是说，如果 `BookShelf` 的实现发生了改变，即 `getBookAt` 方法这个接口（API）发生变化时，我们必须修改 `BookshelfIterator` 类。正如 `Aggregate` 和 `Iterator` 这两个接口是对应的一样，`concreteAggregate` 和 `concreteIterator` 这两个类也是对应的。\n\n| 优点                                           | 缺点                              |\n| -------------------------------------------- | ------------------------------- |\n| 单一职责原则。通过将体积庞大的遍历算法代码抽取为独立的类，可对客户端代码和集合进行整理。 | 如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正。 |\n| 开闭原则。可实现新型的集合和迭代器并将其传递给现有代码，无需修改现有代码。        | 对于某些特殊集合，使用迭代器可能比直接遍历的效率低。      |\n| 可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。             |                                 |\n| 可以暂停遍历并在需要时继续。                               |                                 |\n\n# 引入迭代器的目的\n\n引入迭代器这一复杂的设计模式在于可以将遍历和实现分离开，提高代码的可复用性。\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202508311732990.webp)\n\n## 应对复杂性\n\n对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有 [[有谁还不会二叉树的遍历？|前中后序、按层遍历]]，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。\n\n应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义 `DFSIterator`、`BFSIterator` 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。\n\n## 游标信息存储\n\n将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。\n\n## 易于切换迭代器\n\n容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 `LinkedIterator` 切换为 `ReversedLinkedIterator` 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。\n\n# 拓展思路与相关设计模式\n\n拓展思路：\n\n- 难以理解抽象类和接口的人常常使用 `ConcreteAggregate` 角色和 `ConcreteIterator` 角色编程，而不使用 `Aggregate` 接口和 `Iterator` 接口，他们总想用具体的类来解决所有的问题。但是如果只使用具体的类来解决问题，很容易导致类之间的强耦合，这些类也难以作为组件被再次利用。为了弱化类之间的耦合，进而使得类更加容易作为组件被再次利用，我们需要引入抽象类和接口。（面向抽象编程）\n- 「将遍历功能置于 `Aggregate` 角色之外」是 `Iterator` 模式的一个特征。根据这个特征，可以针对一个 `ConcreteAggregate` 角色编写多个 `ConcreteIterator` 角色。\n- 自己写多种迭代器，比如从最后向前遍历，前后遍历，跳跃式遍历等。\n\n相关的设计模式：\n\n- [[访问者模式填补单分派语言的缺陷|访问者模式]]：迭代器模式是从集合中一个一个取出元素进行遍历，但是并没有在 `Iterator` 接口中声明对取出的元素进行何种处理。访问者模式则是在遍历元素集合的过程中，对元素进行相同的处理。钦注：在课本的例子中，`ConcreteVisitor` 角色中 `visit(Directory directory)` 方法使用了迭代器（`ArrayList` 迭代器）。在遍历集合的过程中对元素进行固定的处理是常有的需求。访问者模式正是为了应对这种需求而出现的。在访问元素集合的过程中对元素进行相同的处理，这种模式就是访问者模式。\n- [[组合模式：树形结构|组合模式]]：组合模式是具有递归结构的模式，在其中使用 `Iterator` 模式比较困难。\n- [[类的工厂|工厂（方法）模式]]：在 `iterator` 方法中生成 `Iterator` 的实例时可能会使用工厂方法模式。\n- [[备忘录模式：拍下照片|备忘录模式]]：可以同时使用备忘录模式和迭代器来获取当前迭代器的状态，并且在需要的时候进行回滚。\n\n# Java 中的迭代器\n\n很多编程语言都将迭代器作为一个基础的类库，直接提供，比如 Java。\n\nJava 中遍历集合的方式：\n\n```java\n// for\nfor (int i = 0, len = strings.size(); i < len; i++) {\n    System.out.println(strings.get(i));\n}\n\n// foreach（实际为语法糖，底层基于迭代器实现，即下面的 Iterator 方法）\nfor (String var : strings) {\n    System.out.println(var);\n}\n\n// Iterator\nIterator iterator = strings.iterator();\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n```\n\n此外还有使用 [[函数式编程与 Java 中的 Lambda 表达式|函数式编程与 Java 中的 Lambda 表达式]] 遍历的方法，详看下面的 `Iterable` 接口中的 `forEach` 的默认实现。\n\nJava 中有垃圾回收（GC），不需要 `deleteIterator` 方法。\n\nJava 迭代器是一种单向遍历机制，即只能从前往后遍历集合中的元素，不能往回遍历。\n\n使用迭代器遍历集合时，如果在遍历过程中对集合进行了修改（例如添加或删除元素），可能会导致 `ConcurrentModificationException` 异常，为了避免这个问题，可以使用迭代器自身的 `remove()` 方法进行删除操作。\n\n## Iterable 接口\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240728150603.webp)\n\n实现 `Iterable` 接口可以为集合类提供 for-each 循环的支持。源代码中，`Iterable` 接口定义了三个方法，其中两个提供了默认实现，只有 `iterator()` 是要求实现类必须实现的方法。那么当某个类实现了 `Iterable` 接口就可以使用 foreach 进行迭代。同时 `Iterable` 中又封装了 `Iterator` 接口，那么这个类也可以使用 `Iterator` 迭代器。\n\n```java\n// Java Iterable 接口源代码\npublic interface Iterable<T> {\n    Iterator<T> iterator();\n\n    default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n    \n    default Spliterator<T> spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n```\n\n## Iterator 接口\n\n`Iterator` 主要是为了方便遍历集合中的所有元素（相当于是定义了遍历元素的范式）。\n\n```java\n// Java Iterator 接口源代码\npublic interface Iterator<E> {\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n# 遍历集合的同时不能删改集合元素\n\n在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历。这种行为称为结果不可预期行为或者未决行为。\n\n## 应对遍历时改变集合所导致的未决行为\n\n「不可预期」比直接出错更加可怕。为了避免出现不可预期的结果，有两种直接的解决方案：\n\n- 遍历的时候不允许增删元素\n- 增删元素之后让遍历报错。Java 语言采用了这种解决方案。\n\nJava 的 `ArrayList` 中定义一个成员变量 `modCount`，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 `modCount` 加 1。当通过调用集合上的 `iterator()` 函数来创建迭代器的时候，我们把 `modCount` 值传递给迭代器的 `expectedModCount` 成员变量，之后每次调用迭代器上的 `hasNext()`、`next()`、`currentItem()` 函数，我们都会检查集合上的 `modCount` 是否等于 `expectedModCount`，也就是看，在创建完迭代器之后，`modCount` 是否改变过。\n\n## 在遍历的同时安全地删除集合元素\n\n像 Java 语言 `ArrayList`，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 `remove()` 方法，能够在遍历集合的同时，安全地删除集合中的元素。但是作用有限，它只能删除游标指向的前一个元素，而且一个 `next()` 函数之后，只能跟着最多一个 `remove()` 操作，多次调用 `remove()` 操作会报错。\n\n> Java `ArrayList` 并没有提供遍历过程中添加元素的方法。\n\n部分源码如下：\n\n```java\npublic class ArrayList<E> {\n  transient Object[] elementData;\n  private int size;\n\n  public Iterator<E> iterator() {return new Itr();}\n\n  private class Itr implements Iterator<E> {\n    int cursor;       // index of next element to return\n    int lastRet = -1; // index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n\n    Itr() {}\n\n    public boolean hasNext() {return cursor != size;}\n\n    @SuppressWarnings(\"unchecked\")\n    public E next() {\n      checkForComodification();\n      int i = cursor;\n      if (i >= size)\n        throw new NoSuchElementException();\n      Object[] elementData = ArrayList.this.elementData;\n      if (i >= elementData.length)\n        throw new ConcurrentModificationException();\n      cursor = i + 1;\n      return (E) elementData[lastRet = i];\n    }\n    \n    public void remove() {\n      if (lastRet < 0)\n        throw new IllegalStateException();\n      checkForComodification();\n\n      try {\n        ArrayList.this.remove(lastRet);\n        cursor = lastRet;\n        lastRet = -1;\n        expectedModCount = modCount;\n      } catch (IndexOutOfBoundsException ex) {\n        throw new ConcurrentModificationException();\n      }\n    }\n  }\n}\n\n```\n\n在上面的代码实现中，迭代器类新增了一个 `lastRet` 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 `lastRet` 值，来保证不会因为删除元素而导致某个元素遍历不到。\n\n## 实现一个支持「快照」功能的 `iterator`\n\n> 本节仅供发散思考，当作一个小小的思维训练。\n\n所谓「快照」，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。\n\n一种简单的解决方案为在迭代器类中定义一个成员变量 `snapshot` 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于 [[原型模式及深浅拷贝|浅拷贝]]，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。\n\n第二种解决方案为，我们可以在容器中为每个元素保存两个时间戳，一个是添加时间戳 `addTimestamp`，一个是删除时间戳 `delTimestamp`。当元素被加入到集合中的时候，我们将 `addTimestamp` 设置为当前时间，将 `delTimestamp` 设置成最大长整型值（`Long.MAX_VALUE`）。当元素被删除时，我们将 `delTimestamp` 更新为当前时间，表示已经被删除。注意，这里只是标记删除，而非真正将它从容器中删除。\n\n同时，每个迭代器也保存一个迭代器创建时间戳 `snapshotTimestamp`，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 `addTimestamp<snapshotTimestamp<delTimestamp` 的元素，才是属于这个迭代器的快照。\n\n如果元素的 `addTimestamp>snapshotTimestamp`，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 `delTimestamp<snapshotTimestamp`，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。\n\n这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。注意，这里我们没有考虑 `ArrayList` 的扩容问题。\n\n实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层依赖数组这种数据结构，原本可以支持快速的随机访问，在 $O(1)$ 时间复杂度内获取下标为 `i` 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。\n\n解决随机访问的方法也不难，我们可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。\n\n# 本文 PlantUML 归档\n\n```plantuml\ninterface Aggregate{\n\t{method} {abstract} iterator\n}\n\ninterface Iterator{\n\t{method} {abstract} hasNext\n\t{method} {abstract} next\n}\n\nclass ConcreteAggregate{\n\t{method} iterator\n}\n\nclass ConcreteIterator{\n\taggregate\n\t{method} hasNext\n\t{method} next\n}\n\nAggregate -> Iterator : Creates\nAggregate <|.. ConcreteAggregate\nConcreteAggregate -o ConcreteIterator\nIterator <|.. ConcreteIterator\n```\n\n# 本文参考\n\n- 《图解设计模式》第 1 章 Iterator 模式\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [Java Iterator（迭代器） | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-iterator.html)\n- [【Java】Iterable接口的使用-CSDN博客](https://blog.csdn.net/weixin_43848614/article/details/114601737)\n- [Java集合系列 Iterable、Iterator这俩兄弟细致解读（超通俗易懂）_java iterable-CSDN博客](https://blog.csdn.net/weixin_45663027/article/details/134135420)\n- [迭代器设计模式](https://refactoringguru.cn/design-patterns/iterator)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"}]},"api":"api/posts/p/61ade5c3.json"}