{"data":{"title":"【索引】高质量代码与设计模式","slug":"高质量代码及设计模式/【索引】高质量代码与设计模式","description":"一篇设计模式索引","date":"2025-07-31T12:27:27.000Z","updated":"2025-10-21T15:12:14.563Z","language":"zh-CN","comments":true,"url":"p/3ac6c05c/","cover":"https://cdn.gallery.uuanqin.top/img/202510212306806.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">这是一篇索引文章</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>本文所有未进行有效链接的站内文章其实已经基本写好了，待进一步润色之后会陆续上线。</p>\n<h1 id=\"编程范式与编程风格\"><a class=\"markdownIt-Anchor\" href=\"#编程范式与编程风格\"></a> 编程范式与编程风格</h1>\n<p>常见的编程范式/编程风格：</p>\n<ul>\n<li>面向过程编程：以函数作为组织代码的单元，数据与方法相分离。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/28239a8d/\"><span class=\"bilink-pop-up\">站内文章</span>面向对象编程 OOP</a>：以类、对象作为组织代码的单元以及它的四大特性。\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e036b68e/\"><span class=\"bilink-pop-up\">站内文章</span>面向切面编程 AOP</a>：将横切关注点从核心业务逻辑中分离出来，形成切面。</li>\n</ul>\n</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c5c0eb2/\"><span class=\"bilink-pop-up\">站内文章</span>函数式编程 Functional Programming</a>：程序可以用一系列数学函数或表达式的组合来表示。</li>\n</ul>\n<p>不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数。</p>\n<h1 id=\"设计原则\"><a class=\"markdownIt-Anchor\" href=\"#设计原则\"></a> 设计原则</h1>\n<p><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>设计原则</a> 文章中介绍 SOLID 等代码编写和设计原则。</p>\n<h1 id=\"设计模式\"><a class=\"markdownIt-Anchor\" href=\"#设计模式\"></a> 设计模式</h1>\n<p>设计模式是指针对软件开发过程中重复发生的问题的解决方法。其中以被称为 Gang of Four 整理出的 23 种设计模式最为有名。除此以外还有其他设计模式，参考：</p>\n<ul>\n<li><a href=\"http://wiki.c2.com/?DesignPatterns\">Design Patterns</a></li>\n<li><a href=\"https://hillside.net/patterns/\">Design Patterns Library</a></li>\n</ul>\n<p>设计模式不是万能的，我们需要明确知道自己的软件中存在什么样的问题，明确设计模式可以解决什么问题，才能选出合适的设计模式。设计模式重要性在于快速掌握经验丰富的开发人员才具有的知识和经验，但也没必要机械地背下来。</p>\n<h2 id=\"gof-23-经典的设计模式及延伸\"><a class=\"markdownIt-Anchor\" href=\"#gof-23-经典的设计模式及延伸\"></a> GoF 23 经典的设计模式及延伸</h2>\n<p>上世纪 90 年代，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合作出版了《Design Patterns: Elements of Reusable Object-Oriented Software》一书，中文译名为《设计模式 - 可复用的面向对象软件元素》。该书首次提到了软件开发中设计模式的概念，并收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506132249993.webp\" alt=\"image.png\" width=\"250px\" /></p>\n<p>四位作者合称 GoF（四人<strong>组</strong>，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下面向对象设计原则：</p>\n<ul>\n<li>对接口编程而不是对实现编程。</li>\n<li>优先使用对象组合而不是继承。</li>\n</ul>\n<p>因此，书中提到的 23 中设计模式，也称为经典的「GoF 设计模式」。</p>\n<h3 id=\"模式分类\"><a class=\"markdownIt-Anchor\" href=\"#模式分类\"></a> 模式分类</h3>\n\n<details class=\"callout\" data-callout=\"hint\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">本科时期我的简记</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>创建型：建造单例原型工厂</li>\n<li>结构型：ABCompositeDFP（不包含创建型），<code>250830</code> 或「想焖主包」（享门组包 Wrapper）。</li>\n<li>行为型：剩下的都是行为型。</li>\n</ul>\n</div></details><p>创建型：解决对象创建的问题</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"bilink-pop-up\">站内文章</span>单例模式</a>：文章讲解多种单例模式写法。单例模式应用可看此文：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/43de456a/\"><span class=\"bilink-pop-up\">站内文章</span>单例模式的应用——为 Java 程序应用全局配置</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"bilink-pop-up\">站内文章</span>工厂模式</a>：文章讲解并区分多种工厂模式的写法，含抽象工厂、工厂方法模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/5b8a11ae/\"><span class=\"bilink-pop-up\">站内文章</span>建造者模式</a>：文章讲解两种建造者模式的写法。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"bilink-pop-up\">站内文章</span>原型模式</a>：文章附带讲解深浅拷贝、Java 中 <code>clone</code> 的使用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>创建型模式</th>\n<th>创建类的特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单例模式</td>\n<td>创建全局唯一的对象</td>\n</tr>\n<tr>\n<td>工厂模式</td>\n<td>创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</td>\n</tr>\n<tr>\n<td>建造者模式</td>\n<td>创建复杂对象，可以通过设置不同的可选参数，「定制化」地创建不同的对象</td>\n</tr>\n<tr>\n<td>原型模式</td>\n<td>创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</td>\n</tr>\n</tbody>\n</table>\n<p>结构型：一些类或对象组合在一起的经典结构</p>\n<ul>\n<li>Wrapper 模式\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>适配器模式：转接头</a>：文章介绍两种适配器模式实现方式以及 Wrapper 模式的对比。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>桥接模式</a>：文章介绍类的两个层次结构引出桥接模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>装饰器模式：相框</a>：文章后讨论了组合和继承的运用。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/ba3851cf/\"><span class=\"bilink-pop-up\">站内文章</span>代理模式：爱因斯坦和他的司机</a>：文章介绍了动态代理和静态代理。</li>\n</ul>\n</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>组合模式：树形结构</a>：它更像是一种数据的形式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>门面模式：点击即用</a>：它把分散的对象又耦合了起来。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>享元模式：共享实例</a>：文章附带介绍 Java 中享元模式的应用。</li>\n</ul>\n<p>行为型：类和对象之间的交互</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/d1e2262f/\"><span class=\"bilink-pop-up\">站内文章</span>观察者模式：订阅与推送</a>：文章还讲解了异步非阻塞的实现方法。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e165ad61/\"><span class=\"bilink-pop-up\">站内文章</span>模板方法模式</a>：文章另外介绍了回调以及 Java 函数式编程方法。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>策略模式：符文槽</a>：文章用案例一步步引入策略模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c4f5b558/\"><span class=\"bilink-pop-up\">站内文章</span>责任链模式</a>：文章讲解责任链的构造、关键代码技巧以及两种变体。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>迭代器模式：游标</a>：文章另外讲解了 Java 中的迭代器以及改变集合所导致的未决行为的解决方案。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>中介者模式：只有一个仲裁者</a>：中介者模式其实是观察者模式的集中处理升级版。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>命令模式</a>：它将命令当成类。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>解释器模式</a>：它将语法结构当成类。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>备忘录模式：拍下照片</a>：它将状态保存为实例。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>状态模式</a>：文章通过 FSM 的实现方式引入对状态模式的介绍。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/b6ca7c41/\"><span class=\"bilink-pop-up\">站内文章</span>访问者模式</a>：文章探讨了访问者模式的诞生于双分派机制。</li>\n</ul>\n<h3 id=\"设计模式之间的区别\"><a class=\"markdownIt-Anchor\" href=\"#设计模式之间的区别\"></a> 设计模式之间的区别</h3>\n<p>23 种设计模式可进一步划分为创建型、组合型和行为型设计模式。</p>\n<p>每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。如果只观察设计模式的代码实现，你会发现一些模式是十分相似的：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>策略模式</a> vs <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"bilink-pop-up\">站内文章</span>工厂模式</a></li>\n<li>Wrapper 模式：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/ba3851cf/\"><span class=\"bilink-pop-up\">站内文章</span>代理模式</a>、<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>桥接模式</a>、<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>装饰器模式</a>、<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>适配器模式</a></li>\n</ul>\n<p>但设计模式之间的主要区别还是在于设计意图，即应用场景。对于某些模式之前的相似性比较，相关设计模式文章中会有所涉及。</p>\n<h3 id=\"用类示例来表示-xxx的模式\"><a class=\"markdownIt-Anchor\" href=\"#用类示例来表示-xxx的模式\"></a> 「用类/示例来表示 XXX」的模式</h3>\n\n<div class=\"callout\" data-callout=\"cite\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-quote\"><path d=\"M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z\"/><path d=\"M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">《图解设计模式》结城浩</div>\n</div>\n<div class=\"callout-content\"><p>在面向对象编程中，是用类表示对象的。也就是说，程序的设计者需要考虑用类来表示什么东西。类对应的东西可能存在于真实世界中，也可能不存在于真实世界中。对于后者，可能有人看到代码后会感到吃惊：这些东西居然也可以是类啊。</p>\n</div></div><p>「用类/示例来表示 XXX」的模式均为行为型设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>命令模式</a>：用类来表示命令</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>解释器模式</a>：用类来表示语法规则</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>策略模式</a>：用类来表示算法</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>备忘录模式</a>：用<strong>实例</strong>表示状态</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>状态模式</a>：用类表示状态</li>\n</ul>\n<h2 id=\"多线程的设计模式\"><a class=\"markdownIt-Anchor\" href=\"#多线程的设计模式\"></a> 多线程的设计模式</h2>\n<p>上面 GoF 23 个经典设计模式中部分模式也有多线程的实现，如：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/f7f6f747/\"><span class=\"bilink-pop-up\">站内文章</span>单例模式</a> 中饿汉和懒汉模式讨论了线程安全问题。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>享元模式</a> 中的不可变类可以多线程并发访问。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/d1e2262f/\"><span class=\"bilink-pop-up\">站内文章</span>观察者模式</a>、<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>中介者模式</a> 的异步非阻塞实现能提高代码的效率。</li>\n</ul>\n<p>此外，一些和多线程有关的设计模式有：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e0b8ae0b/\"><span class=\"bilink-pop-up\">站内文章</span>不变模式</a>：文章也介绍了 Java 的不可变类。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>同步模式——顺序控制</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>同步模式——交替输出</a></li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》【日】结城浩著，杨文轩译，中国工信出版集团，人民邮电出版社</li>\n<li>《Java 面向对象编程》孙卫琴</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/design-pattern-intro.html\">设计模式简介 | 菜鸟教程 (runoob.com)</a></li>\n<li><a href=\"https://refactoringguru.cn/\">免费在线学习代码重构和设计模式</a></li>\n</ul>\n","raw":"---\ntitle: 【索引】高质量代码与设计模式\ntags:\n  - 设计模式\n  - 多线程\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202510212306806.webp'\ndescription: 一篇设计模式索引\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: 3ac6c05c\ndate: 2025-07-31 20:27:27\ntop_img:\n---\n\n> [!hint] 这是一篇索引文章\n\n本文所有未进行有效链接的站内文章其实已经基本写好了，待进一步润色之后会陆续上线。\n\n# 编程范式与编程风格\n\n常见的编程范式/编程风格：\n\n- 面向过程编程：以函数作为组织代码的单元，数据与方法相分离。\n- [[面向对象编程 OOP]]：以类、对象作为组织代码的单元以及它的四大特性。\n\t- [[SpringBoot 中的面向切面编程（AOP）|面向切面编程 AOP]]：将横切关注点从核心业务逻辑中分离出来，形成切面。\n- [[函数式编程与 Java 中的 Lambda 表达式|函数式编程 Functional Programming]]：程序可以用一系列数学函数或表达式的组合来表示。\n\n不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数。\n\n# 设计原则\n\n[[设计原则]] 文章中介绍 SOLID 等代码编写和设计原则。\n\n# 设计模式\n\n设计模式是指针对软件开发过程中重复发生的问题的解决方法。其中以被称为 Gang of Four 整理出的 23 种设计模式最为有名。除此以外还有其他设计模式，参考：\n\n- [Design Patterns](http://wiki.c2.com/?DesignPatterns)\n- [Design Patterns Library](https://hillside.net/patterns/)\n\n设计模式不是万能的，我们需要明确知道自己的软件中存在什么样的问题，明确设计模式可以解决什么问题，才能选出合适的设计模式。设计模式重要性在于快速掌握经验丰富的开发人员才具有的知识和经验，但也没必要机械地背下来。\n\n## GoF 23 经典的设计模式及延伸\n\n上世纪 90 年代，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合作出版了《Design Patterns: Elements of Reusable Object-Oriented Software》一书，中文译名为《设计模式 - 可复用的面向对象软件元素》。该书首次提到了软件开发中设计模式的概念，并收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑。\n\n![image.png|250](https://cdn.gallery.uuanqin.top/img/202506132249993.webp)\n\n四位作者合称 GoF（四人**组**，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下面向对象设计原则：\n\n- 对接口编程而不是对实现编程。\n- 优先使用对象组合而不是继承。\n\n因此，书中提到的 23 中设计模式，也称为经典的「GoF 设计模式」。\n\n### 模式分类\n\n> [!hint]- 本科时期我的简记\n> - 创建型：建造单例原型工厂\n> - 结构型：ABCompositeDFP（不包含创建型），`250830` 或「想焖主包」（享门组包 Wrapper）。\n> - 行为型：剩下的都是行为型。\n\n创建型：解决对象创建的问题\n\n- [[单例模式：保持唯一|单例模式]]：文章讲解多种单例模式写法。单例模式应用可看此文：[[单例模式的应用——为 Java 程序应用全局配置]]\n- [[类的工厂|工厂模式]]：文章讲解并区分多种工厂模式的写法，含抽象工厂、工厂方法模式。\n- [[建造者模式的两种不同实现方式|建造者模式]]：文章讲解两种建造者模式的写法。\n- [[原型模式及深浅拷贝|原型模式]]：文章附带讲解深浅拷贝、Java 中 `clone` 的使用。\n\n| 创建型模式 | 创建类的特点                                             |\n| ----- | -------------------------------------------------- |\n| 单例模式  | 创建全局唯一的对象                                          |\n| 工厂模式  | 创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。 |\n| 建造者模式 | 创建复杂对象，可以通过设置不同的可选参数，「定制化」地创建不同的对象                 |\n| 原型模式  | 创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。        |\n\n结构型：一些类或对象组合在一起的经典结构\n\n- Wrapper 模式\n\t- [[适配器模式：转接头]]：文章介绍两种适配器模式实现方式以及 Wrapper 模式的对比。\n\t- [[桥接模式可以沟通功能层次与实现层次|桥接模式]]：文章介绍类的两个层次结构引出桥接模式。\n\t- [[装饰器模式：相框]]：文章后讨论了组合和继承的运用。\n\t- [[代理模式：爱因斯坦和他的司机]]：文章介绍了动态代理和静态代理。\n- [[组合模式：树形结构]]：它更像是一种数据的形式。\n- [[门面模式：点击即用]]：它把分散的对象又耦合了起来。\n- [[享元模式：共享实例]]：文章附带介绍 Java 中享元模式的应用。\n\n行为型：类和对象之间的交互\n\n- [[观察者模式：订阅与推送]]：文章还讲解了异步非阻塞的实现方法。\n- [[模板方法模式与回调|模板方法模式]]：文章另外介绍了回调以及 Java 函数式编程方法。\n- [[策略模式：符文槽]]：文章用案例一步步引入策略模式。\n- [[责任链模式：击鼓传花|责任链模式]]：文章讲解责任链的构造、关键代码技巧以及两种变体。\n- [[迭代器模式：游标]]：文章另外讲解了 Java 中的迭代器以及改变集合所导致的未决行为的解决方案。\n- [[中介者模式：只有一个仲裁者]]：中介者模式其实是观察者模式的集中处理升级版。\n- [[「用类来表现」的设计模式|命令模式]]：它将命令当成类。\n- [[「用类来表现」的设计模式|解释器模式]]：它将语法结构当成类。\n- [[备忘录模式：拍下照片]]：它将状态保存为实例。\n- [[状态模式实现有限状态机|状态模式]]：文章通过 FSM 的实现方式引入对状态模式的介绍。\n- [[访问者模式填补单分派语言的缺陷|访问者模式]]：文章探讨了访问者模式的诞生于双分派机制。\n\n### 设计模式之间的区别\n\n23 种设计模式可进一步划分为创建型、组合型和行为型设计模式。\n\n每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。如果只观察设计模式的代码实现，你会发现一些模式是十分相似的：\n\n- [[策略模式：符文槽|策略模式]] vs [[类的工厂|工厂模式]]\n- Wrapper 模式：[[代理模式：爱因斯坦和他的司机|代理模式]]、[[桥接模式可以沟通功能层次与实现层次|桥接模式]]、[[装饰器模式：相框|装饰器模式]]、[[适配器模式：转接头|适配器模式]]\n\n但设计模式之间的主要区别还是在于设计意图，即应用场景。对于某些模式之前的相似性比较，相关设计模式文章中会有所涉及。\n\n### 「用类/示例来表示 XXX」的模式\n\n> [!cite] 《图解设计模式》结城浩\n> 在面向对象编程中，是用类表示对象的。也就是说，程序的设计者需要考虑用类来表示什么东西。类对应的东西可能存在于真实世界中，也可能不存在于真实世界中。对于后者，可能有人看到代码后会感到吃惊：这些东西居然也可以是类啊。\n\n「用类/示例来表示 XXX」的模式均为行为型设计模式：\n\n- [[「用类来表现」的设计模式|命令模式]]：用类来表示命令\n- [[「用类来表现」的设计模式|解释器模式]]：用类来表示语法规则\n- [[策略模式：符文槽|策略模式]]：用类来表示算法\n- [[备忘录模式：拍下照片|备忘录模式]]：用**实例**表示状态\n- [[状态模式实现有限状态机|状态模式]]：用类表示状态\n\n## 多线程的设计模式\n\n上面 GoF 23 个经典设计模式中部分模式也有多线程的实现，如：\n\n- [[单例模式：保持唯一|单例模式]] 中饿汉和懒汉模式讨论了线程安全问题。\n- [[享元模式：共享实例|享元模式]] 中的不可变类可以多线程并发访问。\n- [[观察者模式：订阅与推送|观察者模式]]、[[中介者模式：只有一个仲裁者|中介者模式]] 的异步非阻塞实现能提高代码的效率。\n\n此外，一些和多线程有关的设计模式有：\n\n- [[Java 不可变类与不变模式|不变模式]]：文章也介绍了 Java 的不可变类。\n- [[同步模式——顺序控制]]\n- [[同步模式——交替输出]]\n\n# 本文参考\n\n- 《图解设计模式》【日】结城浩著，杨文轩译，中国工信出版集团，人民邮电出版社\n- 《Java 面向对象编程》孙卫琴\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [设计模式简介 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/design-pattern-intro.html)\n- [免费在线学习代码重构和设计模式](https://refactoringguru.cn/)\n","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"多线程","api":"api/tags/多线程.json"}]},"api":"api/posts/p/3ac6c05c.json"}