{"data":{"title":"Java 集合的使用","slug":"计算机语言/Java 集合的使用","description":"快速熟悉 Java 的集合","date":"2024-10-01T16:03:13.000Z","updated":"2025-09-29T03:45:05.867Z","language":"zh-CN","comments":true,"url":"p/182af697/","cover":"https://cdn.gallery.uuanqin.top/img/202502260207493.webp","images":[],"content":"<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"集合-collectionmap\"><a class=\"markdownIt-Anchor\" href=\"#集合-collectionmap\"></a> 集合 <code>Collection</code>/<code>Map</code></h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408161619164.webp\" alt=\"image.png\" /></p>\n<p>集合增删改查速览：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/interface.svg\" alt=\"img\" />接口</th>\n<th><code>Collection</code></th>\n<th><code>List</code></th>\n<th><code>Queue</code></th>\n<th><code>Deque</code></th>\n<th><code>Set</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">增</td>\n<td><code>add(E e)</code></td>\n<td><code>add(int index,E element)</code>、<br><code>addAll(c)</code></td>\n<td>抛异常：<br><code>add(e)</code><br>返回特殊值：<br><code>offer(e)</code></td>\n<td>抛异常：<br><code>addFirst(e)</code>、<code>addLast(e)</code>、<code>push(e)</code><br>返回特殊值：<br><code>offerFirst(e)</code>、<code>offerLast(e)</code></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删</td>\n<td><code>remove(Object o)</code> 移除指定对象<br><code>clear()</code> 清空所有内容</td>\n<td>子类 <code>ArrayList</code> 重载了 <code>remove</code> 方法，使其可以通过索引删除指定位置的元素。</td>\n<td>抛异常：<br><code>remove()</code><br>返回特殊值：<br><code>poll()</code></td>\n<td>抛异常：<br><code>removeFirst()</code>、<code>removeLast()</code>、<code>pop()</code><br>返回特殊值：<br><code>pollFirst()</code>、<code>pollLast()</code></td>\n<td><code>boolean remove(obj)</code><br>移除存在的元素返回 <code>true</code>，移除不存在的元素返回 <code>false</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">改</td>\n<td></td>\n<td><code>set(int index, E element)</code><br>请避免对空列表调用该函数</td>\n<td colspan=\"2\"></td>\n<td rowspan=\"3\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查</td>\n<td><br></td>\n<td><code>get(int index)</code></td>\n<td>抛异常：<br><code>element()</code><br>返回特殊值：<br><code>peek()</code></td>\n<td>抛异常：<br><code>getFirst()</code>、<code>getLast()</code><br>返回特殊值：<br><code>peekFirst()</code>、<code>peekLast()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">判断</td>\n<td><code>contains(Object o)</code><br><code>isEmpty()</code></td>\n<td colspan=\"3\"></td>\n</tr>\n</tbody>\n</table>\n<p><code>List</code> 的灵活操作：</p>\n<ul>\n<li>子列表截取：<code>list.subList(from,to)</code>。用于获取列表的一部分视图，对视图的修改会反映到列表中。如需转换为独立新列表需重新构造：<code>List&lt;String&gt; newList = new ArrayList&lt;&gt;(subView);</code></li>\n<li>拼接：<code>list.addAll(ls)</code></li>\n</ul>\n<p>栈结构的使用：</p>\n<ul>\n<li>队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 <code>Stack</code> 类。在 <code>LinkedList</code> 的实现中：\n<ul>\n<li><code>push(e)</code> 是往队首增加元素，实际调用 <code>addFirst(e)</code></li>\n<li><code>pop()</code> 是从队首删减元素，实际调用 <code>removeFirst(e)</code></li>\n</ul>\n</li>\n<li><code>List</code> 也可用于简单的栈。<code>ls.add(e)</code> 方法作为入栈，<code>ls.remove(ls.size() - 1)</code> 作为出栈。</li>\n</ul>\n<p>变长数组可以使用 <code>ArrayList</code> 进行实现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/interface.svg\" alt=\"img\" />接口</th>\n<th><code>Map</code></th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">增</td>\n<td><code>put(key,value)</code></td>\n<td rowspan=\"5\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删</td>\n<td><code>remove(key)</code> 删除 key 对应的键值对<br><code>clear()</code> 清空 map</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">改</td>\n<td><code>put(key,newValue)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查</td>\n<td><code>get(key)</code><br><code>getOrDefault(key,defaultValue)</code><br></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">判断</td>\n<td><code>containsKey(key)</code><br><code>containsValue(value)</code><br></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">集合</td>\n<td><code>entrySet()</code><br><code>keySet()</code></td>\n<td>注意，没有关于值的集合。</td>\n</tr>\n</tbody>\n</table>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">易错点：<code>getOrDefault</code> 的使用</div>\n</div>\n<div class=\"callout-content\"><p>有时候我们会编写这样的代码：<code>map.getOrDefault(key,func());</code>，我们会误以为只有 <code>map</code> 不存在 <code>key</code> 时才会调用 <code>func()</code>。事实上，Java 在传递参数给方法前，都会计算参数的值。因此即使 key 存在，<code>func()</code> 还是会执行一次。</p>\n<p>如果我们需要 <code>map</code> 不存在时才执行 <code>func()</code>，可以使用 <code>computeIfAbsent</code> 函数：<code>map.computeIfAbsent(key,e-&gt;func());</code></p>\n<p>或者使用三元运算符：<code>int result = map.containsKey(key)? map.get(key) : func();</code></p>\n<p>参考：<a href=\"https://segmentfault.com/q/1010000042903930\">java.util.Map 的 getOrDefault() 是如何工作的？ - SegmentFault 思否</a></p>\n</div></div><h1 id=\"map-的遍历\"><a class=\"markdownIt-Anchor\" href=\"#map-的遍历\"></a> <code>Map</code> 的遍历</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Map 遍历元组对</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> entry.getValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map 遍历 key</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String key : map.keySet()) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> map.get(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"用-map-计数\"><a class=\"markdownIt-Anchor\" href=\"#用-map-计数\"></a> 用 <code>Map</code> 计数</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Character,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">char</span> c: chars)&#123;</span><br><span class=\"line\">\tmap.put(c,map.getOrDefault(c,<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法：<code>hashmap.merge(key, value, remappingFunction)</code></p>\n<ul>\n<li><code>merge()</code> 方法会先判断指定的 <code>key</code> 是否存在，如果不存在，则添加键值对到 <code>hashMap</code> 中。</li>\n<li><code>merge()</code> 返回值：如果 <code>key</code> 对应的 <code>value</code> 不存在，则返回该 <code>value</code> 值，如果存在，则返回通过 <code>remappingFunction</code> 重新计算后的值。</li>\n<li>重新映射函数可以使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c5c0eb2/\"><span class=\"bilink-pop-up\">站内文章</span>Lambda 表达式</a>，比如：<code>(oldValue, newValue) -&gt; oldValue + newValue)</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Character,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">char</span> c: chars)&#123;</span><br><span class=\"line\">\tmap.merge(c, <span class=\"number\">1</span>, Integer::sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法\"></a> 哈希算法</h1>\n<p>详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/66fb7738/\"><span class=\"bilink-pop-up\">站内文章</span>不得不和哈希打交道</a></p>\n<h1 id=\"array-与-list-之间的转换\"><a class=\"markdownIt-Anchor\" href=\"#array-与-list-之间的转换\"></a> <code>Array</code> 与 <code>List</code> 之间的转换</h1>\n<p>两者之间的转换除了 for 循环外，还有以下方式。</p>\n<p>Array2List：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] array = &#123;<span class=\"string\">&quot;A&quot;</span>,<span class=\"string\">&quot;B&quot;</span>,<span class=\"string\">&quot;C&quot;</span>&#125;; <span class=\"comment\">// 基本类型数组的话必须是包装类型数组</span></span><br><span class=\"line\">List&lt;String&gt; ls = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(array));</span><br><span class=\"line\"><span class=\"comment\">// 注意Arrays.asList(array)得到的List是固定长度的，无法完成添加或删除元素</span></span><br><span class=\"line\"><span class=\"comment\">// 因此外面还需要ArrayList包装一下</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">阿里巴巴 Java 开发手册对集合使用的相关要求</div>\n</div>\n<div class=\"callout-content\"><p>【强制】使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时， 不能使用其修改集合相关的方法， 它的 <code>add</code> / <code>remove</code> / <code>clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。<br />\n说明： <code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类， 并没有实现集合的修改方法。 <code>Arrays.asList</code> 体现的是 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>适配器模式</a>， 只是转换接口， 后台的数据仍是数组。</p>\n</div></div><p>List2Array：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; ls = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;()&#123;&#123;add(<span class=\"string\">&quot;aa&quot;</span>);add(<span class=\"string\">&quot;bb&quot;</span>);add(<span class=\"string\">&quot;cc&quot;</span>);&#125;&#125;;</span><br><span class=\"line\">String[] array = ls.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n<p>注意 <code>String[] array = (String [])ls.toArray();</code> 是不对的。因为 <code>ls.toArray()</code> 返回的 <code>Object[]</code> 类不能向下转型为 <code>String[]</code>。有关 <code>List</code> 的 <code>toArray</code> 方法详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/6b5aa645/\"><span class=\"bilink-pop-up\">站内文章</span>这篇文章</a>。</p>\n<blockquote>\n<p><code>Set</code> 转数组也可以使用 <code>toArray(T[] array)</code>。</p>\n</blockquote>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">阿里巴巴 Java 开发手册对集合使用的相关要求</div>\n</div>\n<div class=\"callout-content\"><p>【强制】 使用集合转数组的方法， 必须使用集合的 <code>toArray(T[] array)</code>， 传入的是类型完全一致、 长度为 0 的空数组。</p>\n</div></div><h1 id=\"list-的复制\"><a class=\"markdownIt-Anchor\" href=\"#list-的复制\"></a> <code>List</code> 的复制</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 底层源码涉及到了 Arrays.toArray()</span></span><br><span class=\"line\"><span class=\"comment\">// 注意，对于自定义类型的数组不生效</span></span><br><span class=\"line\">List&lt;Integer&gt; target = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;(origin); </span><br><span class=\"line\"><span class=\"comment\">// target 将是一个全新的数组，与 origin 不相关</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"集合的排序\"><a class=\"markdownIt-Anchor\" href=\"#集合的排序\"></a> 集合的排序</h1>\n<p>集合的排序详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/72156dd2/\"><span class=\"bilink-pop-up\">站内文章</span>Java 中的排序</a></p>\n<h1 id=\"treeset-treemap-的一些常用方法\"><a class=\"markdownIt-Anchor\" href=\"#treeset-treemap-的一些常用方法\"></a> <code>TreeSet</code> <code>TreeMap</code> 的一些常用方法</h1>\n<blockquote>\n<p>以下函数在与「线段树」有关的题目的题解下见得多。可以稍微了解下，毕竟玩 API 玩得好能节省时间。</p>\n</blockquote>\n<ul>\n<li><code>tset.floor(E e)</code> 方法返回在这个集合中小于或者等于给定元素的最大元素，如果不存在这样的元素，返回 <code>null</code></li>\n<li><code>tset.ceiling(E e)</code> 方法返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素，返回 <code>null</code></li>\n<li><code>tset.last()</code></li>\n<li><code>tset.lower()</code></li>\n<li><code>tmap.floorEntry(E e)</code></li>\n<li><code>tmap.higherEntry(E e)</code></li>\n<li><code>tmap.firstEntry()</code></li>\n<li><code>tmap.subMap(E fromKey, E toKey)</code>：返回一个视图，其键范围从 <code>fromKey</code>（包括）到 <code>toKey</code>（不包括）。注意，子 <code>Map</code> 中的更改会反映在原始 <code>Map</code> 中。</li>\n</ul>\n<p>相关题目： 🟨 <a href=\"https://leetcode.cn/problems/my-calendar-i/description/\">729. 我的日程安排表 I - 力扣（LeetCode）</a></p>\n<h1 id=\"优先队列-priorityqueue\"><a class=\"markdownIt-Anchor\" href=\"#优先队列-priorityqueue\"></a> 优先队列 <code>PriorityQueue</code></h1>\n<p>优先队列使用了堆数据结构，堆的形式为数组。基本方法为 <code>peek()</code>、<code>offer(e)</code>、<code>poll()/remove()</code>。</p>\n<p><code>remove()</code> 的另一个重载方法 <code>remove(obj)</code>：尝试从队列中移除指定的对象。如果对象存在于队列中，它将被移除，并返回 <code>true</code>；否则返回 <code>false</code>。时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>因为 <code>PriorityQueue</code> 中插入删除的数据是泛型类，可以是基本类型对应的包装类，也可以是自定义类，在向上调整和向下调整的过程中，需要不断地比较，如果数据没有指定比较规则，或者为 <code>null</code> 时，程序就会抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;Integer&gt; priorityQueue1 = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(); <span class=\"comment\">// 默认数组容量 11</span></span><br><span class=\"line\">Queue&lt;Integer&gt; priorityQueue2 = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"number\">11</span>); <span class=\"comment\">// 指定数组容量</span></span><br><span class=\"line\"><span class=\"comment\">// 设置堆插入时向上调整的比较规则</span></span><br><span class=\"line\">Queue&lt;Integer&gt; priorityQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> o2.compareTo(o1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Lambda 简写</span></span><br><span class=\"line\">Queue&lt;Integer&gt; priorityQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(</span><br><span class=\"line\">\t(o1,o2)-&gt;o2-o1</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>Java 集合中的 <code>PriorityQueue</code> 底层的堆默认是小根堆，如果要设置大根堆，就必须传入比较器, 并重写 <code>compare</code> 方法。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://blog.csdn.net/devnn/article/details/82716447\">【Java】Java双端队列Deque使用详解_dequeuejava-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/yzhcjl_/article/details/129212256\">Java【优先级队列】详细图解 / 模拟实现 + 【PriorityQueue】常用方法介绍_java优先队列-CSDN博客</a></li>\n<li><a href=\"https://www.runoob.com/java/java-hashmap-merge.html\">Java HashMap merge() 方法 | 菜鸟教程</a></li>\n</ul>\n","raw":"---\ntitle: Java 集合的使用\ntags:\n  - LeetCode\n  - Java\n  - 集合\ncover: 'https://cdn.gallery.uuanqin.top/img/202502260207493.webp'\ndescription: 快速熟悉 Java 的集合\ncategories:\n  - 计算机语言\nabbrlink: 182af697\ndate: 2024-10-02 00:03:13\ntop_img:\n---\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 集合 `Collection`/`Map`\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202408161619164.webp)\n\n集合增删改查速览：\n\n| ![img](https://cdn.gallery.uuanqin.top/img/interface.svg)接口 | `Collection`                                  | `List`                                            | `Queue`                                   | `Deque`                                                                                  | `Set`                                                        |\n| :---------------------------------------------------------: | --------------------------------------------- | ------------------------------------------------- | ----------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------ |\n|                              增                              | `add(E e)`                                    | `add(int index,E element)`、<br>`addAll(c)`        | 抛异常：<br>`add(e)`<br>返回特殊值：<br>`offer(e)`  | 抛异常：<br>`addFirst(e)`、`addLast(e)`、`push(e)`<br>返回特殊值：<br>`offerFirst(e)`、`offerLast(e)` |                                                              |\n|                              删                              | `remove(Object o)` 移除指定对象<br>`clear()` 清空所有内容 | 子类 `ArrayList` 重载了 `remove` 方法，使其可以通过索引删除指定位置的元素。 | 抛异常：<br>`remove()`<br>返回特殊值：<br>`poll()`  | 抛异常：<br>`removeFirst()`、`removeLast()`、`pop()`<br>返回特殊值：<br>`pollFirst()`、`pollLast()`   | `boolean remove(obj)`<br>移除存在的元素返回 `true`，移除不存在的元素返回 `false` |\n|                              改                              |                                               | `set(int index, E element)`<br>请避免对空列表调用该函数       |                                           |                                                                                          |                                                              |\n|                              查                              | <br>                                          | `get(int index)`                                  | 抛异常：<br>`element()`<br>返回特殊值：<br>`peek()` | 抛异常：<br>`getFirst()`、`getLast()`<br>返回特殊值：<br>`peekFirst()`、`peekLast()`                 |                                                              |\n|                             判断                              | `contains(Object o)`<br>`isEmpty()`           |                                                   |                                           |                                                                                          |                                                              |\n\n`List` 的灵活操作：\n\n- 子列表截取：`list.subList(from,to)`。用于获取列表的一部分视图，对视图的修改会反映到列表中。如需转换为独立新列表需重新构造：`List<String> newList = new ArrayList<>(subView);`\n- 拼接：`list.addAll(ls)`\n\n栈结构的使用：\n\n- 队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 `Stack` 类。在 `LinkedList` 的实现中：\n\t- `push(e)` 是往队首增加元素，实际调用 `addFirst(e)`\n\t- `pop()` 是从队首删减元素，实际调用 `removeFirst(e)`\n- `List` 也可用于简单的栈。`ls.add(e)` 方法作为入栈，`ls.remove(ls.size() - 1)` 作为出栈。\n\n变长数组可以使用 `ArrayList` 进行实现。\n\n| ![img](https://cdn.gallery.uuanqin.top/img/interface.svg)接口 | `Map`                                              | 说明           |\n| :---------------------------------------------------------: | -------------------------------------------------- | ------------ |\n|                              增                              | `put(key,value)`                                   |              |\n|                              删                              | `remove(key)` 删除 key 对应的键值对<br>`clear()` 清空 map    |              |\n|                              改                              | `put(key,newValue)`                                |              |\n|                              查                              | `get(key)`<br>`getOrDefault(key,defaultValue)`<br> |              |\n|                             判断                              | `containsKey(key)`<br>`containsValue(value)`<br>   |              |\n|                             集合                              | `entrySet()`<br>`keySet()`                         | 注意，没有关于值的集合。 |\n\n> [!hint] 易错点：`getOrDefault` 的使用\n> 有时候我们会编写这样的代码：`map.getOrDefault(key,func());`，我们会误以为只有 `map` 不存在 `key` 时才会调用 `func()`。事实上，Java 在传递参数给方法前，都会计算参数的值。因此即使 key 存在，`func()` 还是会执行一次。\n>\n>\n> 如果我们需要 `map` 不存在时才执行 `func()`，可以使用 `computeIfAbsent` 函数：`map.computeIfAbsent(key,e->func());`\n>\n> 或者使用三元运算符：`int result = map.containsKey(key)? map.get(key) : func();`\n>\n> 参考：[java.util.Map 的 getOrDefault() 是如何工作的？ - SegmentFault 思否](https://segmentfault.com/q/1010000042903930)\n\n#  `Map` 的遍历\n\n```java\n// Map 遍历元组对\nfor (Map.Entry<String, Integer> entry : map.entrySet()) {\n\tString key = entry.getKey();\n\tint val = entry.getValue();\n}\n\n// Map 遍历 key\nfor (String key : map.keySet()) {\n\tint val = map.get(key);\n}\n```\n\n# 用 `Map` 计数\n\n```java\nMap<Character,Integer> map = new HashMap<>();\nfor(char c: chars){\n\tmap.put(c,map.getOrDefault(c,0)+1);\n}\n```\n\n方法：`hashmap.merge(key, value, remappingFunction)`\n\n- `merge()` 方法会先判断指定的 `key` 是否存在，如果不存在，则添加键值对到 `hashMap` 中。\n- `merge()` 返回值：如果 `key` 对应的 `value` 不存在，则返回该 `value` 值，如果存在，则返回通过 `remappingFunction` 重新计算后的值。\n- 重新映射函数可以使用 [[函数式编程与 Java 中的 Lambda 表达式|Lambda 表达式]]，比如：`(oldValue, newValue) -> oldValue + newValue)`\n\n```java\nMap<Character,Integer> map = new HashMap<>();\nfor(char c: chars){\n\tmap.merge(c, 1, Integer::sum);\n}\n```\n\n# 哈希算法\n\n详看：[[不得不和哈希打交道]]\n\n# `Array` 与 `List` 之间的转换\n\n两者之间的转换除了 for 循环外，还有以下方式。\n\nArray2List：\n\n```java\nString[] array = {\"A\",\"B\",\"C\"}; // 基本类型数组的话必须是包装类型数组\nList<String> ls = new ArrayList<>(Arrays.asList(array));\n// 注意Arrays.asList(array)得到的List是固定长度的，无法完成添加或删除元素\n// 因此外面还需要ArrayList包装一下\n```\n\n> [!note] 阿里巴巴 Java 开发手册对集合使用的相关要求\n> 【强制】使用工具类 `Arrays.asList()` 把数组转换成集合时， 不能使用其修改集合相关的方法， 它的 `add` / `remove` / `clear` 方法会抛出 `UnsupportedOperationException` 异常。\n> 说明： `asList` 的返回对象是一个 `Arrays` 内部类， 并没有实现集合的修改方法。 `Arrays.asList` 体现的是 [[适配器模式：转接头|适配器模式]]， 只是转换接口， 后台的数据仍是数组。\n\nList2Array：\n\n```java\nList<String> ls = new ArrayList<String>(){{add(\"aa\");add(\"bb\");add(\"cc\");}};\nString[] array = ls.toArray(new String[0]);\n```\n\n注意 `String[] array = (String [])ls.toArray();` 是不对的。因为 `ls.toArray()` 返回的 `Object[]` 类不能向下转型为 `String[]`。有关 `List` 的 `toArray` 方法详看：[[Java List 的 toArray 方法|这篇文章]]。\n\n> `Set` 转数组也可以使用 `toArray(T[] array)`。\n\n> [!note] 阿里巴巴 Java 开发手册对集合使用的相关要求\n> 【强制】 使用集合转数组的方法， 必须使用集合的 `toArray(T[] array)`， 传入的是类型完全一致、 长度为 0 的空数组。\n\n# `List` 的复制\n\n```java\n// 底层源码涉及到了 Arrays.toArray()\n// 注意，对于自定义类型的数组不生效\nList<Integer> target = new ArrayList<Integer>(origin); \n// target 将是一个全新的数组，与 origin 不相关\n```\n\n# 集合的排序\n\n集合的排序详见：[[Java 中的排序]]\n\n# `TreeSet` `TreeMap` 的一些常用方法\n\n> 以下函数在与「线段树」有关的题目的题解下见得多。可以稍微了解下，毕竟玩 API 玩得好能节省时间。\n\n- `tset.floor(E e)` 方法返回在这个集合中小于或者等于给定元素的最大元素，如果不存在这样的元素，返回 `null`\n- `tset.ceiling(E e)` 方法返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素，返回 `null`\n- `tset.last()`\n- `tset.lower()`\n- `tmap.floorEntry(E e)`\n- `tmap.higherEntry(E e)`\n- `tmap.firstEntry()`\n- `tmap.subMap(E fromKey, E toKey)`：返回一个视图，其键范围从 `fromKey`（包括）到 `toKey`（不包括）。注意，子 `Map` 中的更改会反映在原始 `Map` 中。\n\n相关题目： 🟨 [729. 我的日程安排表 I - 力扣（LeetCode）](https://leetcode.cn/problems/my-calendar-i/description/)\n\n# 优先队列 `PriorityQueue`\n\n优先队列使用了堆数据结构，堆的形式为数组。基本方法为 `peek()`、`offer(e)`、`poll()/remove()`。\n\n`remove()` 的另一个重载方法 `remove(obj)`：尝试从队列中移除指定的对象。如果对象存在于队列中，它将被移除，并返回 `true`；否则返回 `false`。时间复杂度为 $O(n)$。\n\n因为 `PriorityQueue` 中插入删除的数据是泛型类，可以是基本类型对应的包装类，也可以是自定义类，在向上调整和向下调整的过程中，需要不断地比较，如果数据没有指定比较规则，或者为 `null` 时，程序就会抛出异常。\n\n```java\nQueue<Integer> priorityQueue1 = new PriorityQueue<>(); // 默认数组容量 11\nQueue<Integer> priorityQueue2 = new PriorityQueue<>(11); // 指定数组容量\n// 设置堆插入时向上调整的比较规则\nQueue<Integer> priorityQueue = new PriorityQueue<>(\n\tnew Comparator<Integer>() {\n\t\t@Override\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn o2.compareTo(o1);\n\t\t}\n\t}\n);\n\n// 使用 Lambda 简写\nQueue<Integer> priorityQueue = new PriorityQueue<>(\n\t(o1,o2)->o2-o1\n);\n```\n\nJava 集合中的 `PriorityQueue` 底层的堆默认是小根堆，如果要设置大根堆，就必须传入比较器, 并重写 `compare` 方法。\n\n# 本文参考\n\n- [【Java】Java双端队列Deque使用详解_dequeuejava-CSDN博客](https://blog.csdn.net/devnn/article/details/82716447)\n- [Java【优先级队列】详细图解 / 模拟实现 + 【PriorityQueue】常用方法介绍_java优先队列-CSDN博客](https://blog.csdn.net/yzhcjl_/article/details/129212256)\n- [Java HashMap merge() 方法 | 菜鸟教程](https://www.runoob.com/java/java-hashmap-merge.html)","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"集合","api":"api/tags/集合.json"}]},"api":"api/posts/p/182af697.json"}