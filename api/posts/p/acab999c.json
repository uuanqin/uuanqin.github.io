{"data":{"title":"SPI 概念及案例实践（上）","slug":"技术学习/SPI 概念及案例实践（上）","description":"通过动手实践理解 SPI 并尝试编写 ServiceLoader","date":"2024-07-31T13:39:52.000Z","updated":"2025-06-11T16:08:12.778Z","language":"zh-CN","comments":true,"url":"p/acab999c/","cover":"https://cdn.gallery.uuanqin.top/img/20240731214853.webp","images":[],"content":"<h1 id=\"spi-概念\"><a class=\"markdownIt-Anchor\" href=\"#spi-概念\"></a> SPI 概念</h1>\n<p>面向对象设计鼓励模块间基于接口而非具体实现编程，以降低模块间的耦合，遵循依赖倒置原则，并支持开闭原则（对扩展开放，对修改封闭）。</p>\n<p>SPI（Service Provider Interface）服务提供了一种服务发现机制，允许在程序外部动态指定具体实现。这与控制反转（IoC）的思想相似，将组件装配的控制权移交给了程序之外。SPI 主要用于实现模块化开发和插件化扩展。</p>\n<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者<strong>解耦</strong>，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>\n<p>设计思想：</p>\n<ul>\n<li>面向接口</li>\n<li>配置文件</li>\n<li>反射技术</li>\n<li>策略模式</li>\n</ul>\n<p>本文源代码详见文末。</p>\n<h2 id=\"spi-和-api-的区别\"><a class=\"markdownIt-Anchor\" href=\"#spi-和-api-的区别\"></a> SPI 和 API 的区别</h2>\n<p>广义上来说它们都是接口。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240726225753.webp\" alt=\"image.png\" /></p>\n<p>一般模块之间都是通过接口进行通讯，因此我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>\n<ul>\n<li>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 <strong>API</strong>。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。</li>\n<li>当接口存在于调用方这边时，这就是 <strong>SPI</strong>  。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子感受 SPI</div>\n</div>\n<div class=\"callout-content\"><p>我们使用的主流 Java 开发框架中，几乎都使用到了 SPI 机制，比如 Servlet 容器、日志框架、ORM 框架、Spring 框架、Dubbo 的扩展实现。</p>\n<p>例子 1：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>\n<p>例子 2：SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。<br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240726230144.webp\" alt=\"image.png\" /></p>\n<p>例子 3：一个典型的 SPI 应用场景是 JDBC（Java 数据库连接库），不同的数据库驱动程序开发者可以使用 JDBC 库，然后定制自己的数据库驱动程序。<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727180936.webp\" alt=\"image.png\" /></p>\n</div></div><h1 id=\"java-spi-机制\"><a class=\"markdownIt-Anchor\" href=\"#java-spi-机制\"></a> Java SPI 机制</h1>\n<p>一个标准的 SPI，由 3 个组件构成，分别是：</p>\n<ul>\n<li>1️⃣Service：一个公开的接口或抽象类，定义了一个抽象的功能模块。</li>\n<li>2️⃣Service Provider：是 Service 接口的实现类</li>\n<li>3️⃣ServiceLoader：SPI 机制中的核心组件（对应 JDK 中的 ServiceLoader 类），负责在运行时发现并加载 Service Provider</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727180703.webp\" alt=\"image.png\" /></p>\n<p>Java SPI 的规范要素：</p>\n<ol>\n<li>规范的配置文件：\n<ul>\n<li>文件路径：必须在 JAR 包中的 META-INF/services 目录下</li>\n<li>文件名称：Service 接口的全限定名</li>\n<li>文件内容：Service 实现类（即 Service Provider 类）的全限定名。如果有多个实现类，那么每一个实现类在文件中单独占据一行</li>\n</ul>\n</li>\n<li>Service 接口的实现类 Service Provider 类，必须具备无参的默认构造方法。因为随后通过反射技术实例化它时是不带参数的。</li>\n<li>保证能加载到配置文件和 Service Provider 类。\n<ul>\n<li>方式一：将 Service Provider 的 JAR 包放到 classpath 中（最常用）</li>\n<li>方式二：将 JAR 包安装到 JRE 的扩展目录中</li>\n<li>方式三：自定义一个 ClassLoader</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"手写-spi-应用示例\"><a class=\"markdownIt-Anchor\" href=\"#手写-spi-应用示例\"></a> 手写 SPI 应用示例</h1>\n<p>本示例的背景介绍：有一家公司 A，它需要连接互联网。它定义了一个连接网络的 API，由中国移动和中国联通来提供网络服务。</p>\n<p>这个场景涉及到了以下角色：</p>\n<ol>\n<li>消费者：公司 A。提供使用以下模块：\n<ul>\n<li><code>simple-company</code></li>\n<li><code>simple-api</code></li>\n</ul>\n</li>\n<li>服务提供者：中国移动、中国联通\n<ul>\n<li><code>simple-isp-mobile</code>（中国移动提供的 jar 包）</li>\n<li><code>simple-isp-unicom</code>（中国联通提供的 jar 包）</li>\n</ul>\n</li>\n</ol>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727203537.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<h2 id=\"使用-java-的-serviceloader\"><a class=\"markdownIt-Anchor\" href=\"#使用-java-的-serviceloader\"></a> 使用 Java 的 ServiceLoader</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727204157.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p>公司 A 在 <code>simple-api</code> 提供的服务接口（这就是 SPI 中 1️ Service 接口部分 1️⃣）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> uuanqin</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">InternetService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">connectInternet</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务提供者中国移动在 <code>simple-isp-mobile</code> 在 <code>pom.xml</code> 中导入了 <code>simple-api</code>，并为其编写了实现类（北京移动 <code>BeijingMobile</code> 和苏州移动 <code>SuzhouMobile</code> 的联网服务，这些就是 SPI 中的 Service Provider 部分 2️⃣）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>top.uuanqin<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>simple-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.mobile;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> top.uuanqin.InternetService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> uuanqin</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeijingMobile</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InternetService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">connectInternet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;【中国移动（北京移动）】欢迎使用中国移动联网服务！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中国移动在配置目录中放置 SPI 配置文件，文件名是 Service 接口的全限定名，内容是 Service Provider 类的全限定名。多行表示多个 Service Provider。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cn.mobile.BeijingMobile  </span><br><span class=\"line\">cn.mobile.SuzhouMobile</span><br></pre></td></tr></table></figure>\n<p>中国移动 <code>simple-isp-mobile</code> 目录结构如下：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727220435.webp\" alt=\"image.png\" /></p>\n<p>同样的，服务提供者中国联通 <code>simple-isp-unicom</code> 也编写了实现类，假设它只编写了一个实现类 <code>ChinaUnicom</code>。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727220509.webp\" alt=\"image.png\" /></p>\n<p>公司 A 在实际的应用项目 <code>simple-company</code> 中使用了上网服务（包含 SPI 的 ServiceLoader 部分 3️⃣）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ServiceLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ServiceLoader&lt;InternetService&gt; loader = ServiceLoader.load(InternetService.class);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(InternetService provider: loader)&#123;</span><br><span class=\"line\">            provider.connectInternet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pom.xml</code> 中除了引用自己公司定义的 api 外，我想要使用哪个公司的上网服务，就导入哪个公司的 jar 包。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>top.uuanqin<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>simple-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>cn.mobile<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>simple-isp-mobile<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行 <code>Main</code> 方法结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【中国移动（北京移动）】欢迎使用中国移动联网服务！</span><br><span class=\"line\">【中国移动（苏州移动）】欢迎使用中国移动联网服务！</span><br></pre></td></tr></table></figure>\n<p>如果 <code>pom.xml</code> 导入的是中国联通的 jar 包，那么 <code>Main</code> 方法返回：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【中国联通】欢迎使用中国联通的无线上网服务！</span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">如果没打印成功，检查一下 <code>META-INF.services</code> 目录是一个文件夹还是两级文件夹！</div>\n</div>\n<div class=\"callout-content\"><p>在 IDEA 中选择这个取消压缩中间文件夹名：<br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727221048.webp\" alt=\"image.png\" width=\"500px\" /></p>\n</div></div><h2 id=\"尝试写一个简单的-serviceloader\"><a class=\"markdownIt-Anchor\" href=\"#尝试写一个简单的-serviceloader\"></a> 尝试写一个简单的 ServiceLoader</h2>\n<p>在阅读 Java ServiceLoader 源码之前，可以先看一下下面的代码进行理解。下面代码是一个简化了的 ServiceLoader。</p>\n<p>代码引入工具包以减少编写的代码量：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://doc.hutool.cn/ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>cn.hutool<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hutool-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.8.16<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cn.hutool.core.io.resource.ResourceUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyServiceLoader</span>&lt;S&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Iterable</span>&lt;S&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应的接口 Class 模板</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;S&gt; service;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应实现类的 可以有多个，用 List 进行封装</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;S&gt; providers = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 类加载器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ClassLoader classLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; MyServiceLoader&lt;S&gt; <span class=\"title function_\">load</span><span class=\"params\">(Class&lt;S&gt; service)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyServiceLoader</span>&lt;&gt;(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法私有化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">MyServiceLoader</span><span class=\"params\">(Class&lt;S&gt; service)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service = service;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        doLoad();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键方法，加载具体实现类的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLoad</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        List&lt;URL&gt; resources = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名</span></span><br><span class=\"line\">        resources = ResourceUtil.getResources(<span class=\"string\">&quot;META-INF/services/&quot;</span> + service.getName());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL resource : resources) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">InputStreamReader</span> <span class=\"variable\">inputStreamReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(resource.openStream());</span><br><span class=\"line\">                <span class=\"type\">BufferedReader</span> <span class=\"variable\">bufferedReader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(inputStreamReader);</span><br><span class=\"line\">                String line;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((line = bufferedReader.readLine()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过反射拿到实现类的实例</span></span><br><span class=\"line\">                    Class&lt;?&gt; clazz = Class.forName(line, <span class=\"literal\">false</span>, classLoader);</span><br><span class=\"line\">                    <span class=\"comment\">// 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (service.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">                        <span class=\"type\">S</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> (S) clazz.newInstance();</span><br><span class=\"line\">                        <span class=\"comment\">// 把当前构造的实例对象添加到 Provider的列表里面</span></span><br><span class=\"line\">                        providers.add(instance);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;类加载异常&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回spi接口对应的具体实现类列表</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;S&gt; <span class=\"title function_\">getProviders</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> providers;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ************** 迭代器的实现 ********************** //</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Iterator&lt;S&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> providers.iterator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把上例中 Main 函数的 <code>ServiceLoader</code> 换成 <code>MyServiceLoader</code> 将得到同样的结果。</p>\n<p>更定制化的 ServiceLoader 实现以及相关应用场景详见这篇文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e7aa13ce/\"><span class=\"yukari\">站内文章</span>SPI 概念及案例实践（下）</a></p>\n<h1 id=\"拓展java-spi-与-springboot-的自动配置\"><a class=\"markdownIt-Anchor\" href=\"#拓展java-spi-与-springboot-的自动配置\"></a> 【拓展】Java SPI 与 SpringBoot 的自动配置</h1>\n<p>SpringBoot 自动配置，即大名鼎鼎的 Auto-Configuration 是指基于你引入的依赖 Jar 包，对 SpringBoot 应用进行自动配置。提供了自动配置功能的依赖 Jar 包通常被称为 starter，例如 <code>mybatis-spring-boot-starter</code> 等等。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240727202855.webp\" alt=\"image.png\" /></p>\n<p>SpringBoot 与 jdk 在 SPI 机制上，存在些许的差别，但本质上还是事先定义一套规范，来完成对实现类或者组件的动态发现。</p>\n<ul>\n<li>在获取实现类名称集合的层面上，SpringBoot 借助于 SpringFactoriesLoader 加载 <code>spring.factories</code> 配置文件，而 jdk 借助于 ServiceLoader 读取指定路径。</li>\n<li>在是否实例化实现类的层面上，SpringBoot 会依据 <code>@Conditional</code> 注解来判断是否进行实例化并注入进容器中，而 jdk 会在 <code>next()</code> 方法内部懒加载实现类。</li>\n</ul>\n<p>更多参考详见本站文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/21b7da2d/\"><span class=\"yukari\">站内文章</span>SpringBoot 的原理以及写一个自定义 Starter</a></p>\n<h1 id=\"源代码\"><a class=\"markdownIt-Anchor\" href=\"#源代码\"></a> 源代码</h1>\n<p><a href=\"https://github.com/uuanqin/SPI-simple-example\"><img src= \"/image/loading.gif\" data-lazy-src=\"https://github-readme-stats.uuanqin.top/api/pin/?username=uuanqin&amp;repo=SPI-simple-example\" alt=\"Readme Card\" /></a></p>\n<p>GitHub 仓库地址：<a href=\"https://github.com/uuanqin/SPI-simple-example\">uuanqin/SPI-simple-example (github.com)</a></p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://javaguide.cn/java/basis/spi.html#service-provider\">Java SPI 机制详解 | JavaGuide</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1RY4y1v7mN/\">10分钟让你彻底明白Java SPI，附实例代码演示#安员外很有码_哔哩哔哩_bilibili</a></li>\n<li><a href=\"https://yuyuanweb.feishu.cn/wiki/EweIwSYsXiEvCDkzS8BcTiAonyc\">知识星球·编程导航 - 手写 RFC 框架</a></li>\n<li><a href=\"https://blog.csdn.net/qq_33591903/article/details/119843446\">SpringBoot的自动装配原理、自定义starter与spi机制，一网打尽_springboot 有很多的启动器 说一下启动器的自动装配原理-CSDN博客</a></li>\n</ul>\n","raw":"---\ntitle: SPI 概念及案例实践（上）\ntags:\n  - Java\n  - SPI\n  - API\n  - ServiceLoader\ncover: 'https://cdn.gallery.uuanqin.top/img/20240731214853.webp'\ndescription: 通过动手实践理解 SPI 并尝试编写 ServiceLoader\ncategories:\n  - 技术学习\nabbrlink: acab999c\ndate: 2024-07-31 21:39:52\ntop_img:\n---\n\n# SPI 概念\n\n面向对象设计鼓励模块间基于接口而非具体实现编程，以降低模块间的耦合，遵循依赖倒置原则，并支持开闭原则（对扩展开放，对修改封闭）。\n\nSPI（Service Provider Interface）服务提供了一种服务发现机制，允许在程序外部动态指定具体实现。这与控制反转（IoC）的思想相似，将组件装配的控制权移交给了程序之外。SPI 主要用于实现模块化开发和插件化扩展。\n\nSPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者**解耦**，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。\n\n设计思想：\n\n- 面向接口\n- 配置文件\n- 反射技术\n- 策略模式\n\n本文源代码详见文末。\n\n## SPI 和 API 的区别\n\n广义上来说它们都是接口。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240726225753.webp)\n\n一般模块之间都是通过接口进行通讯，因此我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。\n\n- 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 **API**。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。\n- 当接口存在于调用方这边时，这就是 **SPI**  。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。\n\n> [!example] 例子感受 SPI\n> 我们使用的主流 Java 开发框架中，几乎都使用到了 SPI 机制，比如 Servlet 容器、日志框架、ORM 框架、Spring 框架、Dubbo 的扩展实现。\n>\n> 例子 1：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。\n>\n> 例子 2：SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。\n> ![image.png](https://cdn.gallery.uuanqin.top/img/20240726230144.webp)\n>\n> 例子 3：一个典型的 SPI 应用场景是 JDBC（Java 数据库连接库），不同的数据库驱动程序开发者可以使用 JDBC 库，然后定制自己的数据库驱动程序。![image.png](https://cdn.gallery.uuanqin.top/img/20240727180936.webp)\n\n# Java SPI 机制\n\n一个标准的 SPI，由 3 个组件构成，分别是：\n\n- 1️⃣Service：一个公开的接口或抽象类，定义了一个抽象的功能模块。\n- 2️⃣Service Provider：是 Service 接口的实现类\n- 3️⃣ServiceLoader：SPI 机制中的核心组件（对应 JDK 中的 ServiceLoader 类），负责在运行时发现并加载 Service Provider\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240727180703.webp)\n\nJava SPI 的规范要素：\n\n1. 规范的配置文件：\n\t- 文件路径：必须在 JAR 包中的 META-INF/services 目录下\n\t- 文件名称：Service 接口的全限定名\n\t- 文件内容：Service 实现类（即 Service Provider 类）的全限定名。如果有多个实现类，那么每一个实现类在文件中单独占据一行\n2. Service 接口的实现类 Service Provider 类，必须具备无参的默认构造方法。因为随后通过反射技术实例化它时是不带参数的。\n3. 保证能加载到配置文件和 Service Provider 类。\n\t- 方式一：将 Service Provider 的 JAR 包放到 classpath 中（最常用）\n\t- 方式二：将 JAR 包安装到 JRE 的扩展目录中\n\t- 方式三：自定义一个 ClassLoader\n\n# 手写 SPI 应用示例\n\n本示例的背景介绍：有一家公司 A，它需要连接互联网。它定义了一个连接网络的 API，由中国移动和中国联通来提供网络服务。\n\n这个场景涉及到了以下角色：\n\n1. 消费者：公司 A。提供使用以下模块：\n\t- `simple-company`\n\t- `simple-api`\n2. 服务提供者：中国移动、中国联通\n\t- `simple-isp-mobile`（中国移动提供的 jar 包）\n\t- `simple-isp-unicom`（中国联通提供的 jar 包）\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/20240727203537.webp)\n\n## 使用 Java 的 ServiceLoader\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/20240727204157.webp)\n\n公司 A 在 `simple-api` 提供的服务接口（这就是 SPI 中 1️ Service 接口部分 1️⃣）：\n\n```java\npackage top.uuanqin;\n\n/**\n * @author uuanqin\n */\npublic interface InternetService {\n    void connectInternet();\n}\n```\n\n服务提供者中国移动在 `simple-isp-mobile` 在 `pom.xml` 中导入了 `simple-api`，并为其编写了实现类（北京移动 `BeijingMobile` 和苏州移动 `SuzhouMobile` 的联网服务，这些就是 SPI 中的 Service Provider 部分 2️⃣）：\n\n```xml\n<dependencies>\n\t<dependency>\n\t\t<groupId>top.uuanqin</groupId>\n\t\t<artifactId>simple-api</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t</dependency>\n</dependencies>\n```\n\n```java\npackage cn.mobile;\n\nimport top.uuanqin.InternetService;\n\n/**\n * @author uuanqin\n */\npublic class BeijingMobile implements InternetService {\n    @Override\n    public void connectInternet() {\n        System.out.println(\"【中国移动（北京移动）】欢迎使用中国移动联网服务！\");\n    }\n}\n```\n\n中国移动在配置目录中放置 SPI 配置文件，文件名是 Service 接口的全限定名，内容是 Service Provider 类的全限定名。多行表示多个 Service Provider。\n\n```\ncn.mobile.BeijingMobile  \ncn.mobile.SuzhouMobile\n```\n\n中国移动 `simple-isp-mobile` 目录结构如下：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240727220435.webp)\n\n同样的，服务提供者中国联通 `simple-isp-unicom` 也编写了实现类，假设它只编写了一个实现类 `ChinaUnicom`。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240727220509.webp)\n\n公司 A 在实际的应用项目 `simple-company` 中使用了上网服务（包含 SPI 的 ServiceLoader 部分 3️⃣）：\n\n```java\npackage top.uuanqin;\n\nimport java.util.ServiceLoader;\n\npublic class Main {\n    public static void main(String[] args) {\n        ServiceLoader<InternetService> loader = ServiceLoader.load(InternetService.class);\n        for(InternetService provider: loader){\n            provider.connectInternet();\n        }\n    }\n}\n```\n\n`pom.xml` 中除了引用自己公司定义的 api 外，我想要使用哪个公司的上网服务，就导入哪个公司的 jar 包。\n\n```xml\n<dependencies>\n\t<dependency>\n\t\t<groupId>top.uuanqin</groupId>\n\t\t<artifactId>simple-api</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>cn.mobile</groupId>\n\t\t<artifactId>simple-isp-mobile</artifactId>\n\t\t<version>1.0-SNAPSHOT</version>\n\t</dependency>\n</dependencies>\n```\n\n运行 `Main` 方法结果如下：\n\n```\n【中国移动（北京移动）】欢迎使用中国移动联网服务！\n【中国移动（苏州移动）】欢迎使用中国移动联网服务！\n```\n\n如果 `pom.xml` 导入的是中国联通的 jar 包，那么 `Main` 方法返回：\n\n```\n【中国联通】欢迎使用中国联通的无线上网服务！\n```\n\n> [!hint] 如果没打印成功，检查一下 `META-INF.services` 目录是一个文件夹还是两级文件夹！\n> 在 IDEA 中选择这个取消压缩中间文件夹名：\n> ![image.png|500](https://cdn.gallery.uuanqin.top/img/20240727221048.webp)\n\n## 尝试写一个简单的 ServiceLoader\n\n在阅读 Java ServiceLoader 源码之前，可以先看一下下面的代码进行理解。下面代码是一个简化了的 ServiceLoader。\n\n代码引入工具包以减少编写的代码量：\n\n```xml\n<!-- https://doc.hutool.cn/ -->\n<dependency>\n\t<groupId>cn.hutool</groupId>\n\t<artifactId>hutool-all</artifactId>\n\t<version>5.8.16</version>\n</dependency>\n```\n\n```java\npackage top.uuanqin;\n\nimport cn.hutool.core.io.resource.ResourceUtil;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class MyServiceLoader<S> implements Iterable<S> {\n\n    // 对应的接口 Class 模板\n    private final Class<S> service;\n\n    // 对应实现类的 可以有多个，用 List 进行封装\n    private final List<S> providers = new ArrayList<>();\n\n    // 类加载器\n    private final ClassLoader classLoader;\n\n    // 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。\n    public static <S> MyServiceLoader<S> load(Class<S> service) {\n        return new MyServiceLoader<>(service);\n    }\n\n    // 构造方法私有化\n    private MyServiceLoader(Class<S> service) {\n        this.service = service;\n        this.classLoader = Thread.currentThread().getContextClassLoader();\n        doLoad();\n    }\n\n    // 关键方法，加载具体实现类的逻辑\n    private void doLoad() {\n        List<URL> resources = null;\n        // 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名\n        resources = ResourceUtil.getResources(\"META-INF/services/\" + service.getName());\n        for (URL resource : resources) {\n            try {\n                InputStreamReader inputStreamReader = new InputStreamReader(resource.openStream());\n                BufferedReader bufferedReader = new BufferedReader(inputStreamReader);\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    // 通过反射拿到实现类的实例\n                    Class<?> clazz = Class.forName(line, false, classLoader);\n                    // 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例\n                    if (service.isAssignableFrom(clazz)) {\n                        S instance = (S) clazz.newInstance();\n                        // 把当前构造的实例对象添加到 Provider的列表里面\n                        providers.add(instance);\n                    }\n                }\n            } catch (Exception e) {\n                System.out.println(\"类加载异常\");\n            }\n        }\n    }\n\n    // 返回spi接口对应的具体实现类列表\n    public List<S> getProviders() {\n        return providers;\n    }\n\n    // ************** 迭代器的实现 ********************** //\n    @Override\n    public Iterator<S> iterator() {\n        return providers.iterator();\n    }\n}\n```\n\n把上例中 Main 函数的 `ServiceLoader` 换成 `MyServiceLoader` 将得到同样的结果。\n\n更定制化的 ServiceLoader 实现以及相关应用场景详见这篇文章：[[SPI 概念及案例实践（下）]]\n\n# 【拓展】Java SPI 与 SpringBoot 的自动配置\n\nSpringBoot 自动配置，即大名鼎鼎的 Auto-Configuration 是指基于你引入的依赖 Jar 包，对 SpringBoot 应用进行自动配置。提供了自动配置功能的依赖 Jar 包通常被称为 starter，例如 `mybatis-spring-boot-starter` 等等。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240727202855.webp)\n\nSpringBoot 与 jdk 在 SPI 机制上，存在些许的差别，但本质上还是事先定义一套规范，来完成对实现类或者组件的动态发现。\n\n- 在获取实现类名称集合的层面上，SpringBoot 借助于 SpringFactoriesLoader 加载 `spring.factories` 配置文件，而 jdk 借助于 ServiceLoader 读取指定路径。\n- 在是否实例化实现类的层面上，SpringBoot 会依据 `@Conditional` 注解来判断是否进行实例化并注入进容器中，而 jdk 会在 `next()` 方法内部懒加载实现类。\n\n更多参考详见本站文章：[[SpringBoot 的原理以及写一个自定义 Starter]]\n\n# 源代码\n\n[![Readme Card](https://github-readme-stats.uuanqin.top/api/pin/?username=uuanqin&repo=SPI-simple-example)](https://github.com/uuanqin/SPI-simple-example)\n\nGitHub 仓库地址：[uuanqin/SPI-simple-example (github.com)](https://github.com/uuanqin/SPI-simple-example)\n\n# 本文参考\n\n- [Java SPI 机制详解 | JavaGuide](https://javaguide.cn/java/basis/spi.html#service-provider)\n- [10分钟让你彻底明白Java SPI，附实例代码演示#安员外很有码_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1RY4y1v7mN/)\n- [知识星球·编程导航 - 手写 RFC 框架](https://yuyuanweb.feishu.cn/wiki/EweIwSYsXiEvCDkzS8BcTiAonyc)\n- [SpringBoot的自动装配原理、自定义starter与spi机制，一网打尽_springboot 有很多的启动器 说一下启动器的自动装配原理-CSDN博客](https://blog.csdn.net/qq_33591903/article/details/119843446)","categories":[{"name":"技术学习","api":"api/categories/技术学习.json"}],"tags":[{"name":"API","api":"api/tags/API.json"},{"name":"SPI","api":"api/tags/SPI.json"},{"name":"ServiceLoader","api":"api/tags/ServiceLoader.json"},{"name":"Java","api":"api/tags/Java.json"}]},"api":"api/posts/p/acab999c.json"}