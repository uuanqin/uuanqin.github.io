{"data":{"title":"有谁还不会二叉树的遍历？","slug":"算法与数据结构/有谁还不会二叉树的遍历？","description":"别笑，你也想不出第二个方法...","date":"2023-11-28T08:26:49.000Z","updated":"2025-09-26T15:45:30.078Z","language":"zh-CN","comments":true,"url":"p/eca34904/","cover":"https://cdn.gallery.uuanqin.top/img/202509262338422.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">本文创建于 <code>231128</code>，于 <code>250925</code> 从笔记中进行迁移。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>二叉树的遍历问题非常经典，用递归方式实现非常简单。但当递归的程序栈交由自己管理时，事情还会简单吗？</p>\n<p>本文主要内容：</p>\n<ul>\n<li>树遍历的基本概念与特点</li>\n<li>层序遍历方式</li>\n<li>前、中、后序遍历的递归方式</li>\n<li>前、中、后序遍历的常规迭代方式</li>\n<li>前、中、后序遍历的模拟程序栈方式</li>\n<li>前、后序互转技巧</li>\n<li>Morris 算法</li>\n</ul>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"基本概念与特点\"><a class=\"markdownIt-Anchor\" href=\"#基本概念与特点\"></a> 基本概念与特点</h1>\n<p>系统地访问有序树的每个结点，使得对每个结点恰好访问一次，进行数据存取的过程称为有序树遍历算法。</p>\n<p>二叉树的遍历分为：</p>\n<ul>\n<li>先序遍历（前序遍历）：访问次序为根、左子树、右子树</li>\n<li>中序遍历：访问次序为左子树、根、右子树</li>\n<li>后序遍历：访问次序为左子树、右子树、根</li>\n<li>层次遍历</li>\n</ul>\n<p>所谓「序」即指根节点何时被访问。</p>\n<p>由遍历序列构造二叉树：</p>\n<ul>\n<li>唯一确定一棵二叉树（具体算法实现可看后文）：\n<ul>\n<li>先序序列 + 中序序列</li>\n<li>后序序列 + 中序序列</li>\n<li>层序序列 + 中序序列</li>\n</ul>\n</li>\n<li>无法唯一确定一棵二叉树：\n<ul>\n<li>先序序列 + 后序序列。但可以确定二叉树中结点的祖先关系：当两个结点的前序序列为 XY、后序序列为 YX 时，则 X 为 Y 的祖先。</li>\n</ul>\n</li>\n</ul>\n<p>在任意一棵二叉树的前序序列和后序序列中，各叶子之间相对次序关系都相同。叶子结点位于左右两个分支上，先序和后序的遍历属性均是左子树在右子树之前（相对次序一定相同），和二叉树的样式无关。</p>\n<h1 id=\"层序遍历\"><a class=\"markdownIt-Anchor\" href=\"#层序遍历\"></a> 层序遍历</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/description/\">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>自下而上、从右到左的层次遍历算法：利用原有的层次遍历算法，出队的同时将各个结点的指针入栈，在所有结点入栈后再从栈顶开始依次访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">levelOrder</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>)<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        q.offer(root);</span><br><span class=\"line\">        List&lt;Integer&gt; layer;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(q.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> q.size(); <span class=\"comment\">// 确定当前层次的层数</span></span><br><span class=\"line\">            layer = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;now;i++)&#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> q.poll();</span><br><span class=\"line\">                layer.add(node.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.left!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    q.offer(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.right!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    q.offer(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans.add(layer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：记树上所有节点的个数为 n。</p>\n<ul>\n<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>层序遍历特点：结点是一层一层加的。利用这个特点可以知道每一层的高度。比如维护 Map 数组记录每个结点的深度。</p>\n<p>如果不需要记录高度，需要在每层结点处理之间加入间隔，可以维护变量，在装入队列时记录下一层结点的个数。但实际上，遍历每层前队列的大小就是最好的间隔，如上面代码中的 <code>int now = q.size();</code>。</p>\n<h1 id=\"前-中-后序遍历的递归方法\"><a class=\"markdownIt-Anchor\" href=\"#前-中-后序遍历的递归方法\"></a> 前、中、后序遍历的递归方法</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟩 <a href=\"https://leetcode.cn/problems/binary-tree-preorder-traversal/\">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div>\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟩 <a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/description/\">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div>\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟩 <a href=\"https://leetcode.cn/problems/binary-tree-postorder-traversal/description/\">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Track</span><span class=\"params\">(BiTree *T)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 前序遍历visit于此</span></span><br><span class=\"line\">\tTrack(T-&gt;left);</span><br><span class=\"line\">\t<span class=\"comment\">// 中序遍历visit于此</span></span><br><span class=\"line\">\tTrack(T-&gt;right);</span><br><span class=\"line\">\t<span class=\"comment\">// 后序遍历visit于此</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>递归工作栈栈深恰好为树的深度。在最坏情况下，二叉树是有 n 个结点，深度为 n 的单支树，遍历算法的空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>别看上面的题目难度标识为简单，那只是对于递归方式实现而言。用迭代方式去实现可不一定简单。</p>\n<h1 id=\"前-中-后序遍历迭代方法\"><a class=\"markdownIt-Anchor\" href=\"#前-中-后序遍历迭代方法\"></a> 前、中、后序遍历迭代方法</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20231225170324.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<h2 id=\"前-中-后序遍历常规迭代方法\"><a class=\"markdownIt-Anchor\" href=\"#前-中-后序遍历常规迭代方法\"></a> 前、中、后序遍历常规迭代方法</h2>\n<p>前序遍历非递归：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span> || stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                ans.add(w.val); <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">                stack.push(w);</span><br><span class=\"line\">                w=w.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            w = w.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中序遍历非递归：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span> || stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                stack.push(w);</span><br><span class=\"line\">                w=w.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            ans.add(w.val); <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">            w = w.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前序遍历和中序遍历实现的不同之处，只在于访问环节的位置不同。</p>\n<p>后续遍历非递归：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">prev</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 维护上次 visit 过的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span> || stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                stack.push(w);</span><br><span class=\"line\">                w=w.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            w = stack.peek(); <span class=\"comment\">// 打算 visit 此中结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.right == <span class=\"literal\">null</span> || w.right == prev)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 右边没有可以遍历的了</span></span><br><span class=\"line\">                ans.add(w.val);</span><br><span class=\"line\">                prev = stack.pop();</span><br><span class=\"line\">                w = <span class=\"literal\">null</span>; <span class=\"comment\">// 目的是跳过前面的 while</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 右边可以遍历</span></span><br><span class=\"line\">                w = w.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后序遍历引入指针 <code>prev</code>，记录上一次遍历过的结点。这个非递归后序遍历特点是：栈中所有元素的结点均为该结点的祖先。</p>\n<p>后序遍历的方法是不是好像和前面的前序遍历、中序遍历的方法差别很大？不好记忆的话，可以使用文章后面提到的「根右左逆序」技巧。</p>\n<h2 id=\"前-中-后序遍历的模拟栈方法颜色标记法\"><a class=\"markdownIt-Anchor\" href=\"#前-中-后序遍历的模拟栈方法颜色标记法\"></a> 前、中、后序遍历的模拟栈方法（颜色标记法）</h2>\n<p>在上面的迭代方法中，看着各种嵌套循环可能会非常烧脑，导致「一看就会、一用就废」。不同遍历顺序的循环结构差异较大，增加记忆负担。LeetCode 中的网友 henry 介绍了一种简单的迭代方法，不同遍历的循环结构几乎一致，递归方式一样好懂。下面我将对其思想进行优化和解析。</p>\n<p>核心思想：</p>\n<ul>\n<li>为每个结点添加 <code>boolean</code> 类型的标记 <code>isUnfold</code>，表示一个结点是否进行「展开」过。新结点默认为「未展开」状态。</li>\n<li>不断获取栈中元素：\n<ul>\n<li>如果弹出的结点未展开。那么将弹出的结点自身标记为展开，然后按一定的顺序将其左右结点和自身入栈。</li>\n<li>如果弹出的结点已经展开。那么就 <code>visit</code> 该结点（加入答案数组），进入下一轮迭代。</li>\n</ul>\n</li>\n</ul>\n<p>下面演示的是前序遍历的代码。</p>\n<p>由于 henry 将这种做法成为「颜色标记法」，这里我就借「颜色」这个概念，新定义带标记的结点。颜色结点的包装代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ColorNode</span>&#123;</span><br><span class=\"line\">    TreeNode node;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> isUnfold; <span class=\"comment\">// 颜色标记</span></span><br><span class=\"line\">    ColorNode(TreeNode node)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.node = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 展开结点</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ColorNode <span class=\"title function_\">unFold</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.isUnfold = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前序遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;ColorNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>)<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"type\">ColorNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(root);</span><br><span class=\"line\">        stack.push(w);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.isUnfold)&#123;</span><br><span class=\"line\">                ans.add(w.node.val);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 右 - 左 - 中 依次入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.node.right!=<span class=\"literal\">null</span>)stack.push(<span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(w.node.right));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.node.left!=<span class=\"literal\">null</span>)stack.push(<span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(w.node.left));</span><br><span class=\"line\">            stack.push(w.unFold());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中序遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;ColorNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>)<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"type\">ColorNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(root);</span><br><span class=\"line\">        stack.push(w);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.isUnfold)&#123;</span><br><span class=\"line\">                ans.add(w.node.val);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 右 - 中 - 左 依次入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.node.right!=<span class=\"literal\">null</span>)stack.push(<span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(w.node.right));</span><br><span class=\"line\">            stack.push(w.unFold());</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.node.left!=<span class=\"literal\">null</span>)stack.push(<span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(w.node.left));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后序遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;ColorNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>)<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"type\">ColorNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(root);</span><br><span class=\"line\">        stack.push(w);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.isUnfold)&#123;</span><br><span class=\"line\">                ans.add(w.node.val);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 中 - 右 - 左 依次入栈</span></span><br><span class=\"line\">            stack.push(w.unFold());</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.node.right!=<span class=\"literal\">null</span>)stack.push(<span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(w.node.right));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.node.left!=<span class=\"literal\">null</span>)stack.push(<span class=\"keyword\">new</span> <span class=\"title class_\">ColorNode</span>(w.node.left));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>「颜色标记法」入栈方式特别像递归，其的原理在于我们通过代码模拟了递归的过程，只不过递归时是程序中的方法调用栈，这里是用代码模拟这个栈。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509262333213.webp\" alt=\"image.png\" /></p>\n<p>至此，也许你已经快速掌握了更加容易记得非递归遍历二叉树的方式。注意到，先序遍历的写法中还可以存在优化的地方。先序遍历中「右 - 左 - 中」依次入栈后，下一轮迭代中，解折叠后的「中」会首先弹出来并加入答案中，看起来上下两次迭代中，对于「中」结点的入栈和出栈可以在一次迭代中完成。</p>\n<p>在一次迭代中，我们可以把解折叠后的「中」结点直接加入答案数组不再压栈。这样的话，<code>isUnFold</code> 的结点状态标记就没意义了，我们可以把颜色结点退化为基本的树结点。</p>\n<p>先序遍历简化写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w!=<span class=\"literal\">null</span>)stack.push(w);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            ans.add(w.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.right!=<span class=\"literal\">null</span>)stack.push(w.right);</span><br><span class=\"line\">            <span class=\"comment\">// ans.add(w.val); // 也可以写在这，反正不入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.left!=<span class=\"literal\">null</span>)stack.push(w.left);</span><br><span class=\"line\">            <span class=\"comment\">// ans.add(w.val); // 也可以写在这，反正不入栈</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"翻转前序遍历结果可得到后序遍历结果\"><a class=\"markdownIt-Anchor\" href=\"#翻转前序遍历结果可得到后序遍历结果\"></a> 翻转前序遍历结果可得到后序遍历结果</h2>\n<p>前序遍历中遍历结点的顺序为：访问根 - 遍历左子树 - 遍历右子树。访问根后，我们往往会将子树进行压栈处理。如果我们进行以下调整：</p>\n<ul>\n<li>调整子树的压栈顺序：访问根 - 遍历右子树 - 遍历左子树。（根 - 右 - 左）</li>\n<li>把最终的结果逆序排列。（左 - 右 - 根）<br />\n最终得到的遍历结果，就是后序遍历的结果！我们将「根 - 左 - 右」变为了「左 - 右 - 根」。</li>\n</ul>\n<p>我们尝试把上一小节提到的前序遍历的几种非递归方式，使用「翻转前序遍历结果」的方法，将前序遍历改造为「后序遍历」。</p>\n<p>常规迭代方法的后续遍历「根右左逆序」版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span> || stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(w!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                ans.add(w.val); </span><br><span class=\"line\">                stack.push(w);</span><br><span class=\"line\">                w=w.right; <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            w = w.left; <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.reverse(ans); <span class=\"comment\">// 数组翻转</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模拟栈方法，后序遍历「根右左逆序」版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w!=<span class=\"literal\">null</span>)stack.push(w);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(stack.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            w = stack.pop();</span><br><span class=\"line\">            ans.add(w.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.left!=<span class=\"literal\">null</span>)stack.push(w.left); <span class=\"comment\">// 变动</span></span><br><span class=\"line\">            <span class=\"comment\">// ans.add(w.val); // 也可以写在这</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w.right!=<span class=\"literal\">null</span>)stack.push(w.right); <span class=\"comment\">// 变动</span></span><br><span class=\"line\">            <span class=\"comment\">// ans.add(w.val); // 也可以写在这</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.reverse(ans); <span class=\"comment\">// 翻转数组</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线索二叉树morris-算法\"><a class=\"markdownIt-Anchor\" href=\"#线索二叉树morris-算法\"></a> 线索二叉树——Morris 算法</h2>\n<p>本节介绍一种巧妙的方法可以在线性时间内，只占用常数空间来实现树的前、中、后序遍历。这种方法由 Joseph M. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p>\n<p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。</p>\n<p>Morris 遍历可以将非递归遍历中的空间复杂度降为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。从而实现时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，而空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的精妙算法。</p>\n<h3 id=\"实现原则\"><a class=\"markdownIt-Anchor\" href=\"#实现原则\"></a> 实现原则</h3>\n<p>记作当前节点为 <code>cur</code>。</p>\n<ol>\n<li>如果 <code>cur</code> 无左孩子，<code>cur</code> 向右移动（<code>cur=cur.right</code>）</li>\n<li>如果 <code>cur</code> 有左孩子，找到 <code>cur</code> 左子树上最右的节点，记为 <code>mostright</code>\n<ol>\n<li>如果 <code>mostright</code> 的 <code>right</code> 指针指向空，让其指向 <code>cur</code>，<code>cur</code> 向左移动（<code>cur=cur.left</code>）</li>\n<li>如果 <code>mostright</code> 的 <code>right</code> 指针指向 <code>cur</code>，让其指向空，<code>cur</code> 向右移动（<code>cur=cur.right</code>）</li>\n</ol>\n</li>\n</ol>\n<p>实现以上的原则，即实现了 Morris 遍历。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Traversal</span><span class=\"params\">(<span class=\"keyword\">struct</span> TreeNode* root, <span class=\"type\">int</span>* returnSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">cur</span> =</span> root, *mostright = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        mostright = cur-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mostright != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 条件A、条件B都不满足 就一直找最右</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (mostright-&gt;right != <span class=\"literal\">NULL</span> &amp;&amp; mostright-&gt;right != cur)</span><br><span class=\"line\">                mostright = mostright-&gt;right;</span><br><span class=\"line\">                </span><br><span class=\"line\">            <span class=\"comment\">// 只满足条件A</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mostright-&gt;right == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                cur 前序遍历点位 <span class=\"number\">1</span>/<span class=\"number\">2</span></span><br><span class=\"line\">                mostright-&gt;right = cur;</span><br><span class=\"line\">                cur = cur-&gt;left;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 只满足条件B </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mostright-&gt;right = <span class=\"literal\">NULL</span>;    </span><br><span class=\"line\">                cur 中序遍历点位 <span class=\"number\">1</span>/<span class=\"number\">2</span></span><br><span class=\"line\">                <span class=\"comment\">// 预告：接下来将cur移动到右子树上</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// mostright == NULL </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cur 前序遍历点位 <span class=\"number\">2</span>/<span class=\"number\">2</span>      </span><br><span class=\"line\">            cur 中序遍历点位 <span class=\"number\">2</span>/<span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"comment\">// 预告：接下来将cur移动到右子树上</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = cur-&gt;right;                <span class=\"comment\">// 将cur移动到右子树上</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// end while</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20230729005245.png\" alt=\"image.png\" /></p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20230729005252.png\" alt=\"image.png\" /></p>\n<ul>\n<li>后序遍历可以首先按照<strong>根右左</strong>的顺序遍历整棵树，最后将结果翻转一下即可。因此此写法和 <code>Morris</code> 前序遍历相同，区别在于 <code>left</code> 和 <code>right</code> 全部交换即可。</li>\n</ul>\n<h1 id=\"给定两种遍历顺序确定一棵二叉树\"><a class=\"markdownIt-Anchor\" href=\"#给定两种遍历顺序确定一棵二叉树\"></a> 给定两种遍历顺序确定一棵二叉树</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/\">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的先序遍历，<code>inorder</code> 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>\n</div></div><h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>408 思维导图解耦</li>\n<li>研究生课程《离散数学》树的遍历相关内容</li>\n<li>LeetCode 相关题目题解</li>\n<li>⭐推荐：<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/25220/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/\">颜色标记法，一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded binary tree - Wikipedia</a></li>\n</ul>\n","raw":"---\ntitle: 有谁还不会二叉树的遍历？\ntags:\n  - Java\n  - C\n  - 二叉树\ncover: 'https://cdn.gallery.uuanqin.top/img/202509262338422.webp'\ndescription: 别笑，你也想不出第二个方法...\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: eca34904\ndate: 2023-11-28 16:26:49\ntop_img:\n---\n\n> [!note] 本文创建于 `231128`，于 `250925` 从笔记中进行迁移。\n\n二叉树的遍历问题非常经典，用递归方式实现非常简单。但当递归的程序栈交由自己管理时，事情还会简单吗？\n\n本文主要内容：\n\n- 树遍历的基本概念与特点\n- 层序遍历方式\n- 前、中、后序遍历的递归方式\n- 前、中、后序遍历的常规迭代方式\n- 前、中、后序遍历的模拟程序栈方式\n- 前、后序互转技巧\n- Morris 算法\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 基本概念与特点\n\n系统地访问有序树的每个结点，使得对每个结点恰好访问一次，进行数据存取的过程称为有序树遍历算法。\n\n二叉树的遍历分为：\n\n- 先序遍历（前序遍历）：访问次序为根、左子树、右子树\n- 中序遍历：访问次序为左子树、根、右子树\n- 后序遍历：访问次序为左子树、右子树、根\n- 层次遍历\n\n所谓「序」即指根节点何时被访问。\n\n由遍历序列构造二叉树：\n\n- 唯一确定一棵二叉树（具体算法实现可看后文）：\n\t- 先序序列 + 中序序列\n\t- 后序序列 + 中序序列\n\t- 层序序列 + 中序序列\n- 无法唯一确定一棵二叉树：\n\t- 先序序列 + 后序序列。但可以确定二叉树中结点的祖先关系：当两个结点的前序序列为 XY、后序序列为 YX 时，则 X 为 Y 的祖先。\n\n在任意一棵二叉树的前序序列和后序序列中，各叶子之间相对次序关系都相同。叶子结点位于左右两个分支上，先序和后序的遍历属性均是左子树在右子树之前（相对次序一定相同），和二叉树的样式无关。\n\n# 层序遍历\n\n> [!example] 🟨 [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)\n\n自下而上、从右到左的层次遍历算法：利用原有的层次遍历算法，出队的同时将各个结点的指针入栈，在所有结点入栈后再从栈顶开始依次访问。\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if(root==null)return new ArrayList<>();\n        Deque<TreeNode> q = new LinkedList<>();\n        List<List<Integer>> ans = new ArrayList<>();\n        q.offer(root);\n        List<Integer> layer;\n        while(q.size()>0){\n            int now = q.size(); // 确定当前层次的层数\n            layer = new ArrayList<>();\n            for(int i=0;i<now;i++){\n                TreeNode node = q.poll();\n                layer.add(node.val);\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            ans.add(layer);\n        }\n        return ans;\n    }\n}\n```\n\n复杂度分析：记树上所有节点的个数为 n。\n\n- 时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 $O(n)$。\n- 空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 $O(n)$。\n\n层序遍历特点：结点是一层一层加的。利用这个特点可以知道每一层的高度。比如维护 Map 数组记录每个结点的深度。\n\n如果不需要记录高度，需要在每层结点处理之间加入间隔，可以维护变量，在装入队列时记录下一层结点的个数。但实际上，遍历每层前队列的大小就是最好的间隔，如上面代码中的 `int now = q.size();`。\n\n# 前、中、后序遍历的递归方法\n\n> [!example] 🟩 [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n\n> [!example] 🟩 [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)\n\n> [!example] 🟩 [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)\n\n```c\nvoid Track(BiTree *T){\n\tif(T==NULL)return;\n\t// 前序遍历visit于此\n\tTrack(T->left);\n\t// 中序遍历visit于此\n\tTrack(T->right);\n\t// 后序遍历visit于此\n}\n```\n\n递归工作栈栈深恰好为树的深度。在最坏情况下，二叉树是有 n 个结点，深度为 n 的单支树，遍历算法的空间复杂度为 $O(n)$。\n\n别看上面的题目难度标识为简单，那只是对于递归方式实现而言。用迭代方式去实现可不一定简单。\n\n# 前、中、后序遍历迭代方法\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/20231225170324.webp)\n\n## 前、中、后序遍历常规迭代方法\n\n前序遍历非递归：\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        TreeNode w = root;\n        while(w!=null || stack.size()>0){\n            while(w!=null){\n                ans.add(w.val); // 变动点\n                stack.push(w);\n                w=w.left;\n            }\n            w = stack.pop();\n            w = w.right;\n        }\n        return ans;\n    }\n}\n```\n\n中序遍历非递归：\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        TreeNode w = root;\n        while(w!=null || stack.size()>0){\n            while(w!=null){\n                stack.push(w);\n                w=w.left;\n            }\n            w = stack.pop();\n            ans.add(w.val); // 变动点\n            w = w.right;\n        }\n        return ans;\n    }\n}\n```\n\n前序遍历和中序遍历实现的不同之处，只在于访问环节的位置不同。\n\n后续遍历非递归：\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        TreeNode w = root;\n        TreeNode prev = null; // 维护上次 visit 过的结点\n        while(w!=null || stack.size()>0){\n            while(w!=null){\n                stack.push(w);\n                w=w.left;\n            }\n            w = stack.peek(); // 打算 visit 此中结点\n            if(w.right == null || w.right == prev){\n                // 右边没有可以遍历的了\n                ans.add(w.val);\n                prev = stack.pop();\n                w = null; // 目的是跳过前面的 while\n            }else{\n                // 右边可以遍历\n                w = w.right;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n后序遍历引入指针 `prev`，记录上一次遍历过的结点。这个非递归后序遍历特点是：栈中所有元素的结点均为该结点的祖先。\n\n后序遍历的方法是不是好像和前面的前序遍历、中序遍历的方法差别很大？不好记忆的话，可以使用文章后面提到的「根右左逆序」技巧。\n\n## 前、中、后序遍历的模拟栈方法（颜色标记法）\n\n在上面的迭代方法中，看着各种嵌套循环可能会非常烧脑，导致「一看就会、一用就废」。不同遍历顺序的循环结构差异较大，增加记忆负担。LeetCode 中的网友 henry 介绍了一种简单的迭代方法，不同遍历的循环结构几乎一致，递归方式一样好懂。下面我将对其思想进行优化和解析。\n\n核心思想：\n\n- 为每个结点添加 `boolean` 类型的标记 `isUnfold`，表示一个结点是否进行「展开」过。新结点默认为「未展开」状态。\n- 不断获取栈中元素：\n\t- 如果弹出的结点未展开。那么将弹出的结点自身标记为展开，然后按一定的顺序将其左右结点和自身入栈。\n\t- 如果弹出的结点已经展开。那么就 `visit` 该结点（加入答案数组），进入下一轮迭代。\n\n下面演示的是前序遍历的代码。\n\n由于 henry 将这种做法成为「颜色标记法」，这里我就借「颜色」这个概念，新定义带标记的结点。颜色结点的包装代码如下：\n\n```java\nclass ColorNode{\n    TreeNode node;\n    boolean isUnfold; // 颜色标记\n    ColorNode(TreeNode node){\n        this.node = node;\n    }\n    // 展开结点\n    public ColorNode unFold(){\n        this.isUnfold = true;\n        return this;\n    }\n}\n```\n\n前序遍历：\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        Deque<ColorNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        if(root==null)return ans;\n        ColorNode w = new ColorNode(root);\n        stack.push(w);\n        while(stack.size()>0){\n            w = stack.pop();\n            if(w.isUnfold){\n                ans.add(w.node.val);\n                continue;\n            }\n            // 右 - 左 - 中 依次入栈\n            if(w.node.right!=null)stack.push(new ColorNode(w.node.right));\n            if(w.node.left!=null)stack.push(new ColorNode(w.node.left));\n            stack.push(w.unFold());\n        }\n        return ans;\n    }\n}\n```\n\n中序遍历：\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        Deque<ColorNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        if(root==null)return ans;\n        ColorNode w = new ColorNode(root);\n        stack.push(w);\n        while(stack.size()>0){\n            w = stack.pop();\n            if(w.isUnfold){\n                ans.add(w.node.val);\n                continue;\n            }\n            // 右 - 中 - 左 依次入栈\n            if(w.node.right!=null)stack.push(new ColorNode(w.node.right));\n            stack.push(w.unFold());\n            if(w.node.left!=null)stack.push(new ColorNode(w.node.left));\n        }\n        return ans;\n    }\n}\n```\n\n后序遍历：\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        Deque<ColorNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        if(root==null)return ans;\n        ColorNode w = new ColorNode(root);\n        stack.push(w);\n        while(stack.size()>0){\n            w = stack.pop();\n            if(w.isUnfold){\n                ans.add(w.node.val);\n                continue;\n            }\n            // 中 - 右 - 左 依次入栈\n            stack.push(w.unFold());\n            if(w.node.right!=null)stack.push(new ColorNode(w.node.right));\n            if(w.node.left!=null)stack.push(new ColorNode(w.node.left));\n        }\n        return ans;\n    }\n}\n```\n\n「颜色标记法」入栈方式特别像递归，其的原理在于我们通过代码模拟了递归的过程，只不过递归时是程序中的方法调用栈，这里是用代码模拟这个栈。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202509262333213.webp)\n\n至此，也许你已经快速掌握了更加容易记得非递归遍历二叉树的方式。注意到，先序遍历的写法中还可以存在优化的地方。先序遍历中「右 - 左 - 中」依次入栈后，下一轮迭代中，解折叠后的「中」会首先弹出来并加入答案中，看起来上下两次迭代中，对于「中」结点的入栈和出栈可以在一次迭代中完成。\n\n在一次迭代中，我们可以把解折叠后的「中」结点直接加入答案数组不再压栈。这样的话，`isUnFold` 的结点状态标记就没意义了，我们可以把颜色结点退化为基本的树结点。\n\n先序遍历简化写法：\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        TreeNode w = root;\n        if(w!=null)stack.push(w);\n        while(stack.size()>0){\n            w = stack.pop();\n            ans.add(w.val);\n            if(w.right!=null)stack.push(w.right);\n            // ans.add(w.val); // 也可以写在这，反正不入栈\n            if(w.left!=null)stack.push(w.left);\n            // ans.add(w.val); // 也可以写在这，反正不入栈\n        }\n        return ans;\n    }\n}\n```\n\n## 翻转前序遍历结果可得到后序遍历结果\n\n前序遍历中遍历结点的顺序为：访问根 - 遍历左子树 - 遍历右子树。访问根后，我们往往会将子树进行压栈处理。如果我们进行以下调整：\n\n- 调整子树的压栈顺序：访问根 - 遍历右子树 - 遍历左子树。（根 - 右 - 左）\n- 把最终的结果逆序排列。（左 - 右 - 根）\n最终得到的遍历结果，就是后序遍历的结果！我们将「根 - 左 - 右」变为了「左 - 右 - 根」。\n\n我们尝试把上一小节提到的前序遍历的几种非递归方式，使用「翻转前序遍历结果」的方法，将前序遍历改造为「后序遍历」。\n\n常规迭代方法的后续遍历「根右左逆序」版本：\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        TreeNode w = root;\n        while(w!=null || stack.size()>0){\n            while(w!=null){\n                ans.add(w.val); \n                stack.push(w);\n                w=w.right; // 变动点\n            }\n            w = stack.pop();\n            w = w.left; // 变动点\n        }\n        Collections.reverse(ans); // 数组翻转\n        return ans;\n    }\n}\n```\n\n模拟栈方法，后序遍历「根右左逆序」版本：\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        Deque<TreeNode> stack = new LinkedList<>();\n        List<Integer> ans = new ArrayList<>();\n        TreeNode w = root;\n        if(w!=null)stack.push(w);\n        while(stack.size()>0){\n            w = stack.pop();\n            ans.add(w.val);\n            if(w.left!=null)stack.push(w.left); // 变动\n            // ans.add(w.val); // 也可以写在这\n            if(w.right!=null)stack.push(w.right); // 变动\n            // ans.add(w.val); // 也可以写在这\n        }\n        Collections.reverse(ans); // 翻转数组\n        return ans;\n    }\n}\n```\n\n## 线索二叉树——Morris 算法\n\n本节介绍一种巧妙的方法可以在线性时间内，只占用常数空间来实现树的前、中、后序遍历。这种方法由 Joseph M. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。\n\nMorris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。\n\nMorris 遍历可以将非递归遍历中的空间复杂度降为 $O(1)$。从而实现时间复杂度为 $O(N)$，而空间复杂度为 $O(1)$ 的精妙算法。\n\n### 实现原则\n\n记作当前节点为 `cur`。\n\n1. 如果 `cur` 无左孩子，`cur` 向右移动（`cur=cur.right`）\n2. 如果 `cur` 有左孩子，找到 `cur` 左子树上最右的节点，记为 `mostright`\n    1. 如果 `mostright` 的 `right` 指针指向空，让其指向 `cur`，`cur` 向左移动（`cur=cur.left`）\n    2. 如果 `mostright` 的 `right` 指针指向 `cur`，让其指向空，`cur` 向右移动（`cur=cur.right`）\n\n实现以上的原则，即实现了 Morris 遍历。\n\n```C\nvoid Traversal(struct TreeNode* root, int* returnSize) {\n    struct TreeNode *cur = root, *mostright = NULL;\n\n    while (cur != NULL) {\n        mostright = cur->left;\n        if (mostright != NULL) {\n            // 条件A、条件B都不满足 就一直找最右\n            while (mostright->right != NULL && mostright->right != cur)\n                mostright = mostright->right;\n                \n            // 只满足条件A\n            if (mostright->right == NULL) {\n                cur 前序遍历点位 1/2\n                mostright->right = cur;\n                cur = cur->left;\n                continue;\n            }\n            // 只满足条件B \n            else {\n                mostright->right = NULL;    \n                cur 中序遍历点位 1/2\n                // 预告：接下来将cur移动到右子树上\n            }\n        }\n        // mostright == NULL \n        else {\n            cur 前序遍历点位 2/2      \n            cur 中序遍历点位 2/2\n            // 预告：接下来将cur移动到右子树上\n        }\n        cur = cur->right;                // 将cur移动到右子树上\n    } // end while\n}\n```\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20230729005245.png)\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20230729005252.png)\n\n- 后序遍历可以首先按照**根右左**的顺序遍历整棵树，最后将结果翻转一下即可。因此此写法和 `Morris` 前序遍历相同，区别在于 `left` 和 `right` 全部交换即可。\n\n# 给定两种遍历顺序确定一棵二叉树\n\n> [!example] 🟨 [105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)\n> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的先序遍历，`inorder` 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n\n# 本文参考\n\n- 408 思维导图解耦\n- 研究生课程《离散数学》树的遍历相关内容\n- LeetCode 相关题目题解\n- ⭐推荐：[颜色标记法，一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/25220/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/)\n- [Threaded binary tree - Wikipedia](https://en.wikipedia.org/wiki/Threaded_binary_tree)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"C","api":"api/tags/C.json"},{"name":"Java","api":"api/tags/Java.json"},{"name":"二叉树","api":"api/tags/二叉树.json"}]},"api":"api/posts/p/eca34904.json"}