{"data":{"title":"RM 和 EDF 任务调度算法在 μCOSII 上的实现","slug":"嵌入式/RM 和 EDF 任务调度算法在 μCOSII 上的实现","description":"实时操作系统实验 2 实现 RM 和 EDF","date":"2024-06-22T08:29:41.000Z","updated":"2025-01-14T03:49:50.952Z","language":"zh-CN","comments":true,"url":"p/b1c2eea4/","cover":"https://cdn.gallery.uuanqin.top/img/20240622164030.webp","images":[],"content":"<blockquote>\n<p>文章写作背景为《实时系统设计》课程实验二。写这篇东西掉了好多头发🤬。</p>\n</blockquote>\n<p>源码在文章后。</p>\n<h1 id=\"实验介绍\"><a class=\"markdownIt-Anchor\" href=\"#实验介绍\"></a> 实验介绍</h1>\n<p>实验目的：</p>\n<ol>\n<li>熟悉嵌入式实时操作系统 μC/OS 代码结构。</li>\n<li>理解、设计和实现 RM 和 EDF 等算法，调研相关技术。</li>\n<li>在 μC/OS 上使用 VC 运行和调试设计的程序。</li>\n</ol>\n<p>实验环境：</p>\n<ol>\n<li>操作系统：μC/OS-II</li>\n<li>软件：Microsoft Visual C++ 6.0</li>\n</ol>\n<p>实验原理：</p>\n<ol>\n<li>RM 算法。RM(Rate Monotonic) 算法根据周期任务的释放频率，即周期的长短来分配任务的优先级，周期越短的任务优先级越高。当 Di=Ti 时，RM 算法是最优的固定优先级调度算法。如有两个实时任务τA（TA=25，CA=10）、τB（TB=40，CB=10）和τC（TC=100，CC=20），采用 RM 算法调度如下图所示：</li>\n</ol>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240621132520.webp\" alt=\"image.png\" /></p>\n<ol start=\"2\">\n<li>EDF 算法的实现。EDF(Earliest Deadline First) 算法按照实时任务的绝对截止时间来分配优先级，截止时间越近的优先级越高。EDF 算法是最优的动态优先级调度算法。如有两个实时任务τ1（C1=1，D1=3,T1=4）和τ2（C2=2,D2=4,T2=6），采用 EDF 算法调度如下图所示：</li>\n</ol>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240621132534.webp\" alt=\"image.png\" /></p>\n<h1 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"#步骤\"></a> 步骤</h1>\n<h2 id=\"基本认识\"><a class=\"markdownIt-Anchor\" href=\"#基本认识\"></a> 基本认识</h2>\n<p>熟读课件和相关源码片段，我们有以下基本认识：</p>\n<ul>\n<li>任务在 <code>main.c</code> 中创建，新建任务后会生成对应的 TCB 程序控制块（定义在 <code>ucos-ii.h</code> 中的 OS_TCB），并链接到 TCB 链表头中，链表尾是程序创建的空闲任务。</li>\n<li>实验程序我们需要手动模拟时间中断，以触发 <code>OSTimeTick()</code></li>\n<li><code>OSTimeTick()</code> 会遍历任务链表，检查它们的延时。</li>\n<li><code>OS_SchedNew()</code> 是用来设定最高优先级的。默认实现是找就绪组就绪表。我们可以在里面动手脚，直接写我们的调度算法。</li>\n<li><code>OSTimeTick()</code> 调用 <code>OSIntExit()</code>，<code>OSIntExit()</code> 中又 <code>OS_SchedNew()</code>。所以每一次 <code>OSTimeTick()</code> 到来时，都有机会判断当前最高优先级的任务是什么。</li>\n</ul>\n<h2 id=\"为-tcb-块添加扩展\"><a class=\"markdownIt-Anchor\" href=\"#为-tcb-块添加扩展\"></a> 为 TCB 块添加扩展</h2>\n<p>无论是 RM 算法还是 EDF 算法，都需要使用扩展的 TCB 块存储任务优先级数据。统一的扩展数据结构为不同算法的实现方式进行简化。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ucos_ii.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcb_ext_info</span>&#123;</span></span><br><span class=\"line\">\tINT32U c;      <span class=\"comment\">// 保存C</span></span><br><span class=\"line\">\tINT32U t;      <span class=\"comment\">// 保存T 周期</span></span><br><span class=\"line\">\tINT32U d;      <span class=\"comment\">// 保存D 截止时间（EDF算法）</span></span><br><span class=\"line\">\tINT32U rest_c; <span class=\"comment\">// 保存剩余工作时间</span></span><br><span class=\"line\">\tINT32U <span class=\"type\">rest_t</span>; <span class=\"comment\">// 保存周期内剩余的事件</span></span><br><span class=\"line\">\tINT32U rest_d; <span class=\"comment\">// 保存当前时间与截至时间的差值（EDF算法）</span></span><br><span class=\"line\">\tINT32U task_id;<span class=\"comment\">// 任务ID</span></span><br><span class=\"line\">\tINT8U is_pend; <span class=\"comment\">// 判断任务是否挂起（需要手动设置的标记位）</span></span><br><span class=\"line\">&#125; tcb_ext_info;</span><br></pre></td></tr></table></figure>\n<h2 id=\"任务创建\"><a class=\"markdownIt-Anchor\" href=\"#任务创建\"></a> 任务创建</h2>\n<p>main 函数中首先要求输入一个任务数量 <code>TasksNum</code>，根据 <code>TasksNum</code> 进行迭代，持续获取每个任务的基本信息：</p>\n<ol>\n<li>C 计算时间</li>\n<li>T 周期</li>\n<li>D 截止时间（EDF 算法）</li>\n</ol>\n<p>并对其余记录进行填充：</p>\n<ol>\n<li>剩余计算时间</li>\n<li>周期内剩余时间</li>\n<li>剩余截止时间（EDF 算法）</li>\n<li>任务 id</li>\n<li>初始化 <code>is_pend</code> 为 0</li>\n</ol>\n<p><code>timeSetEvent</code> 将模拟时钟中断。</p>\n<p>宏 <code>LAB2_EDF</code> 决定当前使用的是 EDF 算法还是 RM 算法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> TasksNum,i,C,T;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> D;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\ttcb_ext_info* task_info_array = (tcb_ext_info*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(tcb_ext_info)*TasksNum);</span><br><span class=\"line\"></span><br><span class=\"line\">\tVCInit();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 输入提示</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;EDF算法实验。请输入任务数：\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;RM 算法实验。请输入任务数：\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;TasksNum);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TasksNum&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;无效的输入!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(<span class=\"number\">1</span>); \t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tOSInit();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;TasksNum;i++)&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// EDF 每个任务三个参数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>,&amp;C,&amp;D,&amp;T);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\t<span class=\"comment\">// RM 每个任务两个参数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;C,&amp;T);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttask_info_array[i].c = C;</span><br><span class=\"line\">\t\ttask_info_array[i].t = T;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttask_info_array[i].rest_c = C;</span><br><span class=\"line\">\t\ttask_info_array[i].<span class=\"type\">rest_t</span> = T;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttask_info_array[i].task_id = i;</span><br><span class=\"line\">\t\ttask_info_array[i].is_pend = <span class=\"number\">0</span>;  <span class=\"comment\">// 初始为不挂起</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">\t\ttask_info_array[i].d = D;</span><br><span class=\"line\">\t\ttask_info_array[i].rest_d = D;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\tOSTaskCreateExt(</span><br><span class=\"line\">\t\t\tFirstTask, </span><br><span class=\"line\">\t\t\t<span class=\"number\">0</span>, </span><br><span class=\"line\">\t\t\t&amp;TaskStk[i+<span class=\"number\">5</span>][TASK_STK_SIZE<span class=\"number\">-1</span>], </span><br><span class=\"line\">\t\t\ti+<span class=\"number\">5</span>,  <span class=\"comment\">//设置互不冲突的数即可</span></span><br><span class=\"line\">\t\t\ti,  <span class=\"comment\">// 任务ID</span></span><br><span class=\"line\">\t\t\t&amp;TaskStk[i+<span class=\"number\">5</span>][<span class=\"number\">0</span>], </span><br><span class=\"line\">\t\t\tTASK_STK_SIZE,</span><br><span class=\"line\">\t\t\t(<span class=\"type\">void</span> *)&amp;task_info_array[i],</span><br><span class=\"line\">\t\t\tOS_TASK_OPT_NONE  <span class=\"comment\">// opt</span></span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 模拟时钟中断</span></span><br><span class=\"line\">\ttimeSetEvent(<span class=\"number\">1000</span>/OS_TICKS_PER_SEC, <span class=\"number\">0</span>, OSTickISRuser, <span class=\"number\">0</span>, TIME_PERIODIC);</span><br><span class=\"line\"></span><br><span class=\"line\">\tOSStart();\t       </span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>OSTaskCreateExt</code> 创建任务，传入扩展信息块的指针。</p>\n<p><code>FirstTask</code> 中为死循环，什么也不用做。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FirstTask</span><span class=\"params\">(<span class=\"type\">void</span> *pParam)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时钟中断\"><a class=\"markdownIt-Anchor\" href=\"#时钟中断\"></a> 时钟中断</h2>\n<p>每次时钟嘀嗒到来时，完成以下操作：</p>\n<ul>\n<li>将当前运行任务的计算时间减 1\n<ul>\n<li>如果任务计算完毕则挂起</li>\n</ul>\n</li>\n<li>遍历 TCB 链表，将剩余周期减 1</li>\n<li>遍历 TCB 链表，将剩余截止时间减 1（EDF 算法）</li>\n<li>遍历 TCB 链表，检查是否有任务需要恢复。如果需要恢复则重置一下参数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">OSTimeTick</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    OS_TCB    *ptcb;</span><br><span class=\"line\">    <span class=\"comment\">/*********** 此位置源码省略 ***************/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (OSRunning == OS_TRUE) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/*********** 此位置源码省略 ***************/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tptcb = OSTCBList;  <span class=\"comment\">/* Point at first TCB in TCB list               */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// lab2 c--;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(OSTCBCur-&gt;OSTCBPrio != OS_TASK_IDLE_PRIO)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;rest_c &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 剩余有计算时间则减减</span></span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;rest_c--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%-10d 任务%d compute... 执行计算工作\\n&quot;</span>,OSTimeGet(),((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;task_id);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;rest_c == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 任务的计算时间归零，设置任务为挂起状态</span></span><br><span class=\"line\">\t\t\t\t\t((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;is_pend = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%-10d 任务%d complete! 挂起 \\n&quot;</span>,OSTimeGet(),((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;task_id);</span><br><span class=\"line\">\t\t\t\t\tOSTaskSuspend(OSTCBCur-&gt;OSTCBPrio);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ptcb-&gt;OSTCBPrio != OS_TASK_IDLE_PRIO) &#123;     <span class=\"comment\">/* Go through all TCBs in TCB list              */</span></span><br><span class=\"line\">            OS_ENTER_CRITICAL();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Lab2 所有的任务的剩余周期和剩余截止时间都减1（除了空闲任务后的两个任务）</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ptcb-&gt;OSTCBPrio&lt;OS_TASK_IDLE_PRIO<span class=\"number\">-2</span> )&#123; </span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;<span class=\"type\">rest_t</span>--;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;rest_d--;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 恢复任务（除了空闲任务后的两个任务）</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>( ptcb-&gt;OSTCBPrio&lt;OS_TASK_IDLE_PRIO<span class=\"number\">-2</span> &amp;&amp; OSTimeGet() % ((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 当前时间为任务周期整数倍时恢复任务</span></span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;rest_c=((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;c;</span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;<span class=\"type\">rest_t</span>=((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;t;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;rest_d=((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;d;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置任务为未挂起状态</span></span><br><span class=\"line\">\t\t\t\t((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;is_pend = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tOSTaskResume(ptcb-&gt;OSTCBPrio);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*********** 此位置源码省略 ***************/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>遍历的时候不要处理一些无关的任务，比如空闲任务，甚至统计任务等莫名奇妙的任务。所以有类似 <code>ptcb-&gt;OSTCBPrio&lt;OS_TASK_IDLE_PRIO-2</code> 这种判定条件。</p>\n</blockquote>\n<h2 id=\"任务抢占输出\"><a class=\"markdownIt-Anchor\" href=\"#任务抢占输出\"></a> 任务抢占输出</h2>\n<p>任务抢占将调用 <code>OSIntExit()</code>，如果最高优先级不是当前任务的优先级时判定为任务抢占。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">OSIntExit</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> OS_CRITICAL_METHOD == 3u                               <span class=\"comment\">/* Allocate storage for CPU status register */</span></span></span><br><span class=\"line\">    OS_CPU_SR  cpu_sr = <span class=\"number\">0u</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (OSRunning == OS_TRUE) &#123;</span><br><span class=\"line\">        OS_ENTER_CRITICAL();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OSIntNesting &gt; <span class=\"number\">0u</span>) &#123;                           <span class=\"comment\">/* Prevent OSIntNesting from wrapping       */</span></span><br><span class=\"line\">            OSIntNesting--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (OSIntNesting == <span class=\"number\">0u</span>) &#123;                          <span class=\"comment\">/* Reschedule only if all ISRs complete ... */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (OSLockNesting == <span class=\"number\">0u</span>) &#123;                     <span class=\"comment\">/* ... and not locked.                      */</span></span><br><span class=\"line\">                OS_SchedNew();</span><br><span class=\"line\">                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (OSPrioHighRdy != OSPrioCur) &#123;          <span class=\"comment\">/* No Ctx Sw if current task is highest rdy */</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%-10d Preempt 即将发生任务抢断\\n&quot;</span>,OSTimeGet());</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> OS_TASK_PROFILE_EN &gt; 0u</span></span><br><span class=\"line\">                    OSTCBHighRdy-&gt;OSTCBCtxSwCtr++;         <span class=\"comment\">/* Inc. # of context switches to this task  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                    OSCtxSwCtr++;                          <span class=\"comment\">/* Keep track of the number of ctx switches */</span></span><br><span class=\"line\">                    OSIntCtxSw();                          <span class=\"comment\">/* Perform interrupt level ctx switch       */</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        OS_EXIT_CRITICAL();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"调度算法实现\"><a class=\"markdownIt-Anchor\" href=\"#调度算法实现\"></a> 调度算法实现</h1>\n<h2 id=\"替换调度策略\"><a class=\"markdownIt-Anchor\" href=\"#替换调度策略\"></a> 替换调度策略</h2>\n<p><code>OSStart</code> 中通过 <code>OS_SchedNew</code> 获取当前最高优先级的任务。通过修改 <code>OS_SchedNew</code> 实现函数可进行调度算法的替换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">OSStart</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (OSRunning == OS_FALSE) &#123;</span><br><span class=\"line\">        OS_SchedNew();  <span class=\"comment\">/* Find highest priority&#x27;s task priority number   */</span></span><br><span class=\"line\">        OSPrioCur     = OSPrioHighRdy;</span><br><span class=\"line\">        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; <span class=\"comment\">/* Point to highest priority task ready to run    */</span></span><br><span class=\"line\">        OSTCBCur      = OSTCBHighRdy;</span><br><span class=\"line\">        OSStartHighRdy();   <span class=\"comment\">/* Execute target specific code to start task     */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span>  <span class=\"type\">void</span>  <span class=\"title function_\">OS_SchedNew</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSched_Algorithm();</span><br><span class=\"line\">\t<span class=\"comment\">// 把OS_SchedNew的内容注释掉</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"rm-算法与-edf-算法\"><a class=\"markdownIt-Anchor\" href=\"#rm-算法与-edf-算法\"></a> RM 算法与 EDF 算法</h2>\n<p>两种算法使用同一种扩展的数据结构 <code>tcb_ext_info</code> 好处在于代码改动非常小。与 RM 的区别在于找出的是距离截止时间最近的任务作为最高优先级任务。</p>\n<p>算法基本流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">:获取TCB链表;</span><br><span class=\"line\">:初始化最小值min_prio;</span><br><span class=\"line\">while (优先级是否符合要求?)</span><br><span class=\"line\">\t:进入临界区;</span><br><span class=\"line\">\tif (该任务延迟时间为0?) then (yes)</span><br><span class=\"line\">\t\tif (需要比较的优先级参数是否比当前存储的优先级min_prio小?) then (yes)</span><br><span class=\"line\">\t\t\t:min_prio更新为最小值;</span><br><span class=\"line\">\t\t\t:最高优先级任务更改为此任务;</span><br><span class=\"line\">\t\tendif</span><br><span class=\"line\">\tendif</span><br><span class=\"line\">\t:退出临界区;</span><br><span class=\"line\">\t:ptcb指向下一个TCB;</span><br><span class=\"line\">endwhile (no)</span><br><span class=\"line\">stop</span><br></pre></td></tr></table></figure>\n<p>以下代码通过宏 <code>LAB2_EDF</code> 切换使用不同的算法。</p>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">本文源码中涉及宏 <code>LAB2_EDF</code> 的文件</div>\n</div>\n<div class=\"callout-content\"><p>激活 EDF 算法记得在以下文件定义宏 <code>LAB2_EDF</code>：</p>\n<ul>\n<li><code>main.c</code></li>\n<li><code>os_core.c</code></li>\n</ul>\n<p>问：为什么不单独引入一个独立的头文件方便激活或取消宏？<br />\n答：因为我电脑里的古董 VC6 做不到，它会崩溃🤬</p>\n</div></div><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Sched_Algorithm</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\tOS_TCB *ptcb;</span><br><span class=\"line\">\tINT32U min_prio;</span><br><span class=\"line\">\ttcb_ext_info* task_info;</span><br><span class=\"line\">\tINT32U tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\tptcb = OSTCBList;</span><br><span class=\"line\"></span><br><span class=\"line\">\tOS_ENTER_CRITICAL();</span><br><span class=\"line\">\tmin_prio = <span class=\"number\">2147483647</span>; <span class=\"comment\">// INT32U MAX</span></span><br><span class=\"line\">\tOSPrioHighRdy = OS_TASK_IDLE_PRIO;</span><br><span class=\"line\">\tOS_EXIT_CRITICAL();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(ptcb-&gt;OSTCBPrio&lt;OS_TASK_IDLE_PRIO<span class=\"number\">-2</span>)&#123; <span class=\"comment\">//  &amp;&amp; ptcb-&gt;OSTCBPrio != 1</span></span><br><span class=\"line\">\t\tOS_ENTER_CRITICAL();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ptcb-&gt;OSTCBDly==<span class=\"number\">0</span> &amp;&amp; ((tcb_ext_info*)ptcb-&gt;OSTCBExtPtr)-&gt;is_pend == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">\t\t\ttask_info = (tcb_ext_info*)ptcb-&gt;OSTCBExtPtr;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB2_EDF</span></span><br><span class=\"line\">\t\t\ttmp = task_info-&gt;rest_d;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\t\ttmp = task_info-&gt;t;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(tmp&lt;min_prio)&#123;</span><br><span class=\"line\">\t\t\t\tmin_prio = tmp;</span><br><span class=\"line\">\t\t\t\tOSPrioHighRdy = ptcb-&gt;OSTCBPrio;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tptcb = ptcb-&gt;OSTCBNext;</span><br><span class=\"line\">\t\tOS_EXIT_CRITICAL();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">改进提示</div>\n</div>\n<div class=\"callout-content\"><p>为了节省代码编写，RM 和 EDF 采用了同样的遍历链表的逻辑，但对于 RM 来说还可以进一步改进——不使用遍历的方式找到最高优先级，从而提高运行效率。</p>\n</div></div><h1 id=\"运行结果\"><a class=\"markdownIt-Anchor\" href=\"#运行结果\"></a> 运行结果</h1>\n<h2 id=\"rm-算法\"><a class=\"markdownIt-Anchor\" href=\"#rm-算法\"></a> RM 算法</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240622155303.webp\" alt=\"image.png\" /></p>\n<p>案例 1 示例输出：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240622155420.webp\" alt=\"image.png\" /></p>\n<h2 id=\"edf-算法\"><a class=\"markdownIt-Anchor\" href=\"#edf-算法\"></a> EDF 算法</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240622155325.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p>案例 1 的示例输出：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240622155536.webp\" alt=\"image.png\" /></p>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<p>本实验的重要 <a href=\"https://www.cnblogs.com/iterationjia/p/13986006.html\">参考文章</a> 中的思路是：每次 <code>OSTimeTick</code> 计算该时刻任务剩余的周期数 <code>rest_t</code>，然后让任务自己延迟（<code>OSTimeDly</code>）自己，在下一个任务周期就绪。比如它的任务函数是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FirstTask</span><span class=\"params\">(<span class=\"type\">void</span> *pParam)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此处位置代码省略</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tcb_ext_info*)OSTCBCur-&gt;OSTCBExtPtr)-&gt;rest_c &gt; <span class=\"number\">0</span>)&#123;&#125;</span><br><span class=\"line\">\t\tOS_ENTER_CRITICAL();\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 此处位置代码省略</span></span><br><span class=\"line\">\t\tOS_EXIT_CRITICAL();</span><br><span class=\"line\">\t\tOSTimeDly(task_info-&gt;<span class=\"type\">rest_t</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>🐢⭐：这种实现会有点怪。</p>\n</blockquote>\n<p>这样虽然会实现目的，但是我感觉这是任务自己参与去做调度这件事情。而且 <code>OSTimeDly</code> 还不准，一开始输出很正确，运行一会就陷入死循环或程序卡死了，甚至每次编译运行的结果都不一样🤬。</p>\n<p>本篇文章通过 <code>OSTimeTick</code> 统一决定任务的挂起与恢复就绪，让任务函数本身更纯粹一些。当然，拓展的数据结构 <code>tcb_ext_info</code> 中可能会遗留一些没有用到的变量，读者可视情况删除。</p>\n<h1 id=\"实验源码\"><a class=\"markdownIt-Anchor\" href=\"#实验源码\"></a> 实验源码</h1>\n<p>GitHub：<a href=\"https://github.com/uuanqin/ucosii-rm-edf-experiment\">uuanqin/ucosii-rm-edf-experiment: ucosii中实现RM和EDF任务调度算法实验源码。 (github.com)</a></p>\n<p><a href=\"https://github.com/uuanqin/ucosii-rm-edf-experiment\"><img src= \"/image/loading.gif\" data-lazy-src=\"https://github-readme-stats.uuanqin.top/api/pin/?username=uuanqin&amp;repo=ucosii-rm-edf-experiment\" alt=\"Readme Card\" /></a></p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.cnblogs.com/iterationjia/p/13986006.html\">基于μcOS-II实时操作系统源码实现RMS和EDF调度（共享资源） - iterationjia - 博客园 (cnblogs.com)</a></li>\n<li><a href=\"https://blog.csdn.net/oNew_Lifeo/article/details/115189603\">在github上上传本地项目步骤（两种方式）_github怎么往项目本体传-CSDN博客</a></li>\n</ul>\n","raw":"---\ntitle: RM 和 EDF 任务调度算法在 μCOSII 上的实现\ntags:\n  - μCOS\n  - RM\n  - EDF\n  - 实时系统\n  - 任务管理\ncover: 'https://cdn.gallery.uuanqin.top/img/20240622164030.webp'\ndescription: 实时操作系统实验 2 实现 RM 和 EDF\ncategories:\n  - 嵌入式\nabbrlink: b1c2eea4\ndate: 2024-06-22 16:29:41\ntop_img:\n---\n\n> 文章写作背景为《实时系统设计》课程实验二。写这篇东西掉了好多头发🤬。\n\n源码在文章后。\n\n# 实验介绍\n\n实验目的：\n\n1. 熟悉嵌入式实时操作系统 μC/OS 代码结构。\n2. 理解、设计和实现 RM 和 EDF 等算法，调研相关技术。\n3. 在 μC/OS 上使用 VC 运行和调试设计的程序。\n\n实验环境：\n\n1. 操作系统：μC/OS-II\n2. 软件：Microsoft Visual C++ 6.0\n\n实验原理：\n\n1. RM 算法。RM(Rate Monotonic) 算法根据周期任务的释放频率，即周期的长短来分配任务的优先级，周期越短的任务优先级越高。当 Di=Ti 时，RM 算法是最优的固定优先级调度算法。如有两个实时任务τA（TA=25，CA=10）、τB（TB=40，CB=10）和τC（TC=100，CC=20），采用 RM 算法调度如下图所示：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240621132520.webp)\n\n2. EDF 算法的实现。EDF(Earliest Deadline First) 算法按照实时任务的绝对截止时间来分配优先级，截止时间越近的优先级越高。EDF 算法是最优的动态优先级调度算法。如有两个实时任务τ1（C1=1，D1=3,T1=4）和τ2（C2=2,D2=4,T2=6），采用 EDF 算法调度如下图所示：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240621132534.webp)\n\n# 步骤\n\n## 基本认识\n\n熟读课件和相关源码片段，我们有以下基本认识：\n\n- 任务在 `main.c` 中创建，新建任务后会生成对应的 TCB 程序控制块（定义在 `ucos-ii.h` 中的 OS_TCB），并链接到 TCB 链表头中，链表尾是程序创建的空闲任务。\n- 实验程序我们需要手动模拟时间中断，以触发 `OSTimeTick()`\n- `OSTimeTick()` 会遍历任务链表，检查它们的延时。\n- `OS_SchedNew()` 是用来设定最高优先级的。默认实现是找就绪组就绪表。我们可以在里面动手脚，直接写我们的调度算法。\n- `OSTimeTick()` 调用 `OSIntExit()`，`OSIntExit()` 中又 `OS_SchedNew()`。所以每一次 `OSTimeTick()` 到来时，都有机会判断当前最高优先级的任务是什么。\n\n\n## 为 TCB 块添加扩展\n\n无论是 RM 算法还是 EDF 算法，都需要使用扩展的 TCB 块存储任务优先级数据。统一的扩展数据结构为不同算法的实现方式进行简化。\n\n```c\n// ucos_ii.h\ntypedef struct tcb_ext_info{\n\tINT32U c;      // 保存C\n\tINT32U t;      // 保存T 周期\n\tINT32U d;      // 保存D 截止时间（EDF算法）\n\tINT32U rest_c; // 保存剩余工作时间\n\tINT32U rest_t; // 保存周期内剩余的事件\n\tINT32U rest_d; // 保存当前时间与截至时间的差值（EDF算法）\n\tINT32U task_id;// 任务ID\n\tINT8U is_pend; // 判断任务是否挂起（需要手动设置的标记位）\n} tcb_ext_info;\n```\n\n## 任务创建\n\nmain 函数中首先要求输入一个任务数量 `TasksNum`，根据 `TasksNum` 进行迭代，持续获取每个任务的基本信息：\n\n1. C 计算时间\n2. T 周期\n3. D 截止时间（EDF 算法）\n\n并对其余记录进行填充：\n\n1. 剩余计算时间\n2. 周期内剩余时间\n3. 剩余截止时间（EDF 算法）\n4. 任务 id\n5. 初始化 `is_pend` 为 0\n\n`timeSetEvent` 将模拟时钟中断。\n\n宏 `LAB2_EDF` 决定当前使用的是 EDF 算法还是 RM 算法。\n\n```c\nint main(int argc, char **argv)\n{\n\tint TasksNum,i,C,T;\n#ifdef LAB2_EDF\n\tint D;\n#endif\n\n\ttcb_ext_info* task_info_array = (tcb_ext_info*)malloc(sizeof(tcb_ext_info)*TasksNum);\n\n\tVCInit();\n\n\t// 输入提示\n#ifdef LAB2_EDF\n    printf(\"EDF算法实验。请输入任务数：\\n\");\n#else\n\tprintf(\"RM 算法实验。请输入任务数：\\n\");\n#endif\n\n\tscanf(\"%d\",&TasksNum);\n    if (TasksNum<0)\n\t{\n\t\tprintf(\"无效的输入!\");\n        return(1); \t\n\t}\n\tOSInit();\n\t\n\tfor(i=0;i<TasksNum;i++){\n#ifdef LAB2_EDF\n\t\t// EDF 每个任务三个参数\n\t\tscanf(\"%d %d %d\",&C,&D,&T);\n#else\n\t\t// RM 每个任务两个参数\n\t\tscanf(\"%d %d\",&C,&T);\n#endif\n\t\t\n\t\ttask_info_array[i].c = C;\n\t\ttask_info_array[i].t = T;\n\n\t\ttask_info_array[i].rest_c = C;\n\t\ttask_info_array[i].rest_t = T;\n\n\t\ttask_info_array[i].task_id = i;\n\t\ttask_info_array[i].is_pend = 0;  // 初始为不挂起\n\n#ifdef LAB2_EDF\n\t\ttask_info_array[i].d = D;\n\t\ttask_info_array[i].rest_d = D;\n#endif\n\t\t\t\n\t\tOSTaskCreateExt(\n\t\t\tFirstTask, \n\t\t\t0, \n\t\t\t&TaskStk[i+5][TASK_STK_SIZE-1], \n\t\t\ti+5,  //设置互不冲突的数即可\n\t\t\ti,  // 任务ID\n\t\t\t&TaskStk[i+5][0], \n\t\t\tTASK_STK_SIZE,\n\t\t\t(void *)&task_info_array[i],\n\t\t\tOS_TASK_OPT_NONE  // opt\n\t\t);\n\t}\n\n\t// 模拟时钟中断\n\ttimeSetEvent(1000/OS_TICKS_PER_SEC, 0, OSTickISRuser, 0, TIME_PERIODIC);\n\n\tOSStart();\t       \n\treturn(0);\n}\n```\n\n使用 `OSTaskCreateExt` 创建任务，传入扩展信息块的指针。\n\n`FirstTask` 中为死循环，什么也不用做。\n\n```c\nint FirstTask(void *pParam)\n{\n\tfor(;;)\n\t{\n\t}\n\treturn(0); \n}\n```\n\n## 时钟中断\n\n每次时钟嘀嗒到来时，完成以下操作：\n\n- 将当前运行任务的计算时间减 1\n\t- 如果任务计算完毕则挂起\n- 遍历 TCB 链表，将剩余周期减 1\n- 遍历 TCB 链表，将剩余截止时间减 1（EDF 算法）\n- 遍历 TCB 链表，检查是否有任务需要恢复。如果需要恢复则重置一下参数。\n\n```c\nvoid  OSTimeTick (void)\n{\n    OS_TCB    *ptcb;\n    /*********** 此位置源码省略 ***************/\n\tif (OSRunning == OS_TRUE) {\n\t\n\t/*********** 此位置源码省略 ***************/\n\n\t\tptcb = OSTCBList;  /* Point at first TCB in TCB list               */\n\n\t\t// lab2 c--;\n\t\tif(OSTCBCur->OSTCBPrio != OS_TASK_IDLE_PRIO){\n\t\t\tif(((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->rest_c > 0){\n\t\t\t\t// 剩余有计算时间则减减\n\t\t\t\t((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->rest_c--;\n\n\t\t\t\tprintf(\"%-10d 任务%d compute... 执行计算工作\\n\",OSTimeGet(),((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->task_id);\n\t\t\t\tif(((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->rest_c == 0){\n\t\t\t\t\t// 任务的计算时间归零，设置任务为挂起状态\n\t\t\t\t\t((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->is_pend = 1;\n\t\t\t\t\tprintf(\"%-10d 任务%d complete! 挂起 \\n\",OSTimeGet(),((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->task_id);\n\t\t\t\t\tOSTaskSuspend(OSTCBCur->OSTCBPrio);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */\n            OS_ENTER_CRITICAL();\n\n\t\t\t// Lab2 所有的任务的剩余周期和剩余截止时间都减1（除了空闲任务后的两个任务）\n\t\t\tif(ptcb->OSTCBPrio<OS_TASK_IDLE_PRIO-2 ){ \n\t\t\t\t((tcb_ext_info*)ptcb->OSTCBExtPtr)->rest_t--;\n#ifdef LAB2_EDF\n\t\t\t\t((tcb_ext_info*)ptcb->OSTCBExtPtr)->rest_d--;\n#endif\n\t\t\t}\n\t\t\t// 恢复任务（除了空闲任务后的两个任务）\n\t\t\tif( ptcb->OSTCBPrio<OS_TASK_IDLE_PRIO-2 && OSTimeGet() % ((tcb_ext_info*)ptcb->OSTCBExtPtr)->t == 0){\n\t\t\t\t// 当前时间为任务周期整数倍时恢复任务\n\t\t\t\t((tcb_ext_info*)ptcb->OSTCBExtPtr)->rest_c=((tcb_ext_info*)ptcb->OSTCBExtPtr)->c;\n\t\t\t\t((tcb_ext_info*)ptcb->OSTCBExtPtr)->rest_t=((tcb_ext_info*)ptcb->OSTCBExtPtr)->t;\n#ifdef LAB2_EDF\n\t\t\t\t((tcb_ext_info*)ptcb->OSTCBExtPtr)->rest_d=((tcb_ext_info*)ptcb->OSTCBExtPtr)->d;\n#endif\n\t\t\t\t// 设置任务为未挂起状态\n\t\t\t\t((tcb_ext_info*)ptcb->OSTCBExtPtr)->is_pend = 0;\n\n\t\t\t\tOSTaskResume(ptcb->OSTCBPrio);\n\t\t\t}\n\n\t\t\t/*********** 此位置源码省略 ***************/\n        }\n    }\n}\n```\n\n> 遍历的时候不要处理一些无关的任务，比如空闲任务，甚至统计任务等莫名奇妙的任务。所以有类似 `ptcb->OSTCBPrio<OS_TASK_IDLE_PRIO-2` 这种判定条件。\n\n## 任务抢占输出\n\n任务抢占将调用 `OSIntExit()`，如果最高优先级不是当前任务的优先级时判定为任务抢占。\n\n```c\nvoid  OSIntExit (void)\n{\n#if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */\n    OS_CPU_SR  cpu_sr = 0u;\n#endif\n\n    if (OSRunning == OS_TRUE) {\n        OS_ENTER_CRITICAL();\n        if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */\n            OSIntNesting--;\n        }\n        if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */\n            if (OSLockNesting == 0u) {                     /* ... and not locked.                      */\n                OS_SchedNew();\n                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];\n                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */\n\t\t\t\t\tprintf(\"%-10d Preempt 即将发生任务抢断\\n\",OSTimeGet());\n#if OS_TASK_PROFILE_EN > 0u\n                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */\n#endif\n                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */\n                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */\n                }\n            }\n        }\n        OS_EXIT_CRITICAL();\n    }\n}\n```\n\n# 调度算法实现\n\n## 替换调度策略\n\n`OSStart` 中通过 `OS_SchedNew` 获取当前最高优先级的任务。通过修改 `OS_SchedNew` 实现函数可进行调度算法的替换。\n\n```c\nvoid  OSStart (void)\n{\n    if (OSRunning == OS_FALSE) {\n        OS_SchedNew();  /* Find highest priority's task priority number   */\n        OSPrioCur     = OSPrioHighRdy;\n        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */\n        OSTCBCur      = OSTCBHighRdy;\n        OSStartHighRdy();   /* Execute target specific code to start task     */\n    }\n}\n\nstatic  void  OS_SchedNew (void)\n{\n\tSched_Algorithm();\n\t// 把OS_SchedNew的内容注释掉\n}\n```\n\n## RM 算法与 EDF 算法\n\n两种算法使用同一种扩展的数据结构 `tcb_ext_info` 好处在于代码改动非常小。与 RM 的区别在于找出的是距离截止时间最近的任务作为最高优先级任务。\n\n算法基本流程：\n\n```plantuml\nstart\n:获取TCB链表;\n:初始化最小值min_prio;\nwhile (优先级是否符合要求?)\n\t:进入临界区;\n\tif (该任务延迟时间为0?) then (yes)\n\t\tif (需要比较的优先级参数是否比当前存储的优先级min_prio小?) then (yes)\n\t\t\t:min_prio更新为最小值;\n\t\t\t:最高优先级任务更改为此任务;\n\t\tendif\n\tendif\n\t:退出临界区;\n\t:ptcb指向下一个TCB;\nendwhile (no)\nstop\n```\n\n以下代码通过宏 `LAB2_EDF` 切换使用不同的算法。\n\n> [!hint] 本文源码中涉及宏 `LAB2_EDF` 的文件\n> 激活 EDF 算法记得在以下文件定义宏 `LAB2_EDF`：\n> - `main.c`\n> - `os_core.c`\n>\n>  问：为什么不单独引入一个独立的头文件方便激活或取消宏？\n>  答：因为我电脑里的古董 VC6 做不到，它会崩溃🤬\n\n```c\nvoid Sched_Algorithm(void){\n\tOS_TCB *ptcb;\n\tINT32U min_prio;\n\ttcb_ext_info* task_info;\n\tINT32U tmp;\n\n\tptcb = OSTCBList;\n\n\tOS_ENTER_CRITICAL();\n\tmin_prio = 2147483647; // INT32U MAX\n\tOSPrioHighRdy = OS_TASK_IDLE_PRIO;\n\tOS_EXIT_CRITICAL();\n\n\n\twhile(ptcb->OSTCBPrio<OS_TASK_IDLE_PRIO-2){ //  && ptcb->OSTCBPrio != 1\n\t\tOS_ENTER_CRITICAL();\n\t\tif(ptcb->OSTCBDly==0 && ((tcb_ext_info*)ptcb->OSTCBExtPtr)->is_pend == 0 ){\n\t\t\ttask_info = (tcb_ext_info*)ptcb->OSTCBExtPtr;\n#ifdef LAB2_EDF\n\t\t\ttmp = task_info->rest_d;\n#else\n\t\t\ttmp = task_info->t;\n#endif\n\t\t\tif(tmp<min_prio){\n\t\t\t\tmin_prio = tmp;\n\t\t\t\tOSPrioHighRdy = ptcb->OSTCBPrio;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tptcb = ptcb->OSTCBNext;\n\t\tOS_EXIT_CRITICAL();\n\t}\n}\n```\n\n> [!hint] 改进提示\n> 为了节省代码编写，RM 和 EDF 采用了同样的遍历链表的逻辑，但对于 RM 来说还可以进一步改进——不使用遍历的方式找到最高优先级，从而提高运行效率。\n\n# 运行结果\n\n## RM 算法\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240622155303.webp)\n\n案例 1 示例输出：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240622155420.webp)\n\n## EDF 算法\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/20240622155325.webp)\n\n案例 1 的示例输出：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240622155536.webp)\n\n# 后记\n\n本实验的重要 [参考文章](https://www.cnblogs.com/iterationjia/p/13986006.html) 中的思路是：每次 `OSTimeTick` 计算该时刻任务剩余的周期数 `rest_t`，然后让任务自己延迟（`OSTimeDly`）自己，在下一个任务周期就绪。比如它的任务函数是：\n\n```c\n// 任务函数\nint FirstTask(void *pParam)\n{\n\t// 此处位置代码省略\n\tfor(;;)\n\t{\n        while(((tcb_ext_info*)OSTCBCur->OSTCBExtPtr)->rest_c > 0){}\n\t\tOS_ENTER_CRITICAL();\t\t\n\t\t// 此处位置代码省略\n\t\tOS_EXIT_CRITICAL();\n\t\tOSTimeDly(task_info->rest_t);\n\t\t\n\t}\n\treturn(0); \n}\n```\n\n> 🐢⭐：这种实现会有点怪。\n\n这样虽然会实现目的，但是我感觉这是任务自己参与去做调度这件事情。而且 `OSTimeDly` 还不准，一开始输出很正确，运行一会就陷入死循环或程序卡死了，甚至每次编译运行的结果都不一样🤬。\n\n本篇文章通过 `OSTimeTick` 统一决定任务的挂起与恢复就绪，让任务函数本身更纯粹一些。当然，拓展的数据结构 `tcb_ext_info` 中可能会遗留一些没有用到的变量，读者可视情况删除。\n\n# 实验源码\n\nGitHub：[uuanqin/ucosii-rm-edf-experiment: ucosii中实现RM和EDF任务调度算法实验源码。 (github.com)](https://github.com/uuanqin/ucosii-rm-edf-experiment)\n\n[![Readme Card](https://github-readme-stats.uuanqin.top/api/pin/?username=uuanqin&repo=ucosii-rm-edf-experiment)](https://github.com/uuanqin/ucosii-rm-edf-experiment)\n\n# 本文参考\n- [基于μcOS-II实时操作系统源码实现RMS和EDF调度（共享资源） - iterationjia - 博客园 (cnblogs.com)](https://www.cnblogs.com/iterationjia/p/13986006.html)\n- [在github上上传本地项目步骤（两种方式）_github怎么往项目本体传-CSDN博客](https://blog.csdn.net/oNew_Lifeo/article/details/115189603)","categories":[{"name":"嵌入式","api":"api/categories/嵌入式.json"}],"tags":[{"name":"μCOS","api":"api/tags/μCOS.json"},{"name":"RM","api":"api/tags/RM.json"},{"name":"EDF","api":"api/tags/EDF.json"},{"name":"实时系统","api":"api/tags/实时系统.json"},{"name":"任务管理","api":"api/tags/任务管理.json"}]},"api":"api/posts/p/b1c2eea4.json"}