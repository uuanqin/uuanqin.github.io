{"data":{"title":"缓存置换算法的实现与 Java 中相关的数据结构","slug":"算法与数据结构/缓存置换算法的实现与 Java 中相关的数据结构","description":"OPT、LRU、LFU 不再惧怕","date":"2025-09-13T10:15:18.000Z","updated":"2025-09-14T11:46:44.079Z","language":"zh-CN","comments":true,"url":"p/270917b1/","cover":"https://cdn.gallery.uuanqin.top/img/202509131825096.webp","images":[],"content":"\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">文章翻新 <code>250913</code></div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>补充 Java 相关数据结构 <code>LinkedList</code>、<code>LinkedHashMap</code>、<code>PriorityQueue</code> 信息</li>\n<li>补充 OPT、LFU 算法题与解析</li>\n</ul>\n<p>文章最初发表于 <code>240903</code>，原标题：手写 LRU 缓存以理解 Java 中的 LinkedHashMap，<a href=\"https://cdn.gallery.uuanqin.top/img/202409050003261.webp\">原封面</a>。</p>\n</div></details><p>在操作系统的学习过程中，我们会在不同的内容中（页面置换算法、高速缓冲器替换算法）接触到各种缓存置换算法：</p>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OPT</td>\n<td>最佳置换算法</td>\n<td>此算法在已知未来所有访问记录的前提下，每次都替换未来不再被访问/最远被访问的现存数据。该算法是理论上的最优算法。</td>\n</tr>\n<tr>\n<td>FIFO</td>\n<td>先进先出置换算法</td>\n<td>每次替换最先进入缓存的数据，该算法认为最先进入的数据在将来被访问到的可能性最小。FIFO 算法存在 Belady 现象。</td>\n</tr>\n<tr>\n<td>LRU</td>\n<td>最近最少使用置换算法</td>\n<td>每次替换最久未被访问的数据，该算法认为最近一段时间没有被访问到的数据在将来被访问的可能性最小，这种策略在实际中应用较广。</td>\n</tr>\n<tr>\n<td>LFU</td>\n<td>最少使用置换算法</td>\n<td>每次替换访问次数最小的数据，该算法的思想是最近一段时间被访问次数最小的数据在将来被访问的可能性最小。</td>\n</tr>\n<tr>\n<td>RAND</td>\n<td>随机算法</td>\n<td>从现存数据中随机选择一个元素进行替换，该算法不需要维护历史访问记录的任何信息，实现上简单高效，但命中率通常一般。</td>\n</tr>\n</tbody>\n</table>\n\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">Belady 现象</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>Belady 现象是计算机系统中采用先进先出（FIFO）页面置换算法时出现的异常现象，表现为当分配给进程的物理页面数增加时，缺页率不降反升。贝拉迪通过实验发现，当操作系统未满足进程全部页面需求时，FIFO 算法可能因过早置换仍将被频繁访问的页面，引发更多缺页中断。这一发现打破了 「增加内存必然降低缺页率」的传统认知。</p>\n</div></details><p>缓存替换算法用于管理有限的缓存空间，决定哪些数据需要被移除以腾出空间。现在编程题也喜欢考察对于这些算法的实现能力。</p>\n<p>本文结合真实题目，讲解用 Java 语言实现 OPT、LRU、LFU 算法，并了解相关的 Java 数据结构。至于 FIFO、RAND 很简单，读者可自行实现。</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"java-中相关的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#java-中相关的数据结构\"></a> Java 中相关的数据结构</h1>\n<h2 id=\"linkedlist-双向链表\"><a class=\"markdownIt-Anchor\" href=\"#linkedlist-双向链表\"></a> <code>LinkedList</code> 双向链表</h2>\n<blockquote>\n<p>从 JDK1.7 开始，<code>LinkedList</code> 由双向循环链表改为<strong>双向链表</strong>。</p>\n</blockquote>\n<p><code>LinkedList</code> 是一个基于双向链表实现的集合类。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509130013613.webp\" alt=\"image.png\" width=\"400px\" /></p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509130016033.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p>一些操作的时间复杂度：</p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>操作</th>\n<th>时间复杂度</th>\n<th>源码做法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>add(e)</code><br><code>addFirst(e)</code><br><code>addLast(e)</code></td>\n<td>头尾插入</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>双向链表常规做法</td>\n</tr>\n<tr>\n<td><code>add(index,e)</code></td>\n<td>指定位置插入</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>选择靠近的一端向中间遍历</td>\n</tr>\n<tr>\n<td><code>remove()</code><br><code>removeFirst()</code><br><code>removeLast()</code></td>\n<td>头尾删除</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>双向链表常规做法</td>\n</tr>\n<tr>\n<td><code>remove(E e)</code></td>\n<td>指定元素删除（删除首次出现元素）</td>\n<td rowspan=\"2\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>从头到尾遍历链表</td>\n</tr>\n<tr>\n<td><code>remove(index)</code></td>\n<td>指定位置删除</td>\n<td>选择靠近的一端向中间遍历</td>\n</tr>\n<tr>\n<td><code>getFirst()</code><br><code>getLast()</code></td>\n<td>获取头尾元素</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>双向链表常规做法</td>\n</tr>\n<tr>\n<td><code>get(int index)</code></td>\n<td>获取链表指定位置的元素</td>\n<td rowspan=\"3\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>选择靠近的一端向中间遍历</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>移除此链表中的所有元素</td>\n<td rowspan=\"2\">从头到尾遍历链表</td>\n</tr>\n<tr>\n<td><code>contains(e)</code></td>\n<td>查询指定元素是否存于链表</td>\n</tr>\n</tbody>\n</table>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">循环使用 <code>remove(int index)</code> 的时间复杂度。</div>\n</div>\n<div class=\"callout-content\"><p>Q：在一个 <code>LinkedList</code> 类型的变量进行 <code>for</code> 循环遍历时，每轮迭代执行一次 <code>remove(index)</code> 操作，请问该循环时间复杂度是多少？</p>\n<p>A：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，因为一次 <code>remove(int index)</code> 就需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n</div></div><h2 id=\"linkedhashmap-含双向链表的哈希集合\"><a class=\"markdownIt-Anchor\" href=\"#linkedhashmap-含双向链表的哈希集合\"></a> <code>LinkedHashMap</code> 含双向链表的哈希集合</h2>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408310204657.webp\" alt=\"image.png\" width=\"350px\" /></p>\n<p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条<strong>双向链表</strong>。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509130057327.webp\" alt=\"image.png\" width=\"325px\" /></p>\n<p><code>LinkedHashMap</code> 特性：</p>\n<ul>\n<li>支持遍历时会按照插入顺序有序进行迭代。<strong>（与 <code>HashMap</code> 的最大区别）</strong></li>\n<li>支持按照元素访问顺序排序，适用于封装 LRU 缓存工具。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。<strong>由于双向链表的存在，其插入性能可能会比 <code>HashMap</code> 略低。</strong></li>\n</ul>\n<h3 id=\"基本特性-linkedhashmap-迭代顺序和插入顺序一致\"><a class=\"markdownIt-Anchor\" href=\"#基本特性-linkedhashmap-迭代顺序和插入顺序一致\"></a> 基本特性 <code>LinkedHashMap</code> 迭代顺序和插入顺序一致</h3>\n<p>它的用法和 <code>HashMap</code> 一致。特点在于 <code>LinkedHashMap</code> 的从头到尾迭代顺序是和插入顺序一致的，而 <code>HashMap</code> 中是随机的。</p>\n<h3 id=\"可在构造函数中开启访问顺序-accessorder\"><a class=\"markdownIt-Anchor\" href=\"#可在构造函数中开启访问顺序-accessorder\"></a> 可在构造函数中开启访问顺序 <code>accessOrder</code></h3>\n<p><code>LinkedHashMap</code> 定义了排序模式 <code>boolean accessOrder = false</code>。当 <code>accessOrder</code> 为 <code>true</code> 时，被访问的元素将重新拿出来放到<strong>链表尾部</strong>。</p>\n<p>设置方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始容量、负载因子、访问顺序</span></span><br><span class=\"line\">LinkedHashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;(<span class=\"number\">16</span>, <span class=\"number\">0.75f</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"重写-removeeldestentry-方法\"><a class=\"markdownIt-Anchor\" href=\"#重写-removeeldestentry-方法\"></a> 重写 <code>removeEldestEntry</code> 方法</h3>\n<p><code>removeEldestEntry</code> 将返回一个 <code>boolean</code> 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素。我们需要在继承 <code>LinkedHashMap</code> 的子类中重写该方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyMap</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyMap</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">0.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"comment\">/* 编写判断逻辑 */</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"priorityqueue-优先队列二项堆\"><a class=\"markdownIt-Anchor\" href=\"#priorityqueue-优先队列二项堆\"></a> <code>PriorityQueue</code> 优先队列（二项堆）</h2>\n<p>优先队列基于二项堆，用法详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/182af697/\"><span class=\"bilink-pop-up\">站内文章</span>Java 集合的使用</a>。</p>\n<h1 id=\"最佳置换算法-opt\"><a class=\"markdownIt-Anchor\" href=\"#最佳置换算法-opt\"></a> 最佳置换算法 OPT</h1>\n<p>缓存替换的最优算法（MIN/OPT，Optimal）在 1966 年由 Laszlo A.Belady 提出，此算法在已知未来所有访问记录的前提下，每次都替换未来不再被访问/最远被访问的现存数据。该算法是理论上的最优算法，因为需要已知未来所有访问记录，并不具备可实现性，通常用于衡量其它缓存替换算法的优劣。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://www.luogu.com.cn/problem/P4404#ide\">P4404 [JSOI2010] 缓存交换 - 洛谷</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>在计算机中，CPU 只能和高速缓存 Cache 直接交换数据。当所需的内存单元不在 Cache 中时，则需要从主存里把数据调入 Cache。此时，如果 Cache 容量已满，则必须先从中删除一个。</p>\n<p>在现代计算机中，往往采用 LRU(最近最少使用) 的算法来进行 Cache 调度——可是，从上一个例子就能看出，这并不是最优的算法。 对于一个固定容量的空 Cache 和连续的若干主存访问请求，聪聪想知道如何在每次 Cache 缺失时换出正确的主存单元，以达到最少的 Cache 缺失次数。</p>\n</div></div><p>思路：采用 OPT，即淘汰在之后的访问中，出现最晚（甚至不出现）的元素。</p>\n<p>我的解法：</p>\n<ul>\n<li>使用到的数据结构有哈希表和优先队列。</li>\n<li>哈希表用于快速判断缓存中是否存在指定的 <code>key</code>。</li>\n<li>优先队列可快速得出待删元素。</li>\n<li>更新键值时，从优先队列中找出相应元素并删除的 <code>remove(obj)</code> 操作可能有一定的时间复杂度。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.PriorityQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dataIds = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">            dataIds[i]=in.nextInt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> f(N,M,dataIds);</span><br><span class=\"line\">        System.out.println(ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> capacity,<span class=\"type\">int</span>[] dataIds)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n]; <span class=\"comment\">// 表示当前 id 下一次出现的位置</span></span><br><span class=\"line\">        Arrays.fill(next,Integer.MAX_VALUE);</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// id-&gt;lastIdx</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(dataIds[i]))&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">lastIdx</span> <span class=\"operator\">=</span> map.get(dataIds[i]);</span><br><span class=\"line\">                next[lastIdx] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(dataIds[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PriorityQueue&lt;Node&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((n1,n2)-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n2.next-n1.next;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        Map&lt;Integer,Node&gt; keyMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// 为了更快判断缓存中是否存在对应的键</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">miss</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(keyMap.containsKey(dataIds[i]))&#123;</span><br><span class=\"line\">                <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> keyMap.get(dataIds[i]);</span><br><span class=\"line\">                q.remove(node);</span><br><span class=\"line\">                node.next = next[i];</span><br><span class=\"line\">                q.offer(node);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.size()==capacity)&#123;</span><br><span class=\"line\">                <span class=\"type\">Node</span> <span class=\"variable\">oldNode</span> <span class=\"operator\">=</span> q.poll();</span><br><span class=\"line\">                keyMap.remove(oldNode.id);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">newNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(dataIds[i],next[i]);</span><br><span class=\"line\">            q.offer(newNode);</span><br><span class=\"line\">            keyMap.put(dataIds[i],newNode);</span><br><span class=\"line\">            miss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> miss;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    Integer id;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;</span><br><span class=\"line\">    Node(Integer id,<span class=\"type\">int</span> next)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id= id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"最近最少使用-lru\"><a class=\"markdownIt-Anchor\" href=\"#最近最少使用-lru\"></a> 最近最少使用 LRU</h1>\n<p>最近最少使用（Least Recently Used，LRU），是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&amp;envId=top-interview-150\">146. LRU 缓存 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>请你设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。<br />\n实现 <code>LRUCache</code> 类：</p>\n<ul>\n<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>\n<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>\n<li><code>void put(int key, int value)</code>\n<ul>\n<li>如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code></li>\n<li>如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。</li>\n</ul>\n</li>\n</ul>\n<p>函数 <code>get</code> 和 <code>put</code> 必须以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的平均时间复杂度运行。</p>\n</div></div><p>首先介绍直接使用 Java API 的写法。Java 中 <code>LinkedHashMap</code> 的特性使其天然地成为轻松实现 LRU 缓存的数据结构。具体实现思路如下：</p>\n<ul>\n<li>继承 <code>LinkedHashMap</code>；</li>\n<li>构造方法中指定 <code>accessOrder</code> 为 <code>true</code> ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li>\n<li>重写 <code>removeEldestEntry</code> 方法，该方法会返回一个 <code>boolean</code> 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;Integer,Integer&gt;&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(capacity,<span class=\"number\">0.75f</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 由于题目对get返回值要求，这里我们需要进行一些调整，不然我们都可以干脆不写。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getOrDefault(key, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 题目中 put 方法直接交给 LinkedHashMap */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;Integer,Integer&gt; eldest)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果面试手撕环节这道题目这样写，估计面试官就会叫你在家等通知了。<code>LinkedHashMap</code> 无外乎就是哈希表 <code>HashMap</code> + 双向链表 <code>LinkedList</code>。把它拆开来，就会有以下实现：</p>\n<ul>\n<li><code>HashMap</code> + <code>LinkedList</code>。<code>HashMap</code> 用于快速定位双向链表中的结点；<code>LinkedList</code> 用于区分缓存 <code>key</code> 的访问顺序。</li>\n<li>双向链表必须自己手动建立并维护各种结点操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Node&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,Node&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!map.containsKey(key))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> map.get(key);</span><br><span class=\"line\">        list.remove(node);</span><br><span class=\"line\">        list.addLast(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.containsKey(key))&#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> map.get(key);</span><br><span class=\"line\">            list.remove(node);</span><br><span class=\"line\">            node.value = value;</span><br><span class=\"line\">            list.addLast(node);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.size()==capacity)&#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">oldNode</span> <span class=\"operator\">=</span> list.removeFirst();</span><br><span class=\"line\">            map.remove(oldNode.key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">newNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(key,value);</span><br><span class=\"line\">        list.addLast(newNode);</span><br><span class=\"line\">        map.put(key,newNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    Node pre,next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">()</span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(<span class=\"type\">int</span> key,<span class=\"type\">int</span> value)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，上面的实现方法中使用了 <code>LinkedList</code> 的 <code>remove(obj)</code> 操作，这个操作的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，不符合题目的时间复杂度要求。因此我们需要自己手写双向链表改进这块的时间复杂度。在接下来的实现中：</p>\n<ul>\n<li>使用<strong>循环双向链表</strong>，简化代码编写</li>\n<li>利用 <code>HashMap</code> 直接定位链表中待删除的 <code>node</code>，优化 <code>remove(obj)</code> 的时间复杂度</li>\n<li>只会编写必要的链表操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">Node</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,Node&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">        head.next=head;</span><br><span class=\"line\">        head.pre = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!map.containsKey(key))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> map.get(key);</span><br><span class=\"line\">        remove(node);</span><br><span class=\"line\">        addLast(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.containsKey(key))&#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> remove(map.get(key));</span><br><span class=\"line\">            node.value = value;</span><br><span class=\"line\">            addLast(node);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.size()==capacity)&#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">oldNode</span> <span class=\"operator\">=</span> removeFirst();</span><br><span class=\"line\">            map.remove(oldNode.key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">newNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(key,value);</span><br><span class=\"line\">        addLast(newNode);</span><br><span class=\"line\">        map.put(key,newNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度缩短至 O(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"title function_\">remove</span><span class=\"params\">(Node node)</span>&#123;</span><br><span class=\"line\">        node.pre.next = node.next;</span><br><span class=\"line\">        node.next.pre = node.pre;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"title function_\">removeFirst</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> remove(head.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addLast</span><span class=\"params\">(Node node)</span>&#123;</span><br><span class=\"line\">        node.pre = head.pre;</span><br><span class=\"line\">        node.next = head;</span><br><span class=\"line\">        head.pre.next = node;</span><br><span class=\"line\">        head.pre = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    Node pre,next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">()</span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(<span class=\"type\">int</span> key,<span class=\"type\">int</span> value)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"最少使用置换算法-lfu\"><a class=\"markdownIt-Anchor\" href=\"#最少使用置换算法-lfu\"></a> 最少使用置换算法 LFU</h1>\n<p>最近最不常用算法（LFU，Least Frequently Used）每次替换访问次数最小的数据，该算法的思想是最近一段时间被访问次数最小的数据在将来被访问的可能性最小。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟥 <a href=\"https://leetcode.cn/problems/lfu-cache/description/\">460. LFU 缓存 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>\n<p>实现 <code>LFUCache</code> 类：</p>\n<ul>\n<li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li>\n<li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li>\n<li><code>void put(int key, int value)</code> 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最久未使用</strong> 的键。</li>\n</ul>\n<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p>\n<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1（由于 <code>put</code> 操作）。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>\n<p>函数 <code>get</code> 和 <code>put</code> 必须以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的平均时间复杂度运行。</p>\n</div></div><p>同 LRU 中说明的顺序一样，我们还是先从 API 用法开始介绍，再慢慢改造为手工实现。</p>\n<p>实现要点：</p>\n<ul>\n<li>双 <code>HashMap</code>，一个保存 <code>key</code> 对应的频数（频数用于索引链表以及快速判空），一个保存不同频数下保存的链表结构。</li>\n<li>链表结构选用 <code>LinkedHashMap</code>，使用它的一些特性：\n<ul>\n<li>链表特性：在平局情况时快速获取最久未使用的结点（表头结点）；插入键时自动插入链表末端。</li>\n<li>哈希表特性：删除元素时能达到 <code>O(1)</code> 时间复杂度</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LFUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,Map&lt;Integer,Integer&gt;&gt; freq2map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,Integer&gt; key2freq = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">minfreq</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LFUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> move(key,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(move(key,value)!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key2freq.size()==capacity)&#123;</span><br><span class=\"line\">            Map&lt;Integer,Integer&gt; map = freq2map.get(minfreq);</span><br><span class=\"line\">            <span class=\"type\">Integer</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> map.keySet().iterator().next();</span><br><span class=\"line\">            map.remove(k);</span><br><span class=\"line\">            key2freq.remove(k);   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        key2freq.put(key,<span class=\"number\">1</span>);</span><br><span class=\"line\">        freq2map.computeIfAbsent(<span class=\"number\">1</span>,k-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;()).put(key,value);</span><br><span class=\"line\">        minfreq = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">move</span><span class=\"params\">(Integer key, Integer value)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">freq</span> <span class=\"operator\">=</span> key2freq.getOrDefault(key,<span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(freq==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Integer value = freq2map.get(freq).remove(key);</span></span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = freq2map.get(freq);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            value = map.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.size()==<span class=\"number\">0</span> &amp;&amp; minfreq==freq)&#123;</span><br><span class=\"line\">            minfreq++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        </span><br><span class=\"line\">        Integer newFreq= freq+<span class=\"number\">1</span>;</span><br><span class=\"line\">        key2freq.put(key,newFreq);</span><br><span class=\"line\">        freq2map.computeIfAbsent(newFreq,k-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;()).put(key,value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们开始用 <code>LinkedList</code> 替换 <code>LinkedHashMap</code>。变化点：</p>\n<ul>\n<li>我们创建了 <code>Node</code> 结点，把频数内化到 <code>Node</code> 中。</li>\n<li>把频数哈希表变为 <code>key2Node</code>，要获取频数可以先得到 <code>Node</code>，在通过 <code>node.freq</code> 获取。</li>\n<li>使用 <code>LinkedList</code> 进行链表操作，自行模拟链表插入、删除操作维护链表顺序。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LFUCache</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,LinkedList&lt;Node&gt;&gt; freq2list = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,Node&gt; key2node = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">minfreq</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LFUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> move(key,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(move(key,value)!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key2node.size()==capacity)&#123;</span><br><span class=\"line\">            List&lt;Node&gt; list = freq2list.get(minfreq);</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">oldNode</span> <span class=\"operator\">=</span> list.removeFirst();</span><br><span class=\"line\">            key2node.remove(oldNode.key);   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">newNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(key,value,<span class=\"number\">1</span>);</span><br><span class=\"line\">        key2node.put(key,newNode);</span><br><span class=\"line\">        freq2list.computeIfAbsent(<span class=\"number\">1</span>,k-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;()).add(newNode);</span><br><span class=\"line\">        minfreq = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">move</span><span class=\"params\">(Integer key, Integer value)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> key2node.getOrDefault(key,<span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        LinkedList&lt;Node&gt; list = freq2list.get(node.freq);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            value = node.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        list.remove(node); <span class=\"comment\">// 不为 O(1)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list.size()==<span class=\"number\">0</span> &amp;&amp; minfreq==node.freq)&#123;</span><br><span class=\"line\">            minfreq++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        node.freq++;</span><br><span class=\"line\">        node.value = value;</span><br><span class=\"line\">        freq2list.computeIfAbsent(node.freq,k-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;()).add(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"type\">int</span> freq;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">()</span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(<span class=\"type\">int</span> key,<span class=\"type\">int</span> value,<span class=\"type\">int</span> freq)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.freq = freq;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的实现中，还是存在 <code>LinkedList</code> 的 <code>remove(obj)</code> 的时间复杂度过高的问题。我们需要字节写双向链表。要点：</p>\n<ul>\n<li>自写<strong>循环双向链表</strong>，降低代码实现难度</li>\n<li>利用 <code>key2Node</code> 哈希表能在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 时间内定位待删结点，降低时间复杂度。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LFUCache</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,MyLinkedList&gt; freq2list = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Integer,Node&gt; key2node = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">minfreq</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LFUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> move(key,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(move(key,value)!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key2node.size()==capacity)&#123;</span><br><span class=\"line\">            <span class=\"type\">MyLinkedList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> freq2list.get(minfreq);</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">oldNode</span> <span class=\"operator\">=</span> list.removeFirst();</span><br><span class=\"line\">            key2node.remove(oldNode.key);   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">newNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(key,value,<span class=\"number\">1</span>);</span><br><span class=\"line\">        key2node.put(key,newNode);</span><br><span class=\"line\">        freq2list.computeIfAbsent(<span class=\"number\">1</span>,k-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">MyLinkedList</span>()).add(newNode);</span><br><span class=\"line\">        minfreq = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">move</span><span class=\"params\">(Integer key, Integer value)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> key2node.getOrDefault(key,<span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">MyLinkedList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> freq2list.get(node.freq);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            value = node.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        list.remove(node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list.size==<span class=\"number\">0</span> &amp;&amp; minfreq==node.freq)&#123;</span><br><span class=\"line\">            minfreq++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        node.freq++;</span><br><span class=\"line\">        node.value = value;</span><br><span class=\"line\">        freq2list.computeIfAbsent(node.freq,k-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">MyLinkedList</span>()).add(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"type\">int</span> freq;</span><br><span class=\"line\">    Node pre;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">()</span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(Node pre,Node next)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.pre = pre;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(<span class=\"type\">int</span> key,<span class=\"type\">int</span> value,<span class=\"type\">int</span> freq)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.freq = freq;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span>&#123;</span><br><span class=\"line\">    Node dummy;</span><br><span class=\"line\">    <span class=\"type\">int</span> size=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyLinkedList</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dummy = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dummy.next = <span class=\"built_in\">this</span>.dummy;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dummy.pre = <span class=\"built_in\">this</span>.dummy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(Node node)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">lastNode</span> <span class=\"operator\">=</span> dummy.pre;</span><br><span class=\"line\">        lastNode.next = node;</span><br><span class=\"line\">        dummy.pre = node;</span><br><span class=\"line\">        node.pre = lastNode;</span><br><span class=\"line\">        node.next = dummy;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"title function_\">remove</span><span class=\"params\">(Node node)</span>&#123;</span><br><span class=\"line\">        node.pre.next = node.next;</span><br><span class=\"line\">        node.next.pre = node.pre;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"title function_\">removeFirst</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> remove(<span class=\"built_in\">this</span>.dummy.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>王道 2023《408 数据结构》</li>\n<li><a href=\"https://baike.baidu.com/item/LRU\">LRU_百度百科 (baidu.com)</a></li>\n<li><a href=\"https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/?envType=study-plan-v2&amp;envId=top-interview-150\">146. LRU 缓存 - 力扣（LeetCode）</a></li>\n<li><a href=\"https://javaguide.cn/java/collection/linkedhashmap-source-code.html#linkedhashmap-%E7%AE%80%E4%BB%8B\">LinkedHashMap 源码分析 | JavaGuide</a></li>\n<li><a href=\"https://www.mianshiya.com/bank/1788408712975282177/question/1780933294783754241\">什么是 Java 的 LinkedHashMap？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 (mianshiya.com)</a></li>\n<li><a href=\"https://leetcode.cn/problems/lfu-cache/solutions/2457716/tu-jie-yi-zhang-tu-miao-dong-lfupythonja-f56h/\">【图解】一张图秒懂 LFU！（Python/Java/C++/Go/JS/Rust）-@灵茶山艾府- 力扣（LeetCode）</a></li>\n<li><a href=\"https://www.cnblogs.com/NickyYe/p/4461454.html\">Java中LinkedList的remove方法真的耗时O(1)吗？ - NickyYe - 博客园</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/591436083\">经典论文解读——Cache 替换算法 - 知乎</a></li>\n<li><a href=\"https://baike.baidu.com/item/belady/4808156\">belady_百度百科</a></li>\n</ul>\n","raw":"---\ntitle: 缓存置换算法的实现与 Java 中相关的数据结构\ntags:\n  - LRU\n  - LFU\n  - OPT\n  - Java\n  - 缓存\n  - 页面置换\n  - LeetCode\n  - 操作系统\ncover: https://cdn.gallery.uuanqin.top/img/202509131825096.webp\ndescription: OPT、LRU、LFU 不再惧怕\ncategories:\n  - 算法与数据结构\nabbrlink: 270917b1\ndate: 2025-09-13 18:15:18\ntop_img:\nkatex: true\n---\n\n> [!note]- 文章翻新 `250913`\n> - 补充 Java 相关数据结构 `LinkedList`、`LinkedHashMap`、`PriorityQueue` 信息\n> - 补充 OPT、LFU 算法题与解析\n>\n> 文章最初发表于 `240903`，原标题：手写 LRU 缓存以理解 Java 中的 LinkedHashMap，[原封面](https://cdn.gallery.uuanqin.top/img/202409050003261.webp)。\n\n在操作系统的学习过程中，我们会在不同的内容中（页面置换算法、高速缓冲器替换算法）接触到各种缓存置换算法：\n\n| 算法   | 名称         | 说明                                                           |\n| ---- | ---------- | ------------------------------------------------------------ |\n| OPT  | 最佳置换算法     | 此算法在已知未来所有访问记录的前提下，每次都替换未来不再被访问/最远被访问的现存数据。该算法是理论上的最优算法。     |\n| FIFO | 先进先出置换算法   | 每次替换最先进入缓存的数据，该算法认为最先进入的数据在将来被访问到的可能性最小。FIFO 算法存在 Belady 现象。 |\n| LRU  | 最近最少使用置换算法 | 每次替换最久未被访问的数据，该算法认为最近一段时间没有被访问到的数据在将来被访问的可能性最小，这种策略在实际中应用较广。 |\n| LFU  | 最少使用置换算法   | 每次替换访问次数最小的数据，该算法的思想是最近一段时间被访问次数最小的数据在将来被访问的可能性最小。           |\n| RAND | 随机算法       | 从现存数据中随机选择一个元素进行替换，该算法不需要维护历史访问记录的任何信息，实现上简单高效，但命中率通常一般。     |\n\n> [!note]- Belady 现象\n> Belady 现象是计算机系统中采用先进先出（FIFO）页面置换算法时出现的异常现象，表现为当分配给进程的物理页面数增加时，缺页率不降反升。贝拉迪通过实验发现，当操作系统未满足进程全部页面需求时，FIFO 算法可能因过早置换仍将被频繁访问的页面，引发更多缺页中断。这一发现打破了 「增加内存必然降低缺页率」的传统认知。\n\n缓存替换算法用于管理有限的缓存空间，决定哪些数据需要被移除以腾出空间。现在编程题也喜欢考察对于这些算法的实现能力。\n\n本文结合真实题目，讲解用 Java 语言实现 OPT、LRU、LFU 算法，并了解相关的 Java 数据结构。至于 FIFO、RAND 很简单，读者可自行实现。\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# Java 中相关的数据结构\n\n## `LinkedList` 双向链表\n\n> 从 JDK1.7 开始，`LinkedList` 由双向循环链表改为**双向链表**。\n\n`LinkedList` 是一个基于双向链表实现的集合类。\n\n![image.png|400](https://cdn.gallery.uuanqin.top/img/202509130013613.webp)\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202509130016033.webp)\n\n一些操作的时间复杂度：\n\n| API                                             | 操作               | 时间复杂度  | 源码做法         |\n| ----------------------------------------------- | ---------------- | ------ | ------------ |\n| `add(e)`<br>`addFirst(e)`<br>`addLast(e)`       | 头尾插入             | $O(1)$ | 双向链表常规做法     |\n| `add(index,e)`                                  | 指定位置插入           | $O(n)$ | 选择靠近的一端向中间遍历 |\n| `remove()`<br>`removeFirst()`<br>`removeLast()` | 头尾删除             | $O(1)$ | 双向链表常规做法     |\n| `remove(E e)`                                   | 指定元素删除（删除首次出现元素） | $O(n)$ | 从头到尾遍历链表     |\n| `remove(index)`                                 | 指定位置删除           | $O(n)$ | 选择靠近的一端向中间遍历 |\n| `getFirst()`<br>`getLast()`                     | 获取头尾元素           | $O(1)$ | 双向链表常规做法     |\n| `get(int index)`                                | 获取链表指定位置的元素      | $O(n)$ | 选择靠近的一端向中间遍历 |\n| `clear()`                                       | 移除此链表中的所有元素      | $O(n)$ | 从头到尾遍历链表     |\n| `contains(e)`                                   | 查询指定元素是否存于链表     | $O(n)$ | 从头到尾遍历链表     |\n\n> [!question] 循环使用 `remove(int index)` 的时间复杂度。\n> Q：在一个 `LinkedList` 类型的变量进行 `for` 循环遍历时，每轮迭代执行一次 `remove(index)` 操作，请问该循环时间复杂度是多少？\n>\n> A：$O(n^2)$，因为一次 `remove(int index)` 就需要 $O(n)$。\n\n## `LinkedHashMap` 含双向链表的哈希集合\n\n![image.png|350](https://cdn.gallery.uuanqin.top/img/202408310204657.webp)\n\n`LinkedHashMap` 是 Java 提供的一个集合类，它继承自 `HashMap`，并在 `HashMap` 基础上维护一条**双向链表**。\n\n![image.png|325](https://cdn.gallery.uuanqin.top/img/202509130057327.webp)\n\n`LinkedHashMap` 特性：\n\n- 支持遍历时会按照插入顺序有序进行迭代。**（与 `HashMap` 的最大区别）**\n- 支持按照元素访问顺序排序，适用于封装 LRU 缓存工具。\n- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。**由于双向链表的存在，其插入性能可能会比 `HashMap` 略低。**\n\n### 基本特性 `LinkedHashMap` 迭代顺序和插入顺序一致\n\n它的用法和 `HashMap` 一致。特点在于 `LinkedHashMap` 的从头到尾迭代顺序是和插入顺序一致的，而 `HashMap` 中是随机的。\n\n### 可在构造函数中开启访问顺序 `accessOrder`\n\n`LinkedHashMap` 定义了排序模式 `boolean accessOrder = false`。当 `accessOrder` 为 `true` 时，被访问的元素将重新拿出来放到**链表尾部**。\n\n设置方式：\n\n```java\n// 初始容量、负载因子、访问顺序\nLinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);\n```\n\n### 重写 `removeEldestEntry` 方法\n\n`removeEldestEntry` 将返回一个 `boolean` 值，告知 `LinkedHashMap` 是否需要移除链表首元素。我们需要在继承 `LinkedHashMap` 的子类中重写该方法：\n\n```java\npublic class MyMap<K, V> extends LinkedHashMap<K, V> {\n\n    public MyMap(int capacity) {\n        super(capacity, 0.75f, true);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return /* 编写判断逻辑 */;\n    }\n}\n```\n\n## `PriorityQueue` 优先队列（二项堆）\n\n优先队列基于二项堆，用法详见：[[Java 集合的使用]]。\n\n# 最佳置换算法 OPT\n\n缓存替换的最优算法（MIN/OPT，Optimal）在 1966 年由 Laszlo A.Belady 提出，此算法在已知未来所有访问记录的前提下，每次都替换未来不再被访问/最远被访问的现存数据。该算法是理论上的最优算法，因为需要已知未来所有访问记录，并不具备可实现性，通常用于衡量其它缓存替换算法的优劣。\n\n> [!example] 🟨 [P4404 [JSOI2010] 缓存交换 - 洛谷](https://www.luogu.com.cn/problem/P4404#ide)\n>\n> 在计算机中，CPU 只能和高速缓存 Cache 直接交换数据。当所需的内存单元不在 Cache 中时，则需要从主存里把数据调入 Cache。此时，如果 Cache 容量已满，则必须先从中删除一个。\n>\n> 在现代计算机中，往往采用 LRU(最近最少使用) 的算法来进行 Cache 调度——可是，从上一个例子就能看出，这并不是最优的算法。 对于一个固定容量的空 Cache 和连续的若干主存访问请求，聪聪想知道如何在每次 Cache 缺失时换出正确的主存单元，以达到最少的 Cache 缺失次数。\n\n思路：采用 OPT，即淘汰在之后的访问中，出现最晚（甚至不出现）的元素。\n\n我的解法：\n\n- 使用到的数据结构有哈希表和优先队列。\n- 哈希表用于快速判断缓存中是否存在指定的 `key`。\n- 优先队列可快速得出待删元素。\n- 更新键值时，从优先队列中找出相应元素并删除的 `remove(obj)` 操作可能有一定的时间复杂度。\n\n```java\nimport java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int M = in.nextInt();\n        int[] dataIds = new int[N];\n        for(int i=0;i<N;i++){\n            dataIds[i]=in.nextInt();\n        }\n\n        int ans = f(N,M,dataIds);\n        System.out.println(ans);\n    }\n\n    public static int f(int n,int capacity,int[] dataIds){\n        int[] next = new int[n]; // 表示当前 id 下一次出现的位置\n        Arrays.fill(next,Integer.MAX_VALUE);\n        Map<Integer,Integer> map = new HashMap<>(); // id->lastIdx\n        for(int i=0;i<n;i++){\n            if(map.containsKey(dataIds[i])){\n                int lastIdx = map.get(dataIds[i]);\n                next[lastIdx] = i;\n            }\n            map.put(dataIds[i],i);\n        }\n        PriorityQueue<Node> q = new PriorityQueue<>((n1,n2)->{\n            return n2.next-n1.next;\n        });\n        Map<Integer,Node> keyMap = new HashMap<>(); // 为了更快判断缓存中是否存在对应的键\n        int miss = 0;\n        for(int i=0;i<n;i++){\n            if(keyMap.containsKey(dataIds[i])){\n                Node node = keyMap.get(dataIds[i]);\n                q.remove(node);\n                node.next = next[i];\n                q.offer(node);\n                continue;\n            }\n            if(q.size()==capacity){\n                Node oldNode = q.poll();\n                keyMap.remove(oldNode.id);\n            }\n            Node newNode = new Node(dataIds[i],next[i]);\n            q.offer(newNode);\n            keyMap.put(dataIds[i],newNode);\n            miss++;\n        }\n        return miss;\n    }\n}\n\nclass Node{\n    Integer id;\n    int next;\n    Node(Integer id,int next){\n        this.id= id;\n        this.next = next;\n    }\n}\n```\n\n# 最近最少使用 LRU\n\n最近最少使用（Least Recently Used，LRU），是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。\n\n> [!example] 题目：🟨 [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-interview-150)\n> 请你设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。\n> 实现 `LRUCache` 类：\n> - `LRUCache(int capacity)` 以 正整数 作为容量 `capacity` 初始化 LRU 缓存\n> - `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 -1 。\n> - `void put(int key, int value)`\n> \t- 如果关键字 `key` 已经存在，则变更其数据值 `value`\n> \t- 如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 `capacity` ，则应该 逐出 最久未使用的关键字。\n>\n> 函数 `get` 和 `put` 必须以 $O(1)$ 的平均时间复杂度运行。\n\n首先介绍直接使用 Java API 的写法。Java 中 `LinkedHashMap` 的特性使其天然地成为轻松实现 LRU 缓存的数据结构。具体实现思路如下：\n\n- 继承 `LinkedHashMap`；\n- 构造方法中指定 `accessOrder` 为 `true` ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；\n- 重写 `removeEldestEntry` 方法，该方法会返回一个 `boolean` 值，告知 `LinkedHashMap` 是否需要移除链表首元素（缓存容量有限）。\n\n```java\nclass LRUCache extends LinkedHashMap<Integer,Integer>{\n    int capacity;\n    public LRUCache(int capacity) {\n\t\tsuper(capacity,0.75f,true);\n\t\tthis.capacity = capacity;\n    }\n\n\t// 由于题目对get返回值要求，这里我们需要进行一些调整，不然我们都可以干脆不写。\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    /* 题目中 put 方法直接交给 LinkedHashMap */\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest){\n        return size() > capacity;\n    }\n}\n```\n\n如果面试手撕环节这道题目这样写，估计面试官就会叫你在家等通知了。`LinkedHashMap` 无外乎就是哈希表 `HashMap` + 双向链表 `LinkedList`。把它拆开来，就会有以下实现：\n\n- `HashMap` + `LinkedList`。`HashMap` 用于快速定位双向链表中的结点；`LinkedList` 用于区分缓存 `key` 的访问顺序。\n- 双向链表必须自己手动建立并维护各种结点操作\n\n```java\nclass LRUCache {\n    public List<Node> list = new LinkedList<>();\n    public Map<Integer,Node> map = new HashMap<>();\n    public int capacity;\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        Node node = map.get(key);\n        list.remove(node);\n        list.addLast(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            Node node = map.get(key);\n            list.remove(node);\n            node.value = value;\n            list.addLast(node);\n            return;\n        }\n        \n        if(map.size()==capacity){\n            Node oldNode = list.removeFirst();\n            map.remove(oldNode.key);\n        }\n        Node newNode = new Node(key,value);\n        list.addLast(newNode);\n        map.put(key,newNode);\n    }\n}\n\nclass Node{\n    int key;\n    int value;\n    Node pre,next;\n    public Node(){};\n    public Node(int key,int value){\n        this.key = key;\n        this.value = value;\n    }\n}\n```\n\n但是，上面的实现方法中使用了 `LinkedList` 的 `remove(obj)` 操作，这个操作的时间复杂度为 $O(n)$，不符合题目的时间复杂度要求。因此我们需要自己手写双向链表改进这块的时间复杂度。在接下来的实现中：\n\n- 使用**循环双向链表**，简化代码编写\n- 利用 `HashMap` 直接定位链表中待删除的 `node`，优化 `remove(obj)` 的时间复杂度\n- 只会编写必要的链表操作。\n\n```java\nclass LRUCache {\n    public Node head = new Node();\n    public Map<Integer,Node> map = new HashMap<>();\n    public int capacity;\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head.next=head;\n        head.pre = head;\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        Node node = map.get(key);\n        remove(node);\n        addLast(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            Node node = remove(map.get(key));\n            node.value = value;\n            addLast(node);\n            return;\n        }\n        \n        \n        if(map.size()==capacity){\n            Node oldNode = removeFirst();\n            map.remove(oldNode.key);\n        }\n        Node newNode = new Node(key,value);\n        addLast(newNode);\n        map.put(key,newNode);\n    }\n    \n    // 时间复杂度缩短至 O(1)\n    public Node remove(Node node){\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n        return node;\n    }\n    \n    public Node removeFirst(){\n        return remove(head.next);\n    }\n    \n    public void addLast(Node node){\n        node.pre = head.pre;\n        node.next = head;\n        head.pre.next = node;\n        head.pre = node;\n    }\n    \n}\n\nclass Node{\n    int key;\n    int value;\n    Node pre,next;\n    public Node(){};\n    public Node(int key,int value){\n        this.key = key;\n        this.value = value;\n    }\n}\n```\n\n# 最少使用置换算法 LFU\n\n最近最不常用算法（LFU，Least Frequently Used）每次替换访问次数最小的数据，该算法的思想是最近一段时间被访问次数最小的数据在将来被访问的可能性最小。\n\n> [!example] 🟥 [460. LFU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lfu-cache/description/)\n> 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。\n>\n> 实现 `LFUCache` 类：\n>\n> - `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象\n> - `int get(int key)` - 如果键 `key` 存在于缓存中，则获取键的值，否则返回 `-1` 。\n> - `void put(int key, int value)` 如果键 `key` 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 `capacity` 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最久未使用** 的键。\n> \n> 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。\n>\n> 当一个键首次插入到缓存中时，它的使用计数器被设置为 1（由于 `put` 操作）。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。\n>\n> 函数 `get` 和 `put` 必须以 $O(1)$ 的平均时间复杂度运行。\n\n同 LRU 中说明的顺序一样，我们还是先从 API 用法开始介绍，再慢慢改造为手工实现。\n\n实现要点：\n\n- 双 `HashMap`，一个保存 `key` 对应的频数（频数用于索引链表以及快速判空），一个保存不同频数下保存的链表结构。\n- 链表结构选用 `LinkedHashMap`，使用它的一些特性：\n\t- 链表特性：在平局情况时快速获取最久未使用的结点（表头结点）；插入键时自动插入链表末端。\n\t- 哈希表特性：删除元素时能达到 `O(1)` 时间复杂度\n\n```java\nclass LFUCache {\n    public Map<Integer,Map<Integer,Integer>> freq2map = new HashMap<>();\n    public Map<Integer,Integer> key2freq = new HashMap<>();\n\n    public int capacity;\n    public int minfreq = 0;\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return move(key,null);\n    }\n    \n    public void put(int key, int value) {\n        if(move(key,value)!=-1){\n            return;\n        }\n        if(key2freq.size()==capacity){\n            Map<Integer,Integer> map = freq2map.get(minfreq);\n            Integer k = map.keySet().iterator().next();\n            map.remove(k);\n            key2freq.remove(k);   \n        }\n        key2freq.put(key,1);\n        freq2map.computeIfAbsent(1,k->new LinkedHashMap<>()).put(key,value);\n        minfreq = 1;\n    }\n    \n    public Integer move(Integer key, Integer value){\n        Integer freq = key2freq.getOrDefault(key,null);\n        if(freq==null){\n            return -1;\n        }\n        \n        // Integer value = freq2map.get(freq).remove(key);\n        Map<Integer,Integer> map = freq2map.get(freq);\n        if(value==null){\n            value = map.get(key);\n        }\n        map.remove(key);\n        if(map.size()==0 && minfreq==freq){\n            minfreq++;\n        }\n    \n        \n        Integer newFreq= freq+1;\n        key2freq.put(key,newFreq);\n        freq2map.computeIfAbsent(newFreq,k->new LinkedHashMap<>()).put(key,value);\n        return value;\n    }\n}\n```\n\n接下来，我们开始用 `LinkedList` 替换 `LinkedHashMap`。变化点：\n\n- 我们创建了 `Node` 结点，把频数内化到 `Node` 中。\n- 把频数哈希表变为 `key2Node`，要获取频数可以先得到 `Node`，在通过 `node.freq` 获取。\n- 使用 `LinkedList` 进行链表操作，自行模拟链表插入、删除操作维护链表顺序。\n\n```java\nclass LFUCache {\n    \n    public Map<Integer,LinkedList<Node>> freq2list = new HashMap<>();\n    public Map<Integer,Node> key2node = new HashMap<>();\n\n    public int capacity;\n    public int minfreq = 0;\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return move(key,null);\n    }\n    \n    public void put(int key, int value) {\n        if(move(key,value)!=-1){\n            return;\n        }\n        if(key2node.size()==capacity){\n            List<Node> list = freq2list.get(minfreq);\n            Node oldNode = list.removeFirst();\n            key2node.remove(oldNode.key);   \n        }\n        Node newNode = new Node(key,value,1);\n        key2node.put(key,newNode);\n        freq2list.computeIfAbsent(1,k->new LinkedList<>()).add(newNode);\n        minfreq = 1;\n    }\n    \n    public Integer move(Integer key, Integer value){\n        Node node = key2node.getOrDefault(key,null);\n        if(node==null){\n            return -1;\n        }\n        \n        LinkedList<Node> list = freq2list.get(node.freq);\n        if(value==null){\n            value = node.value;\n        }\n        list.remove(node); // 不为 O(1)\n        if(list.size()==0 && minfreq==node.freq){\n            minfreq++;\n        }\n    \n        node.freq++;\n        node.value = value;\n        freq2list.computeIfAbsent(node.freq,k->new LinkedList<>()).add(node);\n        return value;\n    }\n}\n\nclass Node{\n    int key;\n    int value;\n    int freq;\n    public Node(){};\n    public Node(int key,int value,int freq){\n        this.key = key;\n        this.value = value;\n        this.freq = freq;\n    }\n}\n```\n\n在上面的实现中，还是存在 `LinkedList` 的 `remove(obj)` 的时间复杂度过高的问题。我们需要字节写双向链表。要点：\n\n- 自写**循环双向链表**，降低代码实现难度\n- 利用 `key2Node` 哈希表能在 $O(1)$ 时间内定位待删结点，降低时间复杂度。\n\n```java\nclass LFUCache {\n    \n    public Map<Integer,MyLinkedList> freq2list = new HashMap<>();\n    public Map<Integer,Node> key2node = new HashMap<>();\n\n    public int capacity;\n    public int minfreq = 0;\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return move(key,null);\n    }\n    \n    public void put(int key, int value) {\n        if(move(key,value)!=-1){\n            return;\n        }\n        if(key2node.size()==capacity){\n            MyLinkedList list = freq2list.get(minfreq);\n            Node oldNode = list.removeFirst();\n            key2node.remove(oldNode.key);   \n        }\n        Node newNode = new Node(key,value,1);\n        key2node.put(key,newNode);\n        freq2list.computeIfAbsent(1,k->new MyLinkedList()).add(newNode);\n        minfreq = 1;\n    }\n    \n    public Integer move(Integer key, Integer value){\n        Node node = key2node.getOrDefault(key,null);\n        if(node==null){\n            return -1;\n        }\n        \n        MyLinkedList list = freq2list.get(node.freq);\n        if(value==null){\n            value = node.value;\n        }\n        list.remove(node);\n        if(list.size==0 && minfreq==node.freq){\n            minfreq++;\n        }\n    \n        node.freq++;\n        node.value = value;\n        freq2list.computeIfAbsent(node.freq,k->new MyLinkedList()).add(node);\n        return value;\n    }\n}\n\nclass Node{\n    int key;\n    int value;\n    int freq;\n    Node pre;\n    Node next;\n    public Node(){};\n    public Node(Node pre,Node next){\n        this.pre = pre;\n        this.next = next;\n    }\n    public Node(int key,int value,int freq){\n        this.key = key;\n        this.value = value;\n        this.freq = freq;\n    }\n}\n\nclass MyLinkedList{\n    Node dummy;\n    int size=0;\n    public MyLinkedList(){\n        this.dummy = new Node();\n        this.dummy.next = this.dummy;\n        this.dummy.pre = this.dummy;\n    }\n    \n    public void add(Node node){\n        Node lastNode = dummy.pre;\n        lastNode.next = node;\n        dummy.pre = node;\n        node.pre = lastNode;\n        node.next = dummy;\n        this.size++;\n    }\n    \n    public Node remove(Node node){\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n        this.size--;\n        return node;\n    }\n    \n    public Node removeFirst(){\n        return remove(this.dummy.next);\n    }\n   \n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n# 本文参考\n\n- 王道 2023《408 数据结构》\n- [LRU_百度百科 (baidu.com)](https://baike.baidu.com/item/LRU)\n- [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150)\n- [LinkedHashMap 源码分析 | JavaGuide](https://javaguide.cn/java/collection/linkedhashmap-source-code.html#linkedhashmap-%E7%AE%80%E4%BB%8B)\n- [什么是 Java 的 LinkedHashMap？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 (mianshiya.com)](https://www.mianshiya.com/bank/1788408712975282177/question/1780933294783754241)\n- [【图解】一张图秒懂 LFU！（Python/Java/C++/Go/JS/Rust）-@灵茶山艾府- 力扣（LeetCode）](https://leetcode.cn/problems/lfu-cache/solutions/2457716/tu-jie-yi-zhang-tu-miao-dong-lfupythonja-f56h/)\n- [Java中LinkedList的remove方法真的耗时O(1)吗？ - NickyYe - 博客园](https://www.cnblogs.com/NickyYe/p/4461454.html)\n- [经典论文解读——Cache 替换算法 - 知乎](https://zhuanlan.zhihu.com/p/591436083)\n- [belady_百度百科](https://baike.baidu.com/item/belady/4808156)\n\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"LRU","api":"api/tags/LRU.json"},{"name":"LFU","api":"api/tags/LFU.json"},{"name":"OPT","api":"api/tags/OPT.json"},{"name":"缓存","api":"api/tags/缓存.json"},{"name":"页面置换","api":"api/tags/页面置换.json"},{"name":"操作系统","api":"api/tags/操作系统.json"}]},"api":"api/posts/p/270917b1.json"}