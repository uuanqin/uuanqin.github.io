{"data":{"title":"计算汉明重量的两个技巧性算法","slug":"算法与数据结构/计算汉明重量的两个技巧性算法","description":"介绍两个精妙的技巧性算法","date":"2024-07-06T10:53:09.000Z","updated":"2026-02-05T04:31:05.785Z","language":"zh-CN","comments":true,"url":"p/77c7bcae/","cover":"https://cdn.gallery.uuanqin.top/img/202409050044036.webp","images":[],"content":"<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"汉明重量\"><a class=\"markdownIt-Anchor\" href=\"#汉明重量\"></a> 汉明重量</h1>\n<p><a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F\">汉明重量</a> 是一串符号中非零符号的个数。对于二进制串来说就是 <code>1</code> 的个数 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟩 <a href=\"https://leetcode.cn/problems/number-of-1-bits/description/\">191. 位1的个数 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中设置位的个数。</p>\n</div></div><h2 id=\"常规算法\"><a class=\"markdownIt-Anchor\" href=\"#常规算法\"></a> 常规算法</h2>\n<p>常规方法：循环检查二进制位，判断每一位整数是否为 1。</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>，k 是二进制整数的位数</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<h2 id=\"brian-kernighan-算法\"><a class=\"markdownIt-Anchor\" href=\"#brian-kernighan-算法\"></a> Brian Kernighan 算法</h2>\n<blockquote>\n<p>Brian Kernighan 算法发布在 1988 年出版的 The C Programming Language (Second Edition) （由 Brian W. Kernighan 和 Dennis M. Ritchie 编写）的练习中，但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。读者可以在上述书籍中找到更多位操作的技巧。</p>\n</blockquote>\n<p>「Brian Kernighan 算法」用于清除二进制串中最右边的 1。</p>\n<p>统计数 <code>x</code> 二进制表示中 1 的个数可以使用 Brian Kernighan 算法可以加速统计。</p>\n<p>算法核心：记 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 表示 <code>x</code> 和 <code>x-1</code> 进行与运算所得的结果，即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">f(x)=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span><code>x &amp; (x-1)</code>，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 恰为 <code>x</code> 删去其二进制表示中最右侧的 1 的结果。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子</div>\n</div>\n<div class=\"callout-content\"><p><code>x     = 0b10001000</code><br />\n<code>x-1    = 0b10000111</code><br />\n<code>x&amp;(x-1) = 0b10000000</code></p>\n</div></div><p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>。C 表示元素的数据范围，循环次数等于 <code>x</code> 的二进制位中 1 的个数。当 x 为 32 位整数时 ，最坏情况下 <code>x</code> 二进制位全部为 1，我们需要循环 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><msup><mn>2</mn><mn>31</mn></msup><mo>=</mo><mn>31</mn></mrow><annotation encoding=\"application/x-tex\">\\log 2^{31}=31</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">1</span></span></span></span> 次。</p>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，我们只需要常数的空间保存若干变量。</p>\n<blockquote>\n<p>相关题目：🟨 <a href=\"https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/\">201. 数字范围按位与 - 力扣（LeetCode）</a></p>\n</blockquote>\n<h2 id=\"mit-hakm-算法\"><a class=\"markdownIt-Anchor\" href=\"#mit-hakm-算法\"></a> MIT HAKM 算法</h2>\n<blockquote>\n<p>MIT Hackmem 169</p>\n</blockquote>\n<p>求 32 位无符号数的二进制形式中 1 的个数。</p>\n<p>核心原理是分治法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">bitcount</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = n - ((n &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">033333333333</span>)</span><br><span class=\"line\">            - ((n &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">011111111111</span>); <span class=\"comment\">// 注意这是8进制表示</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((tmp + (tmp &gt;&gt; <span class=\"number\">3</span>)) &amp; <span class=\"number\">030707070707</span>)%<span class=\"number\">63</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240706182641.webp\" alt=\"image.png\" /></p>\n<p>考虑 3 位 2 进制数 x：<code>abc</code></p>\n<ul>\n<li><code>x&gt;&gt;1 == 4a+2b+c&gt;&gt;1==2a+b</code></li>\n<li><code>x&gt;&gt;2 == 4a+2b+c&gt;&gt;2==a</code></li>\n<li><code>4a+2b+c-(2a+b)-a == a+b+c</code></li>\n<li>因此 <code>x-x&gt;&gt;1-x&gt;&gt;2 == a+b+c</code> 即为 1 的个数</li>\n</ul>\n<p>把 32 位数按每 3 位划分，通过掩码，完成每 3 位的移位减操作，这样每 3 位中的值就是这 3 位中 1 的个数。</p>\n<p>每相邻 3 位相加，mask 后，每 6 位中的值即为 6 位中 1 的个数</p>\n<p><code>64^5*t6+64^4*t5+64^3*t4+64^2*t3+64*t2+t1 mod 63 = t6+t5+t4+t3+t2+t1</code> 即为 32 位中 1 的个数。取模 63 不出错的要点在于 x 是个 32 位的数，t6+t5+t4+t3+t2+t1 不会被模掉。</p>\n<blockquote>\n<p>注意是取模 63，而不是 64。</p>\n</blockquote>\n<h1 id=\"汉明距离\"><a class=\"markdownIt-Anchor\" href=\"#汉明距离\"></a> 汉明距离</h1>\n<p>本小节为汉明重量的延伸应用。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟩 <a href=\"https://leetcode.cn/problems/hamming-distance/description/\">461. 汉明距离 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p>\n</div></div><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\">汉明距离</a> 广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。</p>\n<p>方法：</p>\n<ol>\n<li>计算 x 和 y 之间的汉明距离，可以先计算 <code>x^y</code></li>\n<li>然后统计结果中等于 1 的位数。可以使用 Brian Kernighan 算法。</li>\n</ol>\n<p>其他相关题目：</p>\n<ul>\n<li>🟩 <a href=\"https://leetcode.cn/problems/convert-integer-lcci/description/\">面试题 05.06. 整数转换 - 力扣（LeetCode）</a></li>\n</ul>\n<blockquote>\n<p>附：常见的距离度量<br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202505212246469.webp\" alt=\"image.png\" width=\"400px\" /></p>\n</blockquote>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《深入理解计算机系统》第 3 版</li>\n<li>研究生课程 CSAPP 课件</li>\n<li>LeetCode 相关题目</li>\n</ul>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>2023 USTC SSE 复试机试题 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","raw":"---\ntitle: 计算汉明重量的两个技巧性算法\ntags:\n  - 汉明重量\n  - 汉明距离\n  - 位运算\n  - LeetCode\n  - C\ncover: 'https://cdn.gallery.uuanqin.top/img/202409050044036.webp'\ndescription: 介绍两个精妙的技巧性算法\ncategories:\n  - 算法与数据结构\nabbrlink: 77c7bcae\nkatex: true\ndate: 2024-07-06 18:53:09\nsummary: >-\n  本文介绍汉明重量及延伸的汉明距离相关知识与求解算法。汉明重量即二进制串中 1 的个数，求解有循环检查的常规算法，还有更高效的 Brian Kernighan 算法，其通过位运算快速清除最右侧 1 来统计，以及基于分治法的 MIT HAKM 算法，能快速计算 32 位无符号数的 1 的个数。汉明距离是两整数二进制位不同位置的数目，可先对两数做异或运算，再用 Brian Kernighan 算法统计结果中 1 的位数求解，二者均有对应的力扣题目可练习。\ntop_img:\n---\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 汉明重量\n\n[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F) 是一串符号中非零符号的个数。对于二进制串来说就是 `1` 的个数 [^kr]。\n\n> [!example] 题目：🟩 [191. 位1的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-1-bits/description/)\n> 编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中设置位的个数。\n\n[^kr]: 2023 USTC SSE 复试机试题\n\n## 常规算法\n\n常规方法：循环检查二进制位，判断每一位整数是否为 1。\n\n- 时间复杂度：$O(k)$，k 是二进制整数的位数\n- 空间复杂度：$O(1)$。\n\n## Brian Kernighan 算法\n\n> Brian Kernighan 算法发布在 1988 年出版的 The C Programming Language (Second Edition) （由 Brian W. Kernighan 和 Dennis M. Ritchie 编写）的练习中，但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。读者可以在上述书籍中找到更多位操作的技巧。\n\n「Brian Kernighan 算法」用于清除二进制串中最右边的 1。\n\n统计数 `x` 二进制表示中 1 的个数可以使用 Brian Kernighan 算法可以加速统计。\n\n算法核心：记 $f(x)$ 表示 `x` 和 `x-1` 进行与运算所得的结果，即 $f(x)=$`x & (x-1)`，那么 $f(x)$ 恰为 `x` 删去其二进制表示中最右侧的 1 的结果。\n\n> [!example] 例子\n> `x     = 0b10001000`\n> `x-1    = 0b10000111`\n> `x&(x-1) = 0b10000000`\n\n时间复杂度：$O(\\log C)$。C 表示元素的数据范围，循环次数等于 `x` 的二进制位中 1 的个数。当 x 为 32 位整数时 ，最坏情况下 `x` 二进制位全部为 1，我们需要循环 $\\log 2^{31}=31$ 次。\n\n空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。\n\n> 相关题目：🟨 [201. 数字范围按位与 - 力扣（LeetCode）](https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/)\n\n## MIT HAKM 算法\n\n> MIT Hackmem 169\n\n求 32 位无符号数的二进制形式中 1 的个数。\n\n核心原理是分治法。\n\n```c\nint bitcount(unsigned int n)\n{\n    unsigned int tmp;\n\n    tmp = n - ((n >> 1) & 033333333333)\n            - ((n >> 2) & 011111111111); // 注意这是8进制表示\n    return ((tmp + (tmp >> 3)) & 030707070707)%63;\n}\n```\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240706182641.webp)\n\n考虑 3 位 2 进制数 x：`abc`\n\n- `x>>1 == 4a+2b+c>>1==2a+b`\n- `x>>2 == 4a+2b+c>>2==a`\n- `4a+2b+c-(2a+b)-a == a+b+c`\n- 因此 `x-x>>1-x>>2 == a+b+c` 即为 1 的个数\n\n把 32 位数按每 3 位划分，通过掩码，完成每 3 位的移位减操作，这样每 3 位中的值就是这 3 位中 1 的个数。\n\n每相邻 3 位相加，mask 后，每 6 位中的值即为 6 位中 1 的个数\n\n`64^5*t6+64^4*t5+64^3*t4+64^2*t3+64*t2+t1 mod 63 = t6+t5+t4+t3+t2+t1` 即为 32 位中 1 的个数。取模 63 不出错的要点在于 x 是个 32 位的数，t6+t5+t4+t3+t2+t1 不会被模掉。\n\n> 注意是取模 63，而不是 64。\n\n# 汉明距离\n\n本小节为汉明重量的延伸应用。\n\n> [!example] 题目：🟩 [461. 汉明距离 - 力扣（LeetCode）](https://leetcode.cn/problems/hamming-distance/description/)\n> 给你两个整数 x 和 y，计算并返回它们之间的汉明距离。\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB) 广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。\n\n方法：\n\n1. 计算 x 和 y 之间的汉明距离，可以先计算 `x^y`\n2. 然后统计结果中等于 1 的位数。可以使用 Brian Kernighan 算法。\n\n其他相关题目：\n\n- 🟩 [面试题 05.06. 整数转换 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-integer-lcci/description/)\n\n> 附：常见的距离度量\n> ![image.png|400](https://cdn.gallery.uuanqin.top/img/202505212246469.webp)\n\n# 本文参考\n\n- 《深入理解计算机系统》第 3 版\n- 研究生课程 CSAPP 课件\n- LeetCode 相关题目\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"C","api":"api/tags/C.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"位运算","api":"api/tags/位运算.json"},{"name":"汉明重量","api":"api/tags/汉明重量.json"},{"name":"汉明距离","api":"api/tags/汉明距离.json"}]},"api":"api/posts/p/77c7bcae.json"}