{"data":{"title":"关于海量数据的若干问题","slug":"算法与数据结构/关于海量数据的若干问题","description":"太卷了","date":"2025-09-05T14:58:15.000Z","updated":"2025-09-05T14:58:54.861Z","language":"zh-CN","comments":true,"url":"p/4fdbc02c/","cover":"https://cdn.gallery.uuanqin.top/img/202509052258680.webp","images":[],"content":"<p>本文为面试笔记整理。以前看八股总是随缘，没有系统的整理。现在秋招，正好有机会把各种八股和以前学过的东西都串联起来，给笔记清清灰。</p>\n<h1 id=\"海量数据问题基本思路\"><a class=\"markdownIt-Anchor\" href=\"#海量数据问题基本思路\"></a> 海量数据问题基本思路</h1>\n<p>看到海量数据的处理问题，可以按以下思想考虑：</p>\n<ol>\n<li>分治。一看到数据量但内存受限的问题首选分治。但是海量数据基本都要分治，可以作为一种基础思想。</li>\n<li>哈希。耗内存，但适合快速查找。</li>\n<li>Bit 位。如位图、布隆过滤器。适用于快速查找、判重。</li>\n<li>堆。Top K、最值问题。注意 K 不要过大，需要能放进内存。</li>\n</ol>\n<p>本文将针对处理海量数据的不同场景，引出相应的数据结构或算法：</p>\n<ol>\n<li>海量数据的存在性与去重：哈希映射、字典树、位图、布隆过滤器</li>\n<li>海量数据的排序：桶排序、计数排序、基数排序、堆与堆排序、归并排序</li>\n<li>海量数据的 Top K 问题：堆的应用</li>\n<li>海量数据的中位数及任意百分位的数据：堆与分片</li>\n<li>海量数据的增删改查：索引与倒排索引</li>\n<li>海量数据的分布式处理：MapReduce</li>\n</ol>\n<p>需要注意的是。对于海量数据的处理，我们会综合使用多种数据结构进行处理，每一种数据结构不一定只会解决同一种问题。</p>\n<h1 id=\"海量数据的存在性与去重\"><a class=\"markdownIt-Anchor\" href=\"#海量数据的存在性与去重\"></a> 海量数据的存在性与去重</h1>\n<h2 id=\"哈希映射-hash\"><a class=\"markdownIt-Anchor\" href=\"#哈希映射-hash\"></a> 哈希映射 hash</h2>\n<p>哈希映射的特点就是，同一个关键字将映射到相同的位置。</p>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">找出两个巨大文件的共同的关键字</div>\n</div>\n<div class=\"callout-content\"><p>给定 a、b 两个文件，各存放 50 亿个关键字，每个关键字各占 64 字节，内存限制是 4G，找出 a、b 文件共同的关键字。</p>\n<p>步骤：</p>\n<ul>\n<li><strong>分治</strong>与<strong>哈希</strong>：\n<ul>\n<li>将文件 a 中的关键字通过哈希映射到 1000 个小文件，每个文件记为 <code>a[i]</code>；将文件 b 中的关键字通过哈希映射到 1000 个小文件，每个文件记为 <code>b[i]</code>。</li>\n<li>由于哈希映射的特点，相同关键字只会被分到 <code>a[i]</code> 或 <code>b[i]</code> 中。</li>\n</ul>\n</li>\n<li>对每个 <code>i</code> 求相同关键字：\n<ul>\n<li>将 <code>a[i]</code> 文件中的关键字放入哈希表 <code>H</code> 中；</li>\n<li>遍历 <code>b[i]</code> 逐个关键字 <code>k</code> 判断是否在哈希表 <code>H</code> 中；</li>\n<li>如果关键字 <code>k</code> 在 <code>H</code> 中出现，那么将 <code>k</code> 加入结果中。</li>\n</ul>\n</li>\n</ul>\n<p>如果判重允许一定错误率，可考虑布隆过滤器。</p>\n</div></div><h2 id=\"字典树-trie\"><a class=\"markdownIt-Anchor\" href=\"#字典树-trie\"></a> 字典树 Trie</h2>\n<p>哈希 Map、字典树可以对小型集合的数据进行去重。</p>\n<p>Trie 树适合数据量大，重复多，但是数据种类小可以放进内存的情景。</p>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">对 1000 万字符串进行去重</div>\n</div>\n<div class=\"callout-content\"><p>对 1000 万字符串进行去重</p>\n<p>步骤：</p>\n<ul>\n<li>对于大型集合，我们可以先用 Hash 分成小文件；</li>\n<li>再用去重方法（Hash、Trie）对小文件去重；</li>\n<li>最后综合再去重。</li>\n</ul>\n</div></div><h2 id=\"位图-bit-map\"><a class=\"markdownIt-Anchor\" href=\"#位图-bit-map\"></a> 位图 Bit-map</h2>\n<p>位图是一种特殊的散列表。</p>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">统计大文件中不同数字的个数</div>\n</div>\n<div class=\"callout-content\"><p>已知某个文件内包含一些数字号码，每个号码为 8 位数字，统计不同号码的个数。</p>\n<p>解法：使用 Bit-map，从 0-99999999 的数字，每个数字对应一个 Bit 位。</p>\n</div></div>\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">找出不重复的整数的个数</div>\n</div>\n<div class=\"callout-content\"><p>2.5 亿个整数中找出不重复的整数的个数，内存空间不足以容纳这 2.5 亿个整数。</p>\n<p>解法 1：</p>\n<ul>\n<li>按整数范围<strong>划分区域</strong>，每个单文件代表一个区域。</li>\n<li>对每一个区域，使用 Bit-map 的扩展，用 2bit 表示一个数，0 表示未出现，1 表示出现一次，2 表示出现 2 次及以上，在遍历这些数的时候，如果对应位置的值是 0，则将其置为 1；如果是 1，将其置为 2；如果是 2，则保持不变。</li>\n<li>或使用两个 Bit-map 进行模拟。</li>\n</ul>\n<p>解法 2：</p>\n<ul>\n<li><strong>哈希</strong>分成多个小文件，在每个小文件中找出不重复的整数，并排序</li>\n<li>使用归并，同时注意去除重复元素</li>\n</ul>\n</div></div>\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">使用位图判断存在性</div>\n</div>\n<div class=\"callout-content\"><p>给 40 亿个不重复的 <code>unsigned int</code> 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</p>\n<p>解决方案：使用位图申请 512M 的内存，一个 bit 位代表一个 <code>unsigned int</code> 值。读入 40 亿个数，设置相应的 bit 位，读入要查询的数，查看相应 bit 位是否为 1，为 1 表示存在，为 0 表示不存在。</p>\n</div></div><h2 id=\"布隆过滤器-bloom-filter\"><a class=\"markdownIt-Anchor\" href=\"#布隆过滤器-bloom-filter\"></a> 布隆过滤器 Bloom Filter</h2>\n<blockquote>\n<p>布隆过滤器基于位图。</p>\n</blockquote>\n<p>它的数据结构由两部分组成：</p>\n<ul>\n<li>二进制向量（位数组）：一个大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1</li>\n<li>一系列随机映射函数（哈希函数）</li>\n</ul>\n<p>优缺点：</p>\n<ul>\n<li>优点：占用空间更少并且效率更高</li>\n<li>缺点：返回的结果是概率性的。理论情况下，添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</li>\n</ul>\n\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">Counting Bloom Filter 解决布隆过滤器无法删除的弊端</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>Counting Bloom Filter 将标准 Bloom Filter 位数组的每一位扩展为一个小的计数器（Counter）：</p>\n<ul>\n<li>在插入元素时给对应的 k （k 为哈希函数个数）个 Counter 的值分别加 1</li>\n<li>删除元素时给对应的 k 个 Counter 的值分别减 1。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509042358022.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p>Counting Bloom Filter 通过多占用几倍的存储空间的代价， 给 Bloom Filter 增加了删除操作。</p>\n</div></details><p>看图读原理：</p>\n<ul>\n<li>数据加入时：用多个哈希函数得到哈希值，并将位数组对应位置 1。</li>\n<li>查询存在性：以相同方式得到哈希。全为 1，数据可能在；不全为 1，数据一定不在。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509030013480.webp\" alt=\"image.png\" /></p>\n<p>使用场景：</p>\n<ul>\n<li>判断给定数据是否存在：\n<ul>\n<li>判断一个数字是否存在于包含大量数字的数字集中（数字集很大，上亿）</li>\n<li>防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）</li>\n<li>邮箱的垃圾邮件过滤（判断一个邮件地址是否在垃圾邮件列表中）</li>\n<li>黑名单功能（判断一个 IP 地址或手机号码是否在黑名单中）</li>\n</ul>\n</li>\n<li>去重：\n<ul>\n<li>比如爬给定网址的时候对已经爬取过的 URL 去重</li>\n<li>对巨量的 QQ 号/订单号去重。</li>\n</ul>\n</li>\n<li>集合求交集</li>\n</ul>\n<h1 id=\"海量数据的排序\"><a class=\"markdownIt-Anchor\" href=\"#海量数据的排序\"></a> 海量数据的排序</h1>\n<h2 id=\"桶排序\"><a class=\"markdownIt-Anchor\" href=\"#桶排序\"></a> 桶排序</h2>\n<p>核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>\n<p>假设要排序的对象有 n 个，划分到 m 个桶中。时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>：</p>\n<ul>\n<li>理想情况下，每个桶有 k = n/m 个元素</li>\n<li>每个桶使用快排算法：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k \\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>m 个桶排序的时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>×</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">m\\times O(k \\log k) = O(n \\log n/m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>\n<ul>\n<li>当 m 趋于 n 时 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">\\log n/m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">m</span></span></span></span> 就是一个很小的常量，这时桶排序的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>极端情况下，所有数据被分到一个桶中，时间复杂度退化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n</li>\n</ul>\n<p>桶排序对要排序数据的要求是非常苛刻：</p>\n<ul>\n<li>要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</li>\n<li>数据在各个桶之间的分布是比较均匀的。否则桶内数据排序的时间复杂度就不是常量级别。</li>\n</ul>\n<p>桶排序适合用在外部排序中。</p>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">海量订单数据的排序</div>\n</div>\n<div class=\"callout-content\"><p>假设有 10GB 的订单金额数据需要排序，金额均为正整数，但我们的内存只有 500MB。应该如何排序？</p>\n<p>步骤：</p>\n<ol>\n<li>扫描文件，定金额范围：假设最小为 1 元，最大为 10w 元，假设金额均匀分布</li>\n<li>订单根据金额划分到 100 个桶：1-1000、1001-2000…</li>\n<li>每个桶（每个待排序的文件）存储约 100M 的数据，符合内存要求，可以进行快速排序</li>\n<li>按照桶的顺序读取订单的数据</li>\n</ol>\n<p>解决订单不均匀分布：</p>\n<ul>\n<li>继续划分金额集中分布的区间为更小的区间。如将 1-1000 的区间划分为 1-100、101-200…</li>\n<li>如果某个区间数据还是过大，则继续划分，直到所有文件都能读入内存为止。</li>\n</ul>\n</div></div>\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">根据年龄给 100 万用户排序</div>\n</div>\n<div class=\"callout-content\"><p>假设年龄的范围最小 1 岁，最大不超过 120 岁，请根据年龄给 100 万用户排序。</p>\n<p>我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。</p>\n<p>同类问题：按照成绩给 50 万考生排序。</p>\n</div></div><h2 id=\"计数排序\"><a class=\"markdownIt-Anchor\" href=\"#计数排序\"></a> 计数排序</h2>\n<p>计数排序是由额外空间的辅助和元素本身的值决定的。 计数排序过程中不存在元素之间的比较和交换操作， 根据元素本身的值， 将每个元素出现的次数记录到辅助空间后， 通过对辅助空间内数据的计算， 即可确定每一个元素最终的位置。</p>\n<p>计数排序是稳定的。</p>\n<p>算法过程：</p>\n<ol>\n<li>根据待排序集合中最大元素和最小元素的差值范围， 申请额外空间；</li>\n<li>遍历待排序集合， 将每一个元素出现的次数记录到元素值对应的额外空间内；</li>\n<li>对额外空间内数据进行计算， 得出每一个元素的正确位置；</li>\n<li>将待排序集合每一个元素移动到计算出的正确位置上。</li>\n</ol>\n<blockquote>\n<p>从某些角度来看，计数排序是桶排序的特殊情况。相当于同一个元素值放到 1 个桶中。</p>\n</blockquote>\n<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COUNTING-SORT(A,B,k)</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化额外空间，数组中，可能出现的值的范围为low至low+k</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i=<span class=\"number\">0</span> <span class=\"keyword\">to</span> k</span><br><span class=\"line\">\t\tC[i] = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 遍历数组 A，统计每个值出现的次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j=<span class=\"number\">1</span> <span class=\"keyword\">to</span> A.length</span><br><span class=\"line\">\t\tC[A[j]] +=<span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 依次计算比i小或与i相等的元素的个数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i=<span class=\"number\">1</span> <span class=\"keyword\">to</span> k:</span><br><span class=\"line\">\t\tC[i] += C[i-<span class=\"number\">1</span>] <span class=\"comment\">// 前缀和</span></span><br><span class=\"line\">\t<span class=\"comment\">// 此时得到的C数组表明，如果下标i在A数组中存在的话，i应该是结果的第C[i]个位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// B为结果数组，现依据A数组元素逆序，决定该元素应该在结果数组的哪一个位置</span></span><br><span class=\"line\">\t<span class=\"comment\">// 注意此时 C 为前缀和数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j = A.length <span class=\"keyword\">downto</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t\tB[C[A[j]]] = A[j] </span><br><span class=\"line\">\t\tC[A[j]] -=<span class=\"number\">1</span>   </span><br></pre></td></tr></table></figure>\n\n<details class=\"callout\" data-callout=\"example\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">案例：计数排序</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p></p>\n<p>以输入数组 <code>[95,94,91,98,99,93,91,92]</code> 为例。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20231212171647.webp\" alt=\"image.png\" width=\"400px\" /></p>\n</div></details><p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。k 表示数据范围，n 表示待排序的数字个数。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。k 表示数据范围，n 表示待排序的数字个数。</li>\n</ul>\n<p>计数排序适用于数据范围 k 不大的场景中。计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>\n<h2 id=\"基数排序-radix-sort\"><a class=\"markdownIt-Anchor\" href=\"#基数排序-radix-sort\"></a> 基数排序 Radix Sort</h2>\n<p>基数排序是一种非比较型整数排序算法，它是基于关键字各位大小来排序。它的基本思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>\n<p>设长度为 n 的线性表中每个结点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 的关键字由 d 元组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>k</mi><mi>j</mi><mrow><mi>d</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo separator=\"true\">,</mo><msubsup><mi>k</mi><mi>j</mi><mrow><mi>d</mi><mo>−</mo><mn>2</mn></mrow></msubsup><mo>…</mo><mo separator=\"true\">,</mo><msubsup><mi>k</mi><mi>j</mi><mi>i</mi></msubsup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>1</mn></msubsup><mo separator=\"true\">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>0</mn></msubsup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(k^{d-1}_j,k^{d-2}_{j}\\dots,k_{j}^i ,...,k^{1}_j,k^{0}_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3022109999999998em;vertical-align:-0.412972em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8892389999999999em;\"><span style=\"top:-2.4231360000000004em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.412972em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8892389999999999em;\"><span style=\"top:-2.4231360000000004em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.412972em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.394772em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.394772em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.394772em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 组成</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0\\le k \\le r-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。即每个数位范围不超过 r。如十进制数时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">r=10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span>。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi><mo separator=\"true\">,</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0\\le j &lt;n,0\\le i \\le d-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</li>\n<li>其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>k</mi><mi>j</mi><mrow><mi>d</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">k^{d-1}_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3022109999999998em;vertical-align:-0.412972em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8892389999999999em;\"><span style=\"top:-2.4231360000000004em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.412972em;\"><span></span></span></span></span></span></span></span></span></span> 为最主位关键字，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>k</mi><mi>j</mi><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">k^{0}_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.20888em;vertical-align:-0.394772em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.394772em;\"><span></span></span></span></span></span></span></span></span></span> 为最次位关键字。</li>\n</ul>\n<p>对于不等长的排序数据，可以对数据前/后进行补齐。</p>\n<p>算法：</p>\n<ol>\n<li>最低位优先（LSD）法。对于一个数据序列的从小到大排序，应采用 LSD。</li>\n<li>最高位优先（MSD）法</li>\n</ol>\n<p>基数排序是稳定的排序算法。</p>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">基数排序一般使用 LSD 对数据进行排序的原因</div>\n</div>\n<div class=\"callout-content\"><p>因为数字大小本身就是高位的权重更大，排序轮数越靠后，相当于其权重越高。<br />\n可以使用 MSD，不过会更加复杂。使用 MSD 时，需要按照高位分桶。每个桶继续分小桶，形成递归。</p>\n</div></div><p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(d(n+r))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>每位进行一趟「分配」和「收集」，共 d 趟\n<ul>\n<li>一趟分配需要 O(n)。使用计数或桶排序（桶排序算法需留意稳定性）。</li>\n<li>一趟收集需要 O®。</li>\n</ul>\n</li>\n<li>与序列初始状态无关</li>\n<li>当 r 是常数且 d 较小时，基数排序可在线性时间内完成。</li>\n</ul>\n<p>空间效率：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>r 个队列（桶）存储临时结果：r 个队头指针和队尾指针</li>\n</ul>\n<p>基数排序适用于对整数或可以表示为固定长度数字序列的对象进行排序。特别是当待排序的数据范围比较固定，且位数相对较少时，它的效率很高：</p>\n<ul>\n<li>手机号码（11 位数字）</li>\n<li>身份证号码（18 位数字）</li>\n<li>日期（将日期转换为数字表示）</li>\n</ul>\n<h2 id=\"二叉堆与堆排序\"><a class=\"markdownIt-Anchor\" href=\"#二叉堆与堆排序\"></a> 二叉堆与堆排序</h2>\n<blockquote>\n<p>本小节整理自笔记，更具体的证明与性质详看本地知识库。</p>\n</blockquote>\n<p>（二叉）堆是一个<strong>数组</strong>，它可以被看成一个近似的完全二叉树。</p>\n<p>二叉堆的两种形式：</p>\n<ul>\n<li>最大堆：最大堆的性质：除了根结点以外的所有结点 i 都要满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>P</mi><mi>A</mi><mi>R</mi><mi>E</mi><mi>N</mi><mi>T</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo><mo>≥</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[PARENT(i)]\\ge A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span></li>\n<li>最小堆：最小堆的性质：除了根结点以外的所有结点 i 都要满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>P</mi><mi>A</mi><mi>R</mi><mi>E</mi><mi>N</mi><mi>T</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo><mo>≤</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[PARENT(i)]\\le A[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span></li>\n</ul>\n<blockquote>\n<p>我的简记：小顶堆装大数、大顶堆装小数。</p>\n</blockquote>\n<p>对堆（大顶堆）操作算法快速回忆：</p>\n<table>\n<thead>\n<tr>\n<th>堆的操作</th>\n<th>时间复杂度</th>\n<th>算法概述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>堆化</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Theta(\\lg n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mop\">l<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>对一个结点进行「下沉」</td>\n</tr>\n<tr>\n<td>建堆</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>从中间往前，进行堆化</td>\n</tr>\n<tr>\n<td>弹出堆顶</td>\n<td rowspan=\"3\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>弹出后，最后一个元素放堆顶，再堆化，防止空洞</td>\n</tr>\n<tr>\n<td>插入堆</td>\n<td>放最后，「上浮」</td>\n</tr>\n<tr>\n<td>更新堆键值</td>\n<td>更新键后，「上浮」</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\lg n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">l<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>建堆；一个个弹出。原址排序的话，弹出位置放堆后，堆大小减减即可。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\"></a> 归并排序</h2>\n<p>思想：如果能把原待排序的数组分解成若干个待排序的子数组，而这些子数组可以方便地排好序，并且通过合并这些子数组的解将能得到原问题的解，则整个数组将排好序。</p>\n<p>2 路归并排序通过应用<strong>分治</strong>法解题的三个基本步骤为：</p>\n<ol>\n<li>divide：把具有 n 个元素的数组分解为二个 n/2 大小的子数组</li>\n<li>conquer：递归地分解子数组，直到子数组只包含一个元素为止</li>\n<li>combine：二二合并已排好序的子数组使之成为一个新的排好序的子数组，重复这样二二合并的过程直到得到原问题的解</li>\n</ol>\n<p>归并排序不能保证一趟结束后一定有元素放在最终位置上。可以说是基本算法中占用辅助空间最多的排序算法。有方法克服但代价是算法会很复杂，且时间复杂度会增加。</p>\n<p>归并排序是一种稳定的算法。平均时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log_2 n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的稳定排序算法只有归并排序。</p>\n<p>从单个记录起两两归并的做法不提倡，可以和直接插入排序结合，利用直接插入排序求得较长的有序文件，然后两两归并（两种算法都是稳定的排序算法，结合起来也是稳定的）。</p>\n<p>归并排序一般用于外部排序使用。</p>\n<h2 id=\"外部排序\"><a class=\"markdownIt-Anchor\" href=\"#外部排序\"></a> 外部排序</h2>\n<p>外部排序在排序过程中根据要求不断在内、外存之间移动。</p>\n<p>外部排序使用归并排序法：</p>\n<ol>\n<li>根据内存缓冲区大小，将外存文件分为若干子文件，依次读入内存，使用内部排序方法进行排序，然后再重新写回外存。这些有序子文件称为归并段或顺串。</li>\n<li>对归并段进行逐趟归并，使归并段逐渐由小到大，直到得到整个有序文件。</li>\n</ol>\n<p>磁盘 I/O 优化方法——减少排序趟数：</p>\n<ul>\n<li>多路平衡归并与败者树（增加归并路数 k）</li>\n<li>置换 - 选择排序（生成初始归并段）（减少初始归并段个数 r）</li>\n<li>最佳归并树</li>\n</ul>\n<h2 id=\"多路归并\"><a class=\"markdownIt-Anchor\" href=\"#多路归并\"></a> 多路归并</h2>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">大文件排序</div>\n</div>\n<div class=\"callout-content\"><p>假定现在有一包含大量整数的文本文件存放于磁盘中，其文件大小为 10GB，而本机内存只有 1GB。如何对文件内容进行排序？</p>\n</div></div><p>由于内存限制，我们无法一次性将文件读入内存进行排序。解决方法：</p>\n<ul>\n<li>将 10GB 大文件拆分为 100 个 100MB 的小文件。</li>\n<li>分别对 100 个小文件进行排序。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">中间问题：有序小文件合并为有序大文件</div>\n</div>\n<div class=\"callout-content\"><p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们如何将这些 100 个小文件合并成一个有序的大文件？</p>\n</div></div><p>解决方法：使用优先队列（小顶堆）进行有序序列的多路归并。</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从 100 个文件各取一个字符串，放入数组并建小顶堆。</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>k</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">O(k), k = 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span></td>\n</tr>\n<tr>\n<td>弹出堆顶元素，放入大文件中。</td>\n<td rowspan=\"2\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>再从堆顶元素所属的文件中取出字符串插入小顶堆</td>\n</tr>\n</tbody>\n</table>\n<p>多路归并的过程可以找中位数。</p>\n<p>相关算法题目：</p>\n<ul>\n<li>🟥 <a href=\"https://leetcode.cn/problems/merge-k-sorted-lists/description/\">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?show=1\">373. 查找和最小的 K 对数字 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"海量数据-top-k-问题\"><a class=\"markdownIt-Anchor\" href=\"#海量数据-top-k-问题\"></a> 海量数据 Top K 问题</h1>\n<p>根据集合的特点，将 Top K 问题分成两类：</p>\n<ul>\n<li>静态数据集合 Top K。在事先确定且不会变动的数据集合中求 Top K。</li>\n<li>动态数据集合 Top K。集合事先不确定，且有动态的数据加入到集合中。在这种集合上求 Top K。</li>\n</ul>\n<p>Top K 问题可以的狭义理解可以理解为：</p>\n<ul>\n<li>Top 1：求数据集合中最大的元素。</li>\n<li>Top N：求排好序的数据集合。</li>\n</ul>\n<h2 id=\"使用堆小型静态数据集合-top-k\"><a class=\"markdownIt-Anchor\" href=\"#使用堆小型静态数据集合-top-k\"></a> 使用堆：小型静态数据集合 Top K</h2>\n<blockquote>\n<p>适合数据量小的数据集合。</p>\n</blockquote>\n<p>在一个包含 n 个数据的静态数组中，查找前 K 大数据。</p>\n<blockquote>\n<p>ME：小堆装大数，让大的下沉保留。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>维护一个大小为 K 的小顶堆</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>顺序遍历数组</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>- 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>- 如果比堆顶元素小，则不做处理，继续遍历数组。</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<p>这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。每次查询花费 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。</p>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">此处可以使用快速排序。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h2 id=\"使用堆动态数据集合-top-k\"><a class=\"markdownIt-Anchor\" href=\"#使用堆动态数据集合-top-k\"></a> 使用堆：动态数据集合 Top K</h2>\n<p>要想知道实时 Top K，需要进行两个操作：</p>\n<ul>\n<li>添加数据</li>\n<li>查询当前 Top K</li>\n</ul>\n<p>如果查询 Top K 时使用静态数据集合的方法，那么每次查询将花费 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>更高效的步骤：</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>如果一开始没建堆，则维护一个大小为 K 的小顶堆</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>当有数据被添加到集合中时，我们就拿它与堆顶的元素对比</td>\n<td>-</td>\n</tr>\n<tr>\n<td>- 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>- 如果比堆顶元素小，则不做处理</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">使用有序数组维护 Top K 列表不会更加高效</div>\n</div>\n<div class=\"callout-content\"><p>使用有序数组维护 Top K 列表并不比堆高效。</p>\n<ul>\n<li>如一开始没构建有序数组，那么它的构建时间为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>插入数据时，二分方式找到插入的位置为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>，移动元素需 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。</p>\n</div></div>\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">相似问题：巨型数据集合 Top K</div>\n</div>\n<div class=\"callout-content\"><p>100w 个数中找出最大的 K 个数。</p>\n</div></div><p>我们可以沿用使用堆处理动态数据集合 Top K 方法：</p>\n<ul>\n<li>先构建大小为 K 最小堆；</li>\n<li>再把剩余数据一个个以相似的方式插入堆即可。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">改进版的快速排序算法不会比堆高效</div>\n</div>\n<div class=\"callout-content\"><p>采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 K 多的时候，采用传统排序算法排序，取前 K 个。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>∗</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N*k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></p>\n</div></div><h2 id=\"求词频-top-k\"><a class=\"markdownIt-Anchor\" href=\"#求词频-top-k\"></a> 求词频 Top K</h2>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">求一个大文件中的 Top K 关键词</div>\n</div>\n<div class=\"callout-content\"><p>现有一个包含 10 亿个关键词的日志文件，可用内存为 1G。求 Top 10 频数最多的关键词。</p>\n<p>对应的 Top 1 问题：在海量数据中找出重复次数最多的一个关键词。<br />\n对应的 Top N 问题：词频排序。</p>\n</div></div><p>步骤：</p>\n<ul>\n<li>使用<strong>哈希</strong>算法取模<strong>分片</strong>，分到 10 个文件中，保证相同的词都放在一个文件里。注意不叫分桶，因为桶排序中桶与桶之间是有序的！</li>\n<li>每片分别读入内存，通过<strong>散列表</strong>、平衡二叉查找树、红黑树、Trie 树等数据结构记录词频。</li>\n<li>每片词频排序方法：\n<ul>\n<li>使用动态数据集合 Top K 方法排序：建小顶堆。</li>\n<li>求 Top N 或数据量小时：建<strong>小顶堆</strong>或快速排序。</li>\n</ul>\n</li>\n<li>组合每片的词频进行最后的排序：\n<ul>\n<li>把每片的 Top K 进行多路归并（使用<strong>堆</strong>），再取 Top K 即可。</li>\n<li>求 Top N 或数据量小时：直接合在一起，再用快速排序。或归并排序。</li>\n</ul>\n</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">求分布在不同文件中的 Top K 关键词</div>\n</div>\n<div class=\"callout-content\"><p>现有多个不同的存储关键词的文件，每个关键词可能分布于多个文件中。求不同文件中的 Top K 关键词。</p>\n<p>相似问法：不同机器中的 Top K 关键词</p>\n</div></div><p>在前一个问题中，我们使用<strong>哈希</strong>算法取模<strong>分片</strong>保证了相同的词只会放在同一个小文件中。本问题稍微有些不同：一开始每个关键词可能分布于多个文件中。</p>\n<p>解决方法：</p>\n<ul>\n<li>方法 1：遍历一遍所有数据，重新<strong>哈希</strong>取模<strong>分片</strong>，并沿用上一个问题的解决步骤进行问题求解。</li>\n<li>方法 2：暴力法。直接统计统计每个文件中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出 Top K。</li>\n</ul>\n<h1 id=\"海量数据的中位数或任意百分位的数据\"><a class=\"markdownIt-Anchor\" href=\"#海量数据的中位数或任意百分位的数据\"></a> 海量数据的中位数或任意百分位的数据</h1>\n<h2 id=\"使用堆求中位数或任意百分位的数据\"><a class=\"markdownIt-Anchor\" href=\"#使用堆求中位数或任意百分位的数据\"></a> 使用堆求中位数或任意百分位的数据</h2>\n<p>静态数据的中位数是固定的，我们可以先排序，再直接取。对于动态数据集合，如果每次查询中位数前都要排序则效率不高。</p>\n<p>正确的方法为利用两个堆：大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509022252028.webp\" alt=\"image.png\" /></p>\n<p>元素动态添加时：</p>\n<ul>\n<li>如果新加入的数据小于等于大顶堆的堆顶元素，加入大顶堆</li>\n<li>否则加入小顶堆</li>\n</ul>\n<p>查询中位数前，需保证大顶堆元素和小顶堆元素数量比例正确：</p>\n<ul>\n<li>我们需要保证：前半部分数据放大顶堆，后半部分数据放小顶堆。如果 n 为奇数，多出的一个放大顶堆中。</li>\n<li>如果查询前两个堆的元素个数不满足条件，则将某一个堆的元素插入到另一个堆中，直到条件满足。</li>\n</ul>\n<p>取出中位数的方式 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>：</p>\n<ul>\n<li>如果 n 是偶数，大顶堆堆顶元素和小顶堆的堆顶元素即为所求。</li>\n<li>如果 n 是奇数，大顶堆堆顶元素即为所求。</li>\n</ul>\n<p>如果要求任意百分位的数，原理是相似的。</p>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">快速求接口的 99% 响应时间</div>\n</div>\n<div class=\"callout-content\"><p>如果将一组数据从小到大排列，这个 99 百分位数就是大于前面 99% 数据的那个数据。</p>\n<p>做法：维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n⨯99% 个数据，小顶堆中保存 n⨯1% 个数据。数据的插入和查询前的调整规则类似前面中位数的要求。最后，每次查询大顶堆堆顶的数据就是我们要找的 99% 响应时间。</p>\n</div></div><h2 id=\"通过分片统计求中位数\"><a class=\"markdownIt-Anchor\" href=\"#通过分片统计求中位数\"></a> 通过分片统计求中位数</h2>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">从海量整数中找到中位数</div>\n</div>\n<div class=\"callout-content\"><p>求 5 亿个 int 的中位数。</p>\n<p>步骤：</p>\n<ul>\n<li>将 int 划分为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></span> 个区域，然后读取数据统计落到各个区域里的数的个数。</li>\n<li>根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。</li>\n<li>第二次扫描我们只统计落在这个区域中的那些数即可。</li>\n</ul>\n<p>如果整数的范围更大，我们可以进行多层次的划分，使每个区域降到可接受的程度。</p>\n</div></div><h1 id=\"海量数据的增删改查\"><a class=\"markdownIt-Anchor\" href=\"#海量数据的增删改查\"></a> 海量数据的增删改查</h1>\n<h2 id=\"数据库索引\"><a class=\"markdownIt-Anchor\" href=\"#数据库索引\"></a> 数据库索引</h2>\n<p>适用范围：大数据量的增删改查</p>\n<p>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>\n<h2 id=\"倒排索引-inverted-index\"><a class=\"markdownIt-Anchor\" href=\"#倒排索引-inverted-index\"></a> 倒排索引 Inverted index</h2>\n<p>适用范围：搜索引擎，关键字查询。</p>\n<p>倒排索引是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下面是被索引的文本</span><br><span class=\"line\">T0 = &quot;it is what it is&quot;</span><br><span class=\"line\">T1 = &quot;what is it&quot;</span><br><span class=\"line\">T2 = &quot;it is a banana&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 下面是反向文件索引</span><br><span class=\"line\">&quot;a&quot;: &#123;2&#125;</span><br><span class=\"line\">&quot;banana&quot;: &#123;2&#125;</span><br><span class=\"line\">&quot;is&quot;: &#123;0, 1, 2&#125;</span><br><span class=\"line\">&quot;it&quot;: &#123;0, 1, 2&#125;</span><br><span class=\"line\">&quot;what&quot;: &#123;0, 1&#125;</span><br></pre></td></tr></table></figure>\n<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p>\n<p>常见问题：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>\n<h1 id=\"海量数据的分布式处理\"><a class=\"markdownIt-Anchor\" href=\"#海量数据的分布式处理\"></a> 海量数据的分布式处理</h1>\n<p>可以看成大量数据被分为小文件的场景。</p>\n<h2 id=\"mapreduce\"><a class=\"markdownIt-Anchor\" href=\"#mapreduce\"></a> MapReduce</h2>\n<blockquote>\n<p>类似归并排序。</p>\n</blockquote>\n<p>MapReduce 是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。</p>\n<p>任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。</p>\n<p>相关问题：</p>\n<ul>\n<li>海量数据分布在 100 台电脑中，想个办法高效统计出这批数据的 Top 10。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">多机器的海量数据查找中位数</div>\n</div>\n<div class=\"callout-content\"><p>一共有 N 个机器，每个机器上有 N 个数。每个机器最多存 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> 个数并对它们操作。如何找到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">N^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> 个数的中位数？</p>\n<p>方法 1：分片统计法</p>\n<ul>\n<li>假设这些数都是 32 位无符号整数，我们可以根据整数范围分 N 个区段</li>\n<li>把每个区段的数放在对应的机器上，这样每个机器上存储的数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> 的</li>\n<li>使用类似分片统计的方法，找到存在中位数的机器</li>\n<li>对该机器进行内部排序，找出中位数即可</li>\n<li>总时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo>+</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)+O(N\\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>方案 2：</p>\n<ul>\n<li>同方案 1，对数据进行分片并存入对应的机器中</li>\n<li>每个机器上都进行内部排序</li>\n<li>使用多路归并找中位数</li>\n</ul>\n</div></div><h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>研究生课程《算法设计与分析》课程内容，以及课后实验二：典型排序算法训练</li>\n<li>《算法导论》第 6 章</li>\n<li>《王道 2023 408》思维导图解耦</li>\n<li><a href=\"https://uaxe.github.io/geektime-docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/\">《算法与数据结构之美》王争-极客时间专栏</a></li>\n<li><a href=\"https://www.cnblogs.com/java-note/p/18630738\">全面解析基数排序：定义、原理、复杂度、稳定性及实现步骤详解 - 软件职业规划 - 博客园</a></li>\n<li><a href=\"https://www.zhihu.com/question/27021728\">为什么基数排序只有从最低位开始才是“稳定的排序算法”？？ - 知乎</a></li>\n<li><a href=\"https://javaguide.cn/cs-basics/data-structure/bloom-filter.html#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D\">布隆过滤器 | JavaGuide</a></li>\n<li><a href=\"https://www.cnblogs.com/GarrettWale/p/14478347.html\">海量数据问题的处理-六种解决思路 - Garrett_Wale - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/a574780196/article/details/122646309\">多路归并算法从理论到应用（易懂）-CSDN博客</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1136056\">Counting Bloom Filter 的原理和实现-腾讯云开发者社区-腾讯云</a></li>\n<li><a href=\"https://blog.csdn.net/v_july_v/article/details/6685962\">海量数据处理面试题集锦-CSDN博客</a></li>\n<li><a href=\"https://uaxe.github.io/geektime-docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/45%20-%20%E4%BD%8D%E5%9B%BE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84URL%E5%8E%BB%E9%87%8D%E5%8A%9F%E8%83%BD%EF%BC%9F/#_3\">45 位图：如何实现网页爬虫中的URL去重功能？ - 极客时间文档 - 王争 - 数据结构之美与算法之美</a></li>\n</ul>\n","raw":"---\ntitle: 关于海量数据的若干问题\ntags:\n  - 桶排序\n  - 外部排序\n  - Top K\n  - 数据结构\n  - 排序\n  - 基数排序\n  - 堆排序\n  - 堆\n  - 优先队列\n  - 布隆过滤器\n  - 面试\n  - 哈希\n  - 多路归并\n  - 分治算法\n  - Trie 树\ncover: 'https://cdn.gallery.uuanqin.top/img/202509052258680.webp'\ndescription: 太卷了\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: 4fdbc02c\ndate: 2025-09-05 22:58:15\ntop_img:\n---\n\n本文为面试笔记整理。以前看八股总是随缘，没有系统的整理。现在秋招，正好有机会把各种八股和以前学过的东西都串联起来，给笔记清清灰。\n\n# 海量数据问题基本思路\n\n看到海量数据的处理问题，可以按以下思想考虑：\n\n1. 分治。一看到数据量但内存受限的问题首选分治。但是海量数据基本都要分治，可以作为一种基础思想。\n2. 哈希。耗内存，但适合快速查找。\n3. Bit 位。如位图、布隆过滤器。适用于快速查找、判重。\n4. 堆。Top K、最值问题。注意 K 不要过大，需要能放进内存。\n\n本文将针对处理海量数据的不同场景，引出相应的数据结构或算法：\n\n1. 海量数据的存在性与去重：哈希映射、字典树、位图、布隆过滤器\n2. 海量数据的排序：桶排序、计数排序、基数排序、堆与堆排序、归并排序\n3. 海量数据的 Top K 问题：堆的应用\n4. 海量数据的中位数及任意百分位的数据：堆与分片\n5. 海量数据的增删改查：索引与倒排索引\n6. 海量数据的分布式处理：MapReduce\n\n需要注意的是。对于海量数据的处理，我们会综合使用多种数据结构进行处理，每一种数据结构不一定只会解决同一种问题。\n\n# 海量数据的存在性与去重\n\n## 哈希映射 hash\n\n哈希映射的特点就是，同一个关键字将映射到相同的位置。\n\n> [!question] 找出两个巨大文件的共同的关键字\n> 给定 a、b 两个文件，各存放 50 亿个关键字，每个关键字各占 64 字节，内存限制是 4G，找出 a、b 文件共同的关键字。\n>\n> 步骤：\n> - **分治**与**哈希**：\n> \t- 将文件 a 中的关键字通过哈希映射到 1000 个小文件，每个文件记为 `a[i]`；将文件 b 中的关键字通过哈希映射到 1000 个小文件，每个文件记为 `b[i]`。\n> \t- 由于哈希映射的特点，相同关键字只会被分到 `a[i]` 或 `b[i]` 中。\n> - 对每个 `i` 求相同关键字：\n> \t- 将 `a[i]` 文件中的关键字放入哈希表 `H` 中；\n> \t- 遍历 `b[i]` 逐个关键字 `k` 判断是否在哈希表 `H` 中；\n> \t- 如果关键字 `k` 在 `H` 中出现，那么将 `k` 加入结果中。\n> \n> 如果判重允许一定错误率，可考虑布隆过滤器。\n\n## 字典树 Trie\n\n哈希 Map、字典树可以对小型集合的数据进行去重。\n\nTrie 树适合数据量大，重复多，但是数据种类小可以放进内存的情景。\n\n> [!question] 对 1000 万字符串进行去重\n> 对 1000 万字符串进行去重\n>\n> 步骤：\n> - 对于大型集合，我们可以先用 Hash 分成小文件；\n> - 再用去重方法（Hash、Trie）对小文件去重；\n> - 最后综合再去重。\n\n## 位图 Bit-map\n\n位图是一种特殊的散列表。\n\n> [!question] 统计大文件中不同数字的个数\n> 已知某个文件内包含一些数字号码，每个号码为 8 位数字，统计不同号码的个数。\n>\n> 解法：使用 Bit-map，从 0-99999999 的数字，每个数字对应一个 Bit 位。\n\n> [!question] 找出不重复的整数的个数\n> 2.5 亿个整数中找出不重复的整数的个数，内存空间不足以容纳这 2.5 亿个整数。\n>\n> 解法 1：\n> - 按整数范围**划分区域**，每个单文件代表一个区域。\n> - 对每一个区域，使用 Bit-map 的扩展，用 2bit 表示一个数，0 表示未出现，1 表示出现一次，2 表示出现 2 次及以上，在遍历这些数的时候，如果对应位置的值是 0，则将其置为 1；如果是 1，将其置为 2；如果是 2，则保持不变。\n> - 或使用两个 Bit-map 进行模拟。\n> \n> 解法 2：\n> - **哈希**分成多个小文件，在每个小文件中找出不重复的整数，并排序\n> - 使用归并，同时注意去除重复元素\n\n> [!question] 使用位图判断存在性\n> 给 40 亿个不重复的 `unsigned int` 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？\n>\n> 解决方案：使用位图申请 512M 的内存，一个 bit 位代表一个 `unsigned int` 值。读入 40 亿个数，设置相应的 bit 位，读入要查询的数，查看相应 bit 位是否为 1，为 1 表示存在，为 0 表示不存在。\n\n## 布隆过滤器 Bloom Filter\n\n> 布隆过滤器基于位图。\n\n它的数据结构由两部分组成：\n\n- 二进制向量（位数组）：一个大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1\n- 一系列随机映射函数（哈希函数）\n\n优缺点：\n\n- 优点：占用空间更少并且效率更高\n- 缺点：返回的结果是概率性的。理论情况下，添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。\n\n> [!note]- Counting Bloom Filter 解决布隆过滤器无法删除的弊端\n> Counting Bloom Filter 将标准 Bloom Filter 位数组的每一位扩展为一个小的计数器（Counter）：\n>\n> - 在插入元素时给对应的 k （k 为哈希函数个数）个 Counter 的值分别加 1\n> - 删除元素时给对应的 k 个 Counter 的值分别减 1。\n> \n> ![image.png|500](https://cdn.gallery.uuanqin.top/img/202509042358022.webp)\n>\n>\n> Counting Bloom Filter 通过多占用几倍的存储空间的代价， 给 Bloom Filter 增加了删除操作。\n\n看图读原理：\n\n- 数据加入时：用多个哈希函数得到哈希值，并将位数组对应位置 1。\n- 查询存在性：以相同方式得到哈希。全为 1，数据可能在；不全为 1，数据一定不在。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202509030013480.webp)\n\n使用场景：\n\n- 判断给定数据是否存在：\n\t- 判断一个数字是否存在于包含大量数字的数字集中（数字集很大，上亿）\n\t- 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）\n\t- 邮箱的垃圾邮件过滤（判断一个邮件地址是否在垃圾邮件列表中）\n\t- 黑名单功能（判断一个 IP 地址或手机号码是否在黑名单中）\n- 去重：\n\t- 比如爬给定网址的时候对已经爬取过的 URL 去重\n\t- 对巨量的 QQ 号/订单号去重。\n- 集合求交集\n\n# 海量数据的排序\n\n## 桶排序\n\n核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n\n假设要排序的对象有 n 个，划分到 m 个桶中。时间复杂度 $O(n)$：\n\n- 理想情况下，每个桶有 k = n/m 个元素\n- 每个桶使用快排算法：$O(k \\log k)$\n- m 个桶排序的时间复杂度：$m\\times O(k \\log k) = O(n \\log n/m)$\n\t- 当 m 趋于 n 时 $\\log n/m$ 就是一个很小的常量，这时桶排序的时间复杂度为 $O(n)$\n\t- 极端情况下，所有数据被分到一个桶中，时间复杂度退化为 $O(n\\log n)$\n\n桶排序对要排序数据的要求是非常苛刻：\n\n- 要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。\n- 数据在各个桶之间的分布是比较均匀的。否则桶内数据排序的时间复杂度就不是常量级别。\n\n桶排序适合用在外部排序中。\n\n> [!question] 海量订单数据的排序\n> 假设有 10GB 的订单金额数据需要排序，金额均为正整数，但我们的内存只有 500MB。应该如何排序？\n>\n> 步骤：\n> 1. 扫描文件，定金额范围：假设最小为 1 元，最大为 10w 元，假设金额均匀分布\n> 2. 订单根据金额划分到 100 个桶：1-1000、1001-2000......\n> 3. 每个桶（每个待排序的文件）存储约 100M 的数据，符合内存要求，可以进行快速排序\n> 4. 按照桶的顺序读取订单的数据\n>  \n> 解决订单不均匀分布：\n> - 继续划分金额集中分布的区间为更小的区间。如将 1-1000 的区间划分为 1-100、101-200......\n> - 如果某个区间数据还是过大，则继续划分，直到所有文件都能读入内存为止。\n\n> [!question] 根据年龄给 100 万用户排序\n> 假设年龄的范围最小 1 岁，最大不超过 120 岁，请根据年龄给 100 万用户排序。\n>\n> 我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。\n>\n> 同类问题：按照成绩给 50 万考生排序。\n\n## 计数排序\n\n计数排序是由额外空间的辅助和元素本身的值决定的。 计数排序过程中不存在元素之间的比较和交换操作， 根据元素本身的值， 将每个元素出现的次数记录到辅助空间后， 通过对辅助空间内数据的计算， 即可确定每一个元素最终的位置。\n\n计数排序是稳定的。\n\n算法过程：\n\n1. 根据待排序集合中最大元素和最小元素的差值范围， 申请额外空间；\n2. 遍历待排序集合， 将每一个元素出现的次数记录到元素值对应的额外空间内；\n3. 对额外空间内数据进行计算， 得出每一个元素的正确位置；\n4. 将待排序集合每一个元素移动到计算出的正确位置上。\n\n> 从某些角度来看，计数排序是桶排序的特殊情况。相当于同一个元素值放到 1 个桶中。\n\n```pascal\nCOUNTING-SORT(A,B,k)\n\t// 初始化额外空间，数组中，可能出现的值的范围为low至low+k\n\tfor i=0 to k\n\t\tC[i] = 0\n\t// 遍历数组 A，统计每个值出现的次数\n\tfor j=1 to A.length\n\t\tC[A[j]] +=1\n\t// 依次计算比i小或与i相等的元素的个数\n\tfor i=1 to k:\n\t\tC[i] += C[i-1] // 前缀和\n\t// 此时得到的C数组表明，如果下标i在A数组中存在的话，i应该是结果的第C[i]个位置\n\n\t// B为结果数组，现依据A数组元素逆序，决定该元素应该在结果数组的哪一个位置\n\t// 注意此时 C 为前缀和数组\n\tfor j = A.length downto 1\n\t\tB[C[A[j]]] = A[j] \n\t\tC[A[j]] -=1   \n```\n\n> [!example]- 案例：计数排序\n>\n>\n> 以输入数组 `[95,94,91,98,99,93,91,92]` 为例。\n>\n> ![image.png|400](https://cdn.gallery.uuanqin.top/img/20231212171647.webp)\n\n复杂度分析：\n\n- 时间复杂度：$O(n+k)$。k 表示数据范围，n 表示待排序的数字个数。\n- 空间复杂度：$O(n+k)$。k 表示数据范围，n 表示待排序的数字个数。\n\n计数排序适用于数据范围 k 不大的场景中。计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。\n\n## 基数排序 Radix Sort\n\n基数排序是一种非比较型整数排序算法，它是基于关键字各位大小来排序。它的基本思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。\n\n设长度为 n 的线性表中每个结点 $a_j$ 的关键字由 d 元组 $(k^{d-1}_j,k^{d-2}_{j}\\dots,k_{j}^i ,...,k^{1}_j,k^{0}_j)$ 组成\n\n- $0\\le k \\le r-1$。即每个数位范围不超过 r。如十进制数时，$r=10$。\n- $0\\le j <n,0\\le i \\le d-1$。\n- 其中 $k^{d-1}_j$ 为最主位关键字，$k^{0}_j$ 为最次位关键字。\n\n对于不等长的排序数据，可以对数据前/后进行补齐。\n\n算法：\n\n1. 最低位优先（LSD）法。对于一个数据序列的从小到大排序，应采用 LSD。\n2. 最高位优先（MSD）法\n\n基数排序是稳定的排序算法。\n\n> [!note] 基数排序一般使用 LSD 对数据进行排序的原因\n> 因为数字大小本身就是高位的权重更大，排序轮数越靠后，相当于其权重越高。\n> 可以使用 MSD，不过会更加复杂。使用 MSD 时，需要按照高位分桶。每个桶继续分小桶，形成递归。\n\n时间复杂度：$O(d(n+r))$\n\n- 每位进行一趟「分配」和「收集」，共 d 趟\n\t- 一趟分配需要 O(n)。使用计数或桶排序（桶排序算法需留意稳定性）。\n\t- 一趟收集需要 O(r)。\n- 与序列初始状态无关\n- 当 r 是常数且 d 较小时，基数排序可在线性时间内完成。\n\n空间效率：$O(n+r)$\n\n- r 个队列（桶）存储临时结果：r 个队头指针和队尾指针\n\n基数排序适用于对整数或可以表示为固定长度数字序列的对象进行排序。特别是当待排序的数据范围比较固定，且位数相对较少时，它的效率很高：\n\n- 手机号码（11 位数字）\n- 身份证号码（18 位数字）\n- 日期（将日期转换为数字表示）\n\n## 二叉堆与堆排序\n\n> 本小节整理自笔记，更具体的证明与性质详看本地知识库。\n\n（二叉）堆是一个**数组**，它可以被看成一个近似的完全二叉树。\n\n二叉堆的两种形式：\n\n- 最大堆：最大堆的性质：除了根结点以外的所有结点 i 都要满足 $A[PARENT(i)]\\ge A[i]$\n- 最小堆：最小堆的性质：除了根结点以外的所有结点 i 都要满足 $A[PARENT(i)]\\le A[i]$\n\n> 我的简记：小顶堆装大数、大顶堆装小数。\n\n对堆（大顶堆）操作算法快速回忆：\n\n| 堆的操作  | 时间复杂度           | 算法概述                             |\n| ----- | --------------- | -------------------------------- |\n| 堆化    | $\\Theta(\\lg n)$ | 对一个结点进行「下沉」                      |\n| 建堆    | $O(n)$          | 从中间往前，进行堆化                       |\n| 弹出堆顶  | $O(\\log n)$     | 弹出后，最后一个元素放堆顶，再堆化，防止空洞           |\n| 插入堆   | $O(\\log n)$     | 放最后，「上浮」                         |\n| 更新堆键值 | $O(\\log n)$     | 更新键后，「上浮」                        |\n| 堆排序   | $O(n\\lg n)$     | 建堆；一个个弹出。原址排序的话，弹出位置放堆后，堆大小减减即可。 |\n\n## 归并排序\n\n思想：如果能把原待排序的数组分解成若干个待排序的子数组，而这些子数组可以方便地排好序，并且通过合并这些子数组的解将能得到原问题的解，则整个数组将排好序。\n\n2 路归并排序通过应用**分治**法解题的三个基本步骤为：\n\n1. divide：把具有 n 个元素的数组分解为二个 n/2 大小的子数组\n2. conquer：递归地分解子数组，直到子数组只包含一个元素为止\n3. combine：二二合并已排好序的子数组使之成为一个新的排好序的子数组，重复这样二二合并的过程直到得到原问题的解\n\n归并排序不能保证一趟结束后一定有元素放在最终位置上。可以说是基本算法中占用辅助空间最多的排序算法。有方法克服但代价是算法会很复杂，且时间复杂度会增加。\n\n归并排序是一种稳定的算法。平均时间复杂度为 $O(n\\log_2 n)$ 的稳定排序算法只有归并排序。\n\n从单个记录起两两归并的做法不提倡，可以和直接插入排序结合，利用直接插入排序求得较长的有序文件，然后两两归并（两种算法都是稳定的排序算法，结合起来也是稳定的）。\n\n归并排序一般用于外部排序使用。\n\n## 外部排序\n\n外部排序在排序过程中根据要求不断在内、外存之间移动。\n\n外部排序使用归并排序法：\n\n1. 根据内存缓冲区大小，将外存文件分为若干子文件，依次读入内存，使用内部排序方法进行排序，然后再重新写回外存。这些有序子文件称为归并段或顺串。\n2. 对归并段进行逐趟归并，使归并段逐渐由小到大，直到得到整个有序文件。\n\n磁盘 I/O 优化方法——减少排序趟数：\n\n- 多路平衡归并与败者树（增加归并路数 k）\n- 置换 - 选择排序（生成初始归并段）（减少初始归并段个数 r）\n- 最佳归并树\n\n## 多路归并\n\n> [!question] 大文件排序\n> 假定现在有一包含大量整数的文本文件存放于磁盘中，其文件大小为 10GB，而本机内存只有 1GB。如何对文件内容进行排序？\n\n由于内存限制，我们无法一次性将文件读入内存进行排序。解决方法：\n\n- 将 10GB 大文件拆分为 100 个 100MB 的小文件。\n- 分别对 100 个小文件进行排序。\n\n> [!question] 中间问题：有序小文件合并为有序大文件\n> 假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们如何将这些 100 个小文件合并成一个有序的大文件？\n\n解决方法：使用优先队列（小顶堆）进行有序序列的多路归并。\n\n| 步骤                          | 时间复杂度           |\n| --------------------------- | --------------- |\n| 从 100 个文件各取一个字符串，放入数组并建小顶堆。 | $O(k), k = 100$ |\n| 弹出堆顶元素，放入大文件中。              | $O(\\log k)$     |\n| 再从堆顶元素所属的文件中取出字符串插入小顶堆      | $O(\\log k)$     |\n\n多路归并的过程可以找中位数。\n\n相关算法题目：\n\n- 🟥 [23. 合并 K 个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/description/)\n- 🟨 [373. 查找和最小的 K 对数字 - 力扣（LeetCode）](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?show=1)\n\n# 海量数据 Top K 问题\n\n根据集合的特点，将 Top K 问题分成两类：\n\n- 静态数据集合 Top K。在事先确定且不会变动的数据集合中求 Top K。\n- 动态数据集合 Top K。集合事先不确定，且有动态的数据加入到集合中。在这种集合上求 Top K。\n \n\n Top K 问题可以的狭义理解可以理解为：\n\n- Top 1：求数据集合中最大的元素。\n- Top N：求排好序的数据集合。\n\n## 使用堆：小型静态数据集合 Top K\n\n> 适合数据量小的数据集合。\n\n在一个包含 n 个数据的静态数组中，查找前 K 大数据。\n\n> ME：小堆装大数，让大的下沉保留。\n\n| 步骤                                 | 时间复杂度       |\n| ---------------------------------- | ----------- |\n| 维护一个大小为 K 的小顶堆                     | $O(k)$      |\n| 顺序遍历数组                             | $O(n)$      |\n| - 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中 | $O(\\log k)$ |\n| - 如果比堆顶元素小，则不做处理，继续遍历数组。           | $O(1)$      |\n\n这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。每次查询花费 $O(n \\log k)$。\n\n> [!hint] 此处可以使用快速排序。\n\n## 使用堆：动态数据集合 Top K\n\n要想知道实时 Top K，需要进行两个操作：\n\n- 添加数据\n- 查询当前 Top K\n\n如果查询 Top K 时使用静态数据集合的方法，那么每次查询将花费 $O(n \\log k)$。\n\n更高效的步骤：\n\n| 步骤                                 | 时间复杂度       |\n| ---------------------------------- | ----------- |\n| 如果一开始没建堆，则维护一个大小为 K 的小顶堆           | $O(k)$      |\n| 当有数据被添加到集合中时，我们就拿它与堆顶的元素对比         | -           |\n| - 如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中 | $O(\\log k)$ |\n| - 如果比堆顶元素小，则不做处理                   | $O(1)$      |\n\n> [!note] 使用有序数组维护 Top K 列表不会更加高效\n> 使用有序数组维护 Top K 列表并不比堆高效。\n> - 如一开始没构建有序数组，那么它的构建时间为 $O(k\\log k)$\n> - 插入数据时，二分方式找到插入的位置为 $O(\\log k)$，移动元素需 $O(k)$\n> \n> 相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。\n\n\n> [!question] 相似问题：巨型数据集合 Top K\n> 100w 个数中找出最大的 K 个数。\n\n我们可以沿用使用堆处理动态数据集合 Top K 方法：\n\n- 先构建大小为 K 最小堆；\n- 再把剩余数据一个个以相似的方式插入堆即可。\n\n> [!note] 改进版的快速排序算法不会比堆高效\n> 采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 K 多的时候，采用传统排序算法排序，取前 K 个。\n>\n> 时间复杂度：$O(N*k)$\n\n## 求词频 Top K\n\n> [!question] 求一个大文件中的 Top K 关键词\n> 现有一个包含 10 亿个关键词的日志文件，可用内存为 1G。求 Top 10 频数最多的关键词。\n>\n> 对应的 Top 1 问题：在海量数据中找出重复次数最多的一个关键词。\n> 对应的 Top N 问题：词频排序。\n\n步骤：\n\n- 使用**哈希**算法取模**分片**，分到 10 个文件中，保证相同的词都放在一个文件里。注意不叫分桶，因为桶排序中桶与桶之间是有序的！\n- 每片分别读入内存，通过**散列表**、平衡二叉查找树、红黑树、Trie 树等数据结构记录词频。\n- 每片词频排序方法：\n\t- 使用动态数据集合 Top K 方法排序：建小顶堆。\n\t- 求 Top N 或数据量小时：建**小顶堆**或快速排序。\n- 组合每片的词频进行最后的排序：\n\t- 把每片的 Top K 进行多路归并（使用**堆**），再取 Top K 即可。\n\t- 求 Top N 或数据量小时：直接合在一起，再用快速排序。或归并排序。\n\n> [!question] 求分布在不同文件中的 Top K 关键词\n> 现有多个不同的存储关键词的文件，每个关键词可能分布于多个文件中。求不同文件中的 Top K 关键词。\n>\n> 相似问法：不同机器中的 Top K 关键词\n\n在前一个问题中，我们使用**哈希**算法取模**分片**保证了相同的词只会放在同一个小文件中。本问题稍微有些不同：一开始每个关键词可能分布于多个文件中。\n\n解决方法：\n\n- 方法 1：遍历一遍所有数据，重新**哈希**取模**分片**，并沿用上一个问题的解决步骤进行问题求解。\n- 方法 2：暴力法。直接统计统计每个文件中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出 Top K。\n\n# 海量数据的中位数或任意百分位的数据\n\n## 使用堆求中位数或任意百分位的数据\n\n静态数据的中位数是固定的，我们可以先排序，再直接取。对于动态数据集合，如果每次查询中位数前都要排序则效率不高。\n\n正确的方法为利用两个堆：大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202509022252028.webp)\n\n元素动态添加时：\n\n- 如果新加入的数据小于等于大顶堆的堆顶元素，加入大顶堆\n- 否则加入小顶堆\n\n查询中位数前，需保证大顶堆元素和小顶堆元素数量比例正确：\n\n- 我们需要保证：前半部分数据放大顶堆，后半部分数据放小顶堆。如果 n 为奇数，多出的一个放大顶堆中。\n- 如果查询前两个堆的元素个数不满足条件，则将某一个堆的元素插入到另一个堆中，直到条件满足。\n\n取出中位数的方式 $O(1)$：\n\n- 如果 n 是偶数，大顶堆堆顶元素和小顶堆的堆顶元素即为所求。\n- 如果 n 是奇数，大顶堆堆顶元素即为所求。\n\n如果要求任意百分位的数，原理是相似的。\n\n> [!question] 快速求接口的 99% 响应时间\n> 如果将一组数据从小到大排列，这个 99 百分位数就是大于前面 99% 数据的那个数据。\n>\n> 做法：维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n⨯99% 个数据，小顶堆中保存 n⨯1% 个数据。数据的插入和查询前的调整规则类似前面中位数的要求。最后，每次查询大顶堆堆顶的数据就是我们要找的 99% 响应时间。\n\n## 通过分片统计求中位数\n\n> [!question] 从海量整数中找到中位数\n> 求 5 亿个 int 的中位数。\n>\n> 步骤：\n> - 将 int 划分为 $2^{16}$ 个区域，然后读取数据统计落到各个区域里的数的个数。\n> - 根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。\n> - 第二次扫描我们只统计落在这个区域中的那些数即可。\n> \n> 如果整数的范围更大，我们可以进行多层次的划分，使每个区域降到可接受的程度。\n\n# 海量数据的增删改查\n\n## 数据库索引\n\n适用范围：大数据量的增删改查\n\n基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。\n\n## 倒排索引 Inverted index\n\n适用范围：搜索引擎，关键字查询。\n\n倒排索引是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。\n\n```text\n# 下面是被索引的文本\nT0 = \"it is what it is\"\nT1 = \"what is it\"\nT2 = \"it is a banana\"\n\n\n# 下面是反向文件索引\n\"a\": {2}\n\"banana\": {2}\n\"is\": {0, 1, 2}\n\"it\": {0, 1, 2}\n\"what\": {0, 1}\n```\n\n正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。\n\n常见问题：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。\n\n# 海量数据的分布式处理\n\n可以看成大量数据被分为小文件的场景。\n\n## MapReduce\n\n> 类似归并排序。\n\nMapReduce 是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。\n\n任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。\n\n相关问题：\n\n- 海量数据分布在 100 台电脑中，想个办法高效统计出这批数据的 Top 10。\n\n> [!question] 多机器的海量数据查找中位数\n> 一共有 N 个机器，每个机器上有 N 个数。每个机器最多存 $O(N)$ 个数并对它们操作。如何找到 $N^2$ 个数的中位数？\n>\n> 方法 1：分片统计法\n> - 假设这些数都是 32 位无符号整数，我们可以根据整数范围分 N 个区段\n> - 把每个区段的数放在对应的机器上，这样每个机器上存储的数为 $O(N)$ 的\n> - 使用类似分片统计的方法，找到存在中位数的机器\n> - 对该机器进行内部排序，找出中位数即可\n> - 总时间复杂度：$O(N^2)+O(N\\log N)$\n> \n> 方案 2：\n> - 同方案 1，对数据进行分片并存入对应的机器中\n> - 每个机器上都进行内部排序\n> - 使用多路归并找中位数\n\n# 本文参考\n\n- 研究生课程《算法设计与分析》课程内容，以及课后实验二：典型排序算法训练\n- 《算法导论》第 6 章\n- 《王道 2023 408》思维导图解耦\n- [《算法与数据结构之美》王争-极客时间专栏](https://uaxe.github.io/geektime-docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/)\n- [全面解析基数排序：定义、原理、复杂度、稳定性及实现步骤详解 - 软件职业规划 - 博客园](https://www.cnblogs.com/java-note/p/18630738)\n- [为什么基数排序只有从最低位开始才是“稳定的排序算法”？？ - 知乎](https://www.zhihu.com/question/27021728)\n- [布隆过滤器 | JavaGuide](https://javaguide.cn/cs-basics/data-structure/bloom-filter.html#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D)\n- [海量数据问题的处理-六种解决思路 - Garrett_Wale - 博客园](https://www.cnblogs.com/GarrettWale/p/14478347.html)\n- [多路归并算法从理论到应用（易懂）-CSDN博客](https://blog.csdn.net/a574780196/article/details/122646309)\n- [Counting Bloom Filter 的原理和实现-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1136056)\n- [海量数据处理面试题集锦-CSDN博客](https://blog.csdn.net/v_july_v/article/details/6685962)\n- [45 位图：如何实现网页爬虫中的URL去重功能？ - 极客时间文档 - 王争 - 数据结构之美与算法之美](https://uaxe.github.io/geektime-docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/45%20-%20%E4%BD%8D%E5%9B%BE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84URL%E5%8E%BB%E9%87%8D%E5%8A%9F%E8%83%BD%EF%BC%9F/#_3)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"面试","api":"api/tags/面试.json"},{"name":"桶排序","api":"api/tags/桶排序.json"},{"name":"外部排序","api":"api/tags/外部排序.json"},{"name":"Top K","api":"api/tags/Top-K.json"},{"name":"数据结构","api":"api/tags/数据结构.json"},{"name":"排序","api":"api/tags/排序.json"},{"name":"基数排序","api":"api/tags/基数排序.json"},{"name":"堆排序","api":"api/tags/堆排序.json"},{"name":"堆","api":"api/tags/堆.json"},{"name":"优先队列","api":"api/tags/优先队列.json"},{"name":"布隆过滤器","api":"api/tags/布隆过滤器.json"},{"name":"哈希","api":"api/tags/哈希.json"},{"name":"多路归并","api":"api/tags/多路归并.json"},{"name":"分治算法","api":"api/tags/分治算法.json"},{"name":"Trie 树","api":"api/tags/Trie-树.json"}]},"api":"api/posts/p/4fdbc02c.json"}