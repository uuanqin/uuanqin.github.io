{"title":"字符串的匹配算法（单模式串）","tags":["LeetCode","KMP","String","Java"],"cover":"https://cdn.gallery.uuanqin.top/img/202409020200851.webp","description":"Needle in a Haystack. 大海捞针","categories":["算法与数据结构"],"abbrlink":"53501b47","katex":true,"date":"2024-09-04T23:58:39.000Z","top_img":null,"summary":"KMP 算法真的是......看了忘，忘了看......每次看时都要从盘古开天辟地开始看......从大一看到现在，真·从小看到大！ 本文题目难度标识：🟩简单，🟨中等，🟥困难。 > [!example] 题目：🟩 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode） > 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 -1 。 模式匹配指的是求子串（模式串）在主串中的位置。常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等。 下文中，有时候将题目中的主串 `haystack` 称为 `S`，模式串 `needle` 称为 `T`。 暴力算法（Brute Force, BF） 每次匹配失败，T 串向前走。直到匹配成功或返回 -1。 我们发现，指向 S 和 T 串的指针，在出现失配时需要进行回溯。 时间复杂度（最坏）：$O(n×m)$，其中 n 是字符串 `haystack` 的长度，m 是字符串 `needle` 的长度。最坏情况下我们需要将字符串 `needle` 与字符串 `haystack` 的所有长度为 m 的子串均匹配一次。 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。 RK 算法（Rabin-Karp） RK 算法是 BF 算法的升级版。 具体思路为：长度为 m 的主串有 n-m+1 个长度为 m 的子串，通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后与模式串的哈希值进行比较。 如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身。 如果某个子串的哈希值等于模式串的哈希值，再进一步对比一下子串和模式串本身，判断是否真的匹配。 对于使用哈希算法计算 n-m+1 个长度为 m 的子串的哈希值的过程，我们要控制其时间复杂度在 $O(n)$，之内。这样的哈希算法有一个特点，在主串中，相邻两个子串哈希值的计算公式有一定的关系。..."}