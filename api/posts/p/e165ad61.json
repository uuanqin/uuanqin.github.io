{"data":{"title":"模板方法模式：命题作文","slug":"高质量代码及设计模式/模板方法模式：命题作文","description":"将具体处理交给子类","date":"2025-08-13T16:28:33.000Z","updated":"2025-08-18T12:49:19.691Z","language":"zh-CN","comments":true,"url":"p/e165ad61/","cover":"https://cdn.gallery.uuanqin.top/img/202409010325343.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408021705517.webp\" alt=\"image.png\" width=\"275px\" /></p>\n\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">概念感受——模板</div>\n</div>\n<div class=\"callout-content\"><p>模板，原义是指带有镂空文字的薄薄塑料板。只要用笔在模板的镂空处进行临摹，即使是手写也能写出整齐的文字。虽然只要看到这些镂空的洞，我们就可以知道能写出哪些文字，但是具体写出的文字是什么感觉则依赖于所用的笔。如果使用签字笔来临摹，则可以写出签字似的文字；如果使用铅笔来临摹，则可以写出铅笔字；而如果是用彩色笔临摹，则可以写出彩色的字。但是无论使用什么笔，文字的形状都会与模板上镂空处的形状一致。</p>\n</div></div>\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">模板方法设计模式 Template Method Design Pattern</div>\n</div>\n<div class=\"callout-content\"><p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.——GoF<br />\n在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>\n</div></div><p>这里的「算法」可理解为广义上的「业务逻辑」。模板方法模式在父类中定义处理流程的框架，允许子类中实现每个流程的具体处理。</p>\n<p>登场角色：</p>\n<ul>\n<li><code>AbstractClass</code>（抽象类）：实现模板方法，声明在模板方法中所使用到的抽象方法。这些方法由子类 <code>ConcreteClass</code> 角色负责实现。</li>\n<li><code>ConcreteClass</code>（具体类）：实现 <code>AbstractClass</code> 角色中定义的抽象方法。这里的实现方法会在 <code>AbstractClass</code> 角色得模板方法中被调用。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508112158507.webp\" alt=\"image.png\" width=\"360px\" /></p>\n<blockquote>\n<p>在模板模式经典的实现中，模板方法定义为 <code>final</code>，可以避免被子类重写。需要子类重写的方法定义为 <code>abstract</code>，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。</p>\n</blockquote>\n<p>观察上面的 <code>AbstractClass</code>，其中 <code>templateMethod</code> 为模板方法，里面使用了 <code>method1</code>、<code>method2</code>、<code>method3</code> 抽象方法。这些抽象方法需要子类去实现。</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TemplateTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">AbstractClass</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteClass</span>();</span><br><span class=\"line\">        c.templateMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractClass</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">templateMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        method1();</span><br><span class=\"line\">        method2();</span><br><span class=\"line\">        method3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractClass</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;1. 打开大门&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;2. 装入大象&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;3. 关上大门&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类的层次与抽象类：</p>\n<ul>\n<li>父类对子类的要求（子类责任）：父类期待子类去实现抽象方法；父类要求子类去实现抽象方法。</li>\n<li>抽象类的意义：在抽象类阶段确定处理的流程。</li>\n<li>父类子类协作：降低子类灵活性，子类可能会臃肿。</li>\n</ul>\n<p>拓展思路要点：</p>\n<ul>\n<li>父类的模板方法中编写了算法，因此无需在每个子类中再编写算法。模板方法出现 Bug 时，只需改模板方法。</li>\n<li>父类子类紧密联系。在子类中实现父类中声明的抽象方法时，必须要理解抽象方法被调用的时机。</li>\n<li>父类与子类的一致性，里氏替换原则 LSP。使用父类类型的变量保存子类实例的优点是，即使没有用 <code>instanceof</code> 等指定子类的种类，程序也能正常工作。LSP 是通用的继承原则，并非仅限于模板方法模式。</li>\n</ul>\n<p>两大作用：</p>\n<ul>\n<li>复用：所有的子类都可以复用父类中模板方法定义的流程代码。</li>\n<li>扩展：这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性。模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。比如，在模板方法中，会调用一些抽象方法，而这些方法的具体实现可以交由子类去扩展。</li>\n</ul>\n<p>应用场景：</p>\n<ol>\n<li>算法的整体框架已经确定，但某些具体步骤的实现可能会有所不同。模板方法模式可以在抽象类中定义整体的算法框架，而将具体步骤的实现留给子类来完成。</li>\n<li>多个类具有相似的算法结构，但其中的某些步骤可能有所不同。通过使用模板方法模式，可以将这些公共的代码逻辑提取到抽象类中的模板方法中，避免代码的重复。</li>\n<li>需要在不破坏原有算法框架的情况下，对算法中的某些步骤进行扩展或修改。通过使用模板方法模式，可以在抽象类中定义通用的算法流程，而在子类中重写需要修改或扩展的具体步骤。</li>\n<li>需要在多个相关类中实现一些公共行为，而不希望将这些行为放在一个单独的类中管理。模板方法模式可以将这些公共行为封装在抽象类中的模板方法中，使得不同的类可以根据需要继承该抽象类并实现具体的步骤。</li>\n<li>需要控制算法的执行顺序和流程。通过模板方法模式，可以在抽象类中控制算法的整体结构，确保每个步骤按照预期顺序执行。</li>\n</ol>\n<h1 id=\"相关的设计模式\"><a class=\"markdownIt-Anchor\" href=\"#相关的设计模式\"></a> 相关的设计模式</h1>\n<p><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"yukari\">站内文章</span>工厂（方法）模式</a> 是将模板方法模式<strong>用于生成实例</strong>的一个典型例子。</p>\n<p>与策略模式的对比：</p>\n<table>\n<thead>\n<tr>\n<th>设计模式</th>\n<th>模板方法模式</th>\n<th>策略模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>改变程序行为的技术</td>\n<td>继承。在父类中定义程序行为的框架，在子类中决定具体的处理。</td>\n<td>委托。</td>\n</tr>\n<tr>\n<td>关注点</td>\n<td>算法的整体框架、步骤。</td>\n<td>不同的算法实现。将算法的实现与具体的类解耦。</td>\n</tr>\n<tr>\n<td>改变程序行为</td>\n<td>子类可以改变部分程序行为。</td>\n<td>替换整个算法。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"java-源代码中的模板方法模式\"><a class=\"markdownIt-Anchor\" href=\"#java-源代码中的模板方法模式\"></a> Java 源代码中的模板方法模式</h1>\n<p><code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code> 类都使用了模板方法模式。<code>AbstractList</code> 的 <code>addAll()</code> 函数也使用了模板方法模式。</p>\n<p>Java 中的 Servlet 生命周期就是使用了模板方法模式，其中抽象类 <code>HttpServlet</code> 定义了 <code>doGet</code>、<code>doPost</code> 等操作方法，而具体的 <code>Servlet</code> 类可以继承 <code>HttpServlet</code> 并重写具体的操作方法来实现自定义的业务逻辑。</p>\n<h1 id=\"回调函数\"><a class=\"markdownIt-Anchor\" href=\"#回调函数\"></a> 回调函数</h1>\n<p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是「回调函数」。A 调用 B，B 反过来又调用 A，这种调用机制就叫作「回调」。</p>\n<p>对于回调，不同的编程语言有不同的实现方式，C 语言中使用函数指针来实现。</p>\n<p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。</p>\n<h2 id=\"同步回调\"><a class=\"markdownIt-Anchor\" href=\"#同步回调\"></a> 同步回调</h2>\n<p>Java 中同步回调函数的典型实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICallback</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">methodToCallback</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B 类内置类处理回调函数的方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">(ICallback callback)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    callback.methodToCallback();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A 类定义了具体回调函数的逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">BClass</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BClass</span>();</span><br><span class=\"line\">    <span class=\"comment\">// A类中定义回调对象，并将其交给B类</span></span><br><span class=\"line\">    b.process(<span class=\"keyword\">new</span> <span class=\"title class_\">ICallback</span>() &#123; </span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">methodToCallback</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Call back me.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同步回调更像是模板方法模式：将不变的执行流程抽离出来，放到模板方法中，然后将可变的部分实际成回调，由用户来定制。</p>\n<h2 id=\"异步回调\"><a class=\"markdownIt-Anchor\" href=\"#异步回调\"></a> 异步回调</h2>\n<p>比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>\n<h2 id=\"回调与模板模式\"><a class=\"markdownIt-Anchor\" href=\"#回调与模板模式\"></a> 回调与模板模式</h2>\n<p>从应用场景上来看，同步回调看起来更像模板模式，它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。异步回调看起来更像观察者模式。</p>\n<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>\n<p>组合优于继承。在代码实现上，回调相对于模板模式会更加灵活，主要体现在：</p>\n<ul>\n<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>\n</ul>\n<h2 id=\"回调与钩子\"><a class=\"markdownIt-Anchor\" href=\"#回调与钩子\"></a> 回调与钩子</h2>\n<p>Callback 是一种异步调用的实现，Callback 本意就是你传递一个函数给对方，当对方的工作有进展的时候就调用这个函数通知你。</p>\n<p>Hook 则是一种 API 拦截手段，特点就是不改变原有双边的逻辑的情况下，在 API 接口上插入一个拦截调用的 Hook 函数，从而截取调用数据、甚至可以改变程序行为。</p>\n<h1 id=\"java-8-之后的模板方法模式新写法\"><a class=\"markdownIt-Anchor\" href=\"#java-8-之后的模板方法模式新写法\"></a> Java 8 之后的模板方法模式新写法</h1>\n<p>Java 8 中最大的新特性就是提供了对 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c5c0eb2/\"><span class=\"yukari\">站内文章</span>函数式编程</a> 的支持。Java 8 在 <code>java.util.function</code> 下面增加增加一系列的函数接口。其中主要有 <code>Consumer</code>、<code>Supplier</code>、<code>Predicate</code>、<code>Function</code> 等。</p>\n<p>在上文中，我们可以知道模板方法模式中，子类通过实现抽象方法替换父类算法框架中的某个步骤。但是如果父类的模板方法中，一些步骤可以进行多种替换。如果仅靠子类实现将会需要编写许多的类。</p>\n<p>我们可以进行以下改进：</p>\n<ul>\n<li>使用函数式编程，让算法步骤作为一个函数类型传入到模板方法中</li>\n<li>在统一的类中定义不同的算法实现，免去继承的麻烦</li>\n</ul>\n<p>文章开头的案例可以改造为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TemplateTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MyHandler</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyHandler</span>();</span><br><span class=\"line\">        c.putElephantIntoRefrigerator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这是模板方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> step1 步骤一</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> step2 步骤二</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> step3 步骤三</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">templateMethod</span><span class=\"params\">(Runnable step1, Runnable step2, Runnable step3)</span>&#123;</span><br><span class=\"line\">        step1.run();</span><br><span class=\"line\">        step2.run();</span><br><span class=\"line\">        step3.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">putElephantIntoRefrigerator</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        templateMethod(</span><br><span class=\"line\">                ()-&gt;System.out.println(<span class=\"string\">&quot;1. 打开大门&quot;</span>),</span><br><span class=\"line\">                ()-&gt;System.out.println(<span class=\"string\">&quot;2. 装入大象&quot;</span>),</span><br><span class=\"line\">                ()-&gt;System.out.println(<span class=\"string\">&quot;3. 关上大门&quot;</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 此处可以扩展更多的方法 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>长得很像上一节讲的同步回调。</p>\n<h1 id=\"本文-plantuml-归档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-归档\"></a> 本文 PlantUML 归档</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class AbstractClass&#123;</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; method1</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; method2</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; method3</span><br><span class=\"line\">\t&#123;method&#125; templateMethod </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ConcreteClass&#123;</span><br><span class=\"line\">\t&#123;method&#125; method1</span><br><span class=\"line\">\t&#123;method&#125; method2</span><br><span class=\"line\">\t&#123;method&#125; method3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AbstractClass &lt;|-- ConcreteClass</span><br><span class=\"line\"></span><br><span class=\"line\">note right of AbstractClass::templateMethod</span><br><span class=\"line\">\t方法使用final关键字修饰，</span><br><span class=\"line\">\t表明不应该重写模板方法</span><br><span class=\"line\">end note</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li>极客时间专栏 - 设计模式之美 - 王争</li>\n<li><a href=\"https://www.zhihu.com/question/501933636\">钩子函数（HOOK）和回调函数（CALLBACK）有什么区别？ - 知乎</a></li>\n<li><a href=\"https://developer.aliyun.com/article/787932\">使用Java8改造出来的模板方法真的是yyds-阿里云开发者社区</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2421967\">JAVA设计模式13：模版方法模式，将一些步骤延迟到子类中实现-腾讯云开发者社区-腾讯云</a></li>\n</ul>\n","raw":"---\ntitle: 模板方法模式：命题作文\ntags:\n  - 设计模式\n  - Java\n  - 回调函数\n  - Hook\ncover: 'https://cdn.gallery.uuanqin.top/img/202409010325343.webp'\ndescription: 将具体处理交给子类\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: e165ad61\ndate: 2025-08-14 00:28:33\ntop_img:\n---\n\n![image.png|275](https://cdn.gallery.uuanqin.top/img/202408021705517.webp)\n\n> [!notice] 概念感受——模板\n> 模板，原义是指带有镂空文字的薄薄塑料板。只要用笔在模板的镂空处进行临摹，即使是手写也能写出整齐的文字。虽然只要看到这些镂空的洞，我们就可以知道能写出哪些文字，但是具体写出的文字是什么感觉则依赖于所用的笔。如果使用签字笔来临摹，则可以写出签字似的文字；如果使用铅笔来临摹，则可以写出铅笔字；而如果是用彩色笔临摹，则可以写出彩色的字。但是无论使用什么笔，文字的形状都会与模板上镂空处的形状一致。\n\n> [!tldr] 模板方法设计模式 Template Method Design Pattern\n> Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.——GoF\n> 在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。\n\n这里的「算法」可理解为广义上的「业务逻辑」。模板方法模式在父类中定义处理流程的框架，允许子类中实现每个流程的具体处理。\n\n登场角色：\n\n- `AbstractClass`（抽象类）：实现模板方法，声明在模板方法中所使用到的抽象方法。这些方法由子类 `ConcreteClass` 角色负责实现。\n- `ConcreteClass`（具体类）：实现 `AbstractClass` 角色中定义的抽象方法。这里的实现方法会在 `AbstractClass` 角色得模板方法中被调用。\n\n![image.png|360](https://cdn.gallery.uuanqin.top/img/202508112158507.webp)\n\n> 在模板模式经典的实现中，模板方法定义为 `final`，可以避免被子类重写。需要子类重写的方法定义为 `abstract`，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。\n\n观察上面的 `AbstractClass`，其中 `templateMethod` 为模板方法，里面使用了 `method1`、`method2`、`method3` 抽象方法。这些抽象方法需要子类去实现。\n\n代码示例：\n\n```java\npublic class TemplateTest {\n    public static void main(String[] args) {\n        AbstractClass c = new ConcreteClass();\n        c.templateMethod();\n    }\n}\n\nabstract class AbstractClass{\n    abstract public void method1();\n    abstract public void method2();\n    abstract public void method3();\n\n    final public void templateMethod(){\n        method1();\n        method2();\n        method3();\n    }\n}\n\nclass ConcreteClass extends AbstractClass{\n\n    @Override\n    public void method1() {\n        System.out.println(\"1. 打开大门\");\n    }\n\n    @Override\n    public void method2() {\n        System.out.println(\"2. 装入大象\");\n    }\n\n    @Override\n    public void method3() {\n        System.out.println(\"3. 关上大门\");\n    }\n}\n```\n\n类的层次与抽象类：\n\n- 父类对子类的要求（子类责任）：父类期待子类去实现抽象方法；父类要求子类去实现抽象方法。\n- 抽象类的意义：在抽象类阶段确定处理的流程。\n- 父类子类协作：降低子类灵活性，子类可能会臃肿。\n\n拓展思路要点：\n\n- 父类的模板方法中编写了算法，因此无需在每个子类中再编写算法。模板方法出现 Bug 时，只需改模板方法。\n- 父类子类紧密联系。在子类中实现父类中声明的抽象方法时，必须要理解抽象方法被调用的时机。\n- 父类与子类的一致性，里氏替换原则 LSP。使用父类类型的变量保存子类实例的优点是，即使没有用 `instanceof` 等指定子类的种类，程序也能正常工作。LSP 是通用的继承原则，并非仅限于模板方法模式。\n\n两大作用：\n\n- 复用：所有的子类都可以复用父类中模板方法定义的流程代码。\n- 扩展：这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性。模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。比如，在模板方法中，会调用一些抽象方法，而这些方法的具体实现可以交由子类去扩展。\n\n应用场景：\n\n1. 算法的整体框架已经确定，但某些具体步骤的实现可能会有所不同。模板方法模式可以在抽象类中定义整体的算法框架，而将具体步骤的实现留给子类来完成。\n2. 多个类具有相似的算法结构，但其中的某些步骤可能有所不同。通过使用模板方法模式，可以将这些公共的代码逻辑提取到抽象类中的模板方法中，避免代码的重复。\n3. 需要在不破坏原有算法框架的情况下，对算法中的某些步骤进行扩展或修改。通过使用模板方法模式，可以在抽象类中定义通用的算法流程，而在子类中重写需要修改或扩展的具体步骤。\n4. 需要在多个相关类中实现一些公共行为，而不希望将这些行为放在一个单独的类中管理。模板方法模式可以将这些公共行为封装在抽象类中的模板方法中，使得不同的类可以根据需要继承该抽象类并实现具体的步骤。\n5. 需要控制算法的执行顺序和流程。通过模板方法模式，可以在抽象类中控制算法的整体结构，确保每个步骤按照预期顺序执行。\n\n# 相关的设计模式\n\n[[类的工厂|工厂（方法）模式]] 是将模板方法模式**用于生成实例**的一个典型例子。\n\n与策略模式的对比：\n\n| 设计模式      | 模板方法模式                        | 策略模式                   |\n| --------- | ----------------------------- | ---------------------- |\n| 改变程序行为的技术 | 继承。在父类中定义程序行为的框架，在子类中决定具体的处理。 | 委托。                    |\n| 关注点       | 算法的整体框架、步骤。                   | 不同的算法实现。将算法的实现与具体的类解耦。 |\n| 改变程序行为    | 子类可以改变部分程序行为。                 | 替换整个算法。                |\n\n# Java 源代码中的模板方法模式\n\n`InputStream`、`OutputStream`、`Reader`、`Writer` 类都使用了模板方法模式。`AbstractList` 的 `addAll()` 函数也使用了模板方法模式。\n\nJava 中的 Servlet 生命周期就是使用了模板方法模式，其中抽象类 `HttpServlet` 定义了 `doGet`、`doPost` 等操作方法，而具体的 `Servlet` 类可以继承 `HttpServlet` 并重写具体的操作方法来实现自定义的业务逻辑。\n\n# 回调函数\n\n相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是「回调函数」。A 调用 B，B 反过来又调用 A，这种调用机制就叫作「回调」。\n\n对于回调，不同的编程语言有不同的实现方式，C 语言中使用函数指针来实现。\n\n回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。\n\n## 同步回调\n\nJava 中同步回调函数的典型实现：\n\n```java\npublic interface ICallback {\n  void methodToCallback();\n}\n\n// B 类内置类处理回调函数的方法\npublic class BClass {\n  public void process(ICallback callback) {\n    //...\n    callback.methodToCallback();\n    //...\n  }\n}\n\n// A 类定义了具体回调函数的逻辑\npublic class AClass {\n  public static void main(String[] args) {\n    BClass b = new BClass();\n    // A类中定义回调对象，并将其交给B类\n    b.process(new ICallback() { \n      @Override\n      public void methodToCallback() {\n        System.out.println(\"Call back me.\");\n      }\n    });\n  }\n}\n```\n\n同步回调更像是模板方法模式：将不变的执行流程抽离出来，放到模板方法中，然后将可变的部分实际成回调，由用户来定制。\n\n## 异步回调\n\n比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。\n\n## 回调与模板模式\n\n从应用场景上来看，同步回调看起来更像模板模式，它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。异步回调看起来更像观察者模式。\n\n从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。\n\n组合优于继承。在代码实现上，回调相对于模板模式会更加灵活，主要体现在：\n\n- 像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。\n- 回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。\n- 如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。\n\n## 回调与钩子\n\nCallback 是一种异步调用的实现，Callback 本意就是你传递一个函数给对方，当对方的工作有进展的时候就调用这个函数通知你。\n\nHook 则是一种 API 拦截手段，特点就是不改变原有双边的逻辑的情况下，在 API 接口上插入一个拦截调用的 Hook 函数，从而截取调用数据、甚至可以改变程序行为。\n\n# Java 8 之后的模板方法模式新写法\n\nJava 8 中最大的新特性就是提供了对 [[Java 8 中的函数式编程|函数式编程]] 的支持。Java 8 在 `java.util.function` 下面增加增加一系列的函数接口。其中主要有 `Consumer`、`Supplier`、`Predicate`、`Function` 等。\n\n在上文中，我们可以知道模板方法模式中，子类通过实现抽象方法替换父类算法框架中的某个步骤。但是如果父类的模板方法中，一些步骤可以进行多种替换。如果仅靠子类实现将会需要编写许多的类。\n\n我们可以进行以下改进：\n\n- 使用函数式编程，让算法步骤作为一个函数类型传入到模板方法中\n- 在统一的类中定义不同的算法实现，免去继承的麻烦\n\n文章开头的案例可以改造为：\n\n```java\npublic class TemplateTest {\n    public static void main(String[] args) {\n        MyHandler c = new MyHandler();\n        c.putElephantIntoRefrigerator();\n    }\n}\n\nclass MyHandler {\n    /**\n     * 这是模板方法\n     * @param step1 步骤一\n     * @param step2 步骤二\n     * @param step3 步骤三\n     */\n    final public void templateMethod(Runnable step1, Runnable step2, Runnable step3){\n        step1.run();\n        step2.run();\n        step3.run();\n    }\n\n    public void putElephantIntoRefrigerator(){\n        templateMethod(\n                ()->System.out.println(\"1. 打开大门\"),\n                ()->System.out.println(\"2. 装入大象\"),\n                ()->System.out.println(\"3. 关上大门\")\n        );\n    }\n    \n    /* 此处可以扩展更多的方法 */\n}\n```\n\n长得很像上一节讲的同步回调。\n\n# 本文 PlantUML 归档\n\n```plantuml\nabstract class AbstractClass{\n\t{method} {abstract} method1\n\t{method} {abstract} method2\n\t{method} {abstract} method3\n\t{method} templateMethod \n}\n\nclass ConcreteClass{\n\t{method} method1\n\t{method} method2\n\t{method} method3\n}\n\nAbstractClass <|-- ConcreteClass\n\nnote right of AbstractClass::templateMethod\n\t方法使用final关键字修饰，\n\t表明不应该重写模板方法\nend note\n```\n\n# 本文参考\n\n- 《图解设计模式》\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- 极客时间专栏 - 设计模式之美 - 王争\n- [钩子函数（HOOK）和回调函数（CALLBACK）有什么区别？ - 知乎](https://www.zhihu.com/question/501933636)\n- [使用Java8改造出来的模板方法真的是yyds-阿里云开发者社区](https://developer.aliyun.com/article/787932)\n- [JAVA设计模式13：模版方法模式，将一些步骤延迟到子类中实现-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2421967)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"回调函数","api":"api/tags/回调函数.json"},{"name":"Hook","api":"api/tags/Hook.json"}]},"api":"api/posts/p/e165ad61.json"}