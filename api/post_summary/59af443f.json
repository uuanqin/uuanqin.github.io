{"title":"前后缀分解的应用","tags":["LeetCode","前缀和","动态规划","哈希表","Java"],"cover":"https://cdn.gallery.uuanqin.top/img/202409220021307.webp","categories":["算法与数据结构"],"abbrlink":"59af443f","description":"动态规划的简单运用，打遍「连续子数组」「接雨水」","katex":true,"date":"2024-09-21T19:12:16.000Z","top_img":null,"summary":"本文题目难度标识：🟩简单，🟨中等，🟥困难。 前缀和 对于「连续子数组问题」一般可以通过前缀和方式解决。 > [!example] 题目：🟨 560. 和为 K 的子数组 - 力扣（LeetCode） > 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 > > 子数组是数组中元素的连续非空序列。 暴力枚举： 时间复杂度：$O(n^2)$，其中 n 为数组的长度。枚举子数组开头和结尾需要 $O(n^2)$ 的时间，其中求和需要 $O(1)$ 的时间复杂度，因此总时间复杂度为 $O(n^2)$。 空间复杂度：$O(1)$。只需要常数空间存放若干变量。 下面介绍前缀和 + 哈希表优化方法。 定义 `pre[i]` 为 `[0..i]` 里所有数的和，则 `pre[i]` 可以由 `pre[i−1]` 递推而来，即：`pre[i]=pre[i−1]+nums[i]`。 那么「`[j..i]` 这个子数组和为 `k` 」这个条件我们可以转化为 `pre[i]−pre[j−1]==k`。 因此我们可以在遍历的同时计算前缀和 `pre[i]` 时，找一下哈希表中有没有存有 `pre[j−1]` 即可。 复杂度分析： 时间复杂度：$O(n)$，其中 n 为数组的长度。我们遍历数组的时间复杂度为 $O(n)$，中间利用哈希表查询删除的复杂度均为 $O(1)$，因此总时间复杂度为 $O(n)$。 空间复杂度：$O(n)$，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 $O(n)$ 的空间复杂度。 相关题目： 🟨 974. 和可被 K 整除的子数组 - 力扣（LeetCode） 对「同余定理」的考察。 🟨 523. 连续的子数组和 - 力扣（LeetCode） 对「同余定理」的考察，并且限制了数组长度，不需要统计符合条件的个数。 🟨53. 最大子数组和 - 力扣（LeetCode）。解法详看 [[最大子数组问题]]。 前缀「条件」和 我这里起名前缀「条件」和，是因为这里 `nums` 元素必须满足一定条件，才统计入前缀和。 > [!example] 题目：🟨 1248. 统计「优美子数组」 - 力扣（LeetCode） > 给你一个整数数组 `nums` 和一个整数 k。..."}