{"data":{"title":"背包问题","slug":"算法与数据结构/背包问题","description":"背包问题集合","date":"2025-05-11T15:23:29.000Z","updated":"2025-09-09T16:36:49.872Z","language":"zh-CN","comments":true,"url":"p/29e8dd2d/","cover":"https://cdn.gallery.uuanqin.top/img/202503100338306.webp","images":[],"content":"<p>背包问题已经是一个很经典而且讨论很广泛的算法问题了。</p>\n<p>背包问题泛指这类种问题： 给定一组有固定价值和固定重量的物品， 以及一个已知最大承重量的背包， 求在不超过背包最大承重量的前提下， 能放进背包里面的物品的最大总价值。</p>\n<p>具体各类背包问题可以分成以下不同的子问题。</p>\n<h1 id=\"不同的背包问题\"><a class=\"markdownIt-Anchor\" href=\"#不同的背包问题\"></a> 不同的背包问题</h1>\n<h2 id=\"0-1-背包问题\"><a class=\"markdownIt-Anchor\" href=\"#0-1-背包问题\"></a> 0-1 背包问题</h2>\n<blockquote>\n<p>特点：每个物品只有一件，选择放或者不放。</p>\n</blockquote>\n<h3 id=\"变形-1存在最大容量-求最大价值\"><a class=\"markdownIt-Anchor\" href=\"#变形-1存在最大容量-求最大价值\"></a> 变形 1：存在最大容量 - 求最大价值</h3>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">0-1 背包问题案例：🟨 <a href=\"https://www.lintcode.com/problem/125/description\">125 · 背包问题（二） - LintCode</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>有 n 个商品，第 i 个商品价值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 元，重 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 千克，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 都是整数。背包最多容纳 W 千克（整数）商品，<strong>每个商品要么全拿走，要么不拿走</strong>，我们需要拿走商品的总价值最高。</p>\n</div></div><p><code>dp[i][j]</code> 表示前 i 个商品在 j 空间下的最优选择的价值。</p>\n<p>这里的模型为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>c</mi><mo>−</mo><mi>w</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mi>v</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dfs(i,c) = \\max (dfs(i-1,c),dfs(i-1,c-w[i])+v[i])\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>我们可以使用动态规划算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给定数组 `a` 表示每个物品的大小和数组 `v` 表示每个物品的价值.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">backPackII</span><span class=\"params\">(<span class=\"type\">int</span> W, <span class=\"type\">int</span>[] a, <span class=\"type\">int</span>[] v)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">\t<span class=\"comment\">// 数组dp[i][j]表示从前i件物品选体积不超过j的物品最大价值</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>][len+<span class=\"number\">1</span>]; <span class=\"comment\">// 初始化其首行首列的值为0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 【不同写法】内外循环是可以调换的</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=W;i++)&#123;            <span class=\"comment\">// 【高效】从1开始。从0也行，但低效</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;       <span class=\"comment\">// 【不同写法】可以从0或从1开始</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a[j]&lt;=i)&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j+<span class=\"number\">1</span>] = Math.max(dp[i][j],dp[i-a[j]][j]+v[j]);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j+<span class=\"number\">1</span>] = dp[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[W][len];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nW)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nW)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">不同循环写法的优劣</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>问：两层循环有两种写法，一种是外层循环枚举物品，内层循环枚举体积；另一种是外层循环枚举体积，内层循环枚举物品。如何评价这两种写法的优劣？</p>\n<p>答：两种写法都可以，但更推荐前者。外层循环枚举物品的写法，只会遍历物品数组一次；而内层循环枚举物品的写法，会遍历物品数组多次。从 cache 的角度分析，多次遍历数组会导致额外的 cache miss，带来额外的开销。所以虽然这两种写法的时间空间复杂度是一样的，但外层循环枚举物品的写法常数更小。</p>\n</div></div><p>滚动数组优化空间复杂度至 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">2*W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">backPackII</span><span class=\"params\">(<span class=\"type\">int</span> W, <span class=\"type\">int</span>[] a, <span class=\"type\">int</span>[] v)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=W;i++)&#123;   <span class=\"comment\">// 【不同写法】此处循环可以正序或者逆序</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a[j]&lt;=i)&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][(j+<span class=\"number\">1</span>)%<span class=\"number\">2</span>] = Math.max(dp[i][j%<span class=\"number\">2</span>],dp[i-a[j]][j%<span class=\"number\">2</span>]+v[j]);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][(j+<span class=\"number\">1</span>)%<span class=\"number\">2</span>] = dp[i][j%<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[W][len%<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nW)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(W)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>注意到，对于物品空间的遍历（也就是上面代码的内层循环），循环顺序不影响结果。我们可以进一步考虑只使用一维 <code>dp</code> 数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">backPackII</span><span class=\"params\">(<span class=\"type\">int</span> W, <span class=\"type\">int</span>[] a, <span class=\"type\">int</span>[] v)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=W;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 【优化点】if-else语句可优化</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a[j]&lt;=i)&#123;</span><br><span class=\"line\">\t\t\t\tdp[i] = Math.max(dp[i],dp[i-a[j]]+v[j]);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tdp[i] = dp[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[W];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，0-1 背包使用一维数组时，内层循环只能<strong>逆序遍历</strong>！逆序遍历时，新值取自上一轮的旧值，所以不会有什么影响。</p>\n<p>对 if-else 语句进行优化，得到最终的 0-1 背包一维数组写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">backPackII</span><span class=\"params\">(<span class=\"type\">int</span> W, <span class=\"type\">int</span>[] a, <span class=\"type\">int</span>[] v)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=W;i&gt;=a[j];i--)&#123;</span><br><span class=\"line\">\t\t\tdp[i] = Math.max(dp[i],dp[i-a[j]]+v[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[W];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nW)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(W)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/ones-and-zeroes/description/\">474. 一和零 - 力扣（LeetCode）</a> 二维背包</li>\n<li>🟨<a href=\"https://leetcode.cn/problems/last-stone-weight-ii/description/\">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></li>\n</ul>\n<h3 id=\"变形-2恰好装满容量-求方案数\"><a class=\"markdownIt-Anchor\" href=\"#变形-2恰好装满容量-求方案数\"></a> 变形 2：恰好装满容量 - 求方案数</h3>\n<p>如果题目要求背包恰好装满，求方案数，这时 dp 边界条件和状态转移公式有些许不同。这里展示最普通的二维数组写法。一维数组写法可自行尝试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[][] dp  = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>][nums.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">1</span>; <span class=\"comment\">// 边界条件</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=W;i++)&#123; <span class=\"comment\">//【注意】强烈建议从0开始</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&gt;=nums[j])&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>] = dp[i][j]+dp[i-nums[j]][j];</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>] = dp[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候，给定的物品中会存在重量为 0 的物品，这时候外层循环中一定要从 0 开始。</p>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/target-sum/description/\">494. 目标和 - 力扣（LeetCode）</a></li>\n<li>🟥 <a href=\"https://leetcode.cn/problems/oPs9Bm/description/\">LCP 47. 入场安检 - 力扣（LeetCode）</a></li>\n</ul>\n<h3 id=\"变形-3恰好装满容量-求可行性\"><a class=\"markdownIt-Anchor\" href=\"#变形-3恰好装满容量-求可行性\"></a> 变形 3：恰好装满容量 - 求可行性</h3>\n<p>假设题目要求我们回答给定的物品能否在指定的空间 W 恰好装满，我们可以有两种方式思考。</p>\n<p>第一种思路是，将题目转变为「变形 1：存在最大容量 - 求最大价值」，最后判断一下最大价值是否是最大容量即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">W</span> <span class=\"operator\">=</span> sum/<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"><span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>][len+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=W;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[j]&lt;=i)&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>] = Math.max(dp[i][j],dp[i-nums[j]][j]+nums[j]);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>]=dp[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[W][len]==W;</span><br></pre></td></tr></table></figure>\n<p>第二种思路是使用布尔 dp。我们需要重新考虑状态转移方程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">W</span> <span class=\"operator\">=</span> sum/<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"><span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[W+<span class=\"number\">1</span>][len+<span class=\"number\">1</span>];</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=W;i++)&#123; <span class=\"comment\">// 【注意】从0开始</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[j]&lt;=i)&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>] = dp[i][j]|dp[i-nums[j]][j];</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>]=dp[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[W][len];</span><br></pre></td></tr></table></figure>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/partition-equal-subset-sum/description/\">416. 分割等和子集 - 力扣（LeetCode）</a></li>\n</ul>\n<h2 id=\"完全背包问题\"><a class=\"markdownIt-Anchor\" href=\"#完全背包问题\"></a> 完全背包问题</h2>\n<blockquote>\n<p>特点：每个物品可以无限选用</p>\n</blockquote>\n<h3 id=\"变种-1存在最大容量-求最大价值\"><a class=\"markdownIt-Anchor\" href=\"#变种-1存在最大容量-求最大价值\"></a> 变种 1：存在最大容量 - 求最大价值</h3>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">完全背包问题案例</div>\n</div>\n<div class=\"callout-content\"><p>有编号分别为 a,b,c,d 的四件物品， 它们的重量分别是 2,3,4,7， 它们的价值分别是 1,3,5,9， 每件物品数量无限个， 现在给你个承重为 10 的背包， 如何让背包里装入的物品具有最大的价值总和？</p>\n</div></div><p>这里的模型为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>c</mi><mo>−</mo><mi>w</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mi>v</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dfs(i,c) = \\max (dfs(i-1,c),dfs(i,c-w[i])+v[i])\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>注意点：</p>\n<ul>\n<li>和 0-1 背包不一样的是，状态转移方程中再进行「选」处理时，<strong>考察的背包空间为 <code>i</code> 而不是 <code>i-1</code></strong>，这体现了完全背包的无限物品取用。</li>\n<li>不要尝试激进贪心，将状态方程转写为 <code>dfs(i,c) = max(dfs(i-1,c),dfs(i,c%w[i])+v[i]*c/w[i])</code>。这种方法可能会导致余数可能无法被其他物品组合，导致无效解，且不能保证所有可能的组合都被覆盖。</li>\n</ul>\n<h3 id=\"变种-2恰好装满容量-求方案数\"><a class=\"markdownIt-Anchor\" href=\"#变种-2恰好装满容量-求方案数\"></a> 变种 2：恰好装满容量 - 求方案数</h3>\n<p>二维 dp 示例写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"><span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>][len+<span class=\"number\">1</span>];</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 【不同方法】内外循环可以调换</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=W;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[j]&lt;=i)&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>] = dp[i][j]+dp[i-nums[j]][j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tdp[i][j+<span class=\"number\">1</span>] = dp[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[W][len];</span><br></pre></td></tr></table></figure>\n<p>一维 dp 示例写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"><span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>];</span><br><span class=\"line\">dp[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=nums[j];i&lt;=W;i++)&#123; <span class=\"comment\">// 【注意】内层循环为顺序遍历</span></span><br><span class=\"line\">\t\tdp[i] = dp[i]+dp[i-nums[j]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[W];</span><br></pre></td></tr></table></figure>\n<p>注意，完全背包问题使用 1 维 dp 数组时，内层循环只能使用<strong>顺序遍历</strong>！想要理解这个过程可以看后文我画的示意图。</p>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/coin-change-ii/description/\">518. 零钱兑换 II - 力扣（LeetCode）</a></li>\n</ul>\n<h3 id=\"变种-3恰好装-capacity求最小价值\"><a class=\"markdownIt-Anchor\" href=\"#变种-3恰好装-capacity求最小价值\"></a> 变种 3：恰好装 capacity，求最小价值</h3>\n<p>一维 dp 示例写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"><span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[W+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> W; <span class=\"comment\">// max 值为最大值。视题目而定，有时候是不可能的大值。</span></span><br><span class=\"line\">Arrays.fill(dp,max); <span class=\"comment\">// 【重要】初始化大值</span></span><br><span class=\"line\">dp[<span class=\"number\">0</span>]=<span class=\"number\">0</span>; <span class=\"comment\">// 【重要】含义为W=0时不需要任何物品，因此价值为0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=nums[j];i&lt;=W;i++)&#123;</span><br><span class=\"line\">\t\tdp[i] = Math.min(dp[i],dp[i-nums[j]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[W];</span><br></pre></td></tr></table></figure>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/coin-change/description/\">322. 零钱兑换 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/perfect-squares/\">279. 完全平方数 - 力扣（LeetCode）</a></li>\n</ul>\n<h2 id=\"分组背包问题\"><a class=\"markdownIt-Anchor\" href=\"#分组背包问题\"></a> 分组背包问题</h2>\n<p>给你 N 组物品，然后每一组你至多选择一个物品（也可以不选），每个物品都有自己的体积和价值，现在给你一个容里为 M 的背包，让你用这个背包装物品，使得物品价值总和最大。</p>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/\">1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）</a></li>\n</ul>\n<h2 id=\"依赖背包问题\"><a class=\"markdownIt-Anchor\" href=\"#依赖背包问题\"></a> 依赖背包问题</h2>\n<p>一棵树有 N 个节点，每一个节点放有一个物品，这些物品有自己的体积和价值。<strong>如果你要选择 v 节点的物品，那么必须先选择 v 的父亲节点上的物品（所谓的依赖关系）</strong>。现在你有容里为 M 的背包，问你选择物品的最大权值和是多少。</p>\n<h2 id=\"多重背包问题\"><a class=\"markdownIt-Anchor\" href=\"#多重背包问题\"></a> 多重背包问题</h2>\n<blockquote>\n<p>特点：每个物品都有一定的数量限制的选取。</p>\n</blockquote>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子</div>\n</div>\n<div class=\"callout-content\"><p>有编号分别为 a,b,c 的三件物品， 它们的重量分别是 1， 2， 2， 它们的价值分别是 6， 10， 20， 他们的数目分别是 10， 5， 2， 现在给你个承重为 8 的背包， 如何让背包里装入的物品具有最大的价值总和？</p>\n</div></div><p>相关题目：</p>\n<ul>\n<li>🟥 <a href=\"https://leetcode.cn/problems/number-of-ways-to-earn-points/description/\">2585. 获得分数的方法数 - 力扣（LeetCode）</a></li>\n</ul>\n<h2 id=\"分数背包问题零头背包\"><a class=\"markdownIt-Anchor\" href=\"#分数背包问题零头背包\"></a> 分数背包问题（零头背包）</h2>\n<p>有 n 个商品，第 i 个商品价值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 元，重 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 千克，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 都是整数。背包最多容纳 W 千克（整数）商品，对于每个商品，我们可以拿走其中一部分。我们需要拿走商品的总价值最高。</p>\n<p>贪心策略：尽量多的拿走每千克价值最高的商品。</p>\n<h1 id=\"总结动态规划中的背包问题\"><a class=\"markdownIt-Anchor\" href=\"#总结动态规划中的背包问题\"></a> 总结：动态规划中的背包问题</h1>\n<h2 id=\"dp-数组的压缩\"><a class=\"markdownIt-Anchor\" href=\"#dp-数组的压缩\"></a> DP 数组的压缩</h2>\n<p>当 dp 数组压缩为一维数组时，遍历顺序：</p>\n<ul>\n<li>0-1 背包为倒序遍历</li>\n<li>完全背包为正序遍历</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202505112146270.webp\" alt=\"image.png\" /></p>\n<h2 id=\"背包问题常见变形\"><a class=\"markdownIt-Anchor\" href=\"#背包问题常见变形\"></a> 背包问题常见变形</h2>\n<p>变形：</p>\n<ul>\n<li>至多装 capacity，求方案数/最大价值和</li>\n<li>恰好装 capacity，求方案数/最大/最小价值和</li>\n<li>至少装 capacity，求方案数/最小价值和</li>\n</ul>\n<p>递推公式中的符号问题：</p>\n<ul>\n<li>方案数：用加法（加法原理）</li>\n<li>最大最小值：用最大最小值函数</li>\n</ul>\n<h1 id=\"背包问题的解决方法\"><a class=\"markdownIt-Anchor\" href=\"#背包问题的解决方法\"></a> 背包问题的解决方法</h1>\n<p>解决方法有：</p>\n<ul>\n<li>动态规划</li>\n<li>贪心算法</li>\n<li>回溯法：先确定解空间的结构， 使用深度优先搜索， 搜索路径一般沿树形结构进行， 在搜索过程中， 首先会判断所搜索的树结点是否包含问题的解， 如果肯定不包含， 则不再搜索以该结点为根的树结点， 而向其祖先结点回溯； 否则进入该子树， 继续按深度优先策略搜索。运用回溯法解题通常包含以下三个步骤：\n<ol>\n<li>针对所给问题， 定义问题的解空间；</li>\n<li>确定易于搜索的解空间结构；</li>\n<li>以深度优先的方式搜索解空间， 并且在搜索过程中用剪枝函数避免无效搜索；</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>分支限界法：分支限界法类似于回溯法，也是在问题的解空间上搜索问题解的算法。分支限界法首先要确定一个合理的限界函数（bound funciton），并根据限界函数确定目标函数的界 <code>[down ,up]</code>，按照广度优先策略或以最小耗费优先搜索问题的解空间树，在分支结点上依次扩展该结点的孩子结点，分别估算孩子结点的目标函数可能值，如果某孩子结点的目标函数可能超出目标函数的界，则将其丢弃；否则将其加入待处理结点表（简称 PT 表），依次从表 PT 中选取使目标函数取得极值的结点成为当前扩展结点，重复上述过程，直到得到最优解。常见的两种分枝限界法包含队列式（FIFO）分支限界法和优先队列式分支限界法。</li>\n</ul>\n\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">【待理解与整理】用分支限界法解决 0-1 背包问题</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202505112318460.webp\" alt=\"image.png\" width=\"475px\" /><br />\n假设比值 pi/wi 最大的物品序号为 s（s ∈ S3），按照价值重量比递减排序后，s 就是集合 S3(k) 中的第一个元素。用 s 进行分支，一个分支结点表示把 s 装入背包，另一个分支结点表示不把 s 装入背包。<br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202505112319380.webp\" alt=\"image.png\" width=\"266px\" /></p>\n<ol>\n<li>设置上界估算方法 b(k)<br />\n假定 b(k) 表示在搜索深度为 k 时，某个分支结点的背包中商品的价值上界。此时 S3(k) = {k, k+1, …, n-1}。<br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202505112320992.webp\" alt=\"image.png\" width=\"450px\" /></li>\n<li>利用分支限界法求解：<br />\n第一步，初始化 bound = 0，把物品按价值重量比递减排序，建立根节点 X；<br />\n第二步，建立新结点，计算新结点的上界，与 bound 进行比较，据此判定是否插入优先队列，直到当前尚待选择的物品集合为空时，找到一个可行解，判定是否更新 bound；<br />\n第三步，同样操作建立另外一个新结点 Z；第四步，取出优先队列首元素作为根结点 X，第四步，如此往复直到搜索深度为所有物品数量为止。</li>\n</ol>\n</div></details><h1 id=\"后续计划\"><a class=\"markdownIt-Anchor\" href=\"#后续计划\"></a> 后续计划</h1>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 处理文中分支限界法解决 0-1 背包问题</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>我的笔记</li>\n<li>《算法导论》动态规划、贪心策略部分解耦</li>\n<li>研究生课程《算法设计与分析》实验五：0-1 背包问题的算法设计</li>\n<li><a href=\"https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=e03d48176855fc5349b27aef691f9cdb\">0-1背包 完全背包【基础算法精讲 18】_哔哩哔哩_bilibili</a></li>\n<li><a href=\"https://blog.csdn.net/TheWayForDream/article/details/116567088\">背包问题----分组背包(超详细讲解)-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/txl199106/article/details/45869557\">0-1背包详解-CSDN博客</a></li>\n<li><a href=\"https://www.jianshu.com/p/c738c8262087\">分支限界法——对解空间的一种策略搜索（广度优先搜索） - 简书</a></li>\n</ul>\n","raw":"---\ntitle: 背包问题\ntags:\n  - 动态规划\n  - Java\n  - LeetCode\ncover: 'https://cdn.gallery.uuanqin.top/img/202503100338306.webp'\ndescription: 背包问题集合\ncategories:\n  - 算法与数据结构\nabbrlink: 29e8dd2d\nkatex: true\ndate: 2025-05-11 23:23:29\ntop_img:\n---\n\n背包问题已经是一个很经典而且讨论很广泛的算法问题了。\n\n背包问题泛指这类种问题： 给定一组有固定价值和固定重量的物品， 以及一个已知最大承重量的背包， 求在不超过背包最大承重量的前提下， 能放进背包里面的物品的最大总价值。\n\n具体各类背包问题可以分成以下不同的子问题。\n\n# 不同的背包问题\n\n## 0-1 背包问题\n\n> 特点：每个物品只有一件，选择放或者不放。\n\n### 变形 1：存在最大容量 - 求最大价值\n\n> [!example] 0-1 背包问题案例：🟨 [125 · 背包问题（二） - LintCode](https://www.lintcode.com/problem/125/description)\n>\n> 有 n 个商品，第 i 个商品价值 $v_i$ 元，重 $w_i$ 千克，$v_i$ 和 $w_i$ 都是整数。背包最多容纳 W 千克（整数）商品，**每个商品要么全拿走，要么不拿走**，我们需要拿走商品的总价值最高。\n\n`dp[i][j]` 表示前 i 个商品在 j 空间下的最优选择的价值。\n\n这里的模型为：\n\n$$\ndfs(i,c) = \\max (dfs(i-1,c),dfs(i-1,c-w[i])+v[i])\n$$\n\n我们可以使用动态规划算法：\n\n```java\n// 给定数组 `a` 表示每个物品的大小和数组 `v` 表示每个物品的价值.\npublic int backPackII(int W, int[] a, int[] v) {\n\tint len = a.length;\n\t// 数组dp[i][j]表示从前i件物品选体积不超过j的物品最大价值\n\tint[][] dp = new int[W+1][len+1]; // 初始化其首行首列的值为0\n\t// 【不同写法】内外循环是可以调换的\n\tfor(int i=1;i<=W;i++){            // 【高效】从1开始。从0也行，但低效\n\t\tfor(int j=0;j<len;j++){       // 【不同写法】可以从0或从1开始\n\t\t\tif(a[j]<=i){\n\t\t\t\tdp[i][j+1] = Math.max(dp[i][j],dp[i-a[j]][j]+v[j]);\n\t\t\t}else{\n\t\t\t\tdp[i][j+1] = dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[W][len];\n}\n```\n\n复杂度分析：\n\n- 时间复杂度： $O(nW)$。\n- 空间复杂度： $O(nW)$。\n\n> [!note] 不同循环写法的优劣\n>\n> 问：两层循环有两种写法，一种是外层循环枚举物品，内层循环枚举体积；另一种是外层循环枚举体积，内层循环枚举物品。如何评价这两种写法的优劣？\n>\n> 答：两种写法都可以，但更推荐前者。外层循环枚举物品的写法，只会遍历物品数组一次；而内层循环枚举物品的写法，会遍历物品数组多次。从 cache 的角度分析，多次遍历数组会导致额外的 cache miss，带来额外的开销。所以虽然这两种写法的时间空间复杂度是一样的，但外层循环枚举物品的写法常数更小。\n\n滚动数组优化空间复杂度至 $2*W$：\n\n```java\npublic int backPackII(int W, int[] a, int[] v) {\n\tint len = a.length;\n\tint[][] dp = new int[W+1][2];\n\tfor(int j=0;j<len;j++){\n\t\tfor(int i=1;i<=W;i++){   // 【不同写法】此处循环可以正序或者逆序\n\t\t\tif(a[j]<=i){\n\t\t\t\tdp[i][(j+1)%2] = Math.max(dp[i][j%2],dp[i-a[j]][j%2]+v[j]);\n\t\t\t}else{\n\t\t\t\tdp[i][(j+1)%2] = dp[i][j%2];\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[W][len%2];\n}\n```\n\n复杂度分析：\n\n- 时间复杂度： $O(nW)$。\n- 空间复杂度： $O(W)$。\n\n注意到，对于物品空间的遍历（也就是上面代码的内层循环），循环顺序不影响结果。我们可以进一步考虑只使用一维 `dp` 数组。\n\n```java\npublic int backPackII(int W, int[] a, int[] v) {\n\tint len = a.length;\n\tint[] dp = new int[W+1];\n\tfor(int j=0;j<len;j++){\n\t\tfor(int i=W;i>=0;i--){\n\t\t\t// 【优化点】if-else语句可优化\n\t\t\tif(a[j]<=i){\n\t\t\t\tdp[i] = Math.max(dp[i],dp[i-a[j]]+v[j]);\n\t\t\t}else{\n\t\t\t\tdp[i] = dp[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[W];\n}\n```\n\n注意，0-1 背包使用一维数组时，内层循环只能**逆序遍历**！逆序遍历时，新值取自上一轮的旧值，所以不会有什么影响。\n\n对 if-else 语句进行优化，得到最终的 0-1 背包一维数组写法：\n\n```java\npublic int backPackII(int W, int[] a, int[] v) {\n\tint len = a.length;\n\tint[] dp = new int[W+1];\n\tfor(int j=0;j<len;j++){\n\t\tfor(int i=W;i>=a[j];i--){\n\t\t\tdp[i] = Math.max(dp[i],dp[i-a[j]]+v[j]);\n\t\t}\n\t}\n\treturn dp[W];\n}\n```\n\n复杂度分析：\n\n- 时间复杂度： $O(nW)$。\n- 空间复杂度： $O(W)$。\n\n相关题目：\n\n- 🟨 [474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/) 二维背包\n- 🟨[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)\n\n### 变形 2：恰好装满容量 - 求方案数\n\n如果题目要求背包恰好装满，求方案数，这时 dp 边界条件和状态转移公式有些许不同。这里展示最普通的二维数组写法。一维数组写法可自行尝试。\n\n```java\nint[][] dp  = new int[W+1][nums.length+1];\ndp[0][0]=1; // 边界条件\nfor(int i=0;i<=W;i++){ //【注意】强烈建议从0开始\n\tfor(int j=0;j<nums.length;j++){\n\t\tif(i>=nums[j]){\n\t\t\tdp[i][j+1] = dp[i][j]+dp[i-nums[j]][j];\n\t\t}else{\n\t\t\tdp[i][j+1] = dp[i][j];\n\t\t}\n\t}\n}\n```\n\n有时候，给定的物品中会存在重量为 0 的物品，这时候外层循环中一定要从 0 开始。\n\n相关题目：\n\n- 🟨 [494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)\n- 🟥 [LCP 47. 入场安检 - 力扣（LeetCode）](https://leetcode.cn/problems/oPs9Bm/description/)\n\n### 变形 3：恰好装满容量 - 求可行性\n\n假设题目要求我们回答给定的物品能否在指定的空间 W 恰好装满，我们可以有两种方式思考。\n\n第一种思路是，将题目转变为「变形 1：存在最大容量 - 求最大价值」，最后判断一下最大价值是否是最大容量即可。\n\n```java\nint W = sum/2;\nint len = nums.length;\nint[][] dp = new int[W+1][len+1];\nfor(int i=1;i<=W;i++){\n\tfor(int j=0;j<len;j++){\n\t\tif(nums[j]<=i){\n\t\t\tdp[i][j+1] = Math.max(dp[i][j],dp[i-nums[j]][j]+nums[j]);\n\t\t}else{\n\t\t\tdp[i][j+1]=dp[i][j];\n\t\t}\n\t}\n}\nreturn dp[W][len]==W;\n```\n\n第二种思路是使用布尔 dp。我们需要重新考虑状态转移方程。\n\n```java\nint W = sum/2;\nint len = nums.length;\nboolean[][] dp = new boolean[W+1][len+1];\ndp[0][0]=true;\nfor(int i=0;i<=W;i++){ // 【注意】从0开始\n\tfor(int j=0;j<len;j++){\n\t\tif(nums[j]<=i){\n\t\t\tdp[i][j+1] = dp[i][j]|dp[i-nums[j]][j];\n\t\t}else{\n\t\t\tdp[i][j+1]=dp[i][j];\n\t\t}\n\t}\n}\nreturn dp[W][len];\n```\n\n相关题目：\n\n- 🟨 [416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)\n\n## 完全背包问题\n\n> 特点：每个物品可以无限选用\n\n### 变种 1：存在最大容量 - 求最大价值\n\n> [!example] 完全背包问题案例\n> 有编号分别为 a,b,c,d 的四件物品， 它们的重量分别是 2,3,4,7， 它们的价值分别是 1,3,5,9， 每件物品数量无限个， 现在给你个承重为 10 的背包， 如何让背包里装入的物品具有最大的价值总和？\n\n这里的模型为：\n\n$$\ndfs(i,c) = \\max (dfs(i-1,c),dfs(i,c-w[i])+v[i])\n$$\n\n注意点：\n\n- 和 0-1 背包不一样的是，状态转移方程中再进行「选」处理时，**考察的背包空间为 `i` 而不是 `i-1`**，这体现了完全背包的无限物品取用。\n- 不要尝试激进贪心，将状态方程转写为 `dfs(i,c) = max(dfs(i-1,c),dfs(i,c%w[i])+v[i]*c/w[i])`。这种方法可能会导致余数可能无法被其他物品组合，导致无效解，且不能保证所有可能的组合都被覆盖。\n\n### 变种 2：恰好装满容量 - 求方案数\n\n二维 dp 示例写法：\n\n```java\nint len = nums.length;\nint[][] dp = new int[W+1][len+1];\ndp[0][0]=1;\n// 【不同方法】内外循环可以调换\nfor(int i=0;i<=W;i++){\n\tfor(int j=0;j<len;j++){\n\t\tif(nums[j]<=i){\n\t\t\tdp[i][j+1] = dp[i][j]+dp[i-nums[j]][j+1];\n\t\t}else{\n\t\t\tdp[i][j+1] = dp[i][j];\n\t\t}\n\t}\n}\nreturn dp[W][len];\n```\n\n一维 dp 示例写法：\n\n```java\nint len = nums.length;\nint[] dp = new int[W+1];\ndp[0]=1;\nfor(int j=0;j<len;j++){\n\tfor(int i=nums[j];i<=W;i++){ // 【注意】内层循环为顺序遍历\n\t\tdp[i] = dp[i]+dp[i-nums[j]];\n\t}\n}\nreturn dp[W];\n```\n\n注意，完全背包问题使用 1 维 dp 数组时，内层循环只能使用**顺序遍历**！想要理解这个过程可以看后文我画的示意图。\n\n相关题目：\n\n- 🟨 [518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/description/)\n\n### 变种 3：恰好装 capacity，求最小价值\n\n一维 dp 示例写法：\n\n```java\nint len = nums.length;\nint[] dp = new int[W+1];\nint max = W; // max 值为最大值。视题目而定，有时候是不可能的大值。\nArrays.fill(dp,max); // 【重要】初始化大值\ndp[0]=0; // 【重要】含义为W=0时不需要任何物品，因此价值为0\nfor(int j=0;j<len;j++){\n\tfor(int i=nums[j];i<=W;i++){\n\t\tdp[i] = Math.min(dp[i],dp[i-nums[j]]+1);\n\t}\n}\nreturn dp[W];\n```\n\n相关题目：\n\n- 🟨 [322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/)\n- 🟨 [279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/)\n\n## 分组背包问题\n\n给你 N 组物品，然后每一组你至多选择一个物品（也可以不选），每个物品都有自己的体积和价值，现在给你一个容里为 M 的背包，让你用这个背包装物品，使得物品价值总和最大。\n\n相关题目：\n\n- 🟨 [1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/)\n\n## 依赖背包问题\n\n一棵树有 N 个节点，每一个节点放有一个物品，这些物品有自己的体积和价值。**如果你要选择 v 节点的物品，那么必须先选择 v 的父亲节点上的物品（所谓的依赖关系）**。现在你有容里为 M 的背包，问你选择物品的最大权值和是多少。\n\n## 多重背包问题\n\n> 特点：每个物品都有一定的数量限制的选取。\n\n> [!example] 例子\n> 有编号分别为 a,b,c 的三件物品， 它们的重量分别是 1， 2， 2， 它们的价值分别是 6， 10， 20， 他们的数目分别是 10， 5， 2， 现在给你个承重为 8 的背包， 如何让背包里装入的物品具有最大的价值总和？\n\n相关题目：\n\n- 🟥 [2585. 获得分数的方法数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-ways-to-earn-points/description/)\n\n## 分数背包问题（零头背包）\n\n有 n 个商品，第 i 个商品价值 $v_i$ 元，重 $w_i$ 千克，$v_i$ 和 $w_i$ 都是整数。背包最多容纳 W 千克（整数）商品，对于每个商品，我们可以拿走其中一部分。我们需要拿走商品的总价值最高。\n\n贪心策略：尽量多的拿走每千克价值最高的商品。\n\n# 总结：动态规划中的背包问题\n\n## DP 数组的压缩\n\n当 dp 数组压缩为一维数组时，遍历顺序：\n\n- 0-1 背包为倒序遍历\n- 完全背包为正序遍历\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202505112146270.webp)\n\n## 背包问题常见变形\n\n变形：\n\n- 至多装 capacity，求方案数/最大价值和\n- 恰好装 capacity，求方案数/最大/最小价值和\n- 至少装 capacity，求方案数/最小价值和\n\n递推公式中的符号问题：\n\n- 方案数：用加法（加法原理）\n- 最大最小值：用最大最小值函数\n\n# 背包问题的解决方法\n\n解决方法有：\n\n* 动态规划\n* 贪心算法\n* 回溯法：先确定解空间的结构， 使用深度优先搜索， 搜索路径一般沿树形结构进行， 在搜索过程中， 首先会判断所搜索的树结点是否包含问题的解， 如果肯定不包含， 则不再搜索以该结点为根的树结点， 而向其祖先结点回溯； 否则进入该子树， 继续按深度优先策略搜索。运用回溯法解题通常包含以下三个步骤：\n\t1. 针对所给问题， 定义问题的解空间；\n\t2. 确定易于搜索的解空间结构；\n\t3. 以深度优先的方式搜索解空间， 并且在搜索过程中用剪枝函数避免无效搜索；\n- 分支限界法：分支限界法类似于回溯法，也是在问题的解空间上搜索问题解的算法。分支限界法首先要确定一个合理的限界函数（bound funciton），并根据限界函数确定目标函数的界 `[down ,up]`，按照广度优先策略或以最小耗费优先搜索问题的解空间树，在分支结点上依次扩展该结点的孩子结点，分别估算孩子结点的目标函数可能值，如果某孩子结点的目标函数可能超出目标函数的界，则将其丢弃；否则将其加入待处理结点表（简称 PT 表），依次从表 PT 中选取使目标函数取得极值的结点成为当前扩展结点，重复上述过程，直到得到最优解。常见的两种分枝限界法包含队列式（FIFO）分支限界法和优先队列式分支限界法。\n\n> [!note]- 【待理解与整理】用分支限界法解决 0-1 背包问题\n> ![image.png|475](https://cdn.gallery.uuanqin.top/img/202505112318460.webp)\n> 假设比值 pi/wi 最大的物品序号为 s（s ∈ S3），按照价值重量比递减排序后，s 就是集合 S3(k) 中的第一个元素。用 s 进行分支，一个分支结点表示把 s 装入背包，另一个分支结点表示不把 s 装入背包。\n> ![image.png|266](https://cdn.gallery.uuanqin.top/img/202505112319380.webp)\n> 1. 设置上界估算方法 b(k)\n> 假定 b(k) 表示在搜索深度为 k 时，某个分支结点的背包中商品的价值上界。此时 S3(k) = {k, k+1, ..., n-1}。\n> ![image.png|450](https://cdn.gallery.uuanqin.top/img/202505112320992.webp)\n> 2. 利用分支限界法求解：\n> 第一步，初始化 bound = 0，把物品按价值重量比递减排序，建立根节点 X；\n> 第二步，建立新结点，计算新结点的上界，与 bound 进行比较，据此判定是否插入优先队列，直到当前尚待选择的物品集合为空时，找到一个可行解，判定是否更新 bound；\n> 第三步，同样操作建立另外一个新结点 Z；第四步，取出优先队列首元素作为根结点 X，第四步，如此往复直到搜索深度为所有物品数量为止。\n\n# 后续计划\n\n- [ ] 处理文中分支限界法解决 0-1 背包问题\n\n# 本文参考\n\n- 我的笔记\n- 《算法导论》动态规划、贪心策略部分解耦\n- 研究生课程《算法设计与分析》实验五：0-1 背包问题的算法设计\n- [0-1背包 完全背包【基础算法精讲 18】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=e03d48176855fc5349b27aef691f9cdb)\n- [背包问题----分组背包(超详细讲解)-CSDN博客](https://blog.csdn.net/TheWayForDream/article/details/116567088)\n- [0-1背包详解-CSDN博客](https://blog.csdn.net/txl199106/article/details/45869557)\n- [分支限界法——对解空间的一种策略搜索（广度优先搜索） - 简书](https://www.jianshu.com/p/c738c8262087)","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"动态规划","api":"api/tags/动态规划.json"}]},"api":"api/posts/p/29e8dd2d.json"}