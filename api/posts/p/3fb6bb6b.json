{"data":{"title":"以作为答案边界的方式理解双指针","slug":"算法与数据结构/以作为答案边界的方式理解双指针","description":"这样就能放心移动指针了","date":"2024-10-01T10:58:55.000Z","updated":"2025-09-26T16:05:50.915Z","language":"zh-CN","comments":true,"url":"p/3fb6bb6b/","cover":"https://cdn.gallery.uuanqin.top/img/202409231544166.webp","images":[],"content":"<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"热身从两数之和问题铺垫\"><a class=\"markdownIt-Anchor\" href=\"#热身从两数之和问题铺垫\"></a> 热身：从「两数之和」问题铺垫</h1>\n<p>「两数之和」在 LeetCode 编号为 1，是题库的第一道题目。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟩 <a href=\"https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked\">1. 两数之和 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code> 的那 两个 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>\n<p>你可以按任意顺序返回答案。</p>\n</div></div><p>暴力方法：最容易想到的方法，枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>哈希表：使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> 降低到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 地寻找 target - x。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，其中 N 是数组中的元素数量。主要为哈希表的开销。</li>\n</ul>\n<h1 id=\"排序-双指针\"><a class=\"markdownIt-Anchor\" href=\"#排序-双指针\"></a> 排序 + 双指针</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/\">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个下标从 1 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序</strong> 排列  ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>\n<p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 index1 和 index2。</p>\n<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>\n<p>你所设计的解决方案必须只使用常量级的额外空间。</p>\n</div></div><p>我们可以使用上题「两数之和」中的方法解决，但是这道题的特点在于输入是一个<strong>有序的数组</strong>，我们可以利用这一点进行方法优化。官方解法有以下两种：</p>\n<ul>\n<li>二分查找：首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，寻找第二个数使用二分查找，时间复杂度是 O(\\log n)，因此总时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n</li>\n<li>双指针</li>\n</ul>\n<p>下面主要介绍双指针方法。</p>\n<p>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。</p>\n<ul>\n<li>如果两个元素之和等于目标值，则发现了唯一解。</li>\n<li>如果两个元素之和小于目标值，则将左侧指针右移一位。</li>\n<li>如果两个元素之和大于目标值，则将右侧指针左移一位。</li>\n<li>移动指针之后，重复上述操作，直到找到答案。</li>\n</ul>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<h2 id=\"双指针的理解\"><a class=\"markdownIt-Anchor\" href=\"#双指针的理解\"></a> 双指针的理解</h2>\n<p>那么上面双指针会不会把可能的解过滤掉？答案是不会。「两数之和 II」中明确表示只存在<strong>唯一的答案</strong>。</p>\n<h3 id=\"理解方式-1抓住了答案后不会错过\"><a class=\"markdownIt-Anchor\" href=\"#理解方式-1抓住了答案后不会错过\"></a> 理解方式 1：抓住了答案后不会错过</h3>\n<p>假设 <code>numbers[i]+numbers[j]==target</code> 是唯一解，其中 <code>0≤i&lt;j≤numbers.length−1</code>。初始时两个指针分别指向下标 <code>0</code> 和下标 <code>numbers.length−1</code>，左指针指向的下标小于或等于 i，右指针指向的下标大于或等于 j。除非初始时左指针和右指针已经位于下标 i 和 j，否则一定是左指针先到达下标 i 的位置或者右指针先到达下标 j 的位置。</p>\n<ul>\n<li>如果左指针先到达下标 i 的位置，此时右指针还在下标 j 的右侧，<code>sum&gt;target</code>，因此一定是右指针左移，左指针不可能移到 i 的右侧。</li>\n<li>如果右指针先到达下标 j 的位置，此时左指针还在下标 i 的左侧，<code>sum&lt;target</code>，因此一定是左指针右移，右指针不可能移到 j 的左侧。</li>\n</ul>\n<p>因此使用双指针一定可以找到答案。</p>\n<h3 id=\"理解方式-2双指针是答案的边界\"><a class=\"markdownIt-Anchor\" href=\"#理解方式-2双指针是答案的边界\"></a> 理解方式 2：双指针是答案的边界</h3>\n<p>双指针还可以这样理解：双指针指示的范围表示答案可能出现的范围。</p>\n<ul>\n<li>计算两个指针 <code>left</code>、<code>right</code> 指向的两个元素之和 <code>nums[left]+nums[right]</code>，如果两个元素之和等于目标值，则发现了唯一解。</li>\n<li>如果两个元素之和小于目标值 <code>nums[left]+nums[right]&lt;target</code>，说明左侧指针指向的值 <code>nums[left]</code> 不可能作为答案。因为 <code>nums[left]</code> 和答案范围内所有其他的数相加，总会有 <code>nums[left]+nums[k]&lt;target</code>，<code>left&lt;k&lt;right</code>，因此需要将左侧指针右移一位，缩短答案范围。</li>\n<li>如果两个元素之和大于目标值，则将右侧指针左移一位。原因同上。</li>\n<li>当左右指针正好指向正确答案时返回结果即可。</li>\n</ul>\n<p>回过头看看最初的「两数之和」问题，其实它也可以用双指针的问题解决，只不过需要额外进行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 排序。</p>\n<h1 id=\"相关题目\"><a class=\"markdownIt-Anchor\" href=\"#相关题目\"></a> 相关题目</h1>\n<p>类似题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/max-number-of-k-sum-pairs/description/?envType=problem-list-v2&amp;envId=two-pointers\">1679. K 和数对的最大数目 - 力扣（LeetCode）</a></li>\n</ul>\n<p>可能的答案不止一个，且要求答案不得重复，这就需要考虑移动指针或遍历元素时跳过重复出现的元素：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/3sum/description/\">15. 三数之和 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/4sum/description/\">18. 四数之和 - 力扣（LeetCode）</a></li>\n</ul>\n<p>寻找最接近答案的目标的组合，这意味着双指针需要遍历完所有的元素找到最接近的答案的组合：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/container-with-most-water/description/\">11. 盛最多水的容器 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/3sum-closest/description/\">16. 最接近的三数之和 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>LeetCode 相关题解</li>\n</ul>\n","raw":"---\ntitle: 以作为答案边界的方式理解双指针\ntags:\n  - LeetCode\n  - Java\n  - 双指针\n  - 贪心\ncover: 'https://cdn.gallery.uuanqin.top/img/202409231544166.webp'\ndescription: 这样就能放心移动指针了\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: 3fb6bb6b\ndate: 2024-10-01 18:58:55\ntop_img:\n---\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 热身：从「两数之和」问题铺垫\n\n「两数之和」在 LeetCode 编号为 1，是题库的第一道题目。\n\n> [!example] 题目：🟩 [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 `target` 的那 两个 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n>\n> 你可以按任意顺序返回答案。\n\n暴力方法：最容易想到的方法，枚举数组中的每一个数 `x`，寻找数组中是否存在 `target - x`。\n\n- 时间复杂度：$O(N^2)$，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n- 空间复杂度：$O(1)$。\n\n哈希表：使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 $O(N)$ 降低到 $O(1)$。\n\n- 时间复杂度：$O(N)$，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 $O(1)$ 地寻找 target - x。\n- 空间复杂度：$O(N)$，其中 N 是数组中的元素数量。主要为哈希表的开销。\n\n# 排序 + 双指针\n\n> [!example] 题目：🟨 [167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)\n> 给你一个下标从 1 开始的整数数组 `numbers` ，该数组已按 **非递减顺序** 排列  ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。\n>\n> 以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 index1 和 index2。\n>\n> 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n>\n> 你所设计的解决方案必须只使用常量级的额外空间。\n\n我们可以使用上题「两数之和」中的方法解决，但是这道题的特点在于输入是一个**有序的数组**，我们可以利用这一点进行方法优化。官方解法有以下两种：\n\n- 二分查找：首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。\n\t- 时间复杂度：$O(n\\log n)$，其中 n 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 $O(n)$，寻找第二个数使用二分查找，时间复杂度是 O(\\log n)，因此总时间复杂度是 $O(n\\log n)$。\n\t- 空间复杂度：$O(1)$。\n- 双指针\n\n下面主要介绍双指针方法。\n\n初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。\n\n- 如果两个元素之和等于目标值，则发现了唯一解。\n- 如果两个元素之和小于目标值，则将左侧指针右移一位。\n- 如果两个元素之和大于目标值，则将右侧指针左移一位。\n- 移动指针之后，重复上述操作，直到找到答案。\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。\n- 空间复杂度：$O(1)$。\n\n## 双指针的理解\n\n那么上面双指针会不会把可能的解过滤掉？答案是不会。「两数之和 II」中明确表示只存在**唯一的答案**。\n\n### 理解方式 1：抓住了答案后不会错过\n\n假设 `numbers[i]+numbers[j]==target` 是唯一解，其中 `0≤i<j≤numbers.length−1`。初始时两个指针分别指向下标 `0` 和下标 `numbers.length−1`，左指针指向的下标小于或等于 i，右指针指向的下标大于或等于 j。除非初始时左指针和右指针已经位于下标 i 和 j，否则一定是左指针先到达下标 i 的位置或者右指针先到达下标 j 的位置。\n\n- 如果左指针先到达下标 i 的位置，此时右指针还在下标 j 的右侧，`sum>target`，因此一定是右指针左移，左指针不可能移到 i 的右侧。\n- 如果右指针先到达下标 j 的位置，此时左指针还在下标 i 的左侧，`sum<target`，因此一定是左指针右移，右指针不可能移到 j 的左侧。\n\n因此使用双指针一定可以找到答案。\n\n### 理解方式 2：双指针是答案的边界\n\n双指针还可以这样理解：双指针指示的范围表示答案可能出现的范围。\n\n- 计算两个指针 `left`、`right` 指向的两个元素之和 `nums[left]+nums[right]`，如果两个元素之和等于目标值，则发现了唯一解。\n- 如果两个元素之和小于目标值 `nums[left]+nums[right]<target`，说明左侧指针指向的值 `nums[left]` 不可能作为答案。因为 `nums[left]` 和答案范围内所有其他的数相加，总会有 `nums[left]+nums[k]<target`，`left<k<right`，因此需要将左侧指针右移一位，缩短答案范围。\n- 如果两个元素之和大于目标值，则将右侧指针左移一位。原因同上。\n- 当左右指针正好指向正确答案时返回结果即可。\n\n回过头看看最初的「两数之和」问题，其实它也可以用双指针的问题解决，只不过需要额外进行 $O(n \\log n)$ 排序。\n\n# 相关题目\n\n类似题目：\n\n- 🟨 [1679. K 和数对的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/max-number-of-k-sum-pairs/description/?envType=problem-list-v2&envId=two-pointers)\n\n可能的答案不止一个，且要求答案不得重复，这就需要考虑移动指针或遍历元素时跳过重复出现的元素：\n\n- 🟨 [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)\n- 🟨 [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)\n\n寻找最接近答案的目标的组合，这意味着双指针需要遍历完所有的元素找到最接近的答案的组合：\n\n- 🟨 [11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/)\n- 🟨 [16. 最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/description/)\n\n# 本文参考\n- LeetCode 相关题解\n\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"双指针","api":"api/tags/双指针.json"},{"name":"贪心","api":"api/tags/贪心.json"}]},"api":"api/posts/p/3fb6bb6b.json"}