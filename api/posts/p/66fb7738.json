{"data":{"title":"不得不和哈希打交道","slug":"算法与数据结构/不得不和哈希打交道","description":"记录一些用过的哈希技巧","date":"2024-10-01T16:03:13.000Z","updated":"2025-09-27T08:52:35.242Z","language":"zh-CN","comments":true,"url":"p/66fb7738/","cover":"https://cdn.gallery.uuanqin.top/img/202509222214661.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><code>250922</code> 文章部分内容解耦自 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/182af697/\"><span class=\"bilink-pop-up\">站内文章</span>Java 集合的使用</a>。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>本文主要记录一些在刷题时常用到的哈希技巧：</p>\n<ol>\n<li>多元组作为键进行存储的思路</li>\n<li>离散化技巧</li>\n<li>写一个粗糙的哈希</li>\n</ol>\n<p>关于 Java 集合的使用详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/182af697/\"><span class=\"bilink-pop-up\">站内文章</span>Java 集合的使用</a>。</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"多元组作为哈希表的键\"><a class=\"markdownIt-Anchor\" href=\"#多元组作为哈希表的键\"></a> 多元组作为哈希表的键</h1>\n<p>有时候我们需要在集合中存储一个元素的二维坐标，我们不需要自己定义二元组存储，我们可以：</p>\n<ul>\n<li>只存储第几个格子即可：<code>i*n+j</code></li>\n<li>将各种参数组合成独一无二的 <code>String</code> 来作为 Key：<code>&quot;12,23,24&quot;</code> 或 <code>&quot;a=1,b=2,c=3&quot;</code>。如需分离，可使用 <code>string.split(regex)</code> 函数进行分离。</li>\n</ul>\n<h1 id=\"离散化\"><a class=\"markdownIt-Anchor\" href=\"#离散化\"></a> 离散化</h1>\n<p>离散化是一种数据处理的技巧，本质上可以看成是一种哈希，其保证数据在哈希以后仍然保持原来的全/偏序关系。</p>\n<p>通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。</p>\n<p>被离散化的可以是大整数、浮点数、字符串等等。</p>\n\n<details class=\"callout\" data-callout=\"note\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">偏序与全序</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>设 R 为非空集合 S 上的关系，如果 R 是自反、反对称和传递的关系，则称 R 为 S 上的偏序关系，简称<strong>偏序</strong>，记作 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding=\"application/x-tex\">\\preceq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⪯</span></span></span></span>。「大于或等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo></mrow><annotation encoding=\"application/x-tex\">\\ge</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≥</span></span></span></span>」关系是整数集合上的偏序。</p>\n<p>如果 a<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding=\"application/x-tex\">\\preceq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⪯</span></span></span></span>b 或 b<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding=\"application/x-tex\">\\preceq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⪯</span></span></span></span>a，偏序集&lt;S,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding=\"application/x-tex\">\\preceq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⪯</span></span></span></span>&gt;中的元素 a 和 b 称为<strong>可比</strong>的。</p>\n<p>如果&lt;S,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding=\"application/x-tex\">\\preceq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⪯</span></span></span></span>&gt;是偏序集，且 S 中的每对都是可比的，则 S 称为全序集或线序集，且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding=\"application/x-tex\">\\preceq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⪯</span></span></span></span> 称为<strong>全序</strong>或线序。</p>\n<p>简单来说，离散化后的数，它们之间的大小关系不变。</p>\n</div></details>\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">离散化案例</div>\n</div>\n<div class=\"callout-content\"><p>例 1：<code>100 200 300 200 100 200</code><br />\n离散化：<code>1 2 3 2 1 2</code></p>\n<p>例 2：<code>123456 123456 123456</code><br />\n离散化：<code>1 1 1</code></p>\n</div></div><p>相关题目：</p>\n<ul>\n<li>🟩 <a href=\"https://www.luogu.com.cn/problem/U232423\">U232423 【模板】离散化 - 洛谷</a>：离散化模板题</li>\n</ul>\n<h2 id=\"实现方式\"><a class=\"markdownIt-Anchor\" href=\"#实现方式\"></a> 实现方式</h2>\n<h3 id=\"相同的元素离散化为相同的数据\"><a class=\"markdownIt-Anchor\" href=\"#相同的元素离散化为相同的数据\"></a> 相同的元素离散化为相同的数据</h3>\n<p>通常原数组中会有重复的元素，一般把相同的元素离散化为相同的数据。</p>\n<p>方法：</p>\n<ol>\n<li>创建原数组的副本。</li>\n<li>将副本中的值从小到大排序。</li>\n<li>将排序好的副本去重。</li>\n<li>查找原数组的每一个元素在副本中的位置，位置即为排名，将其作为离散化后的值。</li>\n</ol>\n<p>基本功练习：</p>\n<ul>\n<li>🟩 <a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array/\">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a>：题目条件苛刻的时候离散化需要原地去重</li>\n<li>🟩 <a href=\"https://leetcode.cn/problems/binary-search/description/\">704. 二分查找 - 力扣（LeetCode）</a>：二分查找算法练习。推荐看这篇：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/817735b/\"><span class=\"bilink-pop-up\">站内文章</span>为什么二分查找总是写不对？</a></li>\n</ul>\n<p>参考实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">long</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">long</span>[n];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            arr[i] = in.nextLong();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span>[] dup = Arrays.copyOf(arr, n);</span><br><span class=\"line\">        Arrays.sort(dup);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> unique(dup);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">long</span> e: arr) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> b(m, dup, e);</span><br><span class=\"line\">            System.out.print((ans + <span class=\"number\">1</span>) + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 二分查找</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">b</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">long</span>[] nums, <span class=\"type\">long</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            mid = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == nums[mid]) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k &lt; nums[mid]) &#123;</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 有序数组去重</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unique</span><span class=\"params\">(<span class=\"type\">long</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] != nums[j]) &#123;</span><br><span class=\"line\">                nums[i] = nums[j];</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相同的元素根据输入顺序离散化为不同的数据\"><a class=\"markdownIt-Anchor\" href=\"#相同的元素根据输入顺序离散化为不同的数据\"></a> 相同的元素根据输入顺序离散化为不同的数据</h3>\n<p>根据题目要求，有时候会把相同的元素根据输入顺序离散化为不同的数据。方法：</p>\n<ol>\n<li>创建原数组的副本，同时记录每个元素出现的位置。</li>\n<li>将副本按值从小到大排序，当值相同时，按出现顺序从小到大排序。</li>\n<li>将离散化后的数字放回原数组。</li>\n</ol>\n<h3 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\"></a> 复杂度分析</h3>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>相同的元素离散化为相同的数据</th>\n<th>相同的元素根据输入顺序离散化为不同的数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>去重</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>-</td>\n</tr>\n<tr>\n<td>排序</td>\n<td colspan=\"2\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>查找</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 次查找，二分查找 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td>-</td>\n</tr>\n<tr>\n<td>时间复杂度</td>\n<td colspan=\"2\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>空间复杂度</td>\n<td colspan=\"2\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"粗糙的哈希\"><a class=\"markdownIt-Anchor\" href=\"#粗糙的哈希\"></a> 粗糙的哈希</h1>\n<p>我们还可以自己实现简单字符串的哈希算法。</p>\n\n<details class=\"callout\" data-callout=\"example\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">不同哈希算法的粗略分析</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p></p>\n<p>下面列举出的算法是在通过例题 🟨 <a href=\"https://leetcode.cn/problems/minimum-number-of-operations-to-make-word-k-periodic/description/\">3137. K 周期字符串需要的最少操作次数 - 力扣（LeetCode）</a> 前提下，对计算时间和复杂性权衡后的结果。</p>\n<table>\n<thead>\n<tr>\n<th>Hash 算法</th>\n<th>时间 (ms)</th>\n<th>内存 (MB)</th>\n<th>时间击败比率 (%)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简易位运算 Hash</td>\n<td>23</td>\n<td rowspan=\"2\">45.2</td>\n<td>100</td>\n</tr>\n<tr>\n<td>简易乘法 Hash</td>\n<td>28</td>\n<td>88.37</td>\n</tr>\n<tr>\n<td>Java Map <code>hash()</code></td>\n<td>43</td>\n<td>44.85</td>\n<td>11.63</td>\n</tr>\n</tbody>\n</table>\n</div></details><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 乘法 Hash</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">genHash</span><span class=\"params\">(<span class=\"type\">char</span>[] cc,<span class=\"type\">int</span> start,<span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> hash=<span class=\"number\">0</span>,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (hash=length, i=<span class=\"number\">0</span>; i&lt;length; ++i)</span><br><span class=\"line\">\t   <span class=\"comment\">// 推荐的乘数还有：31, 131, 1313, 13131, 131313等等。</span></span><br><span class=\"line\">\t   hash = <span class=\"number\">33</span>*hash+cc[start+i]; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 位运算 Hash</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">genHash</span><span class=\"params\">(<span class=\"type\">char</span>[] cc,<span class=\"type\">int</span> start,<span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> hash,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (hash=length, i=<span class=\"number\">0</span>; i&lt;length; ++i)</span><br><span class=\"line\">\t   hash = (hash&lt;&lt;<span class=\"number\">5</span>)^(hash&gt;&gt;<span class=\"number\">27</span>)^cc[i+start];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/subsets-ii/description/\">90. 子集 II - 力扣（LeetCode）</a></li>\n<li>🟥 <a href=\"https://leetcode.cn/problems/max-points-on-a-line/description/\">149. 直线上最多的点数 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<p>后续补充：</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 手撸哈希表</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>研究生课程《离散数学》相关笔记</li>\n<li><a href=\"https://www.cnblogs.com/barrywxx/p/10739871.html\">经典Hash函数的实现 - BarryW - 博客园</a></li>\n<li><a href=\"https://oi-wiki.org/misc/discrete/\">离散化 - OI Wiki</a></li>\n</ul>\n","raw":"---\ntitle: 不得不和哈希打交道\ntags:\n  - 哈希\n  - 离散化\n  - 树状数组\n  - 线段树\n  - 哈希表\n  - Java\n  - 二分查找\n  - 排序\ncover: 'https://cdn.gallery.uuanqin.top/img/202509222214661.webp'\ndescription: 记录一些用过的哈希技巧\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: 66fb7738\ndate: 2024-10-02 00:03:13\ntop_img:\n---\n\n> [!note] `250922` 文章部分内容解耦自 [[Java 集合的使用]]。\n\n本文主要记录一些在刷题时常用到的哈希技巧：\n\n1. 多元组作为键进行存储的思路\n2. 离散化技巧\n3. 写一个粗糙的哈希\n\n关于 Java 集合的使用详见：[[Java 集合的使用]]。\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 多元组作为哈希表的键\n\n有时候我们需要在集合中存储一个元素的二维坐标，我们不需要自己定义二元组存储，我们可以：\n\n- 只存储第几个格子即可：`i*n+j`\n- 将各种参数组合成独一无二的 `String` 来作为 Key：`\"12,23,24\"` 或 `\"a=1,b=2,c=3\"`。如需分离，可使用 `string.split(regex)` 函数进行分离。\n\n# 离散化\n\n离散化是一种数据处理的技巧，本质上可以看成是一种哈希，其保证数据在哈希以后仍然保持原来的全/偏序关系。\n\n通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。\n\n被离散化的可以是大整数、浮点数、字符串等等。\n\n> [!note]- 偏序与全序\n> 设 R 为非空集合 S 上的关系，如果 R 是自反、反对称和传递的关系，则称 R 为 S 上的偏序关系，简称**偏序**，记作 $\\preceq$。「大于或等于 $\\ge$」关系是整数集合上的偏序。\n>\n> 如果 a$\\preceq$b 或 b$\\preceq$a，偏序集<S,$\\preceq$>中的元素 a 和 b 称为**可比**的。\n>\n> 如果<S,$\\preceq$>是偏序集，且 S 中的每对都是可比的，则 S 称为全序集或线序集，且 $\\preceq$ 称为**全序**或线序。\n>\n> 简单来说，离散化后的数，它们之间的大小关系不变。\n\n> [!example] 离散化案例\n> 例 1：`100 200 300 200 100 200`\n> 离散化：`1 2 3 2 1 2`\n>\n> 例 2：`123456 123456 123456`\n> 离散化：`1 1 1`\n\n相关题目：\n\n- 🟩 [U232423 【模板】离散化 - 洛谷](https://www.luogu.com.cn/problem/U232423)：离散化模板题\n\n## 实现方式\n\n### 相同的元素离散化为相同的数据\n\n通常原数组中会有重复的元素，一般把相同的元素离散化为相同的数据。\n\n方法：\n\n1. 创建原数组的副本。\n2. 将副本中的值从小到大排序。\n3. 将排序好的副本去重。\n4. 查找原数组的每一个元素在副本中的位置，位置即为排名，将其作为离散化后的值。\n\n基本功练习：\n\n- 🟩 [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)：题目条件苛刻的时候离散化需要原地去重\n- 🟩 [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)：二分查找算法练习。推荐看这篇：[[为什么二分查找总是写不对？]]\n\n参考实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long[] arr = new long[n];\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = in.nextLong();\n        }\n\n        long[] dup = Arrays.copyOf(arr, n);\n        Arrays.sort(dup);\n        int m = unique(dup);\n\n        for (long e: arr) {\n            int ans = b(m, dup, e);\n            System.out.print((ans + 1) + \" \");\n        }\n    }\n\n    // 二分查找\n    public static int b(int m, long[] nums, long k) {\n        int l = 0, r = m - 1;\n        int mid;\n        while (l <= r) {\n            mid = (r - l) / 2 + l;\n            if (k == nums[mid]) return mid;\n            if (k < nums[mid]) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    // 有序数组去重\n    public static int unique(long[] nums) {\n        if (nums.length <= 1) {\n            return nums.length;\n        }\n        int i = 1, j = 1;\n        for (; j < nums.length; j++) {\n            if (nums[i - 1] != nums[j]) {\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        return i;\n    }\n}\n```\n\n### 相同的元素根据输入顺序离散化为不同的数据\n\n根据题目要求，有时候会把相同的元素根据输入顺序离散化为不同的数据。方法：\n\n1. 创建原数组的副本，同时记录每个元素出现的位置。\n2. 将副本按值从小到大排序，当值相同时，按出现顺序从小到大排序。\n3. 将离散化后的数字放回原数组。\n\n### 复杂度分析\n\n| 步骤    | 相同的元素离散化为相同的数据            | 相同的元素根据输入顺序离散化为不同的数据 |\n| ----- | ------------------------- | -------------------- |\n| 去重    | $O(n)$                    | -                    |\n| 排序    | $O(n\\log n)$              | $O(n\\log n)$         |\n| 查找    | $O(n)$ 次查找，二分查找 $O(\\log n)$ | -                    |\n| 时间复杂度 | $O(n\\log n)$              | $O(n\\log n)$         |\n| 空间复杂度 | $O(n)$                    | $O(n)$               |\n\n# 粗糙的哈希\n\n我们还可以自己实现简单字符串的哈希算法。\n\n> [!example]- 不同哈希算法的粗略分析\n>\n> 下面列举出的算法是在通过例题 🟨 [3137. K 周期字符串需要的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-operations-to-make-word-k-periodic/description/) 前提下，对计算时间和复杂性权衡后的结果。\n>\n> | Hash 算法           | 时间 (ms) | 内存 (MB) | 时间击败比率 (%) |\n> | ----------------- | ------- | ------- | ---------- |\n> | 简易位运算 Hash        | 23      | 45.2    | 100        |\n> | 简易乘法 Hash         | 28      | 45.2    | 88.37      |\n> | Java Map `hash()` | 43      | 44.85   | 11.63      |\n\n```java\n// 乘法 Hash\npublic int genHash(char[] cc,int start,int length){\n\tint hash=0,i;\n\tfor (hash=length, i=0; i<length; ++i)\n\t   // 推荐的乘数还有：31, 131, 1313, 13131, 131313等等。\n\t   hash = 33*hash+cc[start+i]; \n\treturn hash;\n}\n\n// 位运算 Hash\npublic int genHash(char[] cc,int start,int length){\n\tint hash,i;\n\tfor (hash=length, i=0; i<length; ++i)\n\t   hash = (hash<<5)^(hash>>27)^cc[i+start];\n\treturn hash;\n}\n```\n\n相关题目：\n\n- 🟨 [90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/)\n- 🟥 [149. 直线上最多的点数 - 力扣（LeetCode）](https://leetcode.cn/problems/max-points-on-a-line/description/)\n\n# 后记\n\n后续补充：\n\n- [ ] 手撸哈希表\n\n# 本文参考\n\n- 研究生课程《离散数学》相关笔记\n- [经典Hash函数的实现 - BarryW - 博客园](https://www.cnblogs.com/barrywxx/p/10739871.html)\n- [离散化 - OI Wiki](https://oi-wiki.org/misc/discrete/)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"二分查找","api":"api/tags/二分查找.json"},{"name":"哈希","api":"api/tags/哈希.json"},{"name":"离散化","api":"api/tags/离散化.json"},{"name":"树状数组","api":"api/tags/树状数组.json"},{"name":"线段树","api":"api/tags/线段树.json"},{"name":"哈希表","api":"api/tags/哈希表.json"},{"name":"排序","api":"api/tags/排序.json"}]},"api":"api/posts/p/66fb7738.json"}