{"data":{"title":"Git 的分支管理策略 —— Git-flow","slug":"技术学习/Git 的分支管理策略 —— Git-flow","description":"这是一篇对分支管理策略学习和探讨","date":"2023-05-27T13:51:53.000Z","updated":"2026-02-01T07:00:46.570Z","language":"zh-CN","comments":true,"url":"p/6eb2089c/","cover":"https://cdn.gallery.uuanqin.top/img/git-flowcover555555.png","images":[],"content":"<p><a href=\"https://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model</a> 是一篇有名的分支管理策略（Git-Flow）的学习，下面文章以这篇文章为基础，介绍 Git-Flow 工作流，顺便练一下英语。这篇不是简单的英文翻译，里面杂合了我的理解与外部参考。</p>\n<blockquote>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model » nvie.com</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/07/git.html\">Git分支管理策略 - 阮一峰的网络日志 (ruanyifeng.com)</a></li>\n</ul>\n</blockquote>\n<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h1>\n<p>这篇文章诞生于 10 年前，那时 Git 刚诞生不久。在这 10 年里，许多团队都把它当成了“准则”和“灵丹妙药”。现在，越来越多的软件类型转向了 web 应用，而这些应用一般是持续交付的，而不是回滚式的，因此不需要支持多版本管理。如果软件开发团队正在做持续交付的软件，那么可以参考更简单的工作流（如 <a href=\"https://docs.github.com/zh/get-started/quickstart/github-flow\">GitHub 流</a>）而不是非得使用 git-flow。</p>\n<p>当然了，学习前需要记住，世界上没有灵丹妙药。要考虑自己的情况选择自己的工作流。</p>\n<h1 id=\"为什么选择-git\"><a class=\"markdownIt-Anchor\" href=\"#为什么选择-git\"></a> 为什么选择 Git</h1>\n<p>Git 改变了程序员对“合并/分支”的看法。以前（CVS/Subversion 时代），“合并/分支”有点可怕：小心合并冲突，不然它会咬你！但有了 Git，这些操作将变得成本低廉和简单。由于其简单和可重复性的特性，“合并/分支”不再可怕。</p>\n<h1 id=\"去中心化了但是还要中心化\"><a class=\"markdownIt-Anchor\" href=\"#去中心化了但是还要中心化\"></a> “去中心化”了但是还要“中心化”</h1>\n<p>因为 Git 是 DVCS（分布式管理系统），在技术层面上就没有诸如”中心化“仓库的东西。但是要让我们的模型工作得好，首先就得有一个“中心”的“真实”的仓库。这个中心化的仓库我们称为 <code>origin</code>（这个名字对 Git 用户来说比较熟悉）</p>\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/centr-decentr@2x.png\" style=\"zoom:50%;\" />\n<p>每一个开发人员都从 <code>origin</code> 中拉取和推送，与此同时成员之间也互相拉取形成子团队。这适用于 2 到 3 个开发人员在对一个软件的重要特性的进行开发的场景。</p>\n<p>上图中，alice 和 bob、alice 和 david、david 和 clair 组成了子团队，这意味着 Alice 定义了一个远程 Git 仓库名为 bob，反之亦然。</p>\n<h1 id=\"主分支\"><a class=\"markdownIt-Anchor\" href=\"#主分支\"></a> 主分支</h1>\n<p>中心仓库掌握两个主要的分支，它们有着无限的生命周期：</p>\n<ul>\n<li>master 分支：主要分支，<code>HEAD</code> 总是指向一个“可以作为产品发布”的状态。</li>\n<li>develop 分支：主要分支，<code>HEAD</code> 总是指向为下一个版本做准备的最新交付开发版本，它包含了一些针对下一个版本的更改。</li>\n</ul>\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/main-branches@2x.png\" alt=\"img\" style=\"zoom:50%;\" />\n<p>当 develop 中的源代码趋向稳定且做好发布准备时，所有的改变都应以某种方法“合并”回 master，并打上版本标签。因此，每一次把所有改变合并回 master，根据定义，这将是一个全新的发行版本。对于这一点，我们应严格遵守。所以从理论上来讲，每一次 master 分支存在提交，我们编写的 Git Hook 脚本会自动构建并导出我们的软件产品到产品服务器。</p>\n<h1 id=\"辅助分支\"><a class=\"markdownIt-Anchor\" href=\"#辅助分支\"></a> 辅助分支</h1>\n<p>次于 master 和 develop 两个主分支，我们的开发模型使用许多辅助分支以帮助团队成员之间的平行开发、简化特性的追踪、为版本发行做好准备以及对产品临时出现的问题进行修复。与主分支不同，这些分支总是有着有限的生存周期，它们最终将会被永久地移除。</p>\n<p>我们可能会用到的不同辅助分支：</p>\n<ul>\n<li>特性分支（Feature branches）</li>\n<li>预发行分支（Release branches）</li>\n<li>热修复分支（Hotfix branches）</li>\n</ul>\n<p>这些分支有不同的目的，且各自有严格规则约束，这些规则规定了它们原分支和目的分支。从技术上来讲，这些分支并不十分“特殊”，它们都是一般的 Git 分支，只不过我们以“使用它的方式”进行分类罢了。</p>\n<h3 id=\"特性分支\"><a class=\"markdownIt-Anchor\" href=\"#特性分支\"></a> 特性分支</h3>\n<table>\n<thead>\n<tr>\n<th>可能从哪个分支分出来</th>\n<th>必须合并回哪个分支去</th>\n<th>习惯命名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td colspan=\"2\">develop</td>\n<td>除了叫 master、develop、release-* 或 hotfix-*，其他都可以</td>\n</tr>\n</tbody>\n</table>\n<p>特性分支（有时也称主题分支）是用来开发即将到来或远期发行版本新特性的分支。当我们开始开发一个特性时，包含这个特性的发行版本是未知的。特性分支的本质是，只要这个特性还在开发中，它就一直存在，但最终会合并回 develop（这就决定了新特性将加入即将发行的版本之中）或丢弃（以防最终的结果令人失望）。</p>\n<p>特性分支一般只存在于开发中的仓库，而不在 <code>origin</code>。</p>\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/fb@2x.png\" alt=\"img\" style=\"zoom:50%;\" />\n<h4 id=\"创建特性分支\"><a class=\"markdownIt-Anchor\" href=\"#创建特性分支\"></a> 创建特性分支</h4>\n<p>当我们开始在新特性上进行开发时，我们从 develop 中分出新分支</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b myfeature develop</span><br><span class=\"line\"><span class=\"comment\"># git checkout [-b &lt;new-branch&gt;] [&lt;start-point&gt;]</span></span><br><span class=\"line\"><span class=\"comment\"># Create a new branch named &lt;new-branch&gt;, start it at &lt;start-point&gt;, and check the resulting branch out</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在-develop-分支中合并完成的特性\"><a class=\"markdownIt-Anchor\" href=\"#在-develop-分支中合并完成的特性\"></a> 在 develop 分支中合并完成的特性</h4>\n<p>开发完成的特性将合并到 develop 分支中，这就决定了即将发行的版本将包含这个特性。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 合并新特性</span></span><br><span class=\"line\">git checkout develop\t<span class=\"comment\"># Switched to branch &#x27;develop&#x27;</span></span><br><span class=\"line\">git merge --no-ff myfeature</span><br><span class=\"line\"><span class=\"comment\"># 删除特性分支</span></span><br><span class=\"line\">git branch -d myfeature</span><br><span class=\"line\"><span class=\"comment\"># git branch -d &lt;branchname&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># Delete a branch. </span></span><br><span class=\"line\">git push origin develop</span><br></pre></td></tr></table></figure>\n<p><code>--no-ff</code> 参数解释：</p>\n<p>默认情况下，Git 执行 &quot; 快进式合并 &quot;（fast-farward merge，参考 <a href=\"https://sandofsky.com/static/images/fast_forward.pdf\">fast_forward</a>），会直接将 Master 分支指向 Develop 分支。使用 <code>--no-ff</code> 参数后，会执行正常合并，在 Master 分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法（即使这样做会产生空的 commit 结点，但利大于弊）。</p>\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/--no-ff-awdwdwedwad.png\" alt=\"img\" style=\"zoom: 50%;\" />\n<h3 id=\"预发行分支\"><a class=\"markdownIt-Anchor\" href=\"#预发行分支\"></a> 预发行分支</h3>\n<table>\n<thead>\n<tr>\n<th>可能从哪个分支分出来</th>\n<th>必须合并回哪个分支去</th>\n<th>习惯命名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>develop</td>\n<td>develop，master</td>\n<td>release-*</td>\n</tr>\n</tbody>\n</table>\n<p>预发布分支，它是指发布正式版本之前（即合并到 Master 分支之前），我们可能需要有一个预发布的版本进行测试。</p>\n<p>预发行分支辅助新产品发行的准备工作，They allow for last-minute dotting of i’s and crossing t’s. 此外，它允许小错误的修复且为一个发行版本准备元数据（版本号、构建日期等）。通过所有在预发行分支所做的工作，develop 分支将被清除以接收下一个大版本的发行。</p>\n<p>从 develop 分支分叉处新的预发行分支的时刻，就是 develop（几乎）反应新发行版本的理想状态的时刻，至少此时所有指向正在构建的发行版本的特性已经合并到 develop 中（但是指向未来发行版本的特性也许还没有合并进去，它们必须等到那个版本被分出来后，才考虑进行合并）。</p>\n<p>正是在预发行分支存在开始，预发布的版本将被指定一个版本号（不会更早），一直到 develop 分支反映下一个发行版本变动的那一刻。但是，预发行版本的版本号最终是 0.3 还是 1.0 我们是不清楚的。版本号的决定是从预发行分支开始，并由项目的版本号制定规则决定。</p>\n<h4 id=\"创建一个预发行分支\"><a class=\"markdownIt-Anchor\" href=\"#创建一个预发行分支\"></a> 创建一个预发行分支</h4>\n<p>预发行分支从 develop 分支分流出来的。例如，现在的产品版本为 1.1.5，我们将有一个大的发行版本出现，develop 分支也已经为下一个发行版本准备好了，而且我们决定这个版本将为 1.2（而不是 1.1.6 或 2.0）。所以我们分出一条预发行版本分支，其名字反映了新的版本号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b release-1.2 develop <span class=\"comment\"># 切换到新分支 &quot;release-1.2&quot;</span></span><br><span class=\"line\">./bump-version.sh 1.2 <span class=\"comment\"># 文件修改成功，版本升级至1.2</span></span><br><span class=\"line\">git commit -a -m <span class=\"string\">&quot;Bumped version number to 1.2&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># --all: Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.</span></span><br><span class=\"line\"><span class=\"comment\"># -m &lt;msg&gt;: Use the given &lt;msg&gt; as the commit message.</span></span><br></pre></td></tr></table></figure>\n<p>在创建新分支并切换到它之后，我们提升了版本号。<code>./bump-version.sh</code> 在这里是一个虚构的 shell 脚本，他将改变当前工作中的文件（副本）以反映新的版本（当然，你可以自己手动更改，就是一些文件的更改）。最后，提升的版本号将被提交。</p>\n<p>新的分支也许会存在一段时间，直到这个发行版被推出。在这段时间中，release 分支会有很多 bug 修复（而不是在 develop 分支中），但严格禁止在这里增加大的特性。大的特性应该合并到 develop 分支中，并等待下一个发行版本。</p>\n<h4 id=\"完成一个预发行分支\"><a class=\"markdownIt-Anchor\" href=\"#完成一个预发行分支\"></a> 完成一个预发行分支</h4>\n<p>当预发行分支准备好发行时，我们必须进行一些操作。首先，预发行分支合并到 master 分支中（别忘了，master 中的每次提交代表的是一个新的发行版本）。其次，master 中的提交必须被贴上标签以便未来对这个历史版本的参考。最后，预发行分支中的改变需要合并回 develop，这样未来的发行版本中将会包含这些 bug 修复。</p>\n<p>在 Git 中提交的步骤：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-1.2</span><br><span class=\"line\">git tag -a 1.2</span><br><span class=\"line\"><span class=\"comment\"># -a: Make an unsigned, annotated tag object</span></span><br><span class=\"line\"><span class=\"comment\"># 你还可以使用以下标签</span></span><br><span class=\"line\"><span class=\"comment\"># -s: Make a GPG-signed tag, using the default e-mail address’s key. </span></span><br><span class=\"line\"><span class=\"comment\"># -u &lt;key-id&gt;: Make a GPG-signed tag, using the given key.</span></span><br></pre></td></tr></table></figure>\n<p>预发行已经完成，且进行了标签标注以便未来的参考。</p>\n<p>为了保证预发行分支中的改变得到保留，我们需要将其合并到 develop 分支。在 Git 中这样做：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop <span class=\"comment\"># Switched to branch &#x27;develop&#x27;</span></span><br><span class=\"line\">git merge --no-ff release-1.2</span><br></pre></td></tr></table></figure>\n<p>这个步骤可能会导致合并冲突（或者说是必定冲突，因为我们改变了版本号），如果真的这样那就修复它然后提交。</p>\n<p>现在我们真的要完事了，这个分支我们已经不需要了，把它删掉：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d release-1.2</span><br></pre></td></tr></table></figure>\n<h3 id=\"热修复分支\"><a class=\"markdownIt-Anchor\" href=\"#热修复分支\"></a> 热修复分支</h3>\n<table>\n<thead>\n<tr>\n<th>可能从哪个分支分出来</th>\n<th>必须合并回哪个分支去</th>\n<th>习惯命名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master</td>\n<td>develop，master</td>\n<td>hotfix-*</td>\n</tr>\n</tbody>\n</table>\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/hotfix-branches@2x.png\" alt=\"img\" style=\"zoom:50%;\" />\n<p>热修复分支非常像预发行分支，因为它也是为新产品发行做准备。它的出现是为了应对当前版本中出现的错误情况。当现行发行的产品出现一个紧急的 Bug，它必须立即修复，这时热修复分支会从 master 分支中对应版本的 tag 分流出来。</p>\n<p>它的本质就是要在 develop 进行开发的工作团队继续它们的工作，要另一个人去准备好修复这个 Bug。</p>\n<h4 id=\"创建热修复分支\"><a class=\"markdownIt-Anchor\" href=\"#创建热修复分支\"></a> 创建热修复分支</h4>\n<p>热修复分支可以从 master 分支中创建。例如，版本 1.2 是当前产品发行版本，然而出现了严重 Bug。但是 develop 分支中的改变还是不稳定的，我们需要分支出热修复分支并着手开始解决问题。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b hotfix-1.2.1 master <span class=\"comment\"># Switched to a new branch &quot;hotfix-1.2.1&quot;</span></span><br><span class=\"line\">./bump-version.sh 1.2.1 <span class=\"comment\"># 文件修改成功，版本升级至1.2.1</span></span><br><span class=\"line\">git commit -a -m <span class=\"string\">&quot;Bumped version number to 1.2.1&quot;</span></span><br></pre></td></tr></table></figure>\n<p>别忘了分支出热修复分支后提升版本号。</p>\n<p>大约提交几次 commit 后，修复好 Bug。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;Fixed severe production problem&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"完成热修复分支\"><a class=\"markdownIt-Anchor\" href=\"#完成热修复分支\"></a> 完成热修复分支</h4>\n<p>完成 Bug 修复后，需要把热修复分支合并到 master 中以及 develop 中，这是为了保证修复后的内容也被下一个版本包含。这就很像预发布分支完成后的操作。</p>\n<p>首先，更新 master 并标注发行版本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff hotfix-1.2.1</span><br><span class=\"line\">git tag -a 1.2.1</span><br><span class=\"line\"><span class=\"comment\"># 你还可以使用以下标签</span></span><br><span class=\"line\"><span class=\"comment\"># -s: Make a GPG-signed tag, using the default e-mail address’s key. </span></span><br><span class=\"line\"><span class=\"comment\"># -u &lt;key-id&gt;: Make a GPG-signed tag, using the given key.</span></span><br></pre></td></tr></table></figure>\n<p>然后，把 Bug 的修复也合并到 develop 中：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop <span class=\"comment\"># Switched to branch &#x27;develop&#x27;</span></span><br><span class=\"line\">git merge --no-ff hotfix-1.2.1</span><br></pre></td></tr></table></figure>\n<p>有一个例外规则是：<strong>当预发布分支存在时，热修复中的改变需要合并到这个预发布分支，而不是 develop</strong>。合并的预发布分支的修复，会在预发布分支完成后最终合并到 develop 中。当然，如果 develop 分支急需这个修复，你也可以安全的合并到 develop 中。</p>\n<p>最后，移除热修复分支这个临时分支。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h1>\n<p>如果这个分支模型没有什么重大改变，下面这张图将对你的项目非常有用。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/git-model@2x.png\" alt=\"img\" width=\"475px\" /></p>\n<blockquote>\n<p>Author: Vincent Driessen</p>\n<p>Original blog post: <a href=\"http://nvie.com/posts/a-succesful-git-branching-model\">http://nvie.com/posts/a-succesful-git-branching-model</a></p>\n<p>License: Creative Commons BY-SA</p>\n</blockquote>\n<h1 id=\"推荐阅读\"><a class=\"markdownIt-Anchor\" href=\"#推荐阅读\"></a> 推荐阅读</h1>\n<p><a href=\"https://www.conventionalcommits.org/zh-hans/v1.0.0/\">约定式提交 (conventionalcommits.org)</a></p>\n","raw":"---\ntitle: Git 的分支管理策略 —— Git-flow\ntags:\n  - git\ncover: https://cdn.gallery.uuanqin.top/img/git-flowcover555555.png\ndescription: 这是一篇对分支管理策略学习和探讨\nabbrlink: 6eb2089c\ncategories:\n  - 技术学习\nsummary: >-\n  本文介绍了 Git 的分支管理策略——Git-Flow。Git-Flow 是一种流行的工作流，旨在简化 Git 分支管理，提高团队协作效率。文章首先回顾了Git 的起源和优势，强调了 Git 对“合并/分支”操作的简化，使得这些操作变得更加低廉和简单。 接着，文章详细阐述了 Git-Flow 的核心概念，包括主分支（master）和辅助分支（develop、feature、release、hotfix）。主分支用于存放稳定的发布版本，辅助分支则用于支持开发过程中的特性开发、版本预发布和紧急错误修复。文章还解释了如何创建和合并这些分支，以及如何处理分支间的冲突。特性分支允许开发团队在独立的环境中开发新特性，预发布分支用于测试即将发布的版本，而热修复分支则用于紧急修复当前版本中的错误。\n  最后，文章强调了 Git-Flow 的灵活性和适应性，指出它可以根据团队的具体情况进行调整，不一定要遵循固定的规则。通过学习和实践 Git-Flow，开发团队可以更有效地管理代码，提高软件交付的速度和质量。\ndate: 2023-05-27 21:51:53\ntop_img:\n---\n\n[A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/) 是一篇有名的分支管理策略（Git-Flow）的学习，下面文章以这篇文章为基础，介绍 Git-Flow 工作流，顺便练一下英语。这篇不是简单的英文翻译，里面杂合了我的理解与外部参考。\n\n> 参考：\n>\n> * [A successful Git branching model » nvie.com](https://nvie.com/posts/a-successful-git-branching-model/)\n>  * [Git分支管理策略 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2012/07/git.html)\n>\n\n# 前言\n\n这篇文章诞生于 10 年前，那时 Git 刚诞生不久。在这 10 年里，许多团队都把它当成了“准则”和“灵丹妙药”。现在，越来越多的软件类型转向了 web 应用，而这些应用一般是持续交付的，而不是回滚式的，因此不需要支持多版本管理。如果软件开发团队正在做持续交付的软件，那么可以参考更简单的工作流（如 [GitHub 流](https://docs.github.com/zh/get-started/quickstart/github-flow)）而不是非得使用 git-flow。\n\n当然了，学习前需要记住，世界上没有灵丹妙药。要考虑自己的情况选择自己的工作流。\n\n# 为什么选择 Git\n\nGit 改变了程序员对“合并/分支”的看法。以前（CVS/Subversion 时代），“合并/分支”有点可怕：小心合并冲突，不然它会咬你！但有了 Git，这些操作将变得成本低廉和简单。由于其简单和可重复性的特性，“合并/分支”不再可怕。\n\n# “去中心化”了但是还要“中心化”\n\n因为 Git 是 DVCS（分布式管理系统），在技术层面上就没有诸如”中心化“仓库的东西。但是要让我们的模型工作得好，首先就得有一个“中心”的“真实”的仓库。这个中心化的仓库我们称为 `origin`（这个名字对 Git 用户来说比较熟悉）\n\n<img src=\"https://cdn.gallery.uuanqin.top/img/centr-decentr@2x.png\" style=\"zoom:50%;\" />\n\n每一个开发人员都从 `origin` 中拉取和推送，与此同时成员之间也互相拉取形成子团队。这适用于 2 到 3 个开发人员在对一个软件的重要特性的进行开发的场景。\n\n上图中，alice 和 bob、alice 和 david、david 和 clair 组成了子团队，这意味着 Alice 定义了一个远程 Git 仓库名为 bob，反之亦然。\n\n# 主分支\n\n中心仓库掌握两个主要的分支，它们有着无限的生命周期：\n\n* master 分支：主要分支，`HEAD` 总是指向一个“可以作为产品发布”的状态。\n* develop 分支：主要分支，`HEAD` 总是指向为下一个版本做准备的最新交付开发版本，它包含了一些针对下一个版本的更改。\n\n<img src=\"https://cdn.gallery.uuanqin.top/img/main-branches@2x.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n当 develop 中的源代码趋向稳定且做好发布准备时，所有的改变都应以某种方法“合并”回 master，并打上版本标签。因此，每一次把所有改变合并回 master，根据定义，这将是一个全新的发行版本。对于这一点，我们应严格遵守。所以从理论上来讲，每一次 master 分支存在提交，我们编写的 Git Hook 脚本会自动构建并导出我们的软件产品到产品服务器。\n\n# 辅助分支\n\n次于 master 和 develop 两个主分支，我们的开发模型使用许多辅助分支以帮助团队成员之间的平行开发、简化特性的追踪、为版本发行做好准备以及对产品临时出现的问题进行修复。与主分支不同，这些分支总是有着有限的生存周期，它们最终将会被永久地移除。\n\n我们可能会用到的不同辅助分支：\n\n* 特性分支（Feature branches）\n* 预发行分支（Release branches）\n* 热修复分支（Hotfix branches）\n\n这些分支有不同的目的，且各自有严格规则约束，这些规则规定了它们原分支和目的分支。从技术上来讲，这些分支并不十分“特殊”，它们都是一般的 Git 分支，只不过我们以“使用它的方式”进行分类罢了。\n\n### 特性分支\n\n| 可能从哪个分支分出来 | 必须合并回哪个分支去 | 习惯命名                                        |\n| ---------- | ---------- | ------------------------------------------- |\n| develop    | develop    | 除了叫 master、develop、release-\\* 或 hotfix-*，其他都可以 |\n\n特性分支（有时也称主题分支）是用来开发即将到来或远期发行版本新特性的分支。当我们开始开发一个特性时，包含这个特性的发行版本是未知的。特性分支的本质是，只要这个特性还在开发中，它就一直存在，但最终会合并回 develop（这就决定了新特性将加入即将发行的版本之中）或丢弃（以防最终的结果令人失望）。\n\n特性分支一般只存在于开发中的仓库，而不在 `origin`。\n\n<img src=\"https://cdn.gallery.uuanqin.top/img/fb@2x.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n#### 创建特性分支\n\n当我们开始在新特性上进行开发时，我们从 develop 中分出新分支\n\n```sh\ngit checkout -b myfeature develop\n# git checkout [-b <new-branch>] [<start-point>]\n# Create a new branch named <new-branch>, start it at <start-point>, and check the resulting branch out\n```\n\n#### 在 develop 分支中合并完成的特性\n\n开发完成的特性将合并到 develop 分支中，这就决定了即将发行的版本将包含这个特性。\n\n```sh\n# 合并新特性\ngit checkout develop\t# Switched to branch 'develop'\ngit merge --no-ff myfeature\n# 删除特性分支\ngit branch -d myfeature\n# git branch -d <branchname>\n# Delete a branch. \ngit push origin develop\n```\n\n`--no-ff` 参数解释：\n\n默认情况下，Git 执行 \" 快进式合并 \"（fast-farward merge，参考 [fast_forward](https://sandofsky.com/static/images/fast_forward.pdf)），会直接将 Master 分支指向 Develop 分支。使用 `--no-ff` 参数后，会执行正常合并，在 Master 分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法（即使这样做会产生空的 commit 结点，但利大于弊）。\n\n<img src=\"https://cdn.gallery.uuanqin.top/img/--no-ff-awdwdwedwad.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### 预发行分支\n\n| 可能从哪个分支分出来 | 必须合并回哪个分支去 | 习惯命名   |\n| -------------------- | -------------------- | ---------- |\n| develop              | develop，master      | release-\\* |\n\n预发布分支，它是指发布正式版本之前（即合并到 Master 分支之前），我们可能需要有一个预发布的版本进行测试。\n\n预发行分支辅助新产品发行的准备工作，They allow for last-minute dotting of i’s and crossing t’s. 此外，它允许小错误的修复且为一个发行版本准备元数据（版本号、构建日期等）。通过所有在预发行分支所做的工作，develop 分支将被清除以接收下一个大版本的发行。\n\n从 develop 分支分叉处新的预发行分支的时刻，就是 develop（几乎）反应新发行版本的理想状态的时刻，至少此时所有指向正在构建的发行版本的特性已经合并到 develop 中（但是指向未来发行版本的特性也许还没有合并进去，它们必须等到那个版本被分出来后，才考虑进行合并）。\n\n正是在预发行分支存在开始，预发布的版本将被指定一个版本号（不会更早），一直到 develop 分支反映下一个发行版本变动的那一刻。但是，预发行版本的版本号最终是 0.3 还是 1.0 我们是不清楚的。版本号的决定是从预发行分支开始，并由项目的版本号制定规则决定。\n\n#### 创建一个预发行分支\n\n预发行分支从 develop 分支分流出来的。例如，现在的产品版本为 1.1.5，我们将有一个大的发行版本出现，develop 分支也已经为下一个发行版本准备好了，而且我们决定这个版本将为 1.2（而不是 1.1.6 或 2.0）。所以我们分出一条预发行版本分支，其名字反映了新的版本号：\n\n```sh\ngit checkout -b release-1.2 develop # 切换到新分支 \"release-1.2\"\n./bump-version.sh 1.2 # 文件修改成功，版本升级至1.2\ngit commit -a -m \"Bumped version number to 1.2\"\n# --all: Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.\n# -m <msg>: Use the given <msg> as the commit message.\n```\n\n在创建新分支并切换到它之后，我们提升了版本号。`./bump-version.sh` 在这里是一个虚构的 shell 脚本，他将改变当前工作中的文件（副本）以反映新的版本（当然，你可以自己手动更改，就是一些文件的更改）。最后，提升的版本号将被提交。\n\n新的分支也许会存在一段时间，直到这个发行版被推出。在这段时间中，release 分支会有很多 bug 修复（而不是在 develop 分支中），但严格禁止在这里增加大的特性。大的特性应该合并到 develop 分支中，并等待下一个发行版本。\n\n#### 完成一个预发行分支\n\n当预发行分支准备好发行时，我们必须进行一些操作。首先，预发行分支合并到 master 分支中（别忘了，master 中的每次提交代表的是一个新的发行版本）。其次，master 中的提交必须被贴上标签以便未来对这个历史版本的参考。最后，预发行分支中的改变需要合并回 develop，这样未来的发行版本中将会包含这些 bug 修复。\n\n在 Git 中提交的步骤：\n\n```sh\ngit checkout master\ngit merge --no-ff release-1.2\ngit tag -a 1.2\n# -a: Make an unsigned, annotated tag object\n# 你还可以使用以下标签\n# -s: Make a GPG-signed tag, using the default e-mail address’s key. \n# -u <key-id>: Make a GPG-signed tag, using the given key.\n```\n\n预发行已经完成，且进行了标签标注以便未来的参考。\n\n为了保证预发行分支中的改变得到保留，我们需要将其合并到 develop 分支。在 Git 中这样做：\n\n```sh\ngit checkout develop # Switched to branch 'develop'\ngit merge --no-ff release-1.2\n```\n\n这个步骤可能会导致合并冲突（或者说是必定冲突，因为我们改变了版本号），如果真的这样那就修复它然后提交。\n\n现在我们真的要完事了，这个分支我们已经不需要了，把它删掉：\n\n```sh\ngit branch -d release-1.2\n```\n\n### 热修复分支\n\n| 可能从哪个分支分出来 | 必须合并回哪个分支去 | 习惯命名  |\n| -------------------- | -------------------- | --------- |\n| master               | develop，master      | hotfix-\\* |\n\n<img src=\"https://cdn.gallery.uuanqin.top/img/hotfix-branches@2x.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n热修复分支非常像预发行分支，因为它也是为新产品发行做准备。它的出现是为了应对当前版本中出现的错误情况。当现行发行的产品出现一个紧急的 Bug，它必须立即修复，这时热修复分支会从 master 分支中对应版本的 tag 分流出来。\n\n它的本质就是要在 develop 进行开发的工作团队继续它们的工作，要另一个人去准备好修复这个 Bug。\n\n#### 创建热修复分支\n\n热修复分支可以从 master 分支中创建。例如，版本 1.2 是当前产品发行版本，然而出现了严重 Bug。但是 develop 分支中的改变还是不稳定的，我们需要分支出热修复分支并着手开始解决问题。\n\n```sh\ngit checkout -b hotfix-1.2.1 master # Switched to a new branch \"hotfix-1.2.1\"\n./bump-version.sh 1.2.1 # 文件修改成功，版本升级至1.2.1\ngit commit -a -m \"Bumped version number to 1.2.1\"\n```\n\n别忘了分支出热修复分支后提升版本号。\n\n大约提交几次 commit 后，修复好 Bug。\n\n```sh\ngit commit -m \"Fixed severe production problem\"\n```\n\n#### 完成热修复分支\n\n完成 Bug 修复后，需要把热修复分支合并到 master 中以及 develop 中，这是为了保证修复后的内容也被下一个版本包含。这就很像预发布分支完成后的操作。\n\n首先，更新 master 并标注发行版本：\n\n```sh\ngit checkout master\ngit merge --no-ff hotfix-1.2.1\ngit tag -a 1.2.1\n# 你还可以使用以下标签\n# -s: Make a GPG-signed tag, using the default e-mail address’s key. \n# -u <key-id>: Make a GPG-signed tag, using the given key.\n```\n\n然后，把 Bug 的修复也合并到 develop 中：\n\n```sh\ngit checkout develop # Switched to branch 'develop'\ngit merge --no-ff hotfix-1.2.1\n```\n\n有一个例外规则是：**当预发布分支存在时，热修复中的改变需要合并到这个预发布分支，而不是 develop**。合并的预发布分支的修复，会在预发布分支完成后最终合并到 develop 中。当然，如果 develop 分支急需这个修复，你也可以安全的合并到 develop 中。\n\n最后，移除热修复分支这个临时分支。\n\n```sh\ngit branch -d hotfix-1.2.1\n```\n\n# 总结\n\n如果这个分支模型没有什么重大改变，下面这张图将对你的项目非常有用。\n\n![img|475](https://cdn.gallery.uuanqin.top/img/git-model@2x.png)\n\n> Author: Vincent Driessen\n>\n> Original blog post: http://nvie.com/posts/a-succesful-git-branching-model\n>\n> License: Creative Commons BY-SA\n\n# 推荐阅读\n\n[约定式提交 (conventionalcommits.org)](https://www.conventionalcommits.org/zh-hans/v1.0.0/)","categories":[{"name":"技术学习","api":"api/categories/技术学习.json"}],"tags":[{"name":"git","api":"api/tags/git.json"}]},"api":"api/posts/p/6eb2089c.json"}