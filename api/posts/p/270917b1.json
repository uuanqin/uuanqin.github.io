{"data":{"title":"手写 LRU 缓存以理解 Java 中的 LinkedHashMap","slug":"算法与数据结构/手写 LRU 缓存以理解 Java 中的 LinkedHashMap","description":"一个围绕 LRU 的专题综合。","date":"2024-09-03T15:25:18.000Z","updated":"2025-06-09T17:32:18.221Z","language":"zh-CN","comments":true,"url":"p/270917b1/","cover":"https://cdn.gallery.uuanqin.top/img/202409050003261.webp","images":[],"content":"<p>最近最少使用（Least Recently Used，LRU），是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p>\n<p>Java 中可以使用 <code>LinkedHashMap</code> 轻松实现一个 LRU 缓存。</p>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">页面置换算法</div>\n</div>\n<div class=\"callout-content\"><p>在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法（Page-Replacement Algorithms）。</p>\n<ul>\n<li>最佳置换算法（OPT）</li>\n<li>先进先出置换算法（FIFO）</li>\n<li>最少使用置换算法（LFU）</li>\n<li><strong>最近最少使用置换算法（LRU）</strong></li>\n</ul>\n<p>附：高速缓冲器替换算法有：随机算法、FIFO、LFU、<strong>LRU</strong></p>\n</div></div><p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"手写-lru-缓存\"><a class=\"markdownIt-Anchor\" href=\"#手写-lru-缓存\"></a> 手写 LRU 缓存</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&amp;envId=top-interview-150\">146. LRU 缓存 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>请你设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。<br />\n实现 <code>LRUCache</code> 类：</p>\n<ul>\n<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>\n<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>\n<li><code>void put(int key, int value)</code>\n<ul>\n<li>如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code></li>\n<li>如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。</li>\n</ul>\n</li>\n</ul>\n<p>函数 <code>get</code> 和 <code>put</code> 必须以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的平均时间复杂度运行。</p>\n</div></div><p>Java 实现要点：</p>\n<ul>\n<li><code>HashMap</code> + 双向链表。<code>HashMap</code> 用于快速定位双向链表中的结点；双向链表用于区分缓存 <code>key</code> 的访问顺序。</li>\n<li>双向链表必须自己手动建立并维护各种结点操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">DLinkedNode</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> key;</span><br><span class=\"line\">        <span class=\"type\">int</span> value;</span><br><span class=\"line\">        DLinkedNode prev;</span><br><span class=\"line\">        DLinkedNode next;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">DLinkedNode</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">DLinkedNode</span><span class=\"params\">(<span class=\"type\">int</span> _key, <span class=\"type\">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DLinkedNode head, tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">        <span class=\"comment\">// 使用伪头部和伪尾部节点</span></span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> <span class=\"title class_\">DLinkedNode</span>();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> <span class=\"title class_\">DLinkedNode</span>();</span><br><span class=\"line\">        head.next = tail;</span><br><span class=\"line\">        tail.prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DLinkedNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> cache.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class=\"line\">        moveToHead(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DLinkedNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> cache.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 key 不存在，创建一个新的节点</span></span><br><span class=\"line\">            <span class=\"type\">DLinkedNode</span> <span class=\"variable\">newNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DLinkedNode</span>(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 添加进哈希表</span></span><br><span class=\"line\">            cache.put(key, newNode);</span><br><span class=\"line\">            <span class=\"comment\">// 添加至双向链表的头部</span></span><br><span class=\"line\">            addToHead(newNode);</span><br><span class=\"line\">            ++size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &gt; capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class=\"line\">                <span class=\"type\">DLinkedNode</span> <span class=\"variable\">tail</span> <span class=\"operator\">=</span> removeTail();</span><br><span class=\"line\">                <span class=\"comment\">// 删除哈希表中对应的项</span></span><br><span class=\"line\">                cache.remove(tail.key);</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class=\"line\">            node.value = value;</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addToHead</span><span class=\"params\">(DLinkedNode node)</span> &#123;</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">        node.next = head.next;</span><br><span class=\"line\">        head.next.prev = node;</span><br><span class=\"line\">        head.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeNode</span><span class=\"params\">(DLinkedNode node)</span> &#123;</span><br><span class=\"line\">        node.prev.next = node.next;</span><br><span class=\"line\">        node.next.prev = node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">moveToHead</span><span class=\"params\">(DLinkedNode node)</span> &#123;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        addToHead(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DLinkedNode <span class=\"title function_\">removeTail</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DLinkedNode</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> tail.prev;</span><br><span class=\"line\">        removeNode(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"java-中的-linkedhashmap\"><a class=\"markdownIt-Anchor\" href=\"#java-中的-linkedhashmap\"></a> Java 中的 <code>LinkedHashMap</code></h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408310204657.webp\" alt=\"image.png\" width=\"350px\" /></p>\n<p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承了 <code>HashMap</code> 的所有属性和方法，并且在 HashMap 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>\n<p><code>LinkedHashMap</code> 特性：</p>\n<ul>\n<li>支持遍历时会按照插入顺序有序进行迭代。<strong>（与 <code>HashMap</code> 的最大区别）</strong></li>\n<li>支持按照元素访问顺序排序，适用于封装 LRU 缓存工具。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。<strong>由于双向链表的存在，其插入性能可能会比 <code>HashMap</code> 略低。</strong></li>\n</ul>\n<p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408310151331.webp\" alt=\"image.png\" width=\"375px\" /></p>\n<p><code>LinkedHashMap</code> 提供了多个构造方法，包括默认构造方法和带有访问顺序选项的构造方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    accessOrder = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(initialCapacity);</span><br><span class=\"line\">    accessOrder = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    accessOrder = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashMap</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">int</span> initialCapacity, // 容量大小</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">float</span> loadFactor,    // 负载因子</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">boolean</span> accessOrder  </span></span><br><span class=\"line\"><span class=\"params\">)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(initialCapacity, loadFactor); <span class=\"comment\">// 调用直接父类 HashMap 的构造方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过指定 <code>accessOrder</code> 参数为 <code>true</code>，可以让 <code>LinkedHashMap</code> 以访问顺序排序（即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部），而不是插入顺序。利用这一点，我们可以稍微对其改造，就能得到一个 LRU 缓存。</p>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">面试提示</div>\n</div>\n<div class=\"callout-content\"><p>如果面试时考察实现 LRU 的题目，直接使用语言内置特性的做法通常不会符合面试官的要求。但我们还是需要了解如何使用 <code>LinkedHashMap</code> 实现 LRU。</p>\n</div></div><p>具体实现思路如下：</p>\n<ul>\n<li>继承 <code>LinkedHashMap</code>；</li>\n<li>构造方法中指定 <code>accessOrder</code> 为 <code>true</code> ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li>\n<li>重写 <code>removeEldestEntry</code> 方法，该方法会返回一个 <code>boolean</code> 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">0.75F</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// TIPS：HashMap loadFactor 的默认值为 0.75f </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getOrDefault(key, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/LRU\">LRU_百度百科 (baidu.com)</a></li>\n<li><a href=\"https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/?envType=study-plan-v2&amp;envId=top-interview-150\">146. LRU 缓存 - 力扣（LeetCode）</a></li>\n<li><a href=\"https://javaguide.cn/java/collection/linkedhashmap-source-code.html#linkedhashmap-%E7%AE%80%E4%BB%8B\">LinkedHashMap 源码分析 | JavaGuide</a></li>\n<li><a href=\"https://www.mianshiya.com/bank/1788408712975282177/question/1780933294783754241\">什么是 Java 的 LinkedHashMap？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 (mianshiya.com)</a></li>\n<li>王道 2023《408 数据结构》</li>\n</ul>\n","raw":"---\ntitle: 手写 LRU 缓存以理解 Java 中的 LinkedHashMap\ntags:\n  - LRU\n  - Java\n  - LeetCode\n  - 操作系统\ncover: 'https://cdn.gallery.uuanqin.top/img/202409050003261.webp'\ndescription: 一个围绕 LRU 的专题综合。\ncategories:\n  - 算法与数据结构\nabbrlink: 270917b1\ndate: 2024-09-03 23:25:18\ntop_img:\n---\n\n最近最少使用（Least Recently Used，LRU），是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。\n\nJava 中可以使用 `LinkedHashMap` 轻松实现一个 LRU 缓存。\n\n> [!note] 页面置换算法\n> 在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法（Page-Replacement Algorithms）。\n> - 最佳置换算法（OPT）\n> - 先进先出置换算法（FIFO）\n> - 最少使用置换算法（LFU）\n> - **最近最少使用置换算法（LRU）**\n>\n> 附：高速缓冲器替换算法有：随机算法、FIFO、LFU、**LRU**\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 手写 LRU 缓存\n\n> [!example] 题目：🟨 [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-interview-150)\n> 请你设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。\n> 实现 `LRUCache` 类：\n> - `LRUCache(int capacity)` 以 正整数 作为容量 `capacity` 初始化 LRU 缓存\n> - `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 -1 。\n> - `void put(int key, int value)`\n> \t- 如果关键字 `key` 已经存在，则变更其数据值 `value`\n> \t- 如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 `capacity` ，则应该 逐出 最久未使用的关键字。\n>\n> 函数 `get` 和 `put` 必须以 $O(1)$ 的平均时间复杂度运行。\n\nJava 实现要点：\n\n- `HashMap` + 双向链表。`HashMap` 用于快速定位双向链表中的结点；双向链表用于区分缓存 `key` 的访问顺序。\n- 双向链表必须自己手动建立并维护各种结点操作\n\n```java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```\n\n# Java 中的 `LinkedHashMap`\n\n![image.png|350](https://cdn.gallery.uuanqin.top/img/202408310204657.webp)\n\n`LinkedHashMap` 是 Java 提供的一个集合类，它继承了 `HashMap` 的所有属性和方法，并且在 HashMap 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。\n\n`LinkedHashMap` 特性：\n\n- 支持遍历时会按照插入顺序有序进行迭代。**（与 `HashMap` 的最大区别）**\n- 支持按照元素访问顺序排序，适用于封装 LRU 缓存工具。\n- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。**由于双向链表的存在，其插入性能可能会比 `HashMap` 略低。**\n\n`LinkedHashMap` 逻辑结构如下图所示，它是在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。\n\n![image.png|375](https://cdn.gallery.uuanqin.top/img/202408310151331.webp)\n\n`LinkedHashMap` 提供了多个构造方法，包括默认构造方法和带有访问顺序选项的构造方法。\n\n```java\npublic LinkedHashMap() {\n    super();\n    accessOrder = false;\n}\n\npublic LinkedHashMap(int initialCapacity) {\n    super(initialCapacity);\n    accessOrder = false;\n}\n\npublic LinkedHashMap(int initialCapacity, float loadFactor) {\n    super(initialCapacity, loadFactor);\n    accessOrder = false;\n}\n\npublic LinkedHashMap(\n\tint initialCapacity, // 容量大小\n    float loadFactor,    // 负载因子\n    boolean accessOrder  \n) {\n    super(initialCapacity, loadFactor); // 调用直接父类 HashMap 的构造方法\n    this.accessOrder = accessOrder;\n}\n```\n\n通过指定 `accessOrder` 参数为 `true`，可以让 `LinkedHashMap` 以访问顺序排序（即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部），而不是插入顺序。利用这一点，我们可以稍微对其改造，就能得到一个 LRU 缓存。\n\n> [!hint] 面试提示\n> 如果面试时考察实现 LRU 的题目，直接使用语言内置特性的做法通常不会符合面试官的要求。但我们还是需要了解如何使用 `LinkedHashMap` 实现 LRU。\n\n具体实现思路如下：\n\n- 继承 `LinkedHashMap`；\n- 构造方法中指定 `accessOrder` 为 `true` ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；\n- 重写 `removeEldestEntry` 方法，该方法会返回一个 `boolean` 值，告知 `LinkedHashMap` 是否需要移除链表首元素（缓存容量有限）。\n\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true); // TIPS：HashMap loadFactor 的默认值为 0.75f \n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n```\n\n\n\n# 本文参考\n- [LRU_百度百科 (baidu.com)](https://baike.baidu.com/item/LRU)\n- [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150)\n- [LinkedHashMap 源码分析 | JavaGuide](https://javaguide.cn/java/collection/linkedhashmap-source-code.html#linkedhashmap-%E7%AE%80%E4%BB%8B)\n- [什么是 Java 的 LinkedHashMap？ - Java 集合面试题 - 面试鸭 - 程序员求职面试刷题神器 (mianshiya.com)](https://www.mianshiya.com/bank/1788408712975282177/question/1780933294783754241)\n- 王道 2023《408 数据结构》\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"LRU","api":"api/tags/LRU.json"},{"name":"操作系统","api":"api/tags/操作系统.json"}]},"api":"api/posts/p/270917b1.json"}