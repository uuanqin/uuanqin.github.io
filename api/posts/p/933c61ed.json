{"data":{"title":"装饰器模式：相框","slug":"高质量代码及设计模式/装饰器模式：相框","description":"装饰边框与被装饰物的一致性。不断地为对象添加装饰。","date":"2025-08-18T14:54:03.000Z","updated":"2026-02-01T08:42:42.030Z","language":"zh-CN","comments":true,"url":"p/933c61ed/","cover":"https://cdn.gallery.uuanqin.top/img/202602010144463.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311641210.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<p>装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311646546.webp\" alt=\"image.png\" width=\"375px\" /></p>\n<p>登场角色：</p>\n<ul>\n<li><code>Component</code>（部件）：增加功能时的核心角色。<code>Component</code> 角色只是定义了被装饰物接口（API）。</li>\n<li><code>ConcreteComponent</code>（具体部件）：该角色是实现了 <code>Component</code> 角色所定义的接口（API）的具体被装饰物。</li>\n<li><code>Decorator</code>（装饰物）：该角色具有与 <code>Component</code> 角色相同的接口（API）。在它内部保存了被装饰对象——<code>Component</code> 角色。<code>Decorator</code> 角色知道自己要装饰的对象。</li>\n<li><code>ConcreteDecorator</code>（具体的装饰物)：该角色是具体的 <code>Decorator</code> 角色，它在实现方法时，会通过委托，调用 <code>component</code>，从而实现方法增强。</li>\n</ul>\n<p>Main 中的嵌套装饰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Component</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">\t<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteDecorator1</span>(</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteDecorator2</span>(</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteDecorator3</span>(</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteComponent</span>(); <span class=\"comment\">// 被装饰物</span></span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无需创建新子类即可扩展对象的行为。</td>\n<td>在封装器栈中删除特定封装器比较困难。</td>\n</tr>\n<tr>\n<td>可以在运行时添加或删除对象的功能。</td>\n<td>实现行为不受装饰栈顺序影响的装饰比较困难。</td>\n</tr>\n<tr>\n<td>可以用多个装饰封装对象来组合几种行为。</td>\n<td>各层的初始化配置代码看上去可能会很糟糕。</td>\n</tr>\n<tr>\n<td>单一职责原则。可以将实现了许多不同行为的一个大类拆分为多个较小的类。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>拓展思路：</p>\n<ul>\n<li>接口（API）的透明性：装饰边框与被装饰物具有一致性。<code>Decorator</code> 是被装饰物 Component 的子类就体现了它们的一致性，它们具有相同的接口（API）。即使被装饰物被装饰起来了，接口（API）也不会隐藏起来，依然可以调用，这就是接口的透明性。</li>\n<li>在不改变被装饰物的前提下增加功能。</li>\n<li>可以动态地添加功能。装饰器模式中使用委托，它使类之间形成了弱关联关系。因此，不用改变框架代码，就可以生成一个与其他对象具有不同关系的新对象。</li>\n<li>只需要添加一些装饰物即可添加许多功能。这些功能可以自由组合。</li>\n<li>缺点：导致增加许多很小的类</li>\n</ul>\n<h1 id=\"相关设计模式\"><a class=\"markdownIt-Anchor\" href=\"#相关设计模式\"></a> 相关设计模式</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240729185036.webp\" alt=\"image.png\" width=\"200px\" /></p>\n<h2 id=\"相似的设计模式\"><a class=\"markdownIt-Anchor\" href=\"#相似的设计模式\"></a> 相似的设计模式</h2>\n<p>因为透明性，被装饰物实际上也是别的物体的「装饰边框」，形成递归结构。通过下图和 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>组合模式</a>UML 对比即可发现，两者近乎相似，因为两者都依赖递归组合来组织无限数量的对象。</p>\n<ul>\n<li>装饰器模式的目的是通过增加装饰物来增加对象的功能，组合仅对子节点的结果进行求和。</li>\n<li>装饰器只有一个子组件。</li>\n<li>两种模式可以相互合作，可以使用装饰来扩展组合树中特定对象的行为。</li>\n<li>可以用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"bilink-pop-up\">站内文章</span>原型模式</a> 复制复杂结构。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508182339675.webp\" alt=\"\" /></p>\n<p>在类功能改变方面：</p>\n<ul>\n<li>装饰器模式可以像改变被装饰物的边框或是为被装饰物添加多重边框那样，来增加类的功能，改变的是对象的外表。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>策略模式</a> 通过整体地替换算法来改变类的功能，改变本质。</li>\n</ul>\n<p><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c4f5b558/\"><span class=\"bilink-pop-up\">站内文章</span>责任链模式</a> 和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。</p>\n<ul>\n<li>责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。</li>\n<li>各种装饰可以在遵循基本接口的情况下扩展对象的行为。</li>\n<li>装饰无法中断请求的传递。</li>\n</ul>\n<p>装饰器模式和 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/ba3851cf/\"><span class=\"bilink-pop-up\">站内文章</span>代理模式</a> 有着相似的结构，但是其意图却非常不同。关于 Wrapper 模式的辨析，详看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>这篇文章</a>。</p>\n<h2 id=\"关于组合与继承的讨论\"><a class=\"markdownIt-Anchor\" href=\"#关于组合与继承的讨论\"></a> 关于组合与继承的讨论</h2>\n<p><strong>组合优于继承</strong>。对于增加类的功能方面，相比于通过继承生成子类的方法，装饰器更为灵活。</p>\n<p>装饰器模式相对于简单的组合关系，还有两个比较特殊的地方：</p>\n<ul>\n<li>装饰器类和原始类继承同样的父类，这样我们可以对原始类「嵌套」多个装饰器类。在装饰器模式中，使用继承的主要目的是让装饰器和抽象组件是一样的类型，也就是要有共同的超类，也就是使用继承达到「类型匹配」，而不是利用继承获得「行为」。</li>\n<li>装饰器类是对功能的增强。代理模式、桥接模式都使用了组合，尽管它们的代码结构很相似，但是不同设计模式的设计意图是不一样的。具体区别详看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>这篇文章</a> 相关章节的辨析。</li>\n</ul>\n<p>装饰器模式中，装饰边框与被装饰物具有一致性；装饰器使用了继承和委托，这两种方式也内含一种「一致性」，具体详看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/28239a8d/\"><span class=\"bilink-pop-up\">站内文章</span>这篇文章</a> 的相应章节。</p>\n<h1 id=\"java-io-中的装饰者模式\"><a class=\"markdownIt-Anchor\" href=\"#java-io-中的装饰者模式\"></a> Java I/O 中的装饰者模式</h1>\n<p>Java IO 的类库十分庞大，有 40 多个类，负责 IO 数据的读取和写入。我们可以从以下角度将其划分为四类，具体如下：</p>\n<table>\n<thead>\n<tr>\n<th>抽象基类</th>\n<th>字节流</th>\n<th>字符流</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>输入流</td>\n<td><code>InputStream</code></td>\n<td><code>Reader</code></td>\n</tr>\n<tr>\n<td>输出流</td>\n<td><code>OutputStream</code></td>\n<td><code>Writer</code></td>\n</tr>\n</tbody>\n</table>\n<p>针对不同的读取和写入场景，Java IO 又在四个父类基础上，扩展了很多子类：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508182358732.webp\" alt=\"image.png\" /></p>\n<p>一个输入流的装饰器模式结构：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508182358339.webp\" alt=\"image.png\" /></p>\n<p><code>FilterInputStream</code> 是一个抽象的装饰者，构造函数声明为 <code>protected</code>，表明用户不能直接构造该类的对象，只能构造该类的子类对象。对于一些不需要装饰的方法，如 <code>read()</code>，<code>FilterInputStream</code> 只是简单交由被装饰对象 <code>InputStream</code> 完成。</p>\n<h1 id=\"本文-plantuml-存档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-存档\"></a> 本文 PlantUML 存档</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Component&#123;</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; method1</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; method2</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; method3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ConcreteComponent&#123;</span><br><span class=\"line\">\t&#123;method&#125; method1</span><br><span class=\"line\">\t&#123;method&#125; method2</span><br><span class=\"line\">\t&#123;method&#125; method3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class Decorator&#123;</span><br><span class=\"line\">\tcomponent</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ConcreteDecorator&#123;</span><br><span class=\"line\">\t&#123;method&#125; method1</span><br><span class=\"line\">\t&#123;method&#125; method2</span><br><span class=\"line\">\t&#123;method&#125; method3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Component &lt;|-- ConcreteComponent</span><br><span class=\"line\">Component &lt;|- Decorator</span><br><span class=\"line\">Component -o Decorator</span><br><span class=\"line\">Decorator &lt;|-- ConcreteDecorator</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》第 12 章</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://juejin.cn/post/7234450421888974905\">Java面试必知必会 —— 全面解读 Java IO (装饰器模式篇)在上一篇，我们知道了 Java IO 的基本使用， - 掘金</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/composite\">组合设计模式</a>、<a href=\"https://refactoringguru.cn/design-patterns/decorator\">装饰设计（装饰者模式 / 装饰器模式）</a></li>\n</ul>\n","raw":"---\ntitle: 装饰器模式：相框\ntags:\n  - 设计模式\n  - Java\n  - 组合\n  - Wrapper\ncover: https://cdn.gallery.uuanqin.top/img/202602010144463.webp\ndescription: 装饰边框与被装饰物的一致性。不断地为对象添加装饰。\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: 933c61ed\nsummary: >-\n  装饰器模式是一种结构型设计模式，它允许在不修改现有类的情况下，动态地向对象添加新的功能。这种模式通过创建一个包装对象（装饰者），包装原始对象（具体组件），并在保持接口一致性的同时，增加额外的功能。在实际应用中，装饰器模式常用于需要动态扩展功能的场景，如UI组件、流处理等。通过合理使用装饰器模式，可以使得系统更加灵活和易于维护。\ndate: 2025-08-18 22:54:03\ntop_img:\n---\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202508311641210.webp)\n\n装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题。\n\n![image.png|375](https://cdn.gallery.uuanqin.top/img/202508311646546.webp)\n\n登场角色：\n\n- `Component`（部件）：增加功能时的核心角色。`Component` 角色只是定义了被装饰物接口（API）。\n- `ConcreteComponent`（具体部件）：该角色是实现了 `Component` 角色所定义的接口（API）的具体被装饰物。\n- `Decorator`（装饰物）：该角色具有与 `Component` 角色相同的接口（API）。在它内部保存了被装饰对象——`Component` 角色。`Decorator` 角色知道自己要装饰的对象。\n- `ConcreteDecorator`（具体的装饰物)：该角色是具体的 `Decorator` 角色，它在实现方法时，会通过委托，调用 `component`，从而实现方法增强。\n\nMain 中的嵌套装饰：\n\n```java\nComponent c = \n\tnew ConcreteDecorator1(\n\t\tnew ConcreteDecorator2(\n\t\t\tnew ConcreteDecorator3(\n\t\t\t\tnew ConcreteComponent(); // 被装饰物\n\t\t\t)\n\t\t)\n\t)\n```\n\n| 优点                                 | 缺点                    |\n| ---------------------------------- | --------------------- |\n| 无需创建新子类即可扩展对象的行为。                  | 在封装器栈中删除特定封装器比较困难。    |\n| 可以在运行时添加或删除对象的功能。                  | 实现行为不受装饰栈顺序影响的装饰比较困难。 |\n| 可以用多个装饰封装对象来组合几种行为。                | 各层的初始化配置代码看上去可能会很糟糕。  |\n| 单一职责原则。可以将实现了许多不同行为的一个大类拆分为多个较小的类。 |                       |\n\n拓展思路：\n\n- 接口（API）的透明性：装饰边框与被装饰物具有一致性。`Decorator` 是被装饰物 Component 的子类就体现了它们的一致性，它们具有相同的接口（API）。即使被装饰物被装饰起来了，接口（API）也不会隐藏起来，依然可以调用，这就是接口的透明性。\n- 在不改变被装饰物的前提下增加功能。\n- 可以动态地添加功能。装饰器模式中使用委托，它使类之间形成了弱关联关系。因此，不用改变框架代码，就可以生成一个与其他对象具有不同关系的新对象。\n- 只需要添加一些装饰物即可添加许多功能。这些功能可以自由组合。\n- 缺点：导致增加许多很小的类\n\n# 相关设计模式\n\n![image.png|200](https://cdn.gallery.uuanqin.top/img/20240729185036.webp)\n\n## 相似的设计模式\n\n因为透明性，被装饰物实际上也是别的物体的「装饰边框」，形成递归结构。通过下图和 [[组合模式：树形结构|组合模式]]UML 对比即可发现，两者近乎相似，因为两者都依赖递归组合来组织无限数量的对象。\n\n- 装饰器模式的目的是通过增加装饰物来增加对象的功能，组合仅对子节点的结果进行求和。\n- 装饰器只有一个子组件。\n- 两种模式可以相互合作，可以使用装饰来扩展组合树中特定对象的行为。\n- 可以用 [[原型模式及深浅拷贝|原型模式]] 复制复杂结构。\n\n![](https://cdn.gallery.uuanqin.top/img/202508182339675.webp)\n\n在类功能改变方面：\n\n- 装饰器模式可以像改变被装饰物的边框或是为被装饰物添加多重边框那样，来增加类的功能，改变的是对象的外表。\n- [[策略模式：符文槽|策略模式]] 通过整体地替换算法来改变类的功能，改变本质。\n\n[[责任链模式：击鼓传花|责任链模式]] 和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。\n\n- 责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。\n- 各种装饰可以在遵循基本接口的情况下扩展对象的行为。\n- 装饰无法中断请求的传递。\n\n装饰器模式和 [[代理模式：爱因斯坦和他的司机|代理模式]] 有着相似的结构，但是其意图却非常不同。关于 Wrapper 模式的辨析，详看 [[适配器模式：转接头|这篇文章]]。\n\n## 关于组合与继承的讨论\n\n**组合优于继承**。对于增加类的功能方面，相比于通过继承生成子类的方法，装饰器更为灵活。\n\n装饰器模式相对于简单的组合关系，还有两个比较特殊的地方：\n\n- 装饰器类和原始类继承同样的父类，这样我们可以对原始类「嵌套」多个装饰器类。在装饰器模式中，使用继承的主要目的是让装饰器和抽象组件是一样的类型，也就是要有共同的超类，也就是使用继承达到「类型匹配」，而不是利用继承获得「行为」。\n- 装饰器类是对功能的增强。代理模式、桥接模式都使用了组合，尽管它们的代码结构很相似，但是不同设计模式的设计意图是不一样的。具体区别详看 [[适配器模式：转接头|这篇文章]] 相关章节的辨析。\n\n装饰器模式中，装饰边框与被装饰物具有一致性；装饰器使用了继承和委托，这两种方式也内含一种「一致性」，具体详看 [[面向对象编程 OOP|这篇文章]] 的相应章节。\n\n# Java I/O 中的装饰者模式\n\nJava IO 的类库十分庞大，有 40 多个类，负责 IO 数据的读取和写入。我们可以从以下角度将其划分为四类，具体如下：\n\n| 抽象基类 | 字节流            | 字符流      |\n| ---- | -------------- | -------- |\n| 输入流  | `InputStream`  | `Reader` |\n| 输出流  | `OutputStream` | `Writer` |\n\n针对不同的读取和写入场景，Java IO 又在四个父类基础上，扩展了很多子类：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202508182358732.webp)\n\n一个输入流的装饰器模式结构：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202508182358339.webp)\n\n`FilterInputStream` 是一个抽象的装饰者，构造函数声明为 `protected`，表明用户不能直接构造该类的对象，只能构造该类的子类对象。对于一些不需要装饰的方法，如 `read()`，`FilterInputStream` 只是简单交由被装饰对象 `InputStream` 完成。\n\n# 本文 PlantUML 存档\n\n```plantuml\nabstract class Component{\n\t{method} {abstract} method1\n\t{method} {abstract} method2\n\t{method} {abstract} method3\n}\n\nclass ConcreteComponent{\n\t{method} method1\n\t{method} method2\n\t{method} method3\n}\n\nabstract class Decorator{\n\tcomponent\n}\n\nclass ConcreteDecorator{\n\t{method} method1\n\t{method} method2\n\t{method} method3\n}\n\nComponent <|-- ConcreteComponent\nComponent <|- Decorator\nComponent -o Decorator\nDecorator <|-- ConcreteDecorator\n```\n\n# 本文参考\n\n- 《图解设计模式》第 12 章\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [Java面试必知必会 —— 全面解读 Java IO (装饰器模式篇)在上一篇，我们知道了 Java IO 的基本使用， - 掘金](https://juejin.cn/post/7234450421888974905)\n- [组合设计模式](https://refactoringguru.cn/design-patterns/composite)、[装饰设计（装饰者模式 / 装饰器模式）](https://refactoringguru.cn/design-patterns/decorator)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"组合","api":"api/tags/组合.json"},{"name":"Wrapper","api":"api/tags/Wrapper.json"}]},"api":"api/posts/p/933c61ed.json"}