{"data":{"title":"Groovy 基础","slug":"计算机语言/Groovy 基础","description":"既然接触了，干脆就学完吧","date":"2025-05-13T15:55:25.000Z","updated":"2025-06-24T07:06:25.278Z","language":"zh-CN","comments":true,"url":"p/22279b30/","cover":"https://cdn.gallery.uuanqin.top/img/202504170005366.webp","images":[],"content":"<p>刷题几乎不会用到 Groovy，本文目的仅在于快速熟悉 Groovy 语言，并了解其与 Java 语言的区别。</p>\n<h1 id=\"groovy-简介\"><a class=\"markdownIt-Anchor\" href=\"#groovy-简介\"></a> Groovy 简介</h1>\n<p>Groovy 是一门基于 JVM 的脚本语言。它在兼容 Java 语法的同时，借鉴了 Ruby、Python 等语言的特性，有自己一套简洁而灵活的语法。同时，运行在 JVM 上也意味着它也可以使用 Java 语言编写的库。这两点结合，让 Groovy 极其适合编写 Java 代码的测试脚本。</p>\n<p>Groovy 兼容 Java 的语法。有关 Java 语法详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c73083b9/\"><span class=\"yukari\">站内文章</span>【热身索引】Java 代码刷题热身</a></p>\n<p>Groovy 提供了大量的语法糖来方便我们编写脚本。</p>\n<p>在 IDEA 中，可以通过 Tools-&gt;Groovy Console 随时随地进行简单 Groovy 的编写与调试。也可以另外创建 Groovy 项目。</p>\n<p>缺点：</p>\n<ul>\n<li>效率问题。Groovy 作为运行在 JVM 上的动态语言，运行效率是低于 Java 的。虽然可以用 <code>@CompileStatic</code> 注解来静态编译一些类以提高效率，但这样又会失去 Groovy 的一些动态语言的特性。</li>\n<li>语法过于灵活，运用不当会降低可读性与可维护性。Groovy 支持元编程特性，可以在运行时动态添加方法。这一点自然可以简化代码，但也有很大的可能会降低可维护性。函数式编程与大量的语法糖会让不熟悉 Groovy 的人读起来一头雾水，反而降低了可读性。</li>\n</ul>\n<h1 id=\"main-方法\"><a class=\"markdownIt-Anchor\" href=\"#main-方法\"></a> main 方法</h1>\n<blockquote>\n<p>🍬 优化了 Java 的 main 方法。类似 Python。</p>\n</blockquote>\n<p>main 方法的写法可以和 Java 相同。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java 写法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">void</span> main(String []args) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 中 main 方法不一定要写在类中。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行 main 方法可以选其一执行</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> StudentID;</span><br><span class=\"line\">    String StudentName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        println <span class=\"string\">&quot;inside&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;outside&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>甚至，main 方法根本就不需要：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分号 ; 是可选的</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> x = <span class=\"number\">5</span>;  <span class=\"comment\">// 可选类型。def 可以省略</span></span><br><span class=\"line\">println <span class=\"string\">&quot;The value of x is &quot;</span> + x ; <span class=\"comment\">// 方法调用可以用空格代替括号</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"变量的定义和交换\"><a class=\"markdownIt-Anchor\" href=\"#变量的定义和交换\"></a> 变量的定义和交换</h1>\n<blockquote>\n<p>🍬 简化 Java 多变量定义即交换方法。类似 Python。</p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> (var1, var2) = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">(var1, var2) = [<span class=\"number\">1</span>, <span class=\"number\">2</span>] <span class=\"comment\">// def 是可以省略的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span></span><br><span class=\"line\">(a, b) = [b, a]</span><br></pre></td></tr></table></figure>\n<h1 id=\"数据类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型\"></a> 数据类型</h1>\n<h2 id=\"字符串\"><a class=\"markdownIt-Anchor\" href=\"#字符串\"></a> 字符串</h2>\n<blockquote>\n<p>🍬 弥补了 Java 字符串处理中没有重复操作的痛点。类似 Python。</p>\n</blockquote>\n<p>字符串操作：</p>\n<ul>\n<li><code>+</code>：字符串链接</li>\n<li><code>*</code>：字符串重复</li>\n<li><code>str.length()</code>：字符串长度</li>\n</ul>\n<h2 id=\"可选类型\"><a class=\"markdownIt-Anchor\" href=\"#可选类型\"></a> 可选类型</h2>\n<blockquote>\n<p>🍬 优化了 Java 的类型创建。类似 Python。</p>\n</blockquote>\n<p>Groovy 是一种 &quot; 可选 &quot; 类型的语言，在理解该语言的基础知识时，这种区别很重要。 与 Java 相比，Java 是一种 &quot; 强 &quot; 类型语言，编译器知道每个变量的所有类型，并且可以在编译时理解和遵守合同。 这意味着可以在编译时确定方法调用。</p>\n<p>在 Groovy 中编写代码时，开发人员可以灵活地提供或不提供类型。 这可以在实现中提供一些简单性，并且如果使用得当，可以以健壮和动态的方式为您的应用程序提供服务。</p>\n<h2 id=\"范围-range\"><a class=\"markdownIt-Anchor\" href=\"#范围-range\"></a> 范围 Range</h2>\n<p>范围是指定值序列的简写。 Range 由序列中的第一个值和最后一个值表示，Range 可以是包含的，也可以是排除的。 包含范围包括从第一个到最后一个的所有值，而排他范围包括除最后一个之外的所有值。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span><span class=\"number\">.10</span> <span class=\"comment\">// 包含范围的示例</span></span><br><span class=\"line\"><span class=\"number\">1.</span>.&lt;<span class=\"number\">10</span> <span class=\"comment\">// 独占范围的示例，定义半开区间</span></span><br><span class=\"line\"><span class=\"string\">&#x27;a&#x27;</span>..<span class=\"string\">&#x27;x&#x27;</span> <span class=\"comment\">// 范围也可以由字符组成</span></span><br><span class=\"line\"><span class=\"number\">10.</span><span class=\"number\">.1</span> <span class=\"comment\">// 范围也可以按降序排列</span></span><br><span class=\"line\"><span class=\"string\">&#x27;x&#x27;</span>..<span class=\"string\">&#x27;a&#x27;</span> <span class=\"comment\">// 范围也可以由字符组成并按降序排列。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> range = <span class=\"number\">0.</span><span class=\"number\">.5</span></span><br></pre></td></tr></table></figure>\n<p>常用方法：</p>\n<ul>\n<li><code>range.contains(e)</code> 检查范围是否包含特定值 <code>e</code></li>\n<li><code>range.get(i)</code> 返回此 Range 中指定位置 <code>i</code> 的元素。</li>\n<li><code>range.getFrom()</code> 获取此 Range 的下限值。</li>\n<li><code>range.getTo()</code> 获取此 Range 的上限值。</li>\n<li><code>range.isReverse()</code> 是否为反转的 Range</li>\n<li><code>range.size()</code> 返回此 Range 中的元素数。</li>\n<li><code>range.subList(fromIndex,toIndex)</code>：返回此 Range 在指定 <code>fromIndex</code>（包括）和 <code>toIndex</code>（不包括）之间部分的视图</li>\n</ul>\n<h2 id=\"列表-list\"><a class=\"markdownIt-Anchor\" href=\"#列表-list\"></a> 列表 List</h2>\n<blockquote>\n<p>🍬 优化了 Java 中的 List 的创建。类似 Python。</p>\n</blockquote>\n<p>Groovy 可以很轻松的定义 Java 中的 <code>List</code>。</p>\n<p>在 Groovy 中，List 列表包含一系列对象引用。 List 列表中的对象引用在序列中占据一个位置，并通过整数索引进行区分。 List 列表字面量表示为一系列用逗号分隔并用方括号括起来的对象。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>] <span class=\"comment\">// 整数值列表</span></span><br><span class=\"line\">[‘Angular’, ‘Groovy’, ‘Java’] <span class=\"comment\">// 字符串列表</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"number\">5</span>] <span class=\"comment\">// 嵌套列表</span></span><br><span class=\"line\">[‘Groovy’, <span class=\"number\">21</span>, <span class=\"number\">2.11</span>] <span class=\"comment\">// 对象引用的异构列表</span></span><br><span class=\"line\">[ ] <span class=\"comment\">// 一个空列表</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>Java 中类似方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>add(e)</code></td>\n<td>将新值附加到此列表的末尾。</td>\n<td><code>Collection</code> 的「增」</td>\n</tr>\n<tr>\n<td><code>remove(i)</code></td>\n<td>删除此列表中指定位置的元素。</td>\n<td><code>ArrayList</code> 的「删」</td>\n</tr>\n<tr>\n<td><code>get(i)</code></td>\n<td>返回此列表中指定位置的元素。</td>\n<td><code>Collection</code> 的「查」</td>\n</tr>\n<tr>\n<td><code>contains(e)</code><br></td>\n<td>如果此 List 包含指定的值，则返回 true。</td>\n<td rowspan=\"2\"><code>Collection</code> 的的判断</td>\n</tr>\n<tr>\n<td><code>isEmpty()</code></td>\n<td>如果此 List 不包含任何元素，则返回 true</td>\n</tr>\n<tr>\n<td><code>minus()</code></td>\n<td>创建一个由原始元素组成的新列表，而不是集合中指定的元素。</td>\n<td rowspan=\"4\"></td>\n</tr>\n<tr>\n<td><code>plus()</code></td>\n<td>创建一个由原始元素和集合中指定的元素组成的新列表。</td>\n</tr>\n<tr>\n<td><code>pop()</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>reverse()</code></td>\n<td>创建一个新的列表，它与原始列表的元素相反</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>获取此 List 中的元素个数。</td>\n<td><code>Collection</code> 获取长度</td>\n</tr>\n<tr>\n<td><code>sort()</code></td>\n<td>返回原始列表的排序副本。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Java 集合相关内容详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/182af697/\"><span class=\"yukari\">站内文章</span>Java 集合的使用</a></p>\n<p>通过范围可以快速定义 <code>List</code>：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> arrayList = <span class=\"string\">&#x27;A&#x27;</span>..<span class=\"string\">&#x27;D&#x27;</span> <span class=\"keyword\">as</span> ArrayList</span><br><span class=\"line\"><span class=\"keyword\">def</span> linkedList = <span class=\"number\">1.</span>.&lt;<span class=\"number\">5</span> <span class=\"keyword\">as</span> LinkedList</span><br><span class=\"line\">println arrayList</span><br><span class=\"line\">println linkedList</span><br><span class=\"line\"><span class=\"comment\">// assert可以检查表达式是否为true。当表达式为false时，assert会打印出表达式里对象或方法的值</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> arrayList <span class=\"keyword\">instanceof</span> ArrayList</span><br><span class=\"line\"><span class=\"keyword\">assert</span> linkedList <span class=\"keyword\">instanceof</span> LinkedList</span><br></pre></td></tr></table></figure>\n<p><code>List</code> 的运算：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> list1 = []</span><br><span class=\"line\"><span class=\"keyword\">def</span> list2 = list1 + <span class=\"string\">&#x27;Hello&#x27;</span>     <span class=\"comment\">// 加号返回新的list</span></span><br><span class=\"line\">println <span class=\"string\">&quot;$list1 $list2&quot;</span>         <span class=\"comment\">// 输出：[] [Hello]</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> list3 = list2 &lt;&lt; <span class=\"string\">&#x27;World&#x27;</span>    <span class=\"comment\">// list2 会修改原有list</span></span><br><span class=\"line\">println <span class=\"string\">&quot;$list2 $list3&quot;</span>         <span class=\"comment\">// 输出：[Hello, World] [Hello, World]</span></span><br><span class=\"line\">list2 &lt;&lt; <span class=\"string\">&#x27;Yes!&#x27;</span>                 <span class=\"comment\">// 注意，list3 持有 list2 的引用</span></span><br><span class=\"line\">println <span class=\"string\">&quot;$list2 $list3&quot;</span>         <span class=\"comment\">// 输出：[Hello, World, Yes!] [Hello, World, Yes!]</span></span><br><span class=\"line\">println([<span class=\"number\">1</span>,<span class=\"number\">2</span>]+[<span class=\"number\">3</span>,<span class=\"number\">4</span>])            <span class=\"comment\">// 输出：[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>使用 <code>Range</code> 访问 <code>List</code>：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">assert</span> list[<span class=\"number\">0.</span><span class=\"number\">.2</span>] == [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">assert</span> list[<span class=\"number\">0.</span>.<span class=\"number\">-2</span>] == [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\"></a> Map</h2>\n<blockquote>\n<p>🍬 优化了 Java 中的 Map 的创建。</p>\n</blockquote>\n<p>Groovy 可以很轻松的定义 Java 中的 <code>Map</code>。</p>\n<p>Map（也称为关联数组、字典、表和散列）是对象引用的无序集合。 Map 集合中的元素通过键值访问。 Map 中使用的键可以是任何类。 当我们插入 Map 集合时，需要键和值。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;TopicName&#x27;</span> : <span class=\"string\">&#x27;Lists&#x27;</span>, <span class=\"string\">&#x27;Author&#x27;</span> : <span class=\"string\">&#x27;Raghav&#x27;</span>] <span class=\"comment\">// 以 TopicName 为键及其各自值的键值对集合。</span></span><br><span class=\"line\"></span><br><span class=\"line\">[ : ] <span class=\"comment\">// 空 Map 集合。</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>Java <code>Map</code> 存在类似方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>containsKey(key)</code></td>\n<td></td>\n<td rowspan=\"5\">✅</td>\n</tr>\n<tr>\n<td><code>get(key)</code></td>\n<td>如果此 Map 中没有该键的条目，则返回 <code>null</code>。</td>\n</tr>\n<tr>\n<td><code>keySet()</code></td>\n<td rowspan=\"3\"></td>\n</tr>\n<tr>\n<td><code>put(key,newValue)</code></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n</tr>\n<tr>\n<td><code>values()</code></td>\n<td>返回此 Map 中包含的值的集合视图。</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<p>Java Map 集合相关内容详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/182af697/\"><span class=\"yukari\">站内文章</span>Java 集合的使用</a></p>\n<h2 id=\"正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#正则表达式\"></a> 正则表达式</h2>\n<blockquote>\n<p>🍬 优化了 Java 中正则包 <code>java.util.regex</code> 的使用。</p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> regex = ~<span class=\"string\">&#x27;Groovy&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> pattern1 = <span class=\"regexp\">~/match/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> word = <span class=\"string\">&quot;text&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> pattern2 = ~<span class=\"string\">&quot;$word&quot;</span></span><br></pre></td></tr></table></figure>\n<p>条件判断：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> text = <span class=\"string\">&quot;some text to match&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> pattern = <span class=\"regexp\">/some/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (text =~ <span class=\"regexp\">/some/</span>)&#123;</span><br><span class=\"line\">\tprintln <span class=\"string\">&quot;Matched&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> matcher = (text =~ pattern)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (matcher)&#123;</span><br><span class=\"line\">\tprintln <span class=\"string\">&quot;Matched&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下式子在条件判断中，可以得到布尔值</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> =~ <span class=\"string\">&#x27;Groovy&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> =~ <span class=\"string\">&#x27;oo&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> ==~ <span class=\"string\">&#x27;Groovy&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> ==~ <span class=\"string\">&#x27;oo&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> =~ <span class=\"string\">&#x27;∧G&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> =~ <span class=\"string\">&#x27;G$&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> =~ <span class=\"string\">&#x27;Gro*vy&#x27;</span> </span><br><span class=\"line\"><span class=\"string\">&#x27;Groovy&#x27;</span> =~ <span class=\"string\">&#x27;Gro&#123;2&#125;vy&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>捕获组的获得：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> pattern = <span class=\"regexp\">~/A is (\\d+), B is (\\d+)/</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> matcher = (<span class=\"string\">&quot;A is 10, B is 15. A is 20, B is 25&quot;</span> =~ pattern)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> matcher[<span class=\"number\">0</span>][<span class=\"number\">1</span>] == <span class=\"string\">&quot;10&quot;</span> &amp;&amp; matcher[<span class=\"number\">0</span>][<span class=\"number\">2</span>] == <span class=\"string\">&quot;15&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> matcher[<span class=\"number\">1</span>][<span class=\"number\">1</span>] == <span class=\"string\">&quot;20&quot;</span> &amp;&amp; matcher[<span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">&quot;25&quot;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"流程控制语句\"><a class=\"markdownIt-Anchor\" href=\"#流程控制语句\"></a> 流程控制语句</h1>\n<p>Groovy 的 switch case 语法和 Java 类似，但是支持 <code>List</code>、<code>Range</code>、整数、数字、正则、闭包的判断。</p>\n<p>可以使用 for in 语法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1.</span><span class=\"number\">.10</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;$i&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"方法\"><a class=\"markdownIt-Anchor\" href=\"#方法\"></a> 方法</h1>\n<blockquote>\n<p>🍬 优化了 Java 中的方法声明，类似 Python。</p>\n</blockquote>\n<p>方法可以接收任意数量的参数。 在定义参数时不需要显式定义类型。 可以添加诸如 <code>public</code>、<code>private</code> 和 <code>protected</code> 等修饰符。 默认情况下，如果没有提供可见性修饰符，则该方法是公共的。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> methodName() &#123; </span><br><span class=\"line\">   <span class=\"comment\">// Method code </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> methodName(parameter1, parameter2, parameter3) &#123;    </span><br><span class=\"line\">\t<span class=\"comment\">// Method code goes here </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带默认参数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> someMethod(parameter1, parameter2 = <span class=\"number\">0</span>, parameter3 = <span class=\"number\">0</span>) &#123;    </span><br><span class=\"line\">\t<span class=\"comment\">// Method code goes here </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 的方法定义中可以省略 <code>return</code> 关键字。</p>\n<h1 id=\"特殊方法\"><a class=\"markdownIt-Anchor\" href=\"#特殊方法\"></a> 特殊方法</h1>\n<blockquote>\n<p>🍬 对常用方法的使用进行简化。</p>\n</blockquote>\n<p>与 Ruby 类似，groovy 提供了 <code>times</code> 方法，让我们能写出更简洁的循环。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3.</span>times &#123; i -&gt; print <span class=\"string\">&quot;$i &quot;</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">list.size().times &#123; i -&gt; print <span class=\"string\">&quot;$i &quot;</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：0 1 2 0 1 2</span></span><br></pre></td></tr></table></figure>\n<p>在使用 Java 的时候，常常会遇到需要在同一个对象上多次调用方法。Groovy 也提供了相应的语法糖，这就是 <code>with</code> 方法。通过 with 方法，我们在调用对象方法时可以省略对象名。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder()</span><br><span class=\"line\">stringBuilder.with &#123;</span><br><span class=\"line\">    append <span class=\"string\">&quot;W&quot;</span></span><br><span class=\"line\">    append <span class=\"string\">&quot;o&quot;</span></span><br><span class=\"line\">    append <span class=\"string\">&quot;w&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println stringBuilder.toString()</span><br></pre></td></tr></table></figure>\n<h1 id=\"调试标准输出与字符串格式化\"><a class=\"markdownIt-Anchor\" href=\"#调试标准输出与字符串格式化\"></a> 调试（标准输出与字符串格式化）</h1>\n<blockquote>\n<p>🍬 优化了 Java 中的字符串格式化</p>\n</blockquote>\n<p>字符串可以使用模板引擎。</p>\n<p>各种类型直接 <code>println</code> 也能很好的展现出信息来。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> num = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> str = <span class=\"string\">&#x27;Hello&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">def</span> map = [ <span class=\"attr\">one :</span> <span class=\"number\">1</span>, <span class=\"attr\">two :</span> <span class=\"number\">2</span>, <span class=\"attr\">three :</span> <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"comment\">// 花括号可以省略</span></span><br><span class=\"line\">println <span class=\"string\">&quot;number is $&#123;num&#125;, string is $&#123;str&#125;, list is $&#123;list&#125;, map is $&#123;map&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出： </span></span><br><span class=\"line\"><span class=\"comment\">// number is 1, string is Hello, list is [1, 2, 3, 4, 5], map is [one:1, two:2, three:3]</span></span><br></pre></td></tr></table></figure>\n<p>字符串的两端用单引号的话则不会进行格式化。</p>\n<h1 id=\"闭包与函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#闭包与函数式编程\"></a> 闭包与函数式编程</h1>\n<blockquote>\n<p>🍬 优化了 Java 中的 Stream 编程。</p>\n</blockquote>\n<p>闭包是一个简短的匿名代码块。 它通常只跨越几行代码。 方法甚至可以将代码块作为参数。 它们本质上是匿名的。</p>\n<p>与方法不同，闭包在被调用时总是返回一个值。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 形式</span></span><br><span class=\"line\">&#123; [closureParameters -&gt; ] statements &#125;</span><br><span class=\"line\"><span class=\"comment\">// closureParameters 是一个逗号分隔的可选参数列表</span></span><br><span class=\"line\"><span class=\"comment\">// statements 语句是0条或更多Groovy语句</span></span><br><span class=\"line\"><span class=\"comment\">// 当指定一个参数列表时，`-&gt;`字符是必需的，用于将实参从闭包体中分离出来。语句部分由0、1或许多Groovy语句组成。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一个引用名为item的变量的闭包 </span></span><br><span class=\"line\">&#123; item++ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以通过添加箭头 (-&gt;) 显式地将闭包参数从代码中分离出来。 </span></span><br><span class=\"line\">&#123; -&gt; item++ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用隐式参数(it)的闭包 </span></span><br><span class=\"line\">&#123; println it &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//它是一个显式参数的替代版本 </span></span><br><span class=\"line\">&#123; it -&gt; println it &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接受两个类型化参数的闭包</span></span><br><span class=\"line\">&#123; String x, <span class=\"type\">int</span> y -&gt;                                </span><br><span class=\"line\">    println <span class=\"string\">&quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包的使用\"><a class=\"markdownIt-Anchor\" href=\"#闭包的使用\"></a> 闭包的使用</h2>\n<p>闭包作为匿名代码块，可以像调用任何其他方法一样调用。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个不带参数的闭包</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> code = &#123; <span class=\"string\">&#x27;uuanqin.top&#x27;</span> &#125; </span><br><span class=\"line\">println code() <span class=\"comment\">// 隐式调用</span></span><br><span class=\"line\">println code.call() <span class=\"comment\">// 显式调用</span></span><br><span class=\"line\"><span class=\"comment\">//输出： uuanqin.top</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个闭包对象，并添加到isOdd引用。该闭包对象接受int的入参。</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isOdd = &#123; <span class=\"type\">int</span> i -&gt; i%<span class=\"number\">2</span> != <span class=\"number\">0</span> &#125; </span><br><span class=\"line\">println isOdd(<span class=\"number\">3</span>) <span class=\"comment\">// 输出： true </span></span><br><span class=\"line\">println isOdd.call(<span class=\"number\">2</span>) <span class=\"comment\">//输出 ：false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个闭包对象，采用隐式声明，</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isEven = &#123; it%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#125; </span><br><span class=\"line\">println isEven(<span class=\"number\">3</span>) <span class=\"comment\">// 输出：false </span></span><br><span class=\"line\">println isEven.call(<span class=\"number\">2</span>) <span class=\"comment\">// 输出：true</span></span><br></pre></td></tr></table></figure>\n<p>在 Groovy 中，闭包可以作为对象、参数和返回值，所以 Groovy 对高阶函数也有良好的支持。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> addX = &#123; <span class=\"type\">int</span> x -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"type\">int</span> y -&gt;</span><br><span class=\"line\">        println <span class=\"string\">&quot;x is $x, y is $y&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> add1 = addX(<span class=\"number\">1</span>)</span><br><span class=\"line\">println add1(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// x is 1, y is 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包的参数\"><a class=\"markdownIt-Anchor\" href=\"#闭包的参数\"></a> 闭包的参数</h2>\n<p>闭包的参数：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> closureWithOneArg = &#123; str -&gt; str.toUpperCase() &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> closureWithOneArgAndExplicitType = &#123; String str -&gt; str.toUpperCase() &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> closureWithTwoArgs = &#123; a,b -&gt; a+b &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> closureWithTwoArgsAndExplicitTypes = &#123; <span class=\"type\">int</span> a, <span class=\"type\">int</span> b -&gt; a+b &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> closureWithTwoArgsAndOptionalTypes = &#123; a, <span class=\"type\">int</span> b -&gt; a+b &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> closureWithTwoArgAndDefaultValue = &#123; <span class=\"type\">int</span> a, <span class=\"type\">int</span> b=<span class=\"number\">2</span> -&gt; a+b &#125;</span><br></pre></td></tr></table></figure>\n<p>当闭包没有显式定义形参列表 (使用 <code>-&gt;</code>) 时，闭包总是定义一个隐式形参，命名为 <code>it</code>。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> greeting = &#123; it -&gt; <span class=\"string\">&quot;Hello, $it!&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> magicNumber = &#123; -&gt; <span class=\"number\">1024</span> &#125; <span class=\"comment\">//创建一个闭包对象，不允许传参</span></span><br></pre></td></tr></table></figure>\n<p>闭包可以像其他方法一样声明变量参数。如果最后一个形参是可变长度的 (或数组)，就可以接受可变数量的实参：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> concat1 = &#123; String... args -&gt; args.join(<span class=\"string\">&#x27;&#x27;</span>) &#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> concat2 = &#123; String[] args -&gt; args.join(<span class=\"string\">&#x27;&#x27;</span>) &#125;</span><br><span class=\"line\">println concat1(<span class=\"string\">&#x27;ab&#x27;</span>,<span class=\"string\">&#x27;cd&#x27;</span>,<span class=\"string\">&#x27;ef&#x27;</span>) <span class=\"comment\">// 输出：abcdef</span></span><br><span class=\"line\">println concat2(<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;cd&#x27;</span>,<span class=\"string\">&#x27;ef&#x27;</span>) <span class=\"comment\">// 输出：abcdef</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> multiConcat = &#123; <span class=\"type\">int</span> n, String... args -&gt; args.join(<span class=\"string\">&#x27;&#x27;</span>)*n &#125; </span><br><span class=\"line\">println multiConcat(<span class=\"number\">3</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合的筛选与遍历\"><a class=\"markdownIt-Anchor\" href=\"#集合的筛选与遍历\"></a> 集合的筛选与遍历</h2>\n<p>一些集合提供了以闭包作为参数的方法，用于遍历集合。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.find(&#123; it &gt; <span class=\"number\">2</span> &#125;) <span class=\"comment\">// 标准写法</span></span><br><span class=\"line\">list.find &#123; it &gt; <span class=\"number\">2</span> &#125; <span class=\"comment\">// 省略括号。当方法只有闭包一个参数时</span></span><br></pre></td></tr></table></figure>\n<p>一些方法：</p>\n<ul>\n<li><code>each(closure)</code>：遍历集合，集合本身会改变，返回集合的引用。</li>\n<li><code>find(closure)</code>：在集合中找到第一个符合某个条件的值。该闭包必须是一些布尔表达式。</li>\n<li><code>findAll(closure)</code>：在接收对象中查找所有符合闭包条件的值。该闭包必须是一些布尔表达式。相当于对集合进行筛选。</li>\n<li><code>any(closure)</code> 或 <code>every(closure)</code>：<code>any</code> 方法遍历集合的每个元素，检查布尔谓词是否对至少一个元素有效。返回一个布尔值。</li>\n<li><code>collect(closure)</code>：遍历一个集合，使用闭包作为转换器将每个元素转换为新值。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例</span></span><br><span class=\"line\">numbers = <span class=\"number\">1.</span><span class=\"number\">.10</span></span><br><span class=\"line\">sum = numbers.findAll &#123; num -&gt; num  % <span class=\"number\">2</span> == <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        .each &#123; num -&gt; print <span class=\"string\">&quot;$&#123;num&#125; &quot;</span> &#125;</span><br><span class=\"line\">        .sum()</span><br><span class=\"line\">println <span class=\"string\">&quot;sum is $&#123;sum&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a class=\"markdownIt-Anchor\" href=\"#其他\"></a> 其他</h2>\n<p>在闭包中递归调用自身：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> fibonacci = &#123; <span class=\"type\">int</span> n -&gt;</span><br><span class=\"line\">    n == <span class=\"number\">1</span> ? <span class=\"number\">1</span> : n + call(n - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println fibonacci(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"面向对象\"><a class=\"markdownIt-Anchor\" href=\"#面向对象\"></a> 面向对象</h1>\n<blockquote>\n<p>🍬 优化了 Java 中类的操作。</p>\n</blockquote>\n<p>Groovy 会自动为类中的变量加上 getter 与 setter 。（没懂）</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name</span><br><span class=\"line\">    <span class=\"type\">int</span> age</span><br><span class=\"line\">    <span class=\"keyword\">def</span> greet(String otherPerson) &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Hello $&#123;otherPerson&#125;, my name is $&#123;name&#125;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> main(args) &#123;</span><br><span class=\"line\">    Person alice = <span class=\"keyword\">new</span> Person(<span class=\"attr\">age:</span> <span class=\"number\">20</span>) <span class=\"comment\">// 调用构造函数时可以用形如(name: value)的方式给特定参数传参</span></span><br><span class=\"line\">    alice.name = <span class=\"string\">&#x27;Alice&#x27;</span> <span class=\"comment\">// 实际上调用了set方法</span></span><br><span class=\"line\">    println alice.greet(<span class=\"string\">&#x27;Bob&#x27;</span>)</span><br><span class=\"line\">    println alice.age</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Groovy 可以动态地给一个类或对象添加方法。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat kitty = <span class=\"keyword\">new</span> Cat(<span class=\"attr\">name:</span> <span class=\"string\">&#x27;Kitty&#x27;</span>)</span><br><span class=\"line\">kitty.metaClass.meow = &#123; println <span class=\"string\">&quot;Meow&quot;</span> &#125;</span><br><span class=\"line\">kitty.meow()</span><br></pre></td></tr></table></figure>\n<h1 id=\"json-的处理\"><a class=\"markdownIt-Anchor\" href=\"#json-的处理\"></a> Json 的处理</h1>\n<ul>\n<li><code>JsonSlurper</code> ：将 JSON 文本或阅读器内容解析为 Groovy 数据的类结构，例如映射、列表和原始类型，例如 <code>Integer</code>、<code>Double</code>、<code>Boolean</code> 和 <code>String</code>。</li>\n<li><code>JsonOutput</code>：该方法负责将 Groovy 对象序列化为 JSON 字符串。</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> groovy.json.JsonOutput</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    String name</span><br><span class=\"line\">    <span class=\"type\">int</span> ID;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> output = JsonOutput.toJson([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Student(<span class=\"attr\">name:</span> <span class=\"string\">&#x27;John&#x27;</span>,<span class=\"attr\">ID:</span><span class=\"number\">1</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Student(<span class=\"attr\">name:</span> <span class=\"string\">&#x27;Mark&#x27;</span>,<span class=\"attr\">ID:</span><span class=\"number\">2</span>)</span><br><span class=\"line\">])</span><br><span class=\"line\">println(output);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**** 输出 *****</span></span><br><span class=\"line\"><span class=\"comment\">[&#123;&quot;name&quot;:&quot;John&quot;,&quot;ID&quot;:1&#125;,&#123;&quot;name&quot;:&quot;Mark&quot;,&quot;ID&quot;:2&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">****************/</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"多线程\"><a class=\"markdownIt-Anchor\" href=\"#多线程\"></a> 多线程</h1>\n<blockquote>\n<p>🍬 简化 Java 线程的创建</p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread thr = Thread.start &#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;Hello, world!&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thr.join()</span><br></pre></td></tr></table></figure>\n<h1 id=\"文件读写\"><a class=\"markdownIt-Anchor\" href=\"#文件读写\"></a> 文件读写</h1>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> file = <span class=\"keyword\">new</span> File(<span class=\"string\">&#x27;test.txt&#x27;</span>)</span><br><span class=\"line\">file.newOutputStream() &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> file.text == <span class=\"string\">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.w3ccoo.com/groovy/groovy_basic_syntax.html\">Groovy - 基本语法 | Groovy 教程</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2223113\">26. Groovy 闭包-语法与参数学习-第一篇-腾讯云开发者社区-腾讯云</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/257969931\">初探Groovy——无缝兼容Java的脚本语言 - 知乎</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2252859\">【Groovy】集合遍历 ( 使用 for 循环遍历集合 | 使用集合的 each 方法遍历集合 | 集合的 each 方法返回值分析 )-腾讯云开发者社区-腾讯云</a></li>\n<li><a href=\"https://www.w3cschool.cn/groovy/groovy_find.html\">Groovy find()方法_w3cschool</a></li>\n</ul>\n","raw":"---\ntitle: Groovy 基础\ntags:\n  - Groovy\n  - Java\n  - 语法糖\ncover: 'https://cdn.gallery.uuanqin.top/img/202504170005366.webp'\ndescription: 既然接触了，干脆就学完吧\nabbrlink: 22279b30\ncategories:\n  - 计算机语言\ndate: 2025-05-13 23:55:25\ntop_img:\n---\n\n刷题几乎不会用到 Groovy，本文目的仅在于快速熟悉 Groovy 语言，并了解其与 Java 语言的区别。\n\n# Groovy 简介\n\nGroovy 是一门基于 JVM 的脚本语言。它在兼容 Java 语法的同时，借鉴了 Ruby、Python 等语言的特性，有自己一套简洁而灵活的语法。同时，运行在 JVM 上也意味着它也可以使用 Java 语言编写的库。这两点结合，让 Groovy 极其适合编写 Java 代码的测试脚本。\n\nGroovy 兼容 Java 的语法。有关 Java 语法详见：[[【热身索引】Java 代码刷题热身]]\n\nGroovy 提供了大量的语法糖来方便我们编写脚本。\n\n在 IDEA 中，可以通过 Tools->Groovy Console 随时随地进行简单 Groovy 的编写与调试。也可以另外创建 Groovy 项目。\n\n缺点：\n\n- 效率问题。Groovy 作为运行在 JVM 上的动态语言，运行效率是低于 Java 的。虽然可以用 `@CompileStatic` 注解来静态编译一些类以提高效率，但这样又会失去 Groovy 的一些动态语言的特性。\n- 语法过于灵活，运用不当会降低可读性与可维护性。Groovy 支持元编程特性，可以在运行时动态添加方法。这一点自然可以简化代码，但也有很大的可能会降低可维护性。函数式编程与大量的语法糖会让不熟悉 Groovy 的人读起来一头雾水，反而降低了可读性。\n\n# main 方法\n\n> 🍬 优化了 Java 的 main 方法。类似 Python。\n\nmain 方法的写法可以和 Java 相同。\n\n```groovy\n// Java 写法\npublic class HelloWorld {\n    public static void main(String []args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\nGroovy 中 main 方法不一定要写在类中。\n\n```groovy\n// 执行 main 方法可以选其一执行\nclass Student {\n    int StudentID;\n    String StudentName;\n\n    static void main(String[] args) {\n        println \"inside\"\n    }\n}\n\nstatic void main(String[] args) {\n    println \"outside\"\n}\n```\n\n甚至，main 方法根本就不需要：\n\n```groovy\n// 分号 ; 是可选的\ndef x = 5;  // 可选类型。def 可以省略\nprintln \"The value of x is \" + x ; // 方法调用可以用空格代替括号\n```\n\n# 变量的定义和交换\n\n> 🍬 简化 Java 多变量定义即交换方法。类似 Python。\n\n```groovy\ndef (var1, var2) = [1, 2]\n(var1, var2) = [1, 2] // def 是可以省略的\n\nint a = 1, b = 2\n(a, b) = [b, a]\n```\n\n# 数据类型\n\n## 字符串\n\n> 🍬 弥补了 Java 字符串处理中没有重复操作的痛点。类似 Python。\n\n字符串操作：\n\n- `+`：字符串链接\n- `*`：字符串重复\n- `str.length()`：字符串长度\n\n\n## 可选类型\n\n> 🍬 优化了 Java 的类型创建。类似 Python。\n\nGroovy 是一种 \" 可选 \" 类型的语言，在理解该语言的基础知识时，这种区别很重要。 与 Java 相比，Java 是一种 \" 强 \" 类型语言，编译器知道每个变量的所有类型，并且可以在编译时理解和遵守合同。 这意味着可以在编译时确定方法调用。\n\n在 Groovy 中编写代码时，开发人员可以灵活地提供或不提供类型。 这可以在实现中提供一些简单性，并且如果使用得当，可以以健壮和动态的方式为您的应用程序提供服务。\n\n## 范围 Range\n\n范围是指定值序列的简写。 Range 由序列中的第一个值和最后一个值表示，Range 可以是包含的，也可以是排除的。 包含范围包括从第一个到最后一个的所有值，而排他范围包括除最后一个之外的所有值。\n\n```groovy\n1..10 // 包含范围的示例\n1..<10 // 独占范围的示例，定义半开区间\n'a'..'x' // 范围也可以由字符组成\n10..1 // 范围也可以按降序排列\n'x'..'a' // 范围也可以由字符组成并按降序排列。\n```\n\n```groovy\ndef range = 0..5\n```\n\n常用方法：\n\n- `range.contains(e)` 检查范围是否包含特定值 `e`\n- `range.get(i)` 返回此 Range 中指定位置 `i` 的元素。\n- `range.getFrom()` 获取此 Range 的下限值。\n- `range.getTo()` 获取此 Range 的上限值。\n- `range.isReverse()` 是否为反转的 Range\n- `range.size()` 返回此 Range 中的元素数。\n- `range.subList(fromIndex,toIndex)`：返回此 Range 在指定 `fromIndex`（包括）和 `toIndex`（不包括）之间部分的视图\n\n## 列表 List\n\n> 🍬 优化了 Java 中的 List 的创建。类似 Python。\n\nGroovy 可以很轻松的定义 Java 中的 `List`。\n\n在 Groovy 中，List 列表包含一系列对象引用。 List 列表中的对象引用在序列中占据一个位置，并通过整数索引进行区分。 List 列表字面量表示为一系列用逗号分隔并用方括号括起来的对象。\n\n```groovy\n[11, 12, 13, 14] // 整数值列表\n[‘Angular’, ‘Groovy’, ‘Java’] // 字符串列表\n[1, 2, [3, 4], 5] // 嵌套列表\n[‘Groovy’, 21, 2.11] // 对象引用的异构列表\n[ ] // 一个空列表\n```\n\n| 方法                | 描述                           | Java 中类似方法        |\n| ----------------- | ---------------------------- | ----------------- |\n| `add(e)`          | 将新值附加到此列表的末尾。                | `Collection` 的「增」 |\n| `remove(i)`       | 删除此列表中指定位置的元素。               | `ArrayList` 的「删」  |\n| `get(i)`          | 返回此列表中指定位置的元素。               | `Collection` 的「查」 |\n| `contains(e)`<br> | 如果此 List 包含指定的值，则返回 true。    | `Collection` 的的判断 |\n| `isEmpty()`       | 如果此 List 不包含任何元素，则返回 true    | `Collection` 的的判断 |\n| `minus()`         | 创建一个由原始元素组成的新列表，而不是集合中指定的元素。 |                   |\n| `plus()`          | 创建一个由原始元素和集合中指定的元素组成的新列表。    |                   |\n| `pop()`           |                              |                   |\n| `reverse()`       | 创建一个新的列表，它与原始列表的元素相反         |                   |\n| `size()`          | 获取此 List 中的元素个数。             | `Collection` 获取长度 |\n| `sort()`          | 返回原始列表的排序副本。                 |                   |\n\nJava 集合相关内容详见：[[Java 集合的使用]]\n\n通过范围可以快速定义 `List`：\n\n```groovy\ndef arrayList = 'A'..'D' as ArrayList\ndef linkedList = 1..<5 as LinkedList\nprintln arrayList\nprintln linkedList\n// assert可以检查表达式是否为true。当表达式为false时，assert会打印出表达式里对象或方法的值\nassert arrayList instanceof ArrayList\nassert linkedList instanceof LinkedList\n```\n\n`List` 的运算：\n\n```groovy\ndef list1 = []\ndef list2 = list1 + 'Hello'     // 加号返回新的list\nprintln \"$list1 $list2\"         // 输出：[] [Hello]\ndef list3 = list2 << 'World'    // list2 会修改原有list\nprintln \"$list2 $list3\"         // 输出：[Hello, World] [Hello, World]\nlist2 << 'Yes!'                 // 注意，list3 持有 list2 的引用\nprintln \"$list2 $list3\"         // 输出：[Hello, World, Yes!] [Hello, World, Yes!]\nprintln([1,2]+[3,4])            // 输出：[1, 2, 3, 4]\n```\n\n使用 `Range` 访问 `List`：\n\n```groovy\nlist = [1, 2, 3, 4, 5]\nassert list[0..2] == [1, 2, 3]\nassert list[0..-2] == [1, 2, 3, 4]\n```\n\n## Map\n\n> 🍬 优化了 Java 中的 Map 的创建。\n\nGroovy 可以很轻松的定义 Java 中的 `Map`。\n\nMap（也称为关联数组、字典、表和散列）是对象引用的无序集合。 Map 集合中的元素通过键值访问。 Map 中使用的键可以是任何类。 当我们插入 Map 集合时，需要键和值。\n\n```groovy\n['TopicName' : 'Lists', 'Author' : 'Raghav'] // 以 TopicName 为键及其各自值的键值对集合。\n\n[ : ] // 空 Map 集合。\n```\n\n| 方法                  | 描述                           | Java `Map` 存在类似方法 |\n| ------------------- | ---------------------------- | ----------------- |\n| `containsKey(key)`  |                              | ✅                 |\n| `get(key)`          | 如果此 Map 中没有该键的条目，则返回 `null`。 | ✅                 |\n| `keySet()`          |                              | ✅                 |\n| `put(key,newValue)` |                              | ✅                 |\n| `size()`            |                              | ✅                 |\n| `values()`          | 返回此 Map 中包含的值的集合视图。          | ❌                 |\n\nJava Map 集合相关内容详见：[[Java 集合的使用]]\n\n## 正则表达式\n\n> 🍬 优化了 Java 中正则包 `java.util.regex` 的使用。\n\n```groovy\ndef regex = ~'Groovy'\ndef pattern1 = ~/match/\n\ndef word = \"text\"\ndef pattern2 = ~\"$word\"\n```\n\n条件判断：\n\n```groovy\ndef text = \"some text to match\"\ndef pattern = /some/\nif (text =~ /some/){\n\tprintln \"Matched\"\n}\ndef matcher = (text =~ pattern)\nif (matcher){\n\tprintln \"Matched\"\n}\n\n// 以下式子在条件判断中，可以得到布尔值\n'Groovy' =~ 'Groovy' \n'Groovy' =~ 'oo' \n'Groovy' ==~ 'Groovy' \n'Groovy' ==~ 'oo' \n'Groovy' =~ '∧G' \n'Groovy' =~ 'G$' \n'Groovy' =~ 'Gro*vy' \n'Groovy' =~ 'Gro{2}vy'\n```\n\n捕获组的获得：\n\n```groovy\ndef pattern = ~/A is (\\d+), B is (\\d+)/\ndef matcher = (\"A is 10, B is 15. A is 20, B is 25\" =~ pattern)\nassert matcher[0][1] == \"10\" && matcher[0][2] == \"15\"\nassert matcher[1][1] == \"20\" && matcher[1][2] == \"25\"\n```\n\n# 流程控制语句\n\nGroovy 的 switch case 语法和 Java 类似，但是支持 `List`、`Range`、整数、数字、正则、闭包的判断。\n\n可以使用 for in 语法：\n\n```groovy\nfor (i in 1..10)\n{\n    println \"$i\"\n}\n```\n\n# 方法\n\n> 🍬 优化了 Java 中的方法声明，类似 Python。\n\n方法可以接收任意数量的参数。 在定义参数时不需要显式定义类型。 可以添加诸如 `public`、`private` 和 `protected` 等修饰符。 默认情况下，如果没有提供可见性修饰符，则该方法是公共的。\n\n```groovy\ndef methodName() { \n   // Method code \n}\n\ndef methodName(parameter1, parameter2, parameter3) {    \n\t// Method code goes here \n}\n\n// 带默认参数\ndef someMethod(parameter1, parameter2 = 0, parameter3 = 0) {    \n\t// Method code goes here \n}\n```\n\nGroovy 的方法定义中可以省略 `return` 关键字。\n\n# 特殊方法\n\n> 🍬 对常用方法的使用进行简化。\n\n与 Ruby 类似，groovy 提供了 `times` 方法，让我们能写出更简洁的循环。\n\n```groovy\n3.times { i -> print \"$i \" }\ndef list = [1,2,3]\nlist.size().times { i -> print \"$i \"}\n// 输出：0 1 2 0 1 2\n```\n\n在使用 Java 的时候，常常会遇到需要在同一个对象上多次调用方法。Groovy 也提供了相应的语法糖，这就是 `with` 方法。通过 with 方法，我们在调用对象方法时可以省略对象名。\n\n```groovy\nStringBuilder stringBuilder = new StringBuilder()\nstringBuilder.with {\n    append \"W\"\n    append \"o\"\n    append \"w\"\n}\nprintln stringBuilder.toString()\n```\n\n# 调试（标准输出与字符串格式化）\n\n> 🍬 优化了 Java 中的字符串格式化\n\n字符串可以使用模板引擎。\n\n各种类型直接 `println` 也能很好的展现出信息来。\n\n```groovy\ndef num = 1\ndef str = 'Hello'\ndef list = [1,2,3,4,5]\ndef map = [ one : 1, two : 2, three : 3]\n// 花括号可以省略\nprintln \"number is ${num}, string is ${str}, list is ${list}, map is ${map}\"\n\n// 输出： \n// number is 1, string is Hello, list is [1, 2, 3, 4, 5], map is [one:1, two:2, three:3]\n```\n\n字符串的两端用单引号的话则不会进行格式化。\n\n# 闭包与函数式编程\n\n> 🍬 优化了 Java 中的 Stream 编程。\n\n闭包是一个简短的匿名代码块。 它通常只跨越几行代码。 方法甚至可以将代码块作为参数。 它们本质上是匿名的。\n\n与方法不同，闭包在被调用时总是返回一个值。\n\n```groovy\n// 形式\n{ [closureParameters -> ] statements }\n// closureParameters 是一个逗号分隔的可选参数列表\n// statements 语句是0条或更多Groovy语句\n// 当指定一个参数列表时，`->`字符是必需的，用于将实参从闭包体中分离出来。语句部分由0、1或许多Groovy语句组成。\n\n//一个引用名为item的变量的闭包 \n{ item++ }\n\n//可以通过添加箭头 (->) 显式地将闭包参数从代码中分离出来。 \n{ -> item++ }\n\n//使用隐式参数(it)的闭包 \n{ println it }\n\n//它是一个显式参数的替代版本 \n{ it -> println it }\n\n//接受两个类型化参数的闭包\n{ String x, int y ->                                \n    println \"hey ${x} the value is ${y}\"\n}\n```\n\n## 闭包的使用\n\n闭包作为匿名代码块，可以像调用任何其他方法一样调用。\n\n```groovy\n// 定义一个不带参数的闭包\ndef code = { 'uuanqin.top' } \nprintln code() // 隐式调用\nprintln code.call() // 显式调用\n//输出： uuanqin.top\n\n// 创建一个闭包对象，并添加到isOdd引用。该闭包对象接受int的入参。\ndef isOdd = { int i -> i%2 != 0 } \nprintln isOdd(3) // 输出： true \nprintln isOdd.call(2) //输出 ：false\n\n//创建一个闭包对象，采用隐式声明，\ndef isEven = { it%2 == 0 } \nprintln isEven(3) // 输出：false \nprintln isEven.call(2) // 输出：true\n```\n\n在 Groovy 中，闭包可以作为对象、参数和返回值，所以 Groovy 对高阶函数也有良好的支持。\n\n```groovy\ndef addX = { int x ->\n    return { int y ->\n        println \"x is $x, y is $y\"\n        return x + y\n    }\n}\ndef add1 = addX(1)\nprintln add1(2)\n// 输出：\n// x is 1, y is 2\n// 3\n```\n\n## 闭包的参数\n\n闭包的参数：\n\n```groovy\ndef closureWithOneArg = { str -> str.toUpperCase() }\ndef closureWithOneArgAndExplicitType = { String str -> str.toUpperCase() }\ndef closureWithTwoArgs = { a,b -> a+b }\ndef closureWithTwoArgsAndExplicitTypes = { int a, int b -> a+b }\ndef closureWithTwoArgsAndOptionalTypes = { a, int b -> a+b }\ndef closureWithTwoArgAndDefaultValue = { int a, int b=2 -> a+b }\n```\n\n当闭包没有显式定义形参列表 (使用 `->`) 时，闭包总是定义一个隐式形参，命名为 `it`。\n\n```groovy\ndef greeting = { it -> \"Hello, $it!\" }\ndef magicNumber = { -> 1024 } //创建一个闭包对象，不允许传参\n```\n\n闭包可以像其他方法一样声明变量参数。如果最后一个形参是可变长度的 (或数组)，就可以接受可变数量的实参：\n\n```groovy\ndef concat1 = { String... args -> args.join('') }\ndef concat2 = { String[] args -> args.join('') }\nprintln concat1('ab','cd','ef') // 输出：abcdef\nprintln concat2('a','b','cd','ef') // 输出：abcdef\n\ndef multiConcat = { int n, String... args -> args.join('')*n } \nprintln multiConcat(3,'a','c','c')\n```\n\n## 集合的筛选与遍历\n\n一些集合提供了以闭包作为参数的方法，用于遍历集合。\n\n```groovy\nlist.find({ it > 2 }) // 标准写法\nlist.find { it > 2 } // 省略括号。当方法只有闭包一个参数时\n```\n\n一些方法：\n\n- `each(closure)`：遍历集合，集合本身会改变，返回集合的引用。\n- `find(closure)`：在集合中找到第一个符合某个条件的值。该闭包必须是一些布尔表达式。\n- `findAll(closure)`：在接收对象中查找所有符合闭包条件的值。该闭包必须是一些布尔表达式。相当于对集合进行筛选。\n- `any(closure)` 或 `every(closure)`：`any` 方法遍历集合的每个元素，检查布尔谓词是否对至少一个元素有效。返回一个布尔值。\n- `collect(closure)`：遍历一个集合，使用闭包作为转换器将每个元素转换为新值。\n\n```groovy\n// 示例\nnumbers = 1..10\nsum = numbers.findAll { num -> num  % 2 == 0}\n        .each { num -> print \"${num} \" }\n        .sum()\nprintln \"sum is ${sum}\"\n```\n\n## 其他\n\n在闭包中递归调用自身：\n\n```groovy\ndef fibonacci = { int n ->\n    n == 1 ? 1 : n + call(n - 1)\n}\nprintln fibonacci(10)\n```\n\n# 面向对象\n\n> 🍬 优化了 Java 中类的操作。\n\nGroovy 会自动为类中的变量加上 getter 与 setter 。（没懂）\n\n```groovy\nclass Person {\n    private String name\n    int age\n    def greet(String otherPerson) {\n        \"Hello ${otherPerson}, my name is ${name}\"\n    }\n}\n\nstatic main(args) {\n    Person alice = new Person(age: 20) // 调用构造函数时可以用形如(name: value)的方式给特定参数传参\n    alice.name = 'Alice' // 实际上调用了set方法\n    println alice.greet('Bob')\n    println alice.age\n}\n```\n\nGroovy 可以动态地给一个类或对象添加方法。\n\n```groovy\nclass Cat {\n    def name\n}\nCat kitty = new Cat(name: 'Kitty')\nkitty.metaClass.meow = { println \"Meow\" }\nkitty.meow()\n```\n\n# Json 的处理\n\n- `JsonSlurper` ：将 JSON 文本或阅读器内容解析为 Groovy 数据的类结构，例如映射、列表和原始类型，例如 `Integer`、`Double`、`Boolean` 和 `String`。\n- `JsonOutput`：该方法负责将 Groovy 对象序列化为 JSON 字符串。\n\n```groovy\nimport groovy.json.JsonOutput\n\nclass Student {\n    String name\n    int ID;\n}\n\ndef output = JsonOutput.toJson([\n    new Student(name: 'John',ID:1),\n    new Student(name: 'Mark',ID:2)\n])\nprintln(output);\n\n\n/**** 输出 *****\n[{\"name\":\"John\",\"ID\":1},{\"name\":\"Mark\",\"ID\":2}]\n****************/\n```\n\n# 多线程\n\n> 🍬 简化 Java 线程的创建\n\n```groovy\nThread thr = Thread.start {\n    println \"Hello, world!\"\n}\nthr.join()\n```\n\n# 文件读写\n\n```groovy\ndef file = new File('test.txt')\nfile.newOutputStream() << \"Hello, world!\"\nassert file.text == \"Hello, world!\"\n```\n\n# 本文参考\n- [Groovy - 基本语法 | Groovy 教程](https://www.w3ccoo.com/groovy/groovy_basic_syntax.html)\n- [26. Groovy 闭包-语法与参数学习-第一篇-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2223113)\n- [初探Groovy——无缝兼容Java的脚本语言 - 知乎](https://zhuanlan.zhihu.com/p/257969931)\n- [【Groovy】集合遍历 ( 使用 for 循环遍历集合 | 使用集合的 each 方法遍历集合 | 集合的 each 方法返回值分析 )-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2252859)\n- [Groovy find()方法_w3cschool](https://www.w3cschool.cn/groovy/groovy_find.html)\n","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"Groovy","api":"api/tags/Groovy.json"},{"name":"语法糖","api":"api/tags/语法糖.json"}]},"api":"api/posts/p/22279b30.json"}