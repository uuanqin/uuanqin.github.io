{"title":"CSAPP LAB-3 缓冲区溢出炸弹","tags":["CSAPP","C","ASM","GDB","objdump"],"cover":"https://cdn.gallery.uuanqin.top/img/202501232353097.webp","description":"缓冲区溢出攻击实验","categories":["CSAPP LABS"],"abbrlink":"67787353","date":"2024-05-26T15:38:09.000Z","top_img":null,"summary":"我发现我做的实验 3 和网上的都不太一样，难道这实验有新老版本之分？不过主题都是一致的：利用缓冲区溢出的漏洞进行攻击。 > [!notice] CSAPP LAB 实验 > > - [[CSAPP LAB-1 位操作]] > - [[CSAPP LAB-2 二进制炸弹实验]] > - CSAPP LAB-3 缓冲区溢出炸弹（本文） > - [[CSAPP LAB-4 代码优化]] > - [[CSAPP LAB-5 手写动态存储分配器]] 如果你曾经做过 Lab2，那么阅读汇编代码将会很轻松。 实验简介 名称：缓冲区溢出炸弹 实验代码： `makecookie`：生成 cookie，后续实验用到，以判断实验是否成功。例：`./makecookie SA18225155` 生成 cookie `bufbomb`：可执行程序 - 攻击对象 `sendstring`: 字符格式转换 bufbomb 程序 `bufbomb` 中包含一个 `getbuf` 函数，该函数实现如下： 可以发现，这个函数对 buf 没有越界检查（这是常见的 c 编程错误），当输入超过 11 个字符将溢出。溢出的字符将覆盖栈帧上的数据，特别的，会覆盖程序调用的返回地址。这赋予我们控制程序流程的能力，我们可以通过构造溢出字符串，程序将“返回”至我们想要的代码上。 执行以下命令进行反汇编： 观察汇编代码，结合栈帧结构进行理解： sendstring 字符串转换程序 它的功能是将 16 进制的数据转换为 ASCII 字符串。比如：`41 42 43` 转换为 `ABC`。 因为 `bufbomb` 接收的参数是 ASCII 字符串，我们输入的字符串使用了扩展的 ASCII 码（128~255）难以直接输入。 所以实验的基本流程为： 在一个文件，如 `exploit.txt` 写好十六进制数据 执行命令得到字符文件：`./sendstring < exploit.txt > exploit-raw.txt ` 运行 bufbomb 程序：`bufbomb -t <your_number> < exploit-raw.txt`。`<your_number>` 填写你的学号以验证 cookie。..."}