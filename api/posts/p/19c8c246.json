{"data":{"title":"最大子数组问题","slug":"算法与数据结构/最大子数组问题","description":"一道例题引出的多种解法探讨","date":"2024-09-01T14:30:58.000Z","updated":"2025-11-04T14:59:56.262Z","language":"zh-CN","comments":true,"url":"p/19c8c246/","cover":"https://cdn.gallery.uuanqin.top/img/202409050042734.webp","images":[],"content":"<p>在学习算法时，很多书籍资料都是按照类别进行分类学习的，比如先学分治、动态规划，再学贪心等。本博客的部分文章将根据作者本人的刷题经历，以典型题、模板题、系列题进行总结与发散，站在另一个角度审视这些题目，从而看清问题的本质与事物的全貌。</p>\n<p>经典黑书《算法导论》在介绍分治算法时选择了以最大子数组问题为教学案例进行讲解，本文将继续通过这个问题的解决方案进行发散探讨，以串联各种各样的知识。</p>\n<p>最大子数组问题：给定数组 A，寻找其中一个 「和最大的子数组」。只有数组中包含负数时，最大子数组问题才有意义。</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨<a href=\"https://leetcode.cn/problems/maximum-subarray/description/\">53. 最大子数组和 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>子数组：数组中的一个连续非空序列。</p>\n</div></div><p>更多子数组的相关题目详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>动态规划以及题单</a></p>\n<h1 id=\"解决方法\"><a class=\"markdownIt-Anchor\" href=\"#解决方法\"></a> 解决方法</h1>\n<h2 id=\"传统分治解法\"><a class=\"markdownIt-Anchor\" href=\"#传统分治解法\"></a> 传统分治解法</h2>\n\n<div class=\"callout\" data-callout=\"warning\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-alert-triangle\"><path d=\"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z\"/><path d=\"M12 9v4\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">本小节引自《算法导论》第四章内容。本分治策略并不一定是解决这道题的最佳方案。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>假定我们要寻找子数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[low..high]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">]</span></span></span></span> 的最大子数组，利用分治技术划分为两个规模尽量相等的子数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mtext> </mtext><mi>A</mi><mo stretchy=\"false\">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1..</mn><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[low..mid],~A[mid+1..high]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace nobreak\"> </span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">]</span></span></span></span>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[low..high]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">]</span></span></span></span> 的一个最大子数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[i..j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 必然是以下三种情况之一：</p>\n<ol>\n<li>完全位于子数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[low..mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">]</span></span></span></span> （左子数组）中，因此 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">low\\leq i\\leq j\\leq mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span></li>\n<li>完全位于子数组 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1..</mn><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[mid+1..high]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">]</span></span></span></span> （右子树组）中，因此 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">mid&lt; i\\leq j\\leq high</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span></span></span></span></li>\n<li>跨越了中点，因此 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">low\\leq i\\leq mid&lt;j\\leq high</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span></span></span></span><br />\n前两种情况实际上仍是最大数组问题，只是规模更小。我们的工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</li>\n</ol>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20231120201552.webp\" alt=\"image.png\" /></p>\n<p>我们可以在线性时间内求出跨越中点的最大子数组：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20231120232924.webp\" alt=\"image.png\" width=\"500px\" /></p>\n<p><code>FIND-MAX-CROSSING-SUBARRAY</code> 花费时间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Theta(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>求解最大子数组问题的分治算法的伪代码：</p>\n<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FIND-MAXMUM-SUBARRAY(A,low,high)</span><br><span class=\"line\">\t<span class=\"comment\">// 基本情况：只有一个元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> high==low</span><br><span class=\"line\">\t\treturn (low,high,A[low]) </span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tmid = (int)(low+high)/<span class=\"number\">2</span> <span class=\"comment\">// 向下取整</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 左边情况</span></span><br><span class=\"line\">\t\t(left-low,left-high,left-sum)=FIND-MAXMUM-SUBARRAY(A,low,mid)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 右边情况</span></span><br><span class=\"line\">\t\t(right-low,right-high,right-sum)=FIND-MAXMUM-SUBARRAY(A,mid+<span class=\"number\">1</span>,high)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 中间情况</span></span><br><span class=\"line\">\t\t(cross-low,cross-high,cross-sum)=FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 比较三种情况的sum值，返回sum最大值所在的三元组</span></span><br><span class=\"line\">\t\treturn (max-low,max-high,max-sum)</span><br></pre></td></tr></table></figure>\n<p>运行时间的递归式：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.3599999999999999em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>2</mn><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">T(n) = \n\\begin{cases}\n\\Theta(1) &amp; \\text{if}~ n=1 \\\\\n2T(n /2)+\\Theta(n) &amp; \\text{if}~ n&gt;1\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if</span></span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if</span></span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>解为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(n)=\\Theta(n \\lg n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">l<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，需要常数个变量用于选取最大值，需要使用的空间取决于递归栈的深度。</p>\n<h2 id=\"动态规划\"><a class=\"markdownIt-Anchor\" href=\"#动态规划\"></a> 动态规划</h2>\n<p>假设 <code>nums</code> 数组的长度是 <code>n</code>，下标从 <code>0</code> 到 <code>n-1</code>。</p>\n<p>我们用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 代表<strong>以第 i 个数结尾的「连续子数组的最大和」</strong>，那么很显然我们要求的答案就是：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><munder><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munder><mo stretchy=\"false\">{</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\max_{0\\le i \\le n-1}\\{ f(i) \\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.572843em;vertical-align:-0.822843em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43055999999999994em;\"><span style=\"top:-2.372336em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop\">max</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.822843em;\"><span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mclose\">}</span></span></span></span></span></p>\n<p>因此我们只需要求出每个位置的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>，然后返回 f 数组中的最大值即可。动态规划转移方程：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">{</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">f(i)=\\max\\{f(i-1)+nums[i],nums[i]\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span></span></p>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">请注意 DP 数组的定义</div>\n</div>\n<div class=\"callout-content\"><p>本题 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> 定义为以第 i 个数结尾的「连续子数组的最大和」，就是说计算时<strong>必须包括第 i 个数</strong>。</p>\n<p>传统上，我们可能将 DP 数组定义为：<code>dp[i]</code> 表示“从 0 至 i 处的所有子数组中子数组元素之和的最大值”，然后最后将 <code>dp[n-1]</code> 返回出去就行。但在这个问题中其所求是子数组元素之和的最大值，它相当于对之前的多个元素有依赖关系，如果那样定义的话，则无法建立 <code>dp[i+1]</code> 和 <code>dp[i]</code> 之间的递推关系。</p>\n</div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 普通的动态规划写法 空间复杂度为 O(n)</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">\tdp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">maxAns</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class=\"line\">\t\tdp[i] = Math.max(dp[i-<span class=\"number\">1</span>] + nums[i], nums[i]);</span><br><span class=\"line\">\t\tmaxAns = Math.max(maxAns,dp[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里并不是将dp[nums.length-1]直接返回出去，因为这里dp定义的内容并不是题目的答案</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> maxAns; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// Kadane’s Algorithm 空间复杂度为 O(1)。Kadane 算法是基础动态规划的优化。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, maxAns = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums) &#123;</span><br><span class=\"line\">\t\tpre = Math.max(pre + x, x);</span><br><span class=\"line\">\t\tmaxAns = Math.max(maxAns, pre);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> maxAns;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><code>pre</code> 和 <code>maxAns</code> 的初始值</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>如果题目写到子数组非空，那么初始值为第一个元素 <code>nums[0]</code></li>\n<li>如果题目提到子数组可能为空，那么初始值可为 0</li>\n</ul>\n</div></div><p>复杂度：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">O(n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span></span></span></span>)，其中 <code>n</code> 为 <code>nums</code> 数组的长度。我们只需要遍历一遍数组即可求得答案。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。我们只需要常数空间存放若干变量。</li>\n</ul>\n\n<details class=\"callout\" data-callout=\"cite\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-quote\"><path d=\"M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z\"/><path d=\"M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">关于 Kadane’s Algorithm</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>Kadane’s Algorithm 这名字听起来确实挺高大上的。但是我有一个疑惑——所谓 Kadane’s Algorithm 就是指这种压缩空间的技巧吗？为此我收集了以下资料作为参考。</p>\n<ol>\n<li>\n<p><a href=\"https://leetcodethehardway.com/tutorials/basic-topics/kadane\">Kadane Algorithm | LeetCode The Hard Way</a><br />\nThe Kadane’s algorithm is a well-known method for solving the problem of finding the maximum sum of a contiguous subarray of a given array of numbers. The basic idea behind the algorithm is to iterate through the array, keeping track of the maximum sum seen so far and the current sum, and updating the maximum sum whenever a new maximum is found. The algorithm has a time complexity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>\n</li>\n<li>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\">动态规划 - 维基百科，自由的百科全书 (wikipedia.org)</a><br />\n使用动态规划的算法有：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/6c1e0ffd/\"><span class=\"bilink-pop-up\">站内文章</span>最长公共子序列</a>、Floyd-Warshall 算法、Viterbi 算法、<strong>Kadane’s algorithm</strong>、求解马可夫决策过程下最佳策略、莱文斯坦距离。</p>\n</li>\n<li>\n<p>知乎网友 <a href=\"https://www.zhihu.com/people/vincent-fong\">@Vincent Fong</a><br />\n《论算法领域的俚语》：<strong>Kadane 算法</strong>、状压 dp、用滚动变量代替一维数组、动态规划之空间复杂度 O(n) 优化到 O(1)…其实说的都是同一个事情。</p>\n</li>\n</ol>\n<p>总结：Kadane 算法特指解决最大子数组和的一种巧妙的方法，是动态规划思想的一种体现，并使用了状态压缩的技巧。运用 Kadane 算法的思想，可以解决一些「最大子段和」类型的问题。</p>\n</div></details><h2 id=\"前缀和\"><a class=\"markdownIt-Anchor\" href=\"#前缀和\"></a> 前缀和</h2>\n<p>本小节方法灵感来源于 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/41280b89/\"><span class=\"bilink-pop-up\">站内文章</span>「买卖股票的最佳时机」</a> 这个题目，建议先了解一下题解中「一次遍历」方案。点击链接即可直达本站文章查看问题解法。</p>\n<p>如果你已经理解「买卖股票的最佳时机」中一次遍历的算法思路，下面回到本文的「最大子数组问题」的前缀和解决思路：</p>\n<ul>\n<li>计算数组的前缀和。比如 <code>nums=[5,4,-1,7,8]</code> 得到 <code>arr=[5,9,8,15,23]</code>。</li>\n<li>原题目的求解变为：找出当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i&lt;j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 时，<code>arr[j]-arr[i]</code> 最大的值。</li>\n<li>和 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description\">121. 买卖股票的最佳时机</a> 不同的是，本题需要考虑答案子数组长度不为 0，且长度可能拉满。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;        </span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">\t\tsum+=nums[i];            </span><br><span class=\"line\">\t\tans=Math.max(Math.max(ans,sum-min),sum);<span class=\"comment\">// 比较sum是基于子数组往前拉满的情况</span></span><br><span class=\"line\">\t\tmin=Math.min(min,sum); <span class=\"comment\">// 注意：维护历史min在后头</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>连续子数组问题通常可以考虑使用前缀和的方法求解，详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/59af443f/\"><span class=\"bilink-pop-up\">站内文章</span>前后缀分解的应用</a>。</p>\n<h2 id=\"分治法之线段树\"><a class=\"markdownIt-Anchor\" href=\"#分治法之线段树\"></a> 分治法之线段树</h2>\n<p>这个分治方法类似于「线段树求解最长公共上升子序列问题」的 <code>pushUp</code> 操作。</p>\n<p>对于一个区间 <code>[l,r]</code>，我们取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy=\"false\">⌊</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">m=\\lfloor \\frac{l+r}{2} \\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span>，对区间 <code>[l,m]</code> 和 <code>[m+1,r]</code> 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。这个时候我们考虑如何通过 <code>[l,m]</code> 区间的信息和 <code>[m+1,r]</code> 区间的信息合并成区间 <code>[l,r]</code> 的信息。</p>\n<p>对于一个区间 <code>[l,r]</code>，我们可以维护四个量：</p>\n<ul>\n<li><code>lSum</code> 表示 <code>[l,r]</code> 内以 <code>l</code> 为左端点的最大子段和</li>\n<li><code>rSum</code> 表示 <code>[l,r]</code> 内以 <code>r</code> 为右端点的最大子段和</li>\n<li><code>mSum</code> 表示 <code>[l,r]</code> 内的最大子段和</li>\n<li><code>iSum</code> 表示 <code>[l,r]</code> 的区间和</li>\n</ul>\n<p>以下简称 <code>[l,m]</code> 为 <code>[l,r]</code> 的「左子区间」，<code>[m+1,r]</code> 为 <code>[l,r]</code> 的「右子区间」。对于长度为 1 的区间 <code>[i,i]</code>，四个量的值都和 <code>nums[i]</code> 相等。对于长度大于 1 的区间：</p>\n<ul>\n<li>首先最好维护的是 <code>iSum</code>，区间 <code>[l,r]</code> 的 <code>iSum</code> 就等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>iSum</code>。</li>\n<li>对于 <code>[l,r]</code> 的 <code>lSum</code>，存在两种可能，它要么等于「左子区间」的 <code>lSum</code>，要么等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>lSum</code>，二者取大。</li>\n<li>对于 <code>[l,r]</code> 的 <code>rSum</code>，同理，它要么等于「右子区间」的 <code>rSum</code>，要么等于「右子区间」的 <code>iSum</code> 加上「左子区间」的 <code>rSum</code>，二者取大。</li>\n<li>当计算好上面的三个量之后，就很好计算 <code>[l,r]</code> 的 <code>mSum</code> 了。我们可以考虑 <code>[l,r]</code> 的 <code>mSum</code> 对应的区间是否跨越 <code>m</code>——它可能不跨越 <code>m</code>，也就是说 <code>[l,r]</code> 的 <code>mSum</code> 可能是「左子区间」的 <code>mSum</code> 和 「右子区间」的 <code>mSum</code> 中的一个；它也可能跨越 <code>m</code>，可能是「左子区间」的 <code>rSum</code> 和 「右子区间」的 <code>lSum</code> 求和。三者取大。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Status</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> lSum, rSum, mSum, iSum;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Status</span><span class=\"params\">(<span class=\"type\">int</span> lSum, <span class=\"type\">int</span> rSum, <span class=\"type\">int</span> mSum, <span class=\"type\">int</span> iSum)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.lSum = lSum;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rSum = rSum;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.mSum = mSum;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.iSum = iSum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInfo(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>).mSum; <span class=\"comment\">// 取 Status 实例的 mSum</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Status <span class=\"title function_\">getInfo</span><span class=\"params\">(<span class=\"type\">int</span>[] a, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Status</span>(a[l], a[l], a[l], a[l]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// l==r 时已经终止，不会产生 m+1&gt;r</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">Status</span> <span class=\"variable\">lSub</span> <span class=\"operator\">=</span> getInfo(a, l, m);</span><br><span class=\"line\">        <span class=\"type\">Status</span> <span class=\"variable\">rSub</span> <span class=\"operator\">=</span> getInfo(a, m + <span class=\"number\">1</span>, r); <span class=\"comment\">// 不用担心 m+1&gt;r </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pushUp(lSub, rSub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Status <span class=\"title function_\">pushUp</span><span class=\"params\">(Status l, Status r)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">iSum</span> <span class=\"operator\">=</span> l.iSum + r.iSum;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lSum</span> <span class=\"operator\">=</span> Math.max(l.lSum, l.iSum + r.lSum);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rSum</span> <span class=\"operator\">=</span> Math.max(r.rSum, r.iSum + l.rSum);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mSum</span> <span class=\"operator\">=</span> Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Status</span>(lSum, rSum, mSum, iSum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设序列 a 的长度为 n。</p>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow></msubsup><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\sum_{i=1}^{\\log n} 2^{i-1}) = O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029000000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，故渐进时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度：递归会使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的栈空间，故渐进空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/10ab676/\"><span class=\"bilink-pop-up\">站内文章</span>线段树</a></div>\n</div>\n<div class=\"callout-content\"><p>「线段树方法」相较于「动态规划算法」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p>\n<p>对于这道题而言，确实是如此的。但是仔细观察「线段树方法」，它不仅可以解决区间 <code>[0,n-1]</code>，还可以用于解决任意的子区间 <code>[l,r]</code> 的问题。如果我们把 <code>[0,n-1]</code> 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一棵真正的树之后，我们就可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是一种神奇的数据结构——线段树。</p>\n</div></div><h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《算法导论》第四章</li>\n<li><a href=\"https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/\">53. 最大子数组和 - 题解 - 力扣（LeetCode）</a></li>\n<li><a href=\"https://blog.csdn.net/nirendao/article/details/134762324\">简介Kadane算法及相关的普通动态规划-CSDN博客</a></li>\n<li><a href=\"https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?envType=study-plan-v2&amp;envId=top-interview-150\">经典动态规划问题（理解「无后效性」） - 力扣（LeetCode）</a></li>\n</ul>\n","raw":"---\ntitle: 最大子数组问题\ntags:\n  - LeetCode\n  - Java\n  - 动态规划\n  - 分治\n  - 线段树\n  - 前缀和\ncover: 'https://cdn.gallery.uuanqin.top/img/202409050042734.webp'\ndescription: 一道例题引出的多种解法探讨\ncategories:\n  - 算法与数据结构\nabbrlink: 19c8c246\nkatex: true\ndate: 2024-09-01 22:30:58\ntop_img:\n---\n\n在学习算法时，很多书籍资料都是按照类别进行分类学习的，比如先学分治、动态规划，再学贪心等。本博客的部分文章将根据作者本人的刷题经历，以典型题、模板题、系列题进行总结与发散，站在另一个角度审视这些题目，从而看清问题的本质与事物的全貌。\n\n经典黑书《算法导论》在介绍分治算法时选择了以最大子数组问题为教学案例进行讲解，本文将继续通过这个问题的解决方案进行发散探讨，以串联各种各样的知识。\n\n最大子数组问题：给定数组 A，寻找其中一个 「和最大的子数组」。只有数组中包含负数时，最大子数组问题才有意义。\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n> [!example] 题目：🟨[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)\n> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n> 子数组：数组中的一个连续非空序列。\n\n更多子数组的相关题目详见：[[动态规划以及题单]]\n\n# 解决方法\n\n## 传统分治解法\n\n> [!warning] 本小节引自《算法导论》第四章内容。本分治策略并不一定是解决这道题的最佳方案。\n\n假定我们要寻找子数组 $A[low..high]$ 的最大子数组，利用分治技术划分为两个规模尽量相等的子数组 $A[low..mid],~A[mid+1..high]$。$A[low..high]$ 的一个最大子数组 $A[i..j]$ 必然是以下三种情况之一：\n\n1. 完全位于子数组 $A[low..mid]$ （左子数组）中，因此 $low\\leq i\\leq j\\leq mid$\n2. 完全位于子数组 $A[mid+1..high]$ （右子树组）中，因此 $mid< i\\leq j\\leq high$\n3. 跨越了中点，因此 $low\\leq i\\leq mid<j\\leq high$\n前两种情况实际上仍是最大数组问题，只是规模更小。我们的工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20231120201552.webp)\n\n我们可以在线性时间内求出跨越中点的最大子数组：\n\n![image.png|500](https://cdn.gallery.uuanqin.top/img/20231120232924.webp)\n\n`FIND-MAX-CROSSING-SUBARRAY` 花费时间 $\\Theta(n)$。\n\n求解最大子数组问题的分治算法的伪代码：\n\n```pascal\nFIND-MAXMUM-SUBARRAY(A,low,high)\n\t// 基本情况：只有一个元素\n\tif high==low\n\t\treturn (low,high,A[low]) \n\telse\n\t\tmid = (int)(low+high)/2 // 向下取整\n\t\t// 左边情况\n\t\t(left-low,left-high,left-sum)=FIND-MAXMUM-SUBARRAY(A,low,mid)\n\t\t// 右边情况\n\t\t(right-low,right-high,right-sum)=FIND-MAXMUM-SUBARRAY(A,mid+1,high)\n\t\t// 中间情况\n\t\t(cross-low,cross-high,cross-sum)=FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)\n\t\t// 比较三种情况的sum值，返回sum最大值所在的三元组\n\t\treturn (max-low,max-high,max-sum)\n```\n\n运行时间的递归式：\n\n$$\nT(n) = \n\\begin{cases}\n\\Theta(1) & \\text{if}~ n=1 \\\\\n2T(n /2)+\\Theta(n) & \\text{if}~ n>1\n\\end{cases}\n$$\n\n解为 $T(n)=\\Theta(n \\lg n)$。\n\n空间复杂度：$O(\\log n)$，需要常数个变量用于选取最大值，需要使用的空间取决于递归栈的深度。\n\n## 动态规划\n\n假设 `nums` 数组的长度是 `n`，下标从 `0` 到 `n-1`。\n\n我们用 $f(i)$ 代表**以第 i 个数结尾的「连续子数组的最大和」**，那么很显然我们要求的答案就是：\n\n$$\n\\max_{0\\le i \\le n-1}\\{ f(i) \\}\n$$\n\n因此我们只需要求出每个位置的 $f(i)$，然后返回 f 数组中的最大值即可。动态规划转移方程：\n\n$$\nf(i)=\\max\\{f(i-1)+nums[i],nums[i]\\}\n$$\n\n\n> [!NOTE] 请注意 DP 数组的定义\n> 本题 $f(i)$ 定义为以第 i 个数结尾的「连续子数组的最大和」，就是说计算时**必须包括第 i 个数**。\n>\n> 传统上，我们可能将 DP 数组定义为：`dp[i]` 表示“从 0 至 i 处的所有子数组中子数组元素之和的最大值”，然后最后将 `dp[n-1]` 返回出去就行。但在这个问题中其所求是子数组元素之和的最大值，它相当于对之前的多个元素有依赖关系，如果那样定义的话，则无法建立 `dp[i+1]` 和 `dp[i]` 之间的递推关系。\n\n\n```java\n // 普通的动态规划写法 空间复杂度为 O(n)\n public int maxSubArray(int[] nums) {\n\tint[] dp = new int[nums.length];\n\tdp[0] = nums[0];\n\tint maxAns = nums[0];\n\tfor (int i=1;i<nums.length;i++) {\n\t\tdp[i] = Math.max(dp[i-1] + nums[i], nums[i]);\n\t\tmaxAns = Math.max(maxAns,dp[i]);\n\t}\n\t// 这里并不是将dp[nums.length-1]直接返回出去，因为这里dp定义的内容并不是题目的答案\n\treturn maxAns; \n}\n \n // Kadane’s Algorithm 空间复杂度为 O(1)。Kadane 算法是基础动态规划的优化。\npublic int maxSubArray(int[] nums) {\n\tint pre = 0, maxAns = nums[0];\n\tfor (int x : nums) {\n\t\tpre = Math.max(pre + x, x);\n\t\tmaxAns = Math.max(maxAns, pre);\n\t}\n\treturn maxAns;\n}\n\n```\n\n> [!note] `pre` 和 `maxAns` 的初始值\n> - 如果题目写到子数组非空，那么初始值为第一个元素 `nums[0]`\n> - 如果题目提到子数组可能为空，那么初始值可为 0\n\n复杂度：\n\n- 时间复杂度：$O(n$)，其中 `n` 为 `nums` 数组的长度。我们只需要遍历一遍数组即可求得答案。\n- 空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。\n\n> [!cite]- 关于 Kadane's Algorithm\n> Kadane’s Algorithm 这名字听起来确实挺高大上的。但是我有一个疑惑——所谓 Kadane’s Algorithm 就是指这种压缩空间的技巧吗？为此我收集了以下资料作为参考。\n>\n> 1. [Kadane Algorithm | LeetCode The Hard Way](https://leetcodethehardway.com/tutorials/basic-topics/kadane)\n>    The Kadane's algorithm is a well-known method for solving the problem of finding the maximum sum of a contiguous subarray of a given array of numbers. The basic idea behind the algorithm is to iterate through the array, keeping track of the maximum sum seen so far and the current sum, and updating the maximum sum whenever a new maximum is found. The algorithm has a time complexity of $O(n)$.\n>\n> 2. [动态规划 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)\n>    使用动态规划的算法有：[[一起撸串（字符串）|最长公共子序列]]、Floyd-Warshall 算法、Viterbi 算法、**Kadane's algorithm**、求解马可夫决策过程下最佳策略、莱文斯坦距离。\n>\n> 3. 知乎网友 [@Vincent Fong](https://www.zhihu.com/people/vincent-fong)\n>    《论算法领域的俚语》：**Kadane 算法**、状压 dp、用滚动变量代替一维数组、动态规划之空间复杂度 O(n) 优化到 O(1)......其实说的都是同一个事情。\n>\n> 总结：Kadane 算法特指解决最大子数组和的一种巧妙的方法，是动态规划思想的一种体现，并使用了状态压缩的技巧。运用 Kadane 算法的思想，可以解决一些「最大子段和」类型的问题。\n\n## 前缀和\n\n本小节方法灵感来源于 [[买卖股票的最佳时机|「买卖股票的最佳时机」]] 这个题目，建议先了解一下题解中「一次遍历」方案。点击链接即可直达本站文章查看问题解法。\n\n如果你已经理解「买卖股票的最佳时机」中一次遍历的算法思路，下面回到本文的「最大子数组问题」的前缀和解决思路：\n\n- 计算数组的前缀和。比如 `nums=[5,4,-1,7,8]` 得到 `arr=[5,9,8,15,23]`。\n- 原题目的求解变为：找出当 $i<j$ 时，`arr[j]-arr[i]` 最大的值。\n- 和 [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description) 不同的是，本题需要考虑答案子数组长度不为 0，且长度可能拉满。\n\n```java\npublic int maxSubArray(int[] nums) {        \n\tint sum = nums[0];\n\tint min = nums[0];\n\tint ans = nums[0];\n\tfor(int i=1;i<nums.length;i++){\n\t\tsum+=nums[i];            \n\t\tans=Math.max(Math.max(ans,sum-min),sum);// 比较sum是基于子数组往前拉满的情况\n\t\tmin=Math.min(min,sum); // 注意：维护历史min在后头\n\t}\n\treturn ans;\n}\n```\n\n连续子数组问题通常可以考虑使用前缀和的方法求解，详看：[[前后缀分解的应用]]。\n\n## 分治法之线段树\n\n这个分治方法类似于「线段树求解最长公共上升子序列问题」的 `pushUp` 操作。\n\n对于一个区间 `[l,r]`，我们取 $m=\\lfloor \\frac{l+r}{2} \\rfloor$，对区间 `[l,m]` 和 `[m+1,r]` 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。这个时候我们考虑如何通过 `[l,m]` 区间的信息和 `[m+1,r]` 区间的信息合并成区间 `[l,r]` 的信息。\n\n对于一个区间 `[l,r]`，我们可以维护四个量：\n\n- `lSum` 表示 `[l,r]` 内以 `l` 为左端点的最大子段和\n- `rSum` 表示 `[l,r]` 内以 `r` 为右端点的最大子段和\n- `mSum` 表示 `[l,r]` 内的最大子段和\n- `iSum` 表示 `[l,r]` 的区间和\n\n以下简称 `[l,m]` 为 `[l,r]` 的「左子区间」，`[m+1,r]` 为 `[l,r]` 的「右子区间」。对于长度为 1 的区间 `[i,i]`，四个量的值都和 `nums[i]` 相等。对于长度大于 1 的区间：\n\n- 首先最好维护的是 `iSum`，区间 `[l,r]` 的 `iSum` 就等于「左子区间」的 `iSum` 加上「右子区间」的 `iSum`。\n- 对于 `[l,r]` 的 `lSum`，存在两种可能，它要么等于「左子区间」的 `lSum`，要么等于「左子区间」的 `iSum` 加上「右子区间」的 `lSum`，二者取大。\n- 对于 `[l,r]` 的 `rSum`，同理，它要么等于「右子区间」的 `rSum`，要么等于「右子区间」的 `iSum` 加上「左子区间」的 `rSum`，二者取大。\n- 当计算好上面的三个量之后，就很好计算 `[l,r]` 的 `mSum` 了。我们可以考虑 `[l,r]` 的 `mSum` 对应的区间是否跨越 `m`——它可能不跨越 `m`，也就是说 `[l,r]` 的 `mSum` 可能是「左子区间」的 `mSum` 和 「右子区间」的 `mSum` 中的一个；它也可能跨越 `m`，可能是「左子区间」的 `rSum` 和 「右子区间」的 `lSum` 求和。三者取大。\n\n```java\nclass Solution {\n    public class Status {\n        public int lSum, rSum, mSum, iSum;\n\n        public Status(int lSum, int rSum, int mSum, int iSum) {\n            this.lSum = lSum;\n            this.rSum = rSum;\n            this.mSum = mSum;\n            this.iSum = iSum;\n        }\n    }\n\n    public int maxSubArray(int[] nums) {\n        return getInfo(nums, 0, nums.length - 1).mSum; // 取 Status 实例的 mSum\n    }\n\n    public Status getInfo(int[] a, int l, int r) {\n        if (l == r) {\n            return new Status(a[l], a[l], a[l], a[l]);\n        }\n        // l==r 时已经终止，不会产生 m+1>r\n        int m = (l + r) >> 1;\n        Status lSub = getInfo(a, l, m);\n        Status rSub = getInfo(a, m + 1, r); // 不用担心 m+1>r \n        return pushUp(lSub, rSub);\n    }\n\n    public Status pushUp(Status l, Status r) {\n        int iSum = l.iSum + r.iSum;\n        int lSum = Math.max(l.lSum, l.iSum + r.lSum);\n        int rSum = Math.max(r.rSum, r.iSum + l.rSum);\n        int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);\n        return new Status(lSum, rSum, mSum, iSum);\n    }\n}\n```\n\n假设序列 a 的长度为 n。\n\n复杂度分析：\n\n- 时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 $O(\\log n)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\\sum_{i=1}^{\\log n} 2^{i-1}) = O(n)$，故渐进时间复杂度为 $O(n)$。\n- 空间复杂度：递归会使用 $O(\\log n)$ 的栈空间，故渐进空间复杂度为 $O(\\log n)$。\n\n> [!hint] [[线段树模板的理解和使用|线段树]]\n> 「线段树方法」相较于「动态规划算法」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？\n>\n> 对于这道题而言，确实是如此的。但是仔细观察「线段树方法」，它不仅可以解决区间 `[0,n-1]`，还可以用于解决任意的子区间 `[l,r]` 的问题。如果我们把 `[0,n-1]` 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一棵真正的树之后，我们就可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(\\log n)$ 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是一种神奇的数据结构——线段树。\n\n\n# 本文参考\n- 《算法导论》第四章\n- [53. 最大子数组和 - 题解 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/)\n- [简介Kadane算法及相关的普通动态规划-CSDN博客](https://blog.csdn.net/nirendao/article/details/134762324)\n- [经典动态规划问题（理解「无后效性」） - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?envType=study-plan-v2&envId=top-interview-150)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"动态规划","api":"api/tags/动态规划.json"},{"name":"线段树","api":"api/tags/线段树.json"},{"name":"前缀和","api":"api/tags/前缀和.json"},{"name":"分治","api":"api/tags/分治.json"}]},"api":"api/posts/p/19c8c246.json"}