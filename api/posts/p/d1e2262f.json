{"data":{"title":"观察者模式：订阅与推送","slug":"高质量代码及设计模式/观察者模式：订阅与推送","description":"发送状态变化通知","date":"2025-08-20T15:19:35.000Z","updated":"2025-08-31T09:51:29.092Z","language":"zh-CN","comments":true,"url":"p/d1e2262f/","cover":"https://cdn.gallery.uuanqin.top/img/202508262345256.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311749045.webp\" alt=\"image.png\" width=\"375px\" /></p>\n\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">观察者模式 Observer Design Pattern / 发布订阅模式 Publish-Subscribe Design Pattern</div>\n</div>\n<div class=\"callout-content\"><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.——GoF<br />\n在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>\n</div></div><p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>\n<blockquote>\n<p>Observer 本来的意思是「观察者」，但实际上 <code>Observer</code> 角色并非主动地去观察，而是被动地接受来自 <code>Subject</code> 角色的通知。因此，观察者模式也被称为 Publish-Subscribe（发布 - 订阅）模式。《图解设计模式》的作者也认为 Publish（发布） 和 Subscribe（订阅） 这个名字可能更加合适。</p>\n</blockquote>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202502280259324.webp\" alt=\"image.png\" width=\"275px\" /></p>\n<p>登场角色：</p>\n<ul>\n<li><code>Subject</code>（被观察对象）：Subject 角色表示被观察对象。<code>Subject</code> 角色定义了注册观察者和删除观察者的方法。此外，它还声明了「获取现在的状态」的方法。</li>\n<li><code>ConcreteSubject</code>（具体的观察对象）：<code>ConcreteSubject</code> 角色表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的 <code>Observer</code> 角色。</li>\n<li><code>Observer</code>（观察者)：<code>Observer</code> 角色负责接收来自 <code>Subject</code> 角色的状态变化的通知。为此，它声明了 <code>update</code> 方法。</li>\n<li><code>ConcreteObserver</code>（具体的观察者）：<code>ConcreteObserver</code> 角色表示具体的 <code>Observer</code>。当它的 <code>update</code> 方法被调用后，会去获取要观察的对象的最新状态。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202502280259108.webp\" alt=\"image.png\" /></p>\n<p>方法说明：</p>\n<ul>\n<li><code>getSubjectStatus</code> 是给 <code>Observer</code> 获取状态用的。</li>\n<li><code>notifyObserver</code> 调用 <code>Observer</code> 的 <code>update</code> 方法时，是把自己 <code>this</code> 传了过去。比如示例程序中 <code>notifyObserver</code> 是这样写的：</li>\n</ul>\n<p>一种经典的实现方式（同步阻塞实现方式）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">registerObserver</span><span class=\"params\">(Observer observer)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">removeObserver</span><span class=\"params\">(Observer observer)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">notifyObservers</span><span class=\"params\">(Message message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Message message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Observer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerObserver</span><span class=\"params\">(Observer observer)</span> &#123;</span><br><span class=\"line\">    observers.add(observer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeObserver</span><span class=\"params\">(Observer observer)</span> &#123;</span><br><span class=\"line\">    observers.remove(observer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyObservers</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Observer observer : observers) &#123;</span><br><span class=\"line\">      observer.update(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteObserverOne</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//<span class=\"doctag\">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteObserverTwo</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//<span class=\"doctag\">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ConcreteSubject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteSubject</span>();</span><br><span class=\"line\">    subject.registerObserver(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteObserverOne</span>());</span><br><span class=\"line\">    subject.registerObserver(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteObserverTwo</span>());</span><br><span class=\"line\">    subject.notifyObservers(<span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 <code>register</code> 函数还可以叫作 <code>attach</code>，<code>remove</code> 函数还可以叫作 <code>detach</code> 等等。</p>\n<p>拓展思路：</p>\n<ul>\n<li>可替换性。具体的被观察者不需要知道正在观察自己的是哪一个具体观察者。可替换性的设计思想：\n<ul>\n<li>利用抽象类和接口从具体类中抽出抽象方法</li>\n<li>在将实例作为参数传递至类中，或者在类的字段中保存实例时，不使用具体类型，而是使用抽象类型和接口</li>\n</ul>\n</li>\n<li>注意 <code>Observer</code> 的调用顺序。必须要保证 update 方法调用顺序改变时不会发生问题。</li>\n<li><code>Observer</code> 角色也有可能会触发 <code>Subject</code> 角色调用 <code>update</code> 方法，所以要注意不要导致循环调用。观察者不要改变被观察者。</li>\n<li>MVC 中的 Model 和 View 的关系与 <code>Subject</code> 角色和 <code>Observer</code> 角色的关系相对应。Model 是指操作「不依赖于显示形式的内部模型」的部分，View 则是管理 Model「怎样显示」的部分。通常情况下，一个 Model 对应多个 View。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开闭原则。无需修改发布者代码就能引入新的订阅者类（如果是发布者接口则可轻松引入发布者类）。</td>\n<td>订阅者的通知顺序是随机的。</td>\n</tr>\n<tr>\n<td>可以在运行时建立对象之间的联系。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>相关的设计模式：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>中介者模式</a></p>\n<ul>\n<li>在中介者模式中，有时会使用 <code>Observer</code> 模式来实现 <code>Mediator</code> 角色与 <code>Colleague</code> 角色之间的通信。</li>\n<li>就「<strong>发送状态变化通知</strong>」这一点而言，Mediator 模式与 Observer 模式是<strong>类似的</strong>。不过，两种模式中，通知的<strong>目的和视角不同</strong>。\n<ul>\n<li>在中介者模式中，虽然也会发送通知，不过那不过是为了对 <code>Colleague</code> 角色<strong>进行仲裁</strong>而已。</li>\n<li>而在观察者模式中，将 <code>Subject</code> 角色的状态变化通知给 <code>Observer</code> 角色的目的则主要是为了<strong>使 Subject 角色和 Observer 角色同步</strong>。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"观察者模式的实现方式\"><a class=\"markdownIt-Anchor\" href=\"#观察者模式的实现方式\"></a> 观察者模式的实现方式</h1>\n<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p>\n<p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>\n<h2 id=\"异步非阻塞的实现方式\"><a class=\"markdownIt-Anchor\" href=\"#异步非阻塞的实现方式\"></a> 异步非阻塞的实现方式</h2>\n<p>上一个章节介绍的示例模板代码是同步阻塞实现方式，这也是最经典的实现方式，他的作用是代码解耦。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。</p>\n<p>我们可以改造 <code>notifyObservers(Message message)</code>，使其成为异步非阻塞的实现方式：</p>\n<ol>\n<li>多线程实现方式</li>\n<li>引入框架，如 Google Guava EventBus</li>\n</ol>\n<p>异步非阻塞除了可以实现代码解耦外，还能提高代码的执行效率。</p>\n<h3 id=\"多线程实现方式\"><a class=\"markdownIt-Anchor\" href=\"#多线程实现方式\"></a> 多线程实现方式</h3>\n<p>多线程实现方式 1：观察者使用多线程处理消息。这种方式的缺点为频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteObserverX</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多线程实现方式 2：使用线程池通知观察者。尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 <code>notifyObservers()</code> 函数中，增加了这部分业务代码的维护成本。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Observer&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Executor executor; <span class=\"comment\">// 可通过构造函数初始化线程池</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyObservers</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Observer observer : observers) &#123;</span><br><span class=\"line\">\t  executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          observer.update(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们的业务更加复杂，需要在同步阻塞和异步非阻塞之间灵活切换，上面的代码显然无法满足这个需求。我们可以使用 Google Guava EventBus 框架解决这个问题。使用新的框架可以隐藏实现细节，降低开发难度，实现代码的复用，解耦业务与非业务代码。</p>\n<h3 id=\"使用-google-guava-eventbus\"><a class=\"markdownIt-Anchor\" href=\"#使用-google-guava-eventbus\"></a> 使用 Google Guava EventBus</h3>\n<p>在 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c61e522/\"><span class=\"yukari\">站内文章</span>EventBus 框架的简易实现</a> 这篇文章中，我们可以模仿 Google Guava EventBus，动手实现一个简单的框架，加深对观察者模式的理解。</p>\n<h2 id=\"其他实现方式\"><a class=\"markdownIt-Anchor\" href=\"#其他实现方式\"></a> 其他实现方式</h2>\n<p>在上面讲的场景中，不管是同步阻塞的实现方式还是异步非阻塞的实现方式，都是进程内的实现方式。对于跨进程、跨系统的观察者模式，我们可以使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>RPC</a> 接口执行通知操作。</p>\n<p>或者使用更优雅、更常用的方式——引入消息队列。消息队列将观察者和被观察者解耦得更加彻底，被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。不过这样会增加维护成本。</p>\n<h1 id=\"javautilobserver-接口\"><a class=\"markdownIt-Anchor\" href=\"#javautilobserver-接口\"></a> <code>java.util.Observer</code> 接口</h1>\n<p>Java 类库中的 <code>java.util.Observer</code> 接口和 <code>java.util.Observable</code> 类就是一种观察者模式。</p>\n<p><code>java.util.Observer</code> 接口中定义了以下方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span> <span class=\"params\">(Observable obj, Object arg)</span></span><br></pre></td></tr></table></figure>\n<p>而 <code>update</code> 方法的参数则接收到了如下内容：</p>\n<ul>\n<li><code>Observable</code> 类的实例是被观察的 <code>Subject</code> 角色。</li>\n<li><code>Object</code> 类的实例是附加信息</li>\n</ul>\n<p>我们一般不直接用这些接口实现 <code>Observer</code> 模式，因为 <code>java.util.Observer</code> 接口和 <code>java.util.observable</code> 类并不好用。理由很简单，传递给 <code>java.util.Observer</code> 接口的 <code>Subject</code> 角色必须是 <code>java.util.Observable</code> 类型（或者它的子类型）的。但 Java 只能单一继承，也就说如果 <code>Subject</code> 角色已经是某个类的子类了，那么它将无法继承 <code>java.util.observable</code> 类。</p>\n<p>Coad 书讲解了这个问题的解决办法。在该书介绍的观察者模式中，<code>Subject</code> 角色和 <code>Observer</code> 接口都被定义为 Java 的接口，这种观察者模式更容易使用。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》17 章</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/observer\">观察者设计模式</a></li>\n</ul>\n","raw":"---\ntitle: 观察者模式：订阅与推送\ntags:\n  - Java\n  - 设计模式\ndescription: 发送状态变化通知\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: d1e2262f\ndate: 2025-08-20 23:19:35\ncover: https://cdn.gallery.uuanqin.top/img/202508262345256.webp\ntop_img:\n---\n\n![image.png|375](https://cdn.gallery.uuanqin.top/img/202508311749045.webp)\n\n> [!tldr] 观察者模式 Observer Design Pattern / 发布订阅模式 Publish-Subscribe Design Pattern\n> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.——GoF\n> 在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。\n\n一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。\n\n> Observer 本来的意思是「观察者」，但实际上 `Observer` 角色并非主动地去观察，而是被动地接受来自 `Subject` 角色的通知。因此，观察者模式也被称为 Publish-Subscribe（发布 - 订阅）模式。《图解设计模式》的作者也认为 Publish（发布） 和 Subscribe（订阅） 这个名字可能更加合适。\n\n![image.png|275](https://cdn.gallery.uuanqin.top/img/202502280259324.webp)\n\n登场角色：\n\n- `Subject`（被观察对象）：Subject 角色表示被观察对象。`Subject` 角色定义了注册观察者和删除观察者的方法。此外，它还声明了「获取现在的状态」的方法。\n- `ConcreteSubject`（具体的观察对象）：`ConcreteSubject` 角色表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的 `Observer` 角色。\n- `Observer`（观察者)：`Observer` 角色负责接收来自 `Subject` 角色的状态变化的通知。为此，它声明了 `update` 方法。\n- `ConcreteObserver`（具体的观察者）：`ConcreteObserver` 角色表示具体的 `Observer`。当它的 `update` 方法被调用后，会去获取要观察的对象的最新状态。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202502280259108.webp)\n\n方法说明：\n\n- `getSubjectStatus` 是给 `Observer` 获取状态用的。\n- `notifyObserver` 调用 `Observer` 的 `update` 方法时，是把自己 `this` 传了过去。比如示例程序中 `notifyObserver` 是这样写的：\n\n一种经典的实现方式（同步阻塞实现方式）：\n\n```java\npublic interface Subject {\n  void registerObserver(Observer observer);\n  void removeObserver(Observer observer);\n  void notifyObservers(Message message);\n}\n\npublic interface Observer {\n  void update(Message message);\n}\n\npublic class ConcreteSubject implements Subject {\n  private List<Observer> observers = new ArrayList<Observer>();\n\n  @Override\n  public void registerObserver(Observer observer) {\n    observers.add(observer);\n  }\n\n  @Override\n  public void removeObserver(Observer observer) {\n    observers.remove(observer);\n  }\n\n  @Override\n  public void notifyObservers(Message message) {\n    for (Observer observer : observers) {\n      observer.update(message);\n    }\n  }\n}\n\npublic class ConcreteObserverOne implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO: 获取消息通知，执行自己的逻辑...\n    System.out.println(\"ConcreteObserverOne is notified.\");\n  }\n}\n\npublic class ConcreteObserverTwo implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO: 获取消息通知，执行自己的逻辑...\n    System.out.println(\"ConcreteObserverTwo is notified.\");\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ConcreteSubject subject = new ConcreteSubject();\n    subject.registerObserver(new ConcreteObserverOne());\n    subject.registerObserver(new ConcreteObserverTwo());\n    subject.notifyObservers(new Message());\n  }\n}\n\n```\n\n观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 `register` 函数还可以叫作 `attach`，`remove` 函数还可以叫作 `detach` 等等。\n\n拓展思路：\n\n- 可替换性。具体的被观察者不需要知道正在观察自己的是哪一个具体观察者。可替换性的设计思想：\n\t- 利用抽象类和接口从具体类中抽出抽象方法\n\t- 在将实例作为参数传递至类中，或者在类的字段中保存实例时，不使用具体类型，而是使用抽象类型和接口\n- 注意 `Observer` 的调用顺序。必须要保证 update 方法调用顺序改变时不会发生问题。\n- `Observer` 角色也有可能会触发 `Subject` 角色调用 `update` 方法，所以要注意不要导致循环调用。观察者不要改变被观察者。\n- MVC 中的 Model 和 View 的关系与 `Subject` 角色和 `Observer` 角色的关系相对应。Model 是指操作「不依赖于显示形式的内部模型」的部分，View 则是管理 Model「怎样显示」的部分。通常情况下，一个 Model 对应多个 View。\n\n\n| 优点                                            | 缺点            |\n| --------------------------------------------- | ------------- |\n| 开闭原则。无需修改发布者代码就能引入新的订阅者类（如果是发布者接口则可轻松引入发布者类）。 | 订阅者的通知顺序是随机的。 |\n| 可以在运行时建立对象之间的联系。                              |               |\n\n\n\n相关的设计模式：[[中介者模式：只有一个仲裁者|中介者模式]]\n\n- 在中介者模式中，有时会使用 `Observer` 模式来实现 `Mediator` 角色与 `Colleague` 角色之间的通信。\n- 就「**发送状态变化通知**」这一点而言，Mediator 模式与 Observer 模式是**类似的**。不过，两种模式中，通知的**目的和视角不同**。\n\t- 在中介者模式中，虽然也会发送通知，不过那不过是为了对 `Colleague` 角色**进行仲裁**而已。\n\t- 而在观察者模式中，将 `Subject` 角色的状态变化通知给 `Observer` 角色的目的则主要是为了**使 Subject 角色和 Observer 角色同步**。\n\n# 观察者模式的实现方式\n\n观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。\n\n根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。\n\n## 异步非阻塞的实现方式\n\n上一个章节介绍的示例模板代码是同步阻塞实现方式，这也是最经典的实现方式，他的作用是代码解耦。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。\n\n我们可以改造 `notifyObservers(Message message)`，使其成为异步非阻塞的实现方式：\n\n1. 多线程实现方式\n2. 引入框架，如 Google Guava EventBus\n\n异步非阻塞除了可以实现代码解耦外，还能提高代码的执行效率。\n\n### 多线程实现方式\n\n多线程实现方式 1：观察者使用多线程处理消息。这种方式的缺点为频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。\n\n```java\npublic class ConcreteObserverX implements Observer {\n  @Override\n  public void update(Message message) {\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        System.out.println(\"ConcreteObserverOne is notified.\");\n      }\n    });\n    thread.start();\n  }\n}\n```\n\n多线程实现方式 2：使用线程池通知观察者。尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 `notifyObservers()` 函数中，增加了这部分业务代码的维护成本。\n\n```java\npublic class ConcreteSubject implements Subject {\n  private List<Observer> observers = new ArrayList<Observer>();\n  private Executor executor; // 可通过构造函数初始化线程池\n  @Override\n  public void notifyObservers(Message message) {\n    for (Observer observer : observers) {\n\t  executor.execute(new Runnable() {\n        @Override\n        public void run() {\n          observer.update(message);\n        }\n      });\n    }\n  }\n}\n```\n\n如果我们的业务更加复杂，需要在同步阻塞和异步非阻塞之间灵活切换，上面的代码显然无法满足这个需求。我们可以使用 Google Guava EventBus 框架解决这个问题。使用新的框架可以隐藏实现细节，降低开发难度，实现代码的复用，解耦业务与非业务代码。\n\n### 使用 Google Guava EventBus\n\n在 [[EventBus 框架的简易实现]] 这篇文章中，我们可以模仿 Google Guava EventBus，动手实现一个简单的框架，加深对观察者模式的理解。\n\n## 其他实现方式\n\n在上面讲的场景中，不管是同步阻塞的实现方式还是异步非阻塞的实现方式，都是进程内的实现方式。对于跨进程、跨系统的观察者模式，我们可以使用 [[简易 RPC 调用框架的实现|RPC]] 接口执行通知操作。\n\n或者使用更优雅、更常用的方式——引入消息队列。消息队列将观察者和被观察者解耦得更加彻底，被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。不过这样会增加维护成本。\n\n# `java.util.Observer` 接口\n\nJava 类库中的 `java.util.Observer` 接口和 `java.util.Observable` 类就是一种观察者模式。\n\n`java.util.Observer` 接口中定义了以下方法。\n\n```java\npublic void update (Observable obj, Object arg)\n```\n\n而 `update` 方法的参数则接收到了如下内容：\n\n- `Observable` 类的实例是被观察的 `Subject` 角色。\n- `Object` 类的实例是附加信息\n\n我们一般不直接用这些接口实现 `Observer` 模式，因为 `java.util.Observer` 接口和 `java.util.observable` 类并不好用。理由很简单，传递给 `java.util.Observer` 接口的 `Subject` 角色必须是 `java.util.Observable` 类型（或者它的子类型）的。但 Java 只能单一继承，也就说如果 `Subject` 角色已经是某个类的子类了，那么它将无法继承 `java.util.observable` 类。\n\nCoad 书讲解了这个问题的解决办法。在该书介绍的观察者模式中，`Subject` 角色和 `Observer` 接口都被定义为 Java 的接口，这种观察者模式更容易使用。\n\n# 本文参考\n\n- 《图解设计模式》17 章\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [观察者设计模式](https://refactoringguru.cn/design-patterns/observer)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"}]},"api":"api/posts/p/d1e2262f.json"}