{"data":{"title":"最短路径算法","slug":"算法与数据结构/最短路径算法","description":"被机试难倒了，明明很熟悉的算法偏偏就是没有手写过","date":"2025-06-09T17:33:42.000Z","updated":"2025-06-11T16:29:38.927Z","language":"zh-CN","comments":true,"url":"p/9df73d67/","cover":"https://cdn.gallery.uuanqin.top/img/202506100113697.webp","images":[],"content":"<p>本节所有算法和优化算法均有对应的题目和 Java 代码，都附在文后了。</p>\n<table>\n<thead>\n<tr>\n<th>最短路算法</th>\n<th>Floyd</th>\n<th>Bellman-Ford</th>\n<th>Dijkstra</th>\n<th>Johnson（本文不涉及）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最短路类型</td>\n<td>每对结点之间的最短路</td>\n<td colspan=\"2\">单源最短路</td>\n<td>每对结点之间的最短路</td>\n</tr>\n<tr>\n<td>作用于</td>\n<td colspan=\"2\">任意图</td>\n<td>非负权图</td>\n<td>任意图</td>\n</tr>\n<tr>\n<td>能否检测负环</td>\n<td colspan=\"2\">✅</td>\n<td>❌</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>时间复杂度</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NM)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(M\\log M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>（优先队列）</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NM\\log M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"定义与定理\"><a class=\"markdownIt-Anchor\" href=\"#定义与定理\"></a> 定义与定理</h1>\n<blockquote>\n<p>不同教科书对于 walk、trail、path 的中文叫法不尽相同，注意区分！</p>\n</blockquote>\n<p><strong>途径 (walk)</strong>：途径是连接一连串顶点的边的序列，可以为有限或无限长度。形式化地说，一条有限途径 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 是一个边的序列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>e</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_1, e_2, \\ldots, e_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，使得存在一个顶点序列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_0, v_1, \\ldots, v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e_i = (v_{i-1}, v_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">i \\in [1, k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span>。这样的途径可以简写为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mo>→</mo><msub><mi>v</mi><mn>1</mn></msub><mo>→</mo><msub><mi>v</mi><mn>2</mn></msub><mo>→</mo><mo>⋯</mo><mo>→</mo><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_0 \\to v_1 \\to v_2 \\to \\cdots \\to v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。通常来说，边的数量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 被称作这条途径的 <strong>长度</strong>（如果边是带权的，长度通常指途径上的边权之和，题目中也可能另有定义）。</p>\n<p><strong>迹 (trail)</strong>：对于一条途径 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>，若 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>e</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_1, e_2, \\ldots, e_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 两两互不相同，则称 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 是一条迹。</p>\n<p><strong>路径 (path)</strong>，又称 <strong>简单路径 (simple path)</strong>：对于一条迹 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>，若其连接的点的序列中点两两不同，则称 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 是一条路径。</p>\n<p>为了方便叙述，本文约定以下记号的含义：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为图上点的数目，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 为图上边的数目；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 为最短路的源点；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(u)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 点的 <strong>实际</strong> 最短路长度；</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dis(u)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 点的 <strong>估计</strong> 最短路长度。任何时候都有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>≥</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dis(u) \\geq D(u)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span></span></span></span>。特别地，当最短路算法终止时，应有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dis(u)=D(u)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(u,v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> 为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u,v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> 这一条边的边权。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">一些最短路的性质</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>性质 1：对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。</li>\n<li>性质 2：对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。</li>\n<li>性质 3：对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过 n，边数不会超过 n-1。</li>\n</ul>\n</div></div><h1 id=\"floyd-算法\"><a class=\"markdownIt-Anchor\" href=\"#floyd-算法\"></a> Floyd 算法</h1>\n<p>可用于求任意两个结点之间的最短路径，可用于有向图或无向图，边权可正可负但最短路必须存在（不能有负环）。</p>\n<p>定义一个数组 <code>f[k][x][y]</code>，表示只允许经过结点 1 到 k（也就是说，在子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>k</mi></mrow></mrow><annotation encoding=\"application/x-tex\">V&#x27;={1, 2, \\ldots, k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span> 中的路径，注意，x 与 y 不一定在这个子图中），结点 x 到结点 y 的最短路长度。显然，<code>f[n][x][y]</code> 就是结点 x 到结点 y 的最短路长度。因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi></mrow></mrow><annotation encoding=\"application/x-tex\">V&#x27;={1, 2, \\ldots, n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> 即为 V 本身，其表示的最短路径就是所求路径。</p>\n<p>接下来考虑如何求出 f 数组的值。<code>f[0][i][j]</code> 表示一张图的边权，初始化方式：</p>\n<ul>\n<li>当 <code>i</code> 与 <code>j</code> 间有直接相连的边的时，<code>f[0][i][j] = w(i,j)</code></li>\n<li>当 <code>i == j</code> 时，<code>f[0][i][j] = 0</code></li>\n<li>当 <code>i</code> 与 <code>j</code> 没有直接相连的边的时。<code>f[0][i][j] = +∞</code></li>\n</ul>\n<p>推导方式：<code>f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])</code></p>\n<ul>\n<li><code>f[k-1][x][y]</code>：不经过 k 点的最短路径</li>\n<li><code>f[k-1][x][k]+f[k-1][k][y]</code>：经过了 k 点的最短路</li>\n</ul>\n<p>核心代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (k = <span class=\"number\">1</span>; k &lt;= n; k++)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (x = <span class=\"number\">1</span>; x &lt;= n; x++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (y = <span class=\"number\">1</span>; y &lt;= n; y++)</span><br><span class=\"line\">      f[k][x][y] = min(f[k - <span class=\"number\">1</span>][x][y], f[k - <span class=\"number\">1</span>][x][k] + f[k - <span class=\"number\">1</span>][k][y]);</span><br></pre></td></tr></table></figure>\n<p>熟悉 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>动态规划压缩空间写法</a> 的你一眼看出来，第一维对结果无影响可将其省略，于是可以直接改成 <code>f[x][y] = min(f[x][y], f[x][k]+f[k][y])</code>。</p>\n<p>综上，算法的复杂度为：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<h1 id=\"bellman-ford-算法\"><a class=\"markdownIt-Anchor\" href=\"#bellman-ford-算法\"></a> Bellman-Ford 算法</h1>\n<p>Bellman–Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。</p>\n<p>对边 (u,v) 进行松弛操作，意味着有：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dis(v) = \\min (dis(v), dis(u) + w(u, v))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>。Bellman–Ford 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。</p>\n<p>时间复杂度估计：</p>\n<ul>\n<li><strong>在最短路存在的情况下</strong>，一次松弛操作（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 时间复杂度）会使最短路的边数至少 +1，即每一轮松弛可以使某些点的最短路径边数上限增加 1。解释如下：\n<ul>\n<li>Bellman–Ford 的每一轮松弛可以将最短路径的信息沿着边传播 <strong>一步</strong>。</li>\n<li>第 1 轮松弛后，能正确求出从源点 s 出发、只经过 <strong>1 条边</strong> 的所有最短路径。</li>\n<li>第 2 轮松弛后，可以求出所有经过 <strong>最多 2 条边</strong> 的最短路径。</li>\n<li>依此类推，第 k 轮后，可以求出最多包含 k 条边的最短路径。</li>\n</ul>\n</li>\n<li>根据性质 3，最短路的边数最多为 n-1</li>\n<li>因此总时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nm)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>如果从 S 点出发，抵达一个负环时，松弛操作会无休止地进行下去。前面的论证已经说明对于最短路存在的图松弛操作最多会进行 n-1 轮。如果第 n 轮循环仍出现能松弛的边，<strong>说明从 S 点出发，能够抵达负环</strong>。</p>\n<p>即使第 n 轮循环仍出现能松弛的边，并不意味着图上不存在负环。如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman–Ford 算法。</p>\n<h2 id=\"spfa\"><a class=\"markdownIt-Anchor\" href=\"#spfa\"></a> SPFA</h2>\n<blockquote>\n<p>Shortest Path Faster Algorithm，SPFA，是 Bellman-Ford 的队列优化算法。它是西南交通大学段凡丁于 1994 年发表的论文中的名字。不过，段凡丁的证明是错误的，且在 Bellman-Ford 算法提出后不久（1957 年）已有队列优化内容，所以国际上不承认 SPFA 算法是段凡丁提出的。一般国内 OI 界中才有 SPFA 的说法。</p>\n</blockquote>\n<p>在 Bellman-Ford 中，有时候我们并不需要那么多无用的松弛操作。很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。</p>\n<p>我们用队列来维护「哪些结点可能会引起松弛操作」，就能只访问必要的边了。SPFA 也可以用于判断 S 点是否能抵达一个负环，只需记录最短路经过了多少条边，当经过了至少 n 条边时，说明 S 点可以抵达一个负环。</p>\n<p>虽然在大多数情况下 SPFA 跑得很快，但其最坏情况下的时间复杂度为 O(nm)。在没有负权边时最好使用 Dijkstra 算法。</p>\n<p>更多 Bellman–Ford 算法优化详看：<a href=\"https://www.zhihu.com/question/292283275/answer/484871888\">如何看待 SPFA 算法已死这种说法？ - 知乎</a></p>\n<h1 id=\"dijkstra-算法\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra-算法\"></a> Dijkstra 算法</h1>\n<p>Dijkstra（/ˈdikstrɑ/或/ˈdɛikstrɑ/）算法由荷兰计算机科学家 E. W. Dijkstra 于 1956 年发现，1959 年公开发表。是一种求解 <strong>非负权图</strong> 上单源最短路径的算法。</p>\n<h2 id=\"算法思想\"><a class=\"markdownIt-Anchor\" href=\"#算法思想\"></a> 算法思想</h2>\n<p>将图 G(V,E) 中结点集合 V 分成两组：</p>\n<ul>\n<li>已确定最短路长度的点集（记为 S 集合）。</li>\n<li>未确定最短路长度的点集（记为 T 集合）。一开始所有的点都属于 T 集合。</li>\n</ul>\n<p>初始化 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">dis(s)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，其他点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">dis</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span></span></span></span> 均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">+\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span></span></span></span>。这样，第一次操作时可将源点加入 S 集合中。</p>\n<p>然后重复这些操作：</p>\n<ol>\n<li>从 T 集合中，选取一个最短路长度最小的结点，移到 S 集合中。</li>\n<li>对那些刚刚被加入 S 集合的结点的所有出边执行松弛操作。</li>\n<li>直到 T 集合为空，算法结束。</li>\n</ol>\n<p>在操作的过程中每个结点对应一个距离 dis，S 中的结点的距离就是从 s 到此结点的最短路径长度；T 中的结点的距离，是从 s 到此结点只包含 S 中的结点为中间结点的当前最短路径长度。</p>\n\n<details class=\"callout\" data-callout=\"example\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子：Dijkstra 算法图示</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>一个总部和 6 个工地，求从总部到各工地的最短路径。<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240601171641.webp\" alt=\"image.png\" width=\"448px\" /></p>\n<p>解：<br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240601172538.webp\" alt=\"image.png\" width=\"500px\" /><br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240601172550.webp\" alt=\"image.png\" width=\"500px\" /><br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240601172621.webp\" alt=\"image.png\" width=\"500px\" /><br />\n<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240601172649.webp\" alt=\"image.png\" width=\"500px\" /><br />\nA-C-B,         d(A,B)=13;<br />\nA-C,             d(A,C)=10;<br />\nA-C-E-D,     d(A,D)=18;<br />\nA-C-E,         d(A,E)=14;<br />\nA-C-E-F,      d(A,F)=16;<br />\nA-C-E-F-G, d(A,G)=22.</p>\n</div></details><h2 id=\"时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度\"></a> 时间复杂度</h2>\n<p>时间复杂度分析：</p>\n<ul>\n<li>操作 2 总时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>操作 1 总时间复杂度根据实现方式有所不同\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。朴素的实现方法为每一轮操作执行完毕后，直接在 T 集合中暴力寻找最短路长度最小的结点。</li>\n<li>可以用堆来优化这一过程：每成功松弛一条边 (u,v)，就将 v 插入堆中（如果 v 已经在堆中，直接执行 Decrease-key），操作 1 直接取堆顶结点即可。共计 O(m) 次 Decrease-key，O(n) 次 pop，选择不同堆可以取到不同的复杂度。\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>：这是堆优化可达到最优时间复杂度，可用斐波那契堆实现</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>：优先队列。无法执行 Decrease-key 操作，但可以通过每次松弛时重新插入该结点，且弹出时检查该结点是否已被松弛过，若是则跳过，优点是实现较简单。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>：线段树。在一些特殊的非递归线段树实现下，该做法常数比堆更小。并且线段树支持的操作更多，在一些特殊图问题上只能用线段树来维护。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>全过程的时间复杂度为：</p>\n<ul>\n<li>朴素做法：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2 + m) = O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>堆优化最优复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n+m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>在稀疏图中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">m = O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，堆优化的 Dijkstra 算法具有较大的效率优势；而在稠密图中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">m = O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，这时候使用朴素实现更优。</p>\n<h1 id=\"例题与代码\"><a class=\"markdownIt-Anchor\" href=\"#例题与代码\"></a> 例题与代码</h1>\n<h2 id=\"floyd\"><a class=\"markdownIt-Anchor\" href=\"#floyd\"></a> Floyd</h2>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://www.luogu.com.cn/problem/B3647\">B3647 【模板】Floyd - 洛谷</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] f = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化图</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            Arrays.fill(f[i],Integer.MAX_VALUE);</span><br><span class=\"line\">            f[i][i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">startNode</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">endNode</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">weight</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">resWeight</span> <span class=\"operator\">=</span> Math.min(f[startNode][endNode],weight);</span><br><span class=\"line\">            <span class=\"comment\">// 无向图的邻接矩阵为对称矩阵</span></span><br><span class=\"line\">            f[startNode][endNode] = resWeight;</span><br><span class=\"line\">            f[endNode][startNode] = resWeight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t                <span class=\"comment\">// 本题边权为正整数，这里处理无限值</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">addRes</span> <span class=\"operator\">=</span> f[i][k]==Integer.MAX_VALUE || f[k][j]==Integer.MAX_VALUE? Integer.MAX_VALUE : f[i][k]+f[k][j];</span><br><span class=\"line\">                    <span class=\"comment\">// 最短路性质 2</span></span><br><span class=\"line\">                    f[i][j] = Math.min(f[i][j],addRes);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">                System.out.print(f[i][j]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bellman-ford\"><a class=\"markdownIt-Anchor\" href=\"#bellman-ford\"></a> Bellman-Ford</h2>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://www.luogu.com.cn/problem/P3371\">P3371 【模板】单源最短路径（弱化版） - 洛谷</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>下面的代码为 Bellman-Ford 算法的实现，没有进行负环检测。此外，为了降低内存的使用，代码对输入方式进行优化（否则此题内存超限）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StreamTokenizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">StreamTokenizer</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StreamTokenizer</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)));</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">long</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">long</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][<span class=\"number\">3</span>];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        dis[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 根据题意进行的存边操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            edges[i][<span class=\"number\">0</span>] = nextInt();</span><br><span class=\"line\">            edges[i][<span class=\"number\">1</span>] = nextInt();</span><br><span class=\"line\">            edges[i][<span class=\"number\">2</span>] = nextInt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 检测是否出现了变动</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                v = edges[j][<span class=\"number\">1</span>];</span><br><span class=\"line\">                u = edges[j][<span class=\"number\">0</span>];</span><br><span class=\"line\">                w = edges[j][<span class=\"number\">2</span>];</span><br><span class=\"line\">                <span class=\"comment\">// 因为无负权边，且dis为long数组，避免了溢出情况</span></span><br><span class=\"line\">                <span class=\"comment\">// 不可达点 Integer.MAX_VALUE 加上任何数都不可达</span></span><br><span class=\"line\">                <span class=\"comment\">// 此处无需特判可达性</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[v] &gt; dis[u]+w) &#123;</span><br><span class=\"line\">                    dis[v] = dis[u]+w;</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!flag)<span class=\"keyword\">break</span>; <span class=\"comment\">// 没有出现变动则提前跳出循环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据题意进行的输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            System.out.print(dis[i] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">nextInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            in.nextToken();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)in.nval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://www.luogu.com.cn/problem/P3385\">P3385 【模板】负环 - 洛谷</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>此题目中会出现负权的边，判断从指定出发点是否能到达负环。</p>\n<p>下面是 Bellman-Ford 检测负环的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">T</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(T--!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 表示出发点</span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span>[][] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">6002</span>][<span class=\"number\">3</span>]; <span class=\"comment\">// 根据题意，最多6000条边</span></span><br><span class=\"line\">            Arrays.fill(dis, Integer.MAX_VALUE); <span class=\"comment\">// 初始化所有顶点不可达</span></span><br><span class=\"line\">            dis[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">edgeIdx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">            <span class=\"comment\">// 根据题意，单纯存边</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">                u = in.nextInt();</span><br><span class=\"line\">                v = in.nextInt();</span><br><span class=\"line\">                w = in.nextInt();</span><br><span class=\"line\">                edges[edgeIdx][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">                edges[edgeIdx][<span class=\"number\">1</span>] = v;</span><br><span class=\"line\">                edges[edgeIdx][<span class=\"number\">2</span>] = w;</span><br><span class=\"line\">                edgeIdx++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(w&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    edges[edgeIdx][<span class=\"number\">0</span>] = v;</span><br><span class=\"line\">                    edges[edgeIdx][<span class=\"number\">1</span>] = u;</span><br><span class=\"line\">                    edges[edgeIdx][<span class=\"number\">2</span>] = w;</span><br><span class=\"line\">                    edgeIdx++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> i;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 检测是否出现了变动</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">false</span>; </span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; edgeIdx; j++) &#123;</span><br><span class=\"line\">                    u = edges[j][<span class=\"number\">0</span>];</span><br><span class=\"line\">                    v = edges[j][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    w = edges[j][<span class=\"number\">2</span>];</span><br><span class=\"line\">                    <span class=\"comment\">// 存在负权图中，不可达点的判断是有必要的</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dis[u]!=Integer.MAX_VALUE &amp;&amp; dis[v] &gt; dis[u]+w) &#123;</span><br><span class=\"line\">                        dis[v] = dis[u]+w;</span><br><span class=\"line\">                        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!flag)<span class=\"keyword\">break</span>; <span class=\"comment\">// 没有出现变动则提前跳出循环</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">hasNegCir</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 再进行一次松弛</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; edgeIdx; j++) &#123;</span><br><span class=\"line\">                u = edges[j][<span class=\"number\">0</span>];</span><br><span class=\"line\">                v = edges[j][<span class=\"number\">1</span>];</span><br><span class=\"line\">                w = edges[j][<span class=\"number\">2</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[u]!=Integer.MAX_VALUE &amp;&amp; dis[v] &gt; dis[u]+w) &#123;</span><br><span class=\"line\">                    dis[v] = dis[u]+w;</span><br><span class=\"line\">                    hasNegCir = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(hasNegCir?<span class=\"string\">&quot;YES&quot;</span>:<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样是这道题，下面是 SPFA 解法，使用到了 <a href=\"https://oi-wiki.org/graph/save/#__tabbed_3_2\">链式前向星</a> 的存储结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StreamTokenizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">StreamTokenizer</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StreamTokenizer</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)));</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">T</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(T--!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 表示出发点</span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">boolean</span>[] vis = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n+<span class=\"number\">1</span>]; <span class=\"comment\">// 表示是否已加入队列，用于避免重复加入队列</span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] cnt = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];   <span class=\"comment\">// 表示结点经过的路径数，用于判断负环</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 链式前向星</span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] head = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">            Edge[] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>[<span class=\"number\">6002</span>]; <span class=\"comment\">// 根据题意，最多6000条边，分别表示 to,next,w</span></span><br><span class=\"line\">            Arrays.fill(head,-<span class=\"number\">1</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            Arrays.fill(dis, Integer.MAX_VALUE); <span class=\"comment\">// 初始化所有顶点不可达</span></span><br><span class=\"line\">            Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">            dis[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            queue.offer(src);</span><br><span class=\"line\">            vis[src] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">edgeIdx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">            <span class=\"comment\">// 根据题意，使用链式前向星存边</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">                u = nextInt();</span><br><span class=\"line\">                v = nextInt();</span><br><span class=\"line\">                w = nextInt();</span><br><span class=\"line\">                edges[edgeIdx] = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>(v,head[u],w);</span><br><span class=\"line\">                head[u] = edgeIdx;</span><br><span class=\"line\">                edgeIdx++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(w&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    edges[edgeIdx] = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>(u,head[v],w);</span><br><span class=\"line\">                    head[v] = edgeIdx;</span><br><span class=\"line\">                    edgeIdx++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">hasNegCir</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(queue.size()&gt;<span class=\"number\">0</span>&amp;&amp;!hasNegCir)&#123;</span><br><span class=\"line\">                u = queue.poll();</span><br><span class=\"line\">                vis[u] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> head[u]; j!=-<span class=\"number\">1</span>; j=edges[j].next) &#123;</span><br><span class=\"line\">                    v = edges[j].to;</span><br><span class=\"line\">                    w = edges[j].w;</span><br><span class=\"line\">                    <span class=\"comment\">// 存在负权图中，不可达点的判断是有必要的</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dis[u]!=Integer.MAX_VALUE &amp;&amp; dis[v] &gt; dis[u]+w) &#123;</span><br><span class=\"line\">                        dis[v] = dis[u]+w;</span><br><span class=\"line\">                        cnt[v] = cnt[u]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(cnt[v]&gt;=n)&#123;</span><br><span class=\"line\">                            hasNegCir= <span class=\"literal\">true</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(!vis[v])&#123;</span><br><span class=\"line\">                            queue.offer(v);</span><br><span class=\"line\">                            vis[v]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(hasNegCir?<span class=\"string\">&quot;YES&quot;</span>:<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">nextInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            in.nextToken();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)in.nval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    Edge(<span class=\"type\">int</span> to,<span class=\"type\">int</span> next,<span class=\"type\">int</span> w)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.w =  w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dijkstra\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra\"></a> Dijkstra</h2>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://www.luogu.com.cn/problem/P3371\">P3371 【模板】单源最短路径（弱化版） - 洛谷</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>以下代码使用了朴素做法查找下一个遍历的点，并对输入进行了优化以通过全部测试用例，使用到了 <a href=\"https://oi-wiki.org/graph/save/#__tabbed_3_2\">链式前向星</a> 的存储结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StreamTokenizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">StreamTokenizer</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StreamTokenizer</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)));</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">INF</span> <span class=\"operator\">=</span> <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] vis = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n+<span class=\"number\">1</span>]; <span class=\"comment\">// 表示 S / T 集合</span></span><br><span class=\"line\">        Arrays.fill(dis, INF);</span><br><span class=\"line\">        dis[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 链式前向星</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] head = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        Edge[] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>[m]; <span class=\"comment\">// 根据题意，最多6000条边，分别表示 to,next,w</span></span><br><span class=\"line\">        Arrays.fill(head,-<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取边</span></span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            u = nextInt();</span><br><span class=\"line\">            v = nextInt();</span><br><span class=\"line\">            w = nextInt();</span><br><span class=\"line\">            edges[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>(v,head[u],w);</span><br><span class=\"line\">            head[u] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> minDis;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            u = src; <span class=\"comment\">// 默认为起点，有利于第一次操作时找到它</span></span><br><span class=\"line\">            minDis = INF;</span><br><span class=\"line\">            <span class=\"comment\">// 试图暴力找到下一个 T 集合中的点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[j]&amp;&amp; dis[j]&lt;minDis)&#123;</span><br><span class=\"line\">                    minDis = dis[j];</span><br><span class=\"line\">                    u = j; <span class=\"comment\">// 更新候选点</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vis[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// 将候选点加入 S 集合</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> head[u];j!=-<span class=\"number\">1</span>;j=edges[j].next)&#123;</span><br><span class=\"line\">                v = edges[j].to;</span><br><span class=\"line\">                w = edges[j].w;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dis[u]+w&lt;dis[v])&#123;</span><br><span class=\"line\">                    dis[v] = dis[u]+w;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构造输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            System.out.print((dis[i]==INF? Integer.MAX_VALUE : dis[i]) + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">nextInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            in.nextToken();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)in.nval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    Edge(<span class=\"type\">int</span> to,<span class=\"type\">int</span> next,<span class=\"type\">int</span> w)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.w =  w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下代码是优先队列版本。需要注意的是，优先队列进队时需要将结点 <code>dis</code> 信息绑定进队，这样当 <code>dis</code> 数组发生变化时，优先队列能及时响应变化。</p>\n<p>注意到，优先队列会存在一些重复的结点，并携带着过时的 <code>dis</code> 数据。但这并不影响优先队列的正确性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StreamTokenizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.PriorityQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">INF</span> <span class=\"operator\">=</span> <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">StreamTokenizer</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StreamTokenizer</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)));</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">src</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>]; <span class=\"comment\">// 即使Node中存有，此数组也要保留，用于支持随机访问</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] vis = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n+<span class=\"number\">1</span>]; <span class=\"comment\">// 表示 S / T 集合 ，单纯使用vis数组优化内存</span></span><br><span class=\"line\">        Arrays.fill(dis, INF);</span><br><span class=\"line\">        dis[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Queue&lt;Node&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;(o1.dis-o2.dis));</span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(src,<span class=\"number\">0</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 链式前向星</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] head = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        Edge[] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>[m]; <span class=\"comment\">// 根据题意，最多6000条边，分别表示 to,next,w</span></span><br><span class=\"line\">        Arrays.fill(head,-<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取边</span></span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            u = nextInt();</span><br><span class=\"line\">            v = nextInt();</span><br><span class=\"line\">            w = nextInt();</span><br><span class=\"line\">            edges[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Edge</span>(v,head[u],w);</span><br><span class=\"line\">            head[u] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> minDis;</span><br><span class=\"line\">        Node node;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(q.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            node = q.poll();</span><br><span class=\"line\">            u = node.id;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[u])<span class=\"keyword\">continue</span>; <span class=\"comment\">// 此操作保证不使用重复的结点中过时的dis数据</span></span><br><span class=\"line\">            vis[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// 将候选点加入 S 集合</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> head[u];j!=-<span class=\"number\">1</span>;j=edges[j].next)&#123;</span><br><span class=\"line\">                v = edges[j].to;</span><br><span class=\"line\">                w = edges[j].w;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dis[u]+w&lt;dis[v])&#123;</span><br><span class=\"line\">                    dis[v] = dis[u]+w;</span><br><span class=\"line\">                    q.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(v,dis[v]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构造输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            System.out.print((dis[i]==INF? Integer.MAX_VALUE : dis[i]) + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">nextInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            in.nextToken();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)in.nval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;</span><br><span class=\"line\">    <span class=\"type\">int</span> w;</span><br><span class=\"line\">    Edge(<span class=\"type\">int</span> to,<span class=\"type\">int</span> next,<span class=\"type\">int</span> w)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.w =  w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">int</span> dis; <span class=\"comment\">// 用于排序</span></span><br><span class=\"line\">    <span class=\"comment\">// 不需要在此处增加 vis 标记。因为我们的Node会加很多个，可能不止n个！ </span></span><br><span class=\"line\">    <span class=\"comment\">// 当然，我们可以复用Node进行进一步内存优化</span></span><br><span class=\"line\">    Node(<span class=\"type\">int</span> id,<span class=\"type\">int</span> dis)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dis = dis;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_46092061/article/details/118927217\">洛谷 P3371 单源最短路径（Java版）_洛谷3371 java-CSDN博客</a></li>\n<li><a href=\"https://oi-wiki.org/graph/shortest-path/\">最短路 - OI Wiki</a></li>\n<li><a href=\"https://blog.csdn.net/sin1810335764/article/details/136142994\">【模板】负环 问题题解（spfa和bellman解决）_3385 负权环 bellman-CSDN博客</a></li>\n<li><a href=\"https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95/8297411\">SPFA算法_百度百科</a></li>\n<li>研究生课程《离散数学》笔记</li>\n</ul>\n","raw":"---\ntitle: 最短路径算法\ntags:\n  - Dijkstra\n  - Floyd\n  - 堆\n  - 队列\n  - 洛谷\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202506100113697.webp'\ndescription: 被机试难倒了，明明很熟悉的算法偏偏就是没有手写过\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: 9df73d67\ndate: 2025-06-10 01:33:42\ntop_img:\n---\n\n本节所有算法和优化算法均有对应的题目和 Java 代码，都附在文后了。\n\n| 最短路算法  | Floyd      | Bellman-Ford | Dijkstra           | Johnson（本文不涉及） |\n| ------ | ---------- | ------------ | ------------------ | -------------- |\n| 最短路类型  | 每对结点之间的最短路 | 单源最短路        | 单源最短路              | 每对结点之间的最短路     |\n| 作用于    | 任意图        | 任意图          | 非负权图               | 任意图            |\n| 能否检测负环 | ✅          | ✅            | ❌                  | ✅              |\n| 时间复杂度  | $O(N^3)$   | $O(NM)$      | $O(M\\log M)$（优先队列） | $O(NM\\log M)$  |\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 定义与定理\n\n> 不同教科书对于 walk、trail、path 的中文叫法不尽相同，注意区分！\n\n**途径 (walk)**：途径是连接一连串顶点的边的序列，可以为有限或无限长度。形式化地说，一条有限途径 $w$ 是一个边的序列 $e_1, e_2, \\ldots, e_k$，使得存在一个顶点序列 $v_0, v_1, \\ldots, v_k$ 满足 $e_i = (v_{i-1}, v_i)$，其中 $i \\in [1, k]$。这样的途径可以简写为 $v_0 \\to v_1 \\to v_2 \\to \\cdots \\to v_k$。通常来说，边的数量 $k$ 被称作这条途径的 **长度**（如果边是带权的，长度通常指途径上的边权之和，题目中也可能另有定义）。\n\n**迹 (trail)**：对于一条途径 $w$，若 $e_1, e_2, \\ldots, e_k$ 两两互不相同，则称 $w$ 是一条迹。\n\n**路径 (path)**，又称 **简单路径 (simple path)**：对于一条迹 $w$，若其连接的点的序列中点两两不同，则称 $w$ 是一条路径。\n\n为了方便叙述，本文约定以下记号的含义：\n\n- $n$ 为图上点的数目，$m$ 为图上边的数目；\n- $s$ 为最短路的源点；\n- $D(u)$ 为 $s$ 点到 $u$ 点的 **实际** 最短路长度；\n- $dis(u)$ 为 $s$ 点到 $u$ 点的 **估计** 最短路长度。任何时候都有 $dis(u) \\geq D(u)$。特别地，当最短路算法终止时，应有 $dis(u)=D(u)$。\n- $w(u,v)$ 为 $(u,v)$ 这一条边的边权。\n\n> [!tldr] 一些最短路的性质\n> - 性质 1：对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。\n> - 性质 2：对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。\n> - 性质 3：对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过 n，边数不会超过 n-1。\n\n# Floyd 算法\n\n可用于求任意两个结点之间的最短路径，可用于有向图或无向图，边权可正可负但最短路必须存在（不能有负环）。\n\n定义一个数组 `f[k][x][y]`，表示只允许经过结点 1 到 k（也就是说，在子图 $V'={1, 2, \\ldots, k}$ 中的路径，注意，x 与 y 不一定在这个子图中），结点 x 到结点 y 的最短路长度。显然，`f[n][x][y]` 就是结点 x 到结点 y 的最短路长度。因为 $V'={1, 2, \\ldots, n}$ 即为 V 本身，其表示的最短路径就是所求路径。\n\n接下来考虑如何求出 f 数组的值。`f[0][i][j]` 表示一张图的边权，初始化方式：\n\n- 当 `i` 与 `j` 间有直接相连的边的时，`f[0][i][j] = w(i,j)`\n- 当 `i == j` 时，`f[0][i][j] = 0`\n- 当 `i` 与 `j` 没有直接相连的边的时。`f[0][i][j] = +∞`\n\n推导方式：`f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])`\n\n- `f[k-1][x][y]`：不经过 k 点的最短路径\n- `f[k-1][x][k]+f[k-1][k][y]`：经过了 k 点的最短路\n\n核心代码：\n\n```java\nfor (k = 1; k <= n; k++)\n  for (x = 1; x <= n; x++)\n    for (y = 1; y <= n; y++)\n      f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);\n```\n\n熟悉 [[【刷题日记】动态规划题单|动态规划压缩空间写法]] 的你一眼看出来，第一维对结果无影响可将其省略，于是可以直接改成 `f[x][y] = min(f[x][y], f[x][k]+f[k][y])`。\n\n综上，算法的复杂度为：\n\n- 时间复杂度：$O(n^3)$\n- 空间复杂度：$O(n^2)$\n\n# Bellman-Ford 算法\n\nBellman–Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。\n\n对边 (u,v) 进行松弛操作，意味着有：$dis(v) = \\min (dis(v), dis(u) + w(u, v))$。Bellman–Ford 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。\n\n时间复杂度估计：\n\n- **在最短路存在的情况下**，一次松弛操作（$O(m)$ 时间复杂度）会使最短路的边数至少 +1，即每一轮松弛可以使某些点的最短路径边数上限增加 1。解释如下：\n\t- Bellman–Ford 的每一轮松弛可以将最短路径的信息沿着边传播 **一步**。\n\t- 第 1 轮松弛后，能正确求出从源点 s 出发、只经过 **1 条边** 的所有最短路径。\n\t- 第 2 轮松弛后，可以求出所有经过 **最多 2 条边** 的最短路径。\n\t- 依此类推，第 k 轮后，可以求出最多包含 k 条边的最短路径。\n- 根据性质 3，最短路的边数最多为 n-1\n- 因此总时间复杂度为 $O(nm)$\n\n如果从 S 点出发，抵达一个负环时，松弛操作会无休止地进行下去。前面的论证已经说明对于最短路存在的图松弛操作最多会进行 n-1 轮。如果第 n 轮循环仍出现能松弛的边，**说明从 S 点出发，能够抵达负环**。\n\n即使第 n 轮循环仍出现能松弛的边，并不意味着图上不存在负环。如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman–Ford 算法。\n\n## SPFA\n\n> Shortest Path Faster Algorithm，SPFA，是 Bellman-Ford 的队列优化算法。它是西南交通大学段凡丁于 1994 年发表的论文中的名字。不过，段凡丁的证明是错误的，且在 Bellman-Ford 算法提出后不久（1957 年）已有队列优化内容，所以国际上不承认 SPFA 算法是段凡丁提出的。一般国内 OI 界中才有 SPFA 的说法。\n\n在 Bellman-Ford 中，有时候我们并不需要那么多无用的松弛操作。很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。\n\n我们用队列来维护「哪些结点可能会引起松弛操作」，就能只访问必要的边了。SPFA 也可以用于判断 S 点是否能抵达一个负环，只需记录最短路经过了多少条边，当经过了至少 n 条边时，说明 S 点可以抵达一个负环。\n\n虽然在大多数情况下 SPFA 跑得很快，但其最坏情况下的时间复杂度为 O(nm)。在没有负权边时最好使用 Dijkstra 算法。\n\n更多 Bellman–Ford 算法优化详看：[如何看待 SPFA 算法已死这种说法？ - 知乎](https://www.zhihu.com/question/292283275/answer/484871888)\n\n# Dijkstra 算法\n\nDijkstra（/ˈdikstrɑ/或/ˈdɛikstrɑ/）算法由荷兰计算机科学家 E. W. Dijkstra 于 1956 年发现，1959 年公开发表。是一种求解 **非负权图** 上单源最短路径的算法。\n\n## 算法思想\n\n将图 G(V,E) 中结点集合 V 分成两组：\n\n- 已确定最短路长度的点集（记为 S 集合）。\n- 未确定最短路长度的点集（记为 T 集合）。一开始所有的点都属于 T 集合。\n\n初始化 $dis(s)=0$，其他点的 $dis$ 均为 $+\\infty$。这样，第一次操作时可将源点加入 S 集合中。\n\n然后重复这些操作：\n\n1. 从 T 集合中，选取一个最短路长度最小的结点，移到 S 集合中。\n2. 对那些刚刚被加入 S 集合的结点的所有出边执行松弛操作。\n3. 直到 T 集合为空，算法结束。\n\n在操作的过程中每个结点对应一个距离 dis，S 中的结点的距离就是从 s 到此结点的最短路径长度；T 中的结点的距离，是从 s 到此结点只包含 S 中的结点为中间结点的当前最短路径长度。\n\n> [!example]- 例子：Dijkstra 算法图示\n> 一个总部和 6 个工地，求从总部到各工地的最短路径。![image.png|448](https://cdn.gallery.uuanqin.top/img/20240601171641.webp)\n>\n> 解：\n> ![image.png|500](https://cdn.gallery.uuanqin.top/img/20240601172538.webp)\n> ![image.png|500](https://cdn.gallery.uuanqin.top/img/20240601172550.webp)\n> ![image.png|500](https://cdn.gallery.uuanqin.top/img/20240601172621.webp)\n> ![image.png|500](https://cdn.gallery.uuanqin.top/img/20240601172649.webp)\n> A-C-B,         d(A,B)=13;\n> A-C,             d(A,C)=10;\n> A-C-E-D,     d(A,D)=18;\n> A-C-E,         d(A,E)=14;\n> A-C-E-F,      d(A,F)=16;\n> A-C-E-F-G, d(A,G)=22.\n\n\n## 时间复杂度\n\n时间复杂度分析：\n\n- 操作 2 总时间复杂度为 $O(m)$\n- 操作 1 总时间复杂度根据实现方式有所不同\n\t-  $O(n^2)$。朴素的实现方法为每一轮操作执行完毕后，直接在 T 集合中暴力寻找最短路长度最小的结点。\n\t- 可以用堆来优化这一过程：每成功松弛一条边 (u,v)，就将 v 插入堆中（如果 v 已经在堆中，直接执行 Decrease-key），操作 1 直接取堆顶结点即可。共计 O(m) 次 Decrease-key，O(n) 次 pop，选择不同堆可以取到不同的复杂度。\n\t\t- $O(n\\log n)$：这是堆优化可达到最优时间复杂度，可用斐波那契堆实现\n\t\t- $O(m\\log n)$：优先队列。无法执行 Decrease-key 操作，但可以通过每次松弛时重新插入该结点，且弹出时检查该结点是否已被松弛过，若是则跳过，优点是实现较简单。\n\t\t- $O(m\\log n)$：线段树。在一些特殊的非递归线段树实现下，该做法常数比堆更小。并且线段树支持的操作更多，在一些特殊图问题上只能用线段树来维护。\n\n全过程的时间复杂度为：\n\n- 朴素做法：$O(n^2 + m) = O(n^2)$。\n- 堆优化最优复杂度：$O(n\\log n+m)$\n\n在稀疏图中，$m = O(n)$，堆优化的 Dijkstra 算法具有较大的效率优势；而在稠密图中，$m = O(n^2)$，这时候使用朴素实现更优。\n\n# 例题与代码\n\n## Floyd\n\n> [!example] 🟨 [B3647 【模板】Floyd - 洛谷](https://www.luogu.com.cn/problem/B3647)\n\n```java\nimport java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[][] f = new int[n+1][n+1];\n        // 初始化图\n        for(int i=1;i<=n;i++){\n            Arrays.fill(f[i],Integer.MAX_VALUE);\n            f[i][i]=0;\n        }\n        for(int i=0;i<m;i++){\n            int startNode = in.nextInt();\n            int endNode = in.nextInt();\n            int weight = in.nextInt();\n            int resWeight = Math.min(f[startNode][endNode],weight);\n            // 无向图的邻接矩阵为对称矩阵\n            f[startNode][endNode] = resWeight;\n            f[endNode][startNode] = resWeight;\n        }\n\n        for(int k=1;k<=n;k++){\n            for(int i=1;i<=n;i++){\n                for(int j=1;j<=n;j++){\n\t                // 本题边权为正整数，这里处理无限值\n                    int addRes = f[i][k]==Integer.MAX_VALUE || f[k][j]==Integer.MAX_VALUE? Integer.MAX_VALUE : f[i][k]+f[k][j];\n                    // 最短路性质 2\n                    f[i][j] = Math.min(f[i][j],addRes);\n                }\n            }\n        }\n\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                System.out.print(f[i][j]+\" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n## Bellman-Ford\n\n> [!example] 🟨 [P3371 【模板】单源最短路径（弱化版） - 洛谷](https://www.luogu.com.cn/problem/P3371)\n\n下面的代码为 Bellman-Ford 算法的实现，没有进行负环检测。此外，为了降低内存的使用，代码对输入方式进行优化（否则此题内存超限）。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static void main(String[] args) {\n        int n = nextInt();\n        int m = nextInt();\n        int src = nextInt();\n        long[] dis = new long[n+1];\n        int[][] edges = new int[m][3];\n        Arrays.fill(dis, Integer.MAX_VALUE);\n        dis[src] = 0;\n        // 根据题意进行的存边操作\n        for (int i = 0; i < m; i++) {\n            edges[i][0] = nextInt();\n            edges[i][1] = nextInt();\n            edges[i][2] = nextInt();\n        }\n        int u,v,w;\n        for (int i = 1; i <= n; i++) {\n            boolean flag = false; // 检测是否出现了变动\n            for (int j = 0; j < m; j++) {\n                v = edges[j][1];\n                u = edges[j][0];\n                w = edges[j][2];\n                // 因为无负权边，且dis为long数组，避免了溢出情况\n                // 不可达点 Integer.MAX_VALUE 加上任何数都不可达\n                // 此处无需特判可达性\n                if (dis[v] > dis[u]+w) {\n                    dis[v] = dis[u]+w;\n                    flag = true;\n                }\n            }\n            if (!flag)break; // 没有出现变动则提前跳出循环\n        }\n        // 根据题意进行的输出\n        for (int i = 1; i <= n; i++) {\n            System.out.print(dis[i] + \" \");\n        }\n    }\n    static int nextInt() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (int)in.nval;\n    }\n}\n```\n\n> [!example] 🟨 [P3385 【模板】负环 - 洛谷](https://www.luogu.com.cn/problem/P3385)\n\n此题目中会出现负权的边，判断从指定出发点是否能到达负环。\n\n下面是 Bellman-Ford 检测负环的方法：\n\n```java\nimport java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int T = in.nextInt();\n        while(T--!=0){\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int src = 1; // 表示出发点\n            int[] dis = new int[n+1];\n            int[][] edges = new int[6002][3]; // 根据题意，最多6000条边\n            Arrays.fill(dis, Integer.MAX_VALUE); // 初始化所有顶点不可达\n            dis[src] = 0;\n            int edgeIdx = 0;\n            int u,v,w;\n            // 根据题意，单纯存边\n            for (int i = 0; i < m; i++) {\n                u = in.nextInt();\n                v = in.nextInt();\n                w = in.nextInt();\n                edges[edgeIdx][0] = u;\n                edges[edgeIdx][1] = v;\n                edges[edgeIdx][2] = w;\n                edgeIdx++;\n                if(w>=0){\n                    edges[edgeIdx][0] = v;\n                    edges[edgeIdx][1] = u;\n                    edges[edgeIdx][2] = w;\n                    edgeIdx++;\n                }\n            }\n\n            int i;\n            boolean flag = false; // 检测是否出现了变动\n            for (i = 0; i < n-1; i++) {\n                flag = false; \n                for (int j = 0; j < edgeIdx; j++) {\n                    u = edges[j][0];\n                    v = edges[j][1];\n                    w = edges[j][2];\n                    // 存在负权图中，不可达点的判断是有必要的\n                    if (dis[u]!=Integer.MAX_VALUE && dis[v] > dis[u]+w) {\n                        dis[v] = dis[u]+w;\n                        flag = true;\n                    }\n                }\n                if (!flag)break; // 没有出现变动则提前跳出循环\n            }\n            boolean hasNegCir = false;\n            // 再进行一次松弛\n            for (int j = 0; j < edgeIdx; j++) {\n                u = edges[j][0];\n                v = edges[j][1];\n                w = edges[j][2];\n                if (dis[u]!=Integer.MAX_VALUE && dis[v] > dis[u]+w) {\n                    dis[v] = dis[u]+w;\n                    hasNegCir = true;\n                    break;\n                }\n            }\n            System.out.println(hasNegCir?\"YES\":\"NO\");\n        }\n    }\n}\n```\n\n同样是这道题，下面是 SPFA 解法，使用到了 [链式前向星](https://oi-wiki.org/graph/save/#__tabbed_3_2) 的存储结构：\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.LinkedList;\npublic class Main {\n    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static void main(String[] args) {  \n        int T = nextInt();\n        while(T--!=0){\n            int n = nextInt();\n            int m = nextInt();\n            int src = 1; // 表示出发点\n            int[] dis = new int[n+1];\n            boolean[] vis = new boolean[n+1]; // 表示是否已加入队列，用于避免重复加入队列\n            int[] cnt = new int[n+1];   // 表示结点经过的路径数，用于判断负环\n            \n            // 链式前向星\n            int[] head = new int[n+1];\n            Edge[] edges = new Edge[6002]; // 根据题意，最多6000条边，分别表示 to,next,w\n            Arrays.fill(head,-1);\n            \n            Arrays.fill(dis, Integer.MAX_VALUE); // 初始化所有顶点不可达\n            Queue<Integer> queue = new LinkedList<>();\n            dis[src] = 0;\n            queue.offer(src);\n            vis[src] = true;\n            int edgeIdx = 0;\n            int u,v,w;\n            // 根据题意，使用链式前向星存边\n            for (int i = 0; i < m; i++) {\n                u = nextInt();\n                v = nextInt();\n                w = nextInt();\n                edges[edgeIdx] = new Edge(v,head[u],w);\n                head[u] = edgeIdx;\n                edgeIdx++;\n                if(w>=0){\n                    edges[edgeIdx] = new Edge(u,head[v],w);\n                    head[v] = edgeIdx;\n                    edgeIdx++;\n                }\n            }\n            boolean hasNegCir = false;\n\n            while(queue.size()>0&&!hasNegCir){\n                u = queue.poll();\n                vis[u] = false;\n                for (int j = head[u]; j!=-1; j=edges[j].next) {\n                    v = edges[j].to;\n                    w = edges[j].w;\n                    // 存在负权图中，不可达点的判断是有必要的\n                    if (dis[u]!=Integer.MAX_VALUE && dis[v] > dis[u]+w) {\n                        dis[v] = dis[u]+w;\n                        cnt[v] = cnt[u]+1;\n                        if(cnt[v]>=n){\n                            hasNegCir= true;\n                            break;\n                        }\n                        if(!vis[v]){\n                            queue.offer(v);\n                            vis[v]=true;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(hasNegCir?\"YES\":\"NO\");\n        }\n    }\n    static int nextInt() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (int)in.nval;\n    }\n}\n\nclass Edge{\n    int to;\n    int next;\n    int w;\n    Edge(int to,int next,int w){\n        this.to = to;\n        this.next = next;\n        this.w =  w;\n    }\n}\n```\n\n## Dijkstra\n\n> [!example] 🟨 [P3371 【模板】单源最短路径（弱化版） - 洛谷](https://www.luogu.com.cn/problem/P3371)\n\n以下代码使用了朴素做法查找下一个遍历的点，并对输入进行了优化以通过全部测试用例，使用到了 [链式前向星](https://oi-wiki.org/graph/save/#__tabbed_3_2) 的存储结构：\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static final int INF = 0x3f3f3f3f;\n    public static void main(String[] args) {\n        int n = nextInt();\n        int m = nextInt();\n        int src = nextInt();\n        int[] dis = new int[n+1];\n        boolean[] vis = new boolean[n+1]; // 表示 S / T 集合\n        Arrays.fill(dis, INF);\n        dis[src] = 0;\n        \n        // 链式前向星\n        int[] head = new int[n+1];\n        Edge[] edges = new Edge[m]; // 根据题意，最多6000条边，分别表示 to,next,w\n        Arrays.fill(head,-1);\n        \n        // 获取边\n        int u,v,w;\n        for (int i = 0; i < m; i++) {\n            u = nextInt();\n            v = nextInt();\n            w = nextInt();\n            edges[i] = new Edge(v,head[u],w);\n            head[u] = i;\n        }\n        int minDis;\n        for(int i=1;i<=n;i++){\n            u = src; // 默认为起点，有利于第一次操作时找到它\n            minDis = INF;\n            // 试图暴力找到下一个 T 集合中的点\n            for(int j=1;j<=n;j++){\n                if(!vis[j]&& dis[j]<minDis){\n                    minDis = dis[j];\n                    u = j; // 更新候选点\n                }\n            }\n            vis[u] = true; // 将候选点加入 S 集合\n            for(int j = head[u];j!=-1;j=edges[j].next){\n                v = edges[j].to;\n                w = edges[j].w;\n                if(dis[u]+w<dis[v]){\n                    dis[v] = dis[u]+w;\n                }\n            }\n        }\n\n        // 构造输出\n        for (int i = 1; i <= n; i++) {\n            System.out.print((dis[i]==INF? Integer.MAX_VALUE : dis[i]) + \" \");\n        }\n    }\n    static int nextInt() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (int)in.nval;\n    }\n}\n\nclass Edge{\n    int to;\n    int next;\n    int w;\n    Edge(int to,int next,int w){\n        this.to = to;\n        this.next = next;\n        this.w =  w;\n    }\n}\n```\n\n以下代码是优先队列版本。需要注意的是，优先队列进队时需要将结点 `dis` 信息绑定进队，这样当 `dis` 数组发生变化时，优先队列能及时响应变化。\n\n注意到，优先队列会存在一些重复的结点，并携带着过时的 `dis` 数据。但这并不影响优先队列的正确性。\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static final int INF = 0x3f3f3f3f;\n    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static void main(String[] args) {\n        int n = nextInt();\n        int m = nextInt();\n        int src = nextInt();\n        int[] dis = new int[n+1]; // 即使Node中存有，此数组也要保留，用于支持随机访问\n        boolean[] vis = new boolean[n+1]; // 表示 S / T 集合 ，单纯使用vis数组优化内存\n        Arrays.fill(dis, INF);\n        dis[src] = 0;\n        Queue<Node> q = new PriorityQueue<>((o1,o2)->(o1.dis-o2.dis));\n        q.offer(new Node(src,0));\n        \n        // 链式前向星\n        int[] head = new int[n+1];\n        Edge[] edges = new Edge[m]; // 根据题意，最多6000条边，分别表示 to,next,w\n        Arrays.fill(head,-1);\n        \n        // 获取边\n        int u,v,w;\n        for (int i = 0; i < m; i++) {\n            u = nextInt();\n            v = nextInt();\n            w = nextInt();\n            edges[i] = new Edge(v,head[u],w);\n            head[u] = i;\n        }\n        int minDis;\n        Node node;\n        while(q.size()>0){\n            node = q.poll();\n            u = node.id;\n            if(vis[u])continue; // 此操作保证不使用重复的结点中过时的dis数据\n            vis[u] = true; // 将候选点加入 S 集合\n            for(int j = head[u];j!=-1;j=edges[j].next){\n                v = edges[j].to;\n                w = edges[j].w;\n                if(dis[u]+w<dis[v]){\n                    dis[v] = dis[u]+w;\n                    q.offer(new Node(v,dis[v]));\n                }\n            }\n        }\n\n        // 构造输出\n        for (int i = 1; i <= n; i++) {\n            System.out.print((dis[i]==INF? Integer.MAX_VALUE : dis[i]) + \" \");\n        }\n    }\n    static int nextInt() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (int)in.nval;\n    }\n}\n\nclass Edge{\n    int to;\n    int next;\n    int w;\n    Edge(int to,int next,int w){\n        this.to = to;\n        this.next = next;\n        this.w =  w;\n    }\n}\n\nclass Node{\n    int id;\n    int dis; // 用于排序\n    // 不需要在此处增加 vis 标记。因为我们的Node会加很多个，可能不止n个！ \n    // 当然，我们可以复用Node进行进一步内存优化\n    Node(int id,int dis){\n        this.id = id;\n        this.dis = dis;\n    }\n}\n```\n\n# 本文参考\n- [洛谷 P3371 单源最短路径（Java版）_洛谷3371 java-CSDN博客](https://blog.csdn.net/qq_46092061/article/details/118927217)\n- [最短路 - OI Wiki](https://oi-wiki.org/graph/shortest-path/)\n- [【模板】负环 问题题解（spfa和bellman解决）_3385 负权环 bellman-CSDN博客](https://blog.csdn.net/sin1810335764/article/details/136142994)\n- [SPFA算法_百度百科](https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95/8297411)\n- 研究生课程《离散数学》笔记\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"Dijkstra","api":"api/tags/Dijkstra.json"},{"name":"Floyd","api":"api/tags/Floyd.json"},{"name":"堆","api":"api/tags/堆.json"},{"name":"队列","api":"api/tags/队列.json"},{"name":"洛谷","api":"api/tags/洛谷.json"}]},"api":"api/posts/p/9df73d67.json"}