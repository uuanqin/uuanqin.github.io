{"data":{"title":"单例模式一文通","slug":"高质量代码及设计模式/单例模式一文通","description":"单例模式——只有一个实例。除了具体实现外，还探讨单例模式的一些问题及解决方案","date":"2025-06-11T15:49:21.000Z","updated":"2025-06-12T14:20:37.444Z","language":"zh-CN","comments":true,"url":"p/f7f6f747/","cover":"https://cdn.gallery.uuanqin.top/img/202506120021808.webp","images":[],"content":"<p>想在程序中表示某个东西只会存在一个，比如表示程序所运行于那台计算机的类、表示软件系统相关设置的类、表示视窗系统（Window system）的类时，我们可以使用单例模式。</p>\n<pre><code class=\"highlight mermaid\">classDiagram\n    class Singleton &#123;\n        -$singleton\n        -Singleton()\n        +$getInstance()\n    &#125;</code></pre>\n<p>这种使用单例模式的类通常会占用较多的内存，或者示例的初始化过程比较冗长，如果随意创建这些类的示例会影响系统性能。我们使用单例模式的目的：</p>\n<ul>\n<li>想确保任何情况下都绝对只有 1 个实例，在程序上表现出「只存在一个实例」</li>\n<li>处理资源访问冲突</li>\n</ul>\n<h1 id=\"单例模式的实现方法\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的实现方法\"></a> 单例模式的实现方法</h1>\n<p>设计单例时需要考虑的要点：</p>\n<ol>\n<li>构造方法为私有</li>\n<li>注意线程安全问题</li>\n<li>考虑是否延时加载</li>\n<li>考虑获取单例 <code>getInstance()</code> 的性能是否够高</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>实现方法</th>\n<th>基本饿汉式</th>\n<th>线程不安全的懒汉式</th>\n<th>线程安全但锁粒度大的懒汉式</th>\n<th>DCL</th>\n<th>IoDH</th>\n<th>枚举</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>饿汉/懒汉</td>\n<td>饿汉</td>\n<td colspan=\"4\">懒汉</td>\n<td>饿汉</td>\n</tr>\n<tr>\n<td>JDK 版本</td>\n<td colspan=\"3\"></td>\n<td>JDK1.5 起</td>\n<td></td>\n<td>JDK1.5 起</td>\n</tr>\n<tr>\n<td>延迟加载</td>\n<td>🟥</td>\n<td>🟩</td>\n<td rowspan=\"3\">🟩</td>\n<td rowspan=\"2\" colspan=\"2\">🟩</td>\n<td>🟥</td>\n</tr>\n<tr>\n<td>线程安全</td>\n<td rowspan=\"2\">🟩</td>\n<td>🟥</td>\n<td rowspan=\"2\">🟩</td>\n</tr>\n<tr>\n<td>实现难度</td>\n<td>🟩</td>\n<td colspan=\"2\">🟥</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>一般情况下使用</td>\n<td colspan=\"2\">不建议</td>\n<td>存在特殊需求时</td>\n<td>在要明确实现 lazy loading 效果时</td>\n<td>涉及到反序列化创建对象时</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"基本饿汉模式\"><a class=\"markdownIt-Anchor\" href=\"#基本饿汉模式\"></a> 基本饿汉模式</h2>\n<p>基于 classloader 机制避免了多线程的同步问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//  外部第一次调用getInstance函数时instance才初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 私有构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生成了一个实例。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//从Singleton类外部获取唯一实例</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>instance</code> 前的关键字加上了 <code>final</code> 关键字的原因：防止子类不恰当的方法覆盖单例。</p>\n<p>构造方法为私有 <code>private</code> 的原因：禁止从 <code>Singleton</code> 类外部调用构造函数。只有自己才能 <code>new</code> 自己。外部只能通过类的静态方法使用。但是不能防止反射创建新的实例。</p>\n<p>如果 <code>Singleton</code> 实现了序列化接口，我们还需要增加以下代码防止反序列化破坏单例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">\t<span class=\"comment\">/* ... */</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Object <span class=\"title function_\">readResolve</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的初始化是可以保证单例对象创建时的线程安全。因为静态成员变量的初始化在类加载阶段完成，类加载阶段由 JVM 保证线程安全。</p>\n<p>如果饿汉模式下的单例初始化时间长，占用资源多是否意味着提前初始化是浪费资源的行为？答案是否定的，我们最好不要等用到的时候再初始化这个单例，这反而会降低系统性能。饿汉模式下将耗时的初始化操作提前到程序启动时完成，可以避免程序运行时初始化导致的性能问题。</p>\n<p>相关参考：</p>\n<ul>\n<li>类的生命周期中解释 <code>instance</code> 实例化的时机。</li>\n<li>这种饿汉模式的单例模式实现方法，是静态工厂模式的一种应用。</li>\n</ul>\n<h2 id=\"基本懒汉模式\"><a class=\"markdownIt-Anchor\" href=\"#基本懒汉模式\"></a> 基本懒汉模式</h2>\n<p>懒汉模式：没有一上来就创建实例，而是需要用的时候才创建。</p>\n<h3 id=\"代码-1线程不安全的写法\"><a class=\"markdownIt-Anchor\" href=\"#代码-1线程不安全的写法\"></a> 代码 1：线程不安全的写法</h3>\n<blockquote>\n<p>严格意义上，这不是单例模式。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生成了一个实例。&quot;</span>);</span><br><span class=\"line\">                           </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个实现适合于单线程程序。然而，当引入多线程时，就必须通过同步来保护 <code>getInstance()</code> 方法。如果不保护 <code>getInstance()</code> 方法，则可能返回 <code>Singleton</code> 对象的两个不同的实例。</p>\n<h3 id=\"代码-2线程安全的写法锁粒度较大\"><a class=\"markdownIt-Anchor\" href=\"#代码-2线程安全的写法锁粒度较大\"></a> 代码 2：线程安全的写法（锁粒度较大）</h3>\n<blockquote>\n<p>Balking 模式的一种体现。</p>\n</blockquote>\n<p>改造 <code>getInstance</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码1容易有竞争问题，如果两个线程 getInstance，可能都误以为都是NULL。所以添加synchronized</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;           <span class=\"comment\">// 1</span></span><br><span class=\"line\">\t\tinstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();   <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;                  <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，当分析这段代码时，我们发现只有在第一次调用方法时才需要同步。由于只有第一次调用执行了 <code>//2</code> 处的代码，而只有此行代码需要同步，因此就无需对后续调用使用同步。</p>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><code>synchronized</code> 是一个重量级的锁操作，它将全部代码块锁住，会导致较大的性能开销。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>否则，后续的每一次对 <code>getInstance</code> 的调用都要付出同步的代价。</p>\n<h3 id=\"代码-3双重检查锁-dcl\"><a class=\"markdownIt-Anchor\" href=\"#代码-3双重检查锁-dcl\"></a> 代码 3：双重检查锁 DCL</h3>\n<blockquote>\n<p>双重检查锁 DCL(double checked locking)</p>\n</blockquote>\n<p>为了避免对除第一次调用外的所有调用都实行同步的昂贵代价。我们将代码 2 中的 <code>//2</code> 包到一个同步块中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//可能多个线程同时进入到这一步进行阻塞等待</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span>(Singleton.class) &#123;</span><br><span class=\"line\">\t\t\tinstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是还是出现了和代码 1 一样的问题，可能会出现多个线程进入 <code>if</code> 内部。</p>\n<p>为处理上面代码中的问题，我们需要对 <code>instance</code> 进行第二次检查。这就是“双重检查锁定”名称的由来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DCL 双重检查锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>)&#123;                   <span class=\"comment\">//1</span></span><br><span class=\"line\">\t    <span class=\"keyword\">synchronized</span>(Singleton.class) &#123;       <span class=\"comment\">//2</span></span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>)&#123;           <span class=\"comment\">//3</span></span><br><span class=\"line\">\t\t\t    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();  <span class=\"comment\">//4</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个过程让我想起了动物界的精卵结合的过程…第一层 null 判断可快速返回单例，第二层 null 判断可防止重写。</p>\n</blockquote>\n<p>双重检查锁定背后的理论是完美的，但还是会存在问题。双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型，这个内存模型允许所谓的“指令重排序”。</p>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">指令重排序</div>\n</div>\n<div class=\"callout-content\"><p>指令重排序是指编译器或处理器为了优化性能而采取的一种手段，在不存在数据依赖性情况下（如写后读，读后写，写后写），调整代码执行顺序。</p>\n</div></div><p>代码行 <code>//4</code> 中，在 java 中创建一个对象并非是一个原子操作，可以被分解成三行伪代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1：分配对象的内存空间</span></span><br><span class=\"line\">memory = allocate();</span><br><span class=\"line\"><span class=\"comment\">//2：初始化对象</span></span><br><span class=\"line\">ctorInstance(memory);  </span><br><span class=\"line\"><span class=\"comment\">//3：设置instance指向刚分配的内存地址</span></span><br><span class=\"line\">instance = memory;     </span><br></pre></td></tr></table></figure>\n<p>而在一些 JIT 编译器中，为提高性能，伪代码的第二步和第三步顺序会交换（变为先赋值，再调用构造函数）。在单线程程序下，重排序不会对最终结果产生影响，但是并发的情况下，可能会导致某些线程访问到未初始化的变量。模拟一个 2 个线程创建单例的场景，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>线程 A</th>\n<th>线程 B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>t1</td>\n<td>A1: 分配对象内存空间</td>\n<td rowspan=\"2\"></td>\n</tr>\n<tr>\n<td>t2</td>\n<td>A3：设置 <code>instance</code> 指向内存空间（先赋值）</td>\n</tr>\n<tr>\n<td>t3</td>\n<td rowspan=\"2\"></td>\n<td>B1：判断 <code>instance</code> 是否为空</td>\n</tr>\n<tr>\n<td>t4</td>\n<td>B2：由于 <code>instance</code> 不为 null，线程 B 将访问 <code>instance</code> 引用的对象</td>\n</tr>\n<tr>\n<td>t5</td>\n<td>A2：初始化对象（再调用构造函数）</td>\n<td rowspan=\"2\"></td>\n</tr>\n<tr>\n<td>t6</td>\n<td>A4：访问 <code>instance</code> 引用的对象</td>\n</tr>\n</tbody>\n</table>\n<p>按照这样的顺序执行，线程 B 将会获得一个未初始化的对象，并且自始至终，线程 B 无需获取锁！</p>\n<p>解决「指令重排序」的方法：</p>\n<ul>\n<li>（在 JDK1.5 之后）使用 <code>volatile</code> 关键字。<code>private static volatile Singleton instance;</code>。</li>\n<li>不用双重检查锁，而是使用代码 2 中的方法</li>\n<li>改用饿汉模式</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><code>volatile</code> 关键字</div>\n</div>\n<div class=\"callout-content\"><p><code>volatile</code> 保证了”可见性“，它的”可见性“是通过它的内存语义实现的：</p>\n<ul>\n<li>写 <code>volatile</code> 修饰的变量时，JMM 会把本地内存中值刷新到主内存</li>\n<li>读 <code>volatile</code> 修饰的变量时，JMM 会设置本地内存无效</li>\n</ul>\n<p>为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来防止重排序。</p>\n</div></div><h2 id=\"登记式静态内部类-iodh\"><a class=\"markdownIt-Anchor\" href=\"#登记式静态内部类-iodh\"></a> 登记式/静态内部类 IoDH</h2>\n<blockquote>\n<p>Initialization Demand Holder。</p>\n</blockquote>\n<p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。</p>\n<p>在 IoDH 中，我们在单例类中增加一个静态（<code>static</code>）内部类，在该内部类中创建单例对象，再将该单例对象通过 <code>getInstance()</code> 方法返回给外部使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonIoDH</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HolderClass</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">SingletonIoDH</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonIoDH</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonIoDH</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生成了一个实例。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonIoDH <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HolderClass.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和饿汉式方法一样，它同样利用了 classloader 机制来保证初始化 <code>instance</code> 时只有一个线程。不一样的是，饿汉式中，只要 <code>Singleton</code> 类被装载了，那么 <code>instance</code> 就会被实例化，没有达到延迟加载（lazy loading）的效果。IoDH 是 <code>Singleton</code> 类被装载了，<code>instance</code> 不一定被初始化。因为 <code>SingletonHolder</code> 类没有被主动使用，只有通过显式调用 <code>getInstance</code> 方法时，才会显式装载 <code>SingletonHolder</code> 类，从而实例化 <code>instance</code>。</p>\n<p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<p>通过使用 IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的 Java 语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持 IoDH）。</p>\n<h2 id=\"枚举\"><a class=\"markdownIt-Anchor\" href=\"#枚举\"></a> 枚举</h2>\n<p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p>\n<p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>\n<p>枚举单例不能通过反射破坏单例。枚举属于饿汉式单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123; </span><br><span class=\"line\">\tINSTANCE;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 可以加入一些初始化方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"单例模式存在的问题\"><a class=\"markdownIt-Anchor\" href=\"#单例模式存在的问题\"></a> 单例模式存在的问题</h1>\n<h2 id=\"单例模式对面向对象特性支持不友好\"><a class=\"markdownIt-Anchor\" href=\"#单例模式对面向对象特性支持不友好\"></a> 单例模式对面向对象特性支持不友好</h2>\n<p>单例模式对面向对象特性中的继承、抽象、多态的支持不友好（注意用词，不是「完全不支持」）。假设现有一单例类 ID 生成器 <code>IdGenerator</code>，调用其 <code>getId()</code> 方法可以生成一个 id 编号。现有如下情景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> create&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId(); <span class=\"comment\">// 硬编码</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> create&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId(); <span class=\"comment\">// 硬编码</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种场景下，单例类 <code>IdGenerator</code> 违背了基于接口而非实现的设计原则，即违背 OOP 中的抽象特性。如果我们需要替换部分单例类 ID 生成器的实现，我们需要修改所有用到 ID 生成器的代码。</p>\n<p>理论上讲，单例类可以被继承或实现多态，但实现方式很奇怪，减少了代码的可读性。所以，一旦选择将某个类设计为单例类，就意味着放弃了继承和多态特性，损失了可以应对未来需求变化的拓展性。</p>\n<h2 id=\"单例会隐藏类之间的依赖关系\"><a class=\"markdownIt-Anchor\" href=\"#单例会隐藏类之间的依赖关系\"></a> 单例会隐藏类之间的依赖关系</h2>\n<p>单例类我们直接上手用就行了，不会看到平常我们使用类时的创建和传递依赖参数的过程。当代码比较复杂时，单例类的调用关系就会非常隐蔽。在阅读某一个类的代码时，我们需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>\n<p>解决方式为，可以使用依赖注入方式使用单例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以前调用单例的方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getInstance().getId();</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用新的依赖注入方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">demofunction</span><span class=\"params\">(IdGenerator idGenerator)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用demofunction()的时候，传入idGenerator</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGenerator</span> <span class=\"operator\">=</span> IdGenerator.getInsance();</span><br><span class=\"line\">demofunction(idGenerator);</span><br></pre></td></tr></table></figure>\n<p>在新的方式中，我们可以将单例生成的对象当作参数传递给函数，或者某个类的成员变量。这样可以解决单例隐藏类之间的依赖关系。</p>\n<h2 id=\"单例对代码的扩展性和可测试性并不友好\"><a class=\"markdownIt-Anchor\" href=\"#单例对代码的扩展性和可测试性并不友好\"></a> 单例对代码的扩展性和可测试性并不友好</h2>\n<p>单例类只能有一个实例，如果有一天想改成多个实例，就会对代码产生大的改动。一般数据库连接池、线程池最好不要设计成单例类。</p>\n<p>如果单例类依赖比较重的外部资源，比如 DB，当我们在写单元测试的时候希望通过 mock 的方式将它替换掉时，单例的硬编码会导致我们无法实现 mock 替换。</p>\n<p>此外，单例类持有的成员变量实际上相当于全局变量，被所有的代码共享。如果全局变量为可被修改的，在测试时还需关注不同测试用例之间的相互影响问题。</p>\n<h2 id=\"单例不支持有参数的构造函数\"><a class=\"markdownIt-Anchor\" href=\"#单例不支持有参数的构造函数\"></a> 单例不支持有参数的构造函数</h2>\n<p>假设我们要创建一个连接池单例对象，我们无法通过参数指定连接池的大小。</p>\n<p>下面介绍两种解决方案。</p>\n<p>方法一：增加 <code>init()</code> 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Singleton has been created!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">Singleton.init(<span class=\"number\">10</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 先init，再使用</span></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br></pre></td></tr></table></figure>\n<p>方法二：将参数放到 <code>getInstance()</code> 方法中，但会有些问题。两次执行 <code>getInstance()</code> 方法时，即使前后传递的参数不一致，得到的单例中的参数总是第一次调用时传递的，这会对调用者产生迷惑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">int</span> paramA, <span class=\"type\">int</span> paramB)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>(paramA, paramB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Singleton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.getInstance(<span class=\"number\">10</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<p>方式三：将参数放置在另一个全局变量 Config 类中。Config 存储的变量可以是静态定义，也可以从配置文件中加载。这种方式是推荐的方式 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_A</span> <span class=\"operator\">=</span> <span class=\"number\">123</span>; <span class=\"comment\">// 静态定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PARAM_B</span> <span class=\"operator\">=</span> <span class=\"number\">456</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramA;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t  instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/43de456a/\"><span class=\"yukari\">站内文章</span>单例模式的应用——为 Java 程序应用全局配置</a> 文章中，展示了单例模式实现方式一、方式三的初始化方式。</p>\n<h1 id=\"替代单例模式的解决方案\"><a class=\"markdownIt-Anchor\" href=\"#替代单例模式的解决方案\"></a> 替代单例模式的解决方案</h1>\n<p>上一节提到了单例模式中的很多问题，但是如果不用单例模式，有什么其他的替代方案保证类的实例全局唯一？</p>\n<p>我们可以使用静态方法实现。但是这种方式比单例更不灵活，他无法支持延迟加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态方法实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用举例</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> IdGenerator.getId();</span><br></pre></td></tr></table></figure>\n<p>也可以通过 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"yukari\">站内文章</span>工厂模式</a>、IOC 容器保证类的全局唯一性，也可以通过程序员自己来保证不创建两个对象的实例（让程序员为代码做承诺不稀奇，毕竟在 C++ 中，程序员也是要保证内存对象的正确释放的）。</p>\n<h1 id=\"单例模式的唯一性\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的唯一性\"></a> 单例模式的唯一性</h1>\n<p>单例模式是指，一个类只允许创建唯一一个对象。这个唯一指的是<strong>进程唯一</strong>的。新老进程中的单例对象并不是同一个对象。</p>\n<p>单例是进程唯一的，该进程下的线程间也都使用同一个单例。<strong>线程唯一</strong>指的是在同一个进程上，不同线程使用各自不同的单例。实现线程唯一的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">currentThreadId</span> <span class=\"operator\">=</span> Thread.currentThread().getId();</span><br><span class=\"line\">    instances.putIfAbsent(currentThreadId, <span class=\"keyword\">new</span> <span class=\"title class_\">IdGenerator</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(currentThreadId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java 本身提供了 <code>ThreadLocal</code> 工具类，可以更加轻松地实现线程唯一的单例。不过，<code>ThreadLocal</code> 的底层实现原理也是基于上面的 <code>HashMap</code>。</p>\n<p>集群可以理解为多个进程构成的集合。集群唯一的单例是指，在同一个集群内的进程都共享同一个单例。实现的具体方式为，把这个单例对象序列化并存储到外部共享存储区（如文件），进程间在使用这个单例对象的时候，先从外部共享存储区中将它读到内存，并反序列化为对象然后再使用，使用完成后需要再存储回外部共享存储区。这个过程中，我们需要对对象进行加锁/解锁操作，以及显示从内存中删除已经使用过的单例的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdGenerator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">SharedObjectStorage</span> <span class=\"variable\">storage</span> <span class=\"operator\">=</span> FileSharedObjectStorage(<span class=\"comment\">/*入参省略，比如文件地址，或者这里可以使用 redis 之类的*/</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">DistributedLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DistributedLock</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">IdGenerator</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      instance = storage.load(IdGenerator.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> synchroinzed <span class=\"keyword\">void</span> <span class=\"title function_\">freeInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    storage.save(<span class=\"built_in\">this</span>, IdGeneator.class);</span><br><span class=\"line\">    instance = <span class=\"literal\">null</span>; <span class=\"comment\">//释放对象</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IdGenerator使用举例</span></span><br><span class=\"line\"><span class=\"type\">IdGenerator</span> <span class=\"variable\">idGeneator</span> <span class=\"operator\">=</span> IdGenerator.getInstance();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.getId();</span><br><span class=\"line\">IdGenerator.freeInstance(); <span class=\"comment\">// 显示删除内存</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"实现一个多例模式\"><a class=\"markdownIt-Anchor\" href=\"#实现一个多例模式\"></a> 实现一个多例模式</h1>\n<p>这里的多例模式是指一个类可以创建有数量限制的多个对象。</p>\n<p>简易实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BackendServer</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> serverNo;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String serverAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SERVER_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">1L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">1L</span>, <span class=\"string\">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">2L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">2L</span>, <span class=\"string\">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class=\"line\">    serverInstances.put(<span class=\"number\">3L</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BackendServer</span>(<span class=\"number\">3L</span>, <span class=\"string\">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">BackendServer</span><span class=\"params\">(<span class=\"type\">long</span> serverNo, String serverAddress)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverNo = serverNo;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.serverAddress = serverAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getInstance</span><span class=\"params\">(<span class=\"type\">long</span> serverNo)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(serverNo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> BackendServer <span class=\"title function_\">getRandomInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">no</span> <span class=\"operator\">=</span> r.nextInt(SERVER_COUNT)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serverInstances.get(no);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于多例模式的另一种理解为：同一个类型的只能创建一个对象，不同类型的可以创建多个对象。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class=\"line\">          = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">Logger</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getInstance</span><span class=\"params\">(String loggerName)</span> &#123;</span><br><span class=\"line\">    instances.putIfAbsent(loggerName, <span class=\"keyword\">new</span> <span class=\"title class_\">Logger</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances.get(loggerName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//l1==l2, l1!=l3</span></span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l1</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l2</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;User.class&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Logger</span> <span class=\"variable\">l3</span> <span class=\"operator\">=</span> Logger.getInstance(<span class=\"string\">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这种多例模式的理解方式有点类似以下两个设计模式：</p>\n<ul>\n<li>工厂模式。与之不同的是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象</li>\n<li>享元模式。</li>\n</ul>\n<p>枚举类型其实也相当于多例模式：一个类型只能对应一个对象，一个类可以创建多个对象。</p>\n<h1 id=\"与单例模式相关的设计模式\"><a class=\"markdownIt-Anchor\" href=\"#与单例模式相关的设计模式\"></a> 与单例模式相关的设计模式</h1>\n<p>在多数情况下，<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"yukari\">站内文章</span>抽象工厂 Abstract Factory</a>、Builder 模式、门面模式 Facade、Prototype 模式只会生成一个单例。</p>\n<h1 id=\"本文-plantuml-代码存档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-代码存档\"></a> 本文 PlantUML 代码存档</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Singleton&#123;</span><br><span class=\"line\">\t- &#123;static&#125; singleton</span><br><span class=\"line\">\t&#123;method&#125; - Singleton</span><br><span class=\"line\">\t&#123;method&#125; + &#123;static&#125; getInstance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》第 5 章单例模式</li>\n<li><a href=\"https://blog.csdn.net/qq_40685457/article/details/82891884\">软件设计模式与体系结构–单例模式_软件设计模式与体系结构电子版-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/ring2/p/11401809.html\">单例模式之双重检测锁 - ring977 - 博客园 (cnblogs.com)</a></li>\n<li>IBM 公司高级软件工程师 Peter Haggar 2004 年在 IBM developerWorks 上发表了一篇名为《<em>双重检查锁定及单例模式——全面理解这一失效的编程习语</em>》的文章，对 JDK 1.5 之前的双重检查锁定及单例模式进行了全面分析和阐述。JDK 1.5 版本之前加入的 volatile 关键字不生效。中文翻译（我猜的）：<a href=\"https://blog.csdn.net/chenchaofuck1/article/details/51702129\">Java单例模式中双重检查锁的问题_java单例模式双重锁-CSDN博客</a></li>\n<li><a href=\"https://gee.cs.oswego.edu/dl/cpj/updates.html\">Updates (oswego.edu)</a> 说明了 JDK 1.5 版本之后 volatile 关键字生效。</li>\n<li><a href=\"https://blog.csdn.net/Rinvay_Cui/article/details/111059024\">63-单例模式的双重检查锁模式为什么必须加 volatile？_double-checked locking 为什么要加volatile-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/lkxsnow/p/12293791.html\">单例陷阱——双重检查锁中的指令重排问题 - Nauyus - 博客园 (cnblogs.com)</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\">单例模式 | 菜鸟教程 (runoob.com)</a></li>\n<li><a href=\"https://blog.csdn.net/ritterliu/article/details/49744397\">IoDH实现的单例模式-CSDN博客</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV16J411h7Rd?spm_id_from=333.788.player.switch&amp;vd_source=e03d48176855fc5349b27aef691f9cdb&amp;p=1\">黑马程序员深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili</a></li>\n<li>极客时间专栏 - 设计模式之美 - 王争（<a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/docs/196790.md\">开源文档地址</a>）</li>\n</ul>\n","raw":"---\ntitle: 单例模式一文通\ntags:\n  - 设计模式\n  - 单例模式\n  - Java\ndescription: 单例模式——只有一个实例。除了具体实现外，还探讨单例模式的一些问题及解决方案\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: f7f6f747\ndate: 2025-06-11 23:49:21\ncover: https://cdn.gallery.uuanqin.top/img/202506120021808.webp\ntop_img:\n---\n\n想在程序中表示某个东西只会存在一个，比如表示程序所运行于那台计算机的类、表示软件系统相关设置的类、表示视窗系统（Window system）的类时，我们可以使用单例模式。\n\n```mermaid\nclassDiagram\n    class Singleton {\n        -$singleton\n        -Singleton()\n        +$getInstance()\n    }\n```\n\n这种使用单例模式的类通常会占用较多的内存，或者示例的初始化过程比较冗长，如果随意创建这些类的示例会影响系统性能。我们使用单例模式的目的：\n\n- 想确保任何情况下都绝对只有 1 个实例，在程序上表现出「只存在一个实例」\n- 处理资源访问冲突\n\n# 单例模式的实现方法\n\n设计单例时需要考虑的要点：\n\n1. 构造方法为私有\n2. 注意线程安全问题\n3. 考虑是否延时加载\n4. 考虑获取单例 `getInstance()` 的性能是否够高\n\n| 实现方法   | 基本饿汉式   | 线程不安全的懒汉式 | 线程安全但锁粒度大的懒汉式 | DCL      | IoDH                    | 枚举           |\n| ------ | ------- | --------- | ------------- | -------- | ----------------------- | ------------ |\n| 饿汉/懒汉  | 饿汉      | 懒汉        | 懒汉            | 懒汉       | 懒汉                      | 饿汉           |\n| JDK 版本 |         |           |               | JDK1.5 起 |                         | JDK1.5 起     |\n| 延迟加载   | 🟥      | 🟩        | 🟩            | 🟩       | 🟩                      | 🟥           |\n| 线程安全   | 🟩      | 🟥        | 🟩            | 🟩       | 🟩                      | 🟩           |\n| 实现难度   | 🟩      | 🟩        | 🟩            | 🟥       | 🟥                      | 🟩           |\n| 应用场景   | 一般情况下使用 | 不建议       | 不建议           | 存在特殊需求时  | 在要明确实现 lazy loading 效果时 | 涉及到反序列化创建对象时 |\n\n## 基本饿汉模式\n\n基于 classloader 机制避免了多线程的同步问题。\n\n```java\npublic class Singleton {\n\t//  外部第一次调用getInstance函数时instance才初始化\n    private final static Singleton instance = new Singleton();\n\n\t// 私有构造方法\n    private Singleton() {\n        System.out.println(\"生成了一个实例。\");\n    }\n\n\t//从Singleton类外部获取唯一实例\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n`instance` 前的关键字加上了 `final` 关键字的原因：防止子类不恰当的方法覆盖单例。\n\n构造方法为私有 `private` 的原因：禁止从 `Singleton` 类外部调用构造函数。只有自己才能 `new` 自己。外部只能通过类的静态方法使用。但是不能防止反射创建新的实例。\n\n如果 `Singleton` 实现了序列化接口，我们还需要增加以下代码防止反序列化破坏单例：\n\n```java\npublic class Singleton implements Serializable {\n\tprivate final static Singleton instance = new Singleton();\n\t/* ... */\n\tpublic Object readResolve(){\n\t\treturn instance;\n\t}\n}\n```\n\n这样的初始化是可以保证单例对象创建时的线程安全。因为静态成员变量的初始化在类加载阶段完成，类加载阶段由 JVM 保证线程安全。\n\n如果饿汉模式下的单例初始化时间长，占用资源多是否意味着提前初始化是浪费资源的行为？答案是否定的，我们最好不要等用到的时候再初始化这个单例，这反而会降低系统性能。饿汉模式下将耗时的初始化操作提前到程序启动时完成，可以避免程序运行时初始化导致的性能问题。\n\n相关参考：\n\n- 类的生命周期中解释 `instance` 实例化的时机。\n- 这种饿汉模式的单例模式实现方法，是静态工厂模式的一种应用。\n\n## 基本懒汉模式\n\n懒汉模式：没有一上来就创建实例，而是需要用的时候才创建。\n\n### 代码 1：线程不安全的写法\n\n> 严格意义上，这不是单例模式。\n\n```java\npublic class Singleton {\n    private static Singleton instance = null;\n    private Singleton() {\n        System.out.println(\"生成了一个实例。\");\n                           \n    }\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n这个实现适合于单线程程序。然而，当引入多线程时，就必须通过同步来保护 `getInstance()` 方法。如果不保护 `getInstance()` 方法，则可能返回 `Singleton` 对象的两个不同的实例。\n\n### 代码 2：线程安全的写法（锁粒度较大）\n\n> Balking 模式的一种体现。\n\n改造 `getInstance` 方法：\n\n```java\n// 代码1容易有竞争问题，如果两个线程 getInstance，可能都误以为都是NULL。所以添加synchronized\npublic static synchronized Singleton getInstance() {\n\tif (instance == null) {           // 1\n\t\tinstance = new Singleton();   // 2\n\t}\n\treturn instance;                  // 3\n}\n```\n\n然而，当分析这段代码时，我们发现只有在第一次调用方法时才需要同步。由于只有第一次调用执行了 `//2` 处的代码，而只有此行代码需要同步，因此就无需对后续调用使用同步。\n\n> [!hint] `synchronized` 是一个重量级的锁操作，它将全部代码块锁住，会导致较大的性能开销。\n\n否则，后续的每一次对 `getInstance` 的调用都要付出同步的代价。\n\n### 代码 3：双重检查锁 DCL\n\n> 双重检查锁 DCL(double checked locking)\n\n为了避免对除第一次调用外的所有调用都实行同步的昂贵代价。我们将代码 2 中的 `//2` 包到一个同步块中。\n\n```java\npublic static Singleton getInstance() {\n\tif(instance==null) {\n\t\t//可能多个线程同时进入到这一步进行阻塞等待\n\t\tsynchronized(Singleton.class) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t}\n\treturn instance;\n}\n```\n\n但是还是出现了和代码 1 一样的问题，可能会出现多个线程进入 `if` 内部。\n\n为处理上面代码中的问题，我们需要对 `instance` 进行第二次检查。这就是“双重检查锁定”名称的由来。\n\n```java\n// DCL 双重检查锁\npublic static Singleton getInstance(){\n\tif (instance == null){                   //1\n\t    synchronized(Singleton.class) {       //2\n\t\t    if (instance == null){           //3\n\t\t\t    instance = new Singleton();  //4\n\t\t\t}\n\t    }\n\t}\n\treturn instance;\n}\n```\n\n> 这个过程让我想起了动物界的精卵结合的过程......第一层 null 判断可快速返回单例，第二层 null 判断可防止重写。\n\n双重检查锁定背后的理论是完美的，但还是会存在问题。双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型，这个内存模型允许所谓的“指令重排序”。\n\n> [!hint] 指令重排序\n> 指令重排序是指编译器或处理器为了优化性能而采取的一种手段，在不存在数据依赖性情况下（如写后读，读后写，写后写），调整代码执行顺序。\n\n代码行 `//4` 中，在 java 中创建一个对象并非是一个原子操作，可以被分解成三行伪代码：\n\n```java\n//1：分配对象的内存空间\nmemory = allocate();\n//2：初始化对象\nctorInstance(memory);  \n//3：设置instance指向刚分配的内存地址\ninstance = memory;     \n```\n\n而在一些 JIT 编译器中，为提高性能，伪代码的第二步和第三步顺序会交换（变为先赋值，再调用构造函数）。在单线程程序下，重排序不会对最终结果产生影响，但是并发的情况下，可能会导致某些线程访问到未初始化的变量。模拟一个 2 个线程创建单例的场景，如下表：\n\n| 时间  | 线程 A                         | 线程 B                                               |\n| --- | ---------------------------- | -------------------------------------------------- |\n| t1  | A1: 分配对象内存空间                 |                                                    |\n| t2  | A3：设置 `instance` 指向内存空间（先赋值） |                                                    |\n| t3  |                              | B1：判断 `instance` 是否为空                              |\n| t4  |                              | B2：由于 `instance` 不为 null，线程 B 将访问 `instance` 引用的对象 |\n| t5  | A2：初始化对象（再调用构造函数）            |                                                    |\n| t6  | A4：访问 `instance` 引用的对象       |                                                    |\n\n按照这样的顺序执行，线程 B 将会获得一个未初始化的对象，并且自始至终，线程 B 无需获取锁！\n\n解决「指令重排序」的方法：\n\n- （在 JDK1.5 之后）使用 `volatile` 关键字。`private static volatile Singleton instance;`。\n- 不用双重检查锁，而是使用代码 2 中的方法\n- 改用饿汉模式\n\n> [!hint] `volatile` 关键字\n> `volatile` 保证了”可见性“，它的”可见性“是通过它的内存语义实现的：\n>\n> - 写 `volatile` 修饰的变量时，JMM 会把本地内存中值刷新到主内存\n> - 读 `volatile` 修饰的变量时，JMM 会设置本地内存无效\n> \n> 为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来防止重排序。\n\n## 登记式/静态内部类 IoDH\n\n> Initialization Demand Holder。\n\n饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。\n\n在 IoDH 中，我们在单例类中增加一个静态（`static`）内部类，在该内部类中创建单例对象，再将该单例对象通过 `getInstance()` 方法返回给外部使用。\n\n```java\npublic class SingletonIoDH {\n\n    private static class HolderClass{\n        private final static SingletonIoDH instance = new SingletonIoDH();\n    }\n    private SingletonIoDH(){\n        System.out.println(\"生成了一个实例。\");\n    }\n\n    public static SingletonIoDH getInstance() {\n        return HolderClass.instance;\n    }\n\n}\n```\n\n和饿汉式方法一样，它同样利用了 classloader 机制来保证初始化 `instance` 时只有一个线程。不一样的是，饿汉式中，只要 `Singleton` 类被装载了，那么 `instance` 就会被实例化，没有达到延迟加载（lazy loading）的效果。IoDH 是 `Singleton` 类被装载了，`instance` 不一定被初始化。因为 `SingletonHolder` 类没有被主动使用，只有通过显式调用 `getInstance` 方法时，才会显式装载 `SingletonHolder` 类，从而实例化 `instance`。\n\n这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n通过使用 IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的 Java 语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持 IoDH）。\n\n## 枚举\n\n这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。\n\n这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。\n\n枚举单例不能通过反射破坏单例。枚举属于饿汉式单例模式。\n\n```java\npublic enum Singleton { \n\tINSTANCE;\n\tprivate AtomicLong id = new AtomicLong(0);\n\t// 可以加入一些初始化方法\n\tpublic long getId(){\n\t\treturn id.incrementAndGet();\n\t}\n}\n```\n\n# 单例模式存在的问题\n\n## 单例模式对面向对象特性支持不友好\n\n单例模式对面向对象特性中的继承、抽象、多态的支持不友好（注意用词，不是「完全不支持」）。假设现有一单例类 ID 生成器 `IdGenerator`，调用其 `getId()` 方法可以生成一个 id 编号。现有如下情景：\n\n```java\npublic class Order {\n\tpublic void create{\n\t\tlong id = IdGenerator.getInstance().getId(); // 硬编码\n\t}\n}\n\npublic class User {\n\tpublic void create{\n\t\tlong id = IdGenerator.getInstance().getId(); // 硬编码\n\t}\n}\n```\n\n这种场景下，单例类 `IdGenerator` 违背了基于接口而非实现的设计原则，即违背 OOP 中的抽象特性。如果我们需要替换部分单例类 ID 生成器的实现，我们需要修改所有用到 ID 生成器的代码。\n\n理论上讲，单例类可以被继承或实现多态，但实现方式很奇怪，减少了代码的可读性。所以，一旦选择将某个类设计为单例类，就意味着放弃了继承和多态特性，损失了可以应对未来需求变化的拓展性。\n\n## 单例会隐藏类之间的依赖关系\n\n单例类我们直接上手用就行了，不会看到平常我们使用类时的创建和传递依赖参数的过程。当代码比较复杂时，单例类的调用关系就会非常隐蔽。在阅读某一个类的代码时，我们需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\n\n解决方式为，可以使用依赖注入方式使用单例：\n\n```java\n// 以前调用单例的方式\npublic demofunction() {\n\t//...\n\tlong id = IdGenerator.getInstance().getId();\n\t//...\n}\n\n// 使用新的依赖注入方式\npublic demofunction(IdGenerator idGenerator) {\n\tlong id = idGenerator.getId();\n}\n// 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator = IdGenerator.getInsance();\ndemofunction(idGenerator);\n```\n\n在新的方式中，我们可以将单例生成的对象当作参数传递给函数，或者某个类的成员变量。这样可以解决单例隐藏类之间的依赖关系。\n\n## 单例对代码的扩展性和可测试性并不友好\n\n单例类只能有一个实例，如果有一天想改成多个实例，就会对代码产生大的改动。一般数据库连接池、线程池最好不要设计成单例类。\n\n如果单例类依赖比较重的外部资源，比如 DB，当我们在写单元测试的时候希望通过 mock 的方式将它替换掉时，单例的硬编码会导致我们无法实现 mock 替换。\n\n此外，单例类持有的成员变量实际上相当于全局变量，被所有的代码共享。如果全局变量为可被修改的，在测试时还需关注不同测试用例之间的相互影响问题。\n\n## 单例不支持有参数的构造函数\n\n假设我们要创建一个连接池单例对象，我们无法通过参数指定连接池的大小。\n\n下面介绍两种解决方案。\n\n方法一：增加 `init()` 方法。\n\n```java\npublic class Singleton {\n    private static Singleton instance = null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) {\n        this.paramA = paramA;\n        this.paramB = paramB;\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            throw new RuntimeException(\"Run init() first.\");\n        }\n        return instance;\n    }\n\n    public synchronized static Singleton init(int paramA, int paramB) {\n        if (instance != null){\n            throw new RuntimeException(\"Singleton has been created!\");\n        }\n        instance = new Singleton(paramA, paramB);\n        return instance;\n    }\n}\n\n// 使用方式\nSingleton.init(10, 50); // 先init，再使用\nSingleton singleton = Singleton.getInstance();\n```\n\n方法二：将参数放到 `getInstance()` 方法中，但会有些问题。两次执行 `getInstance()` 方法时，即使前后传递的参数不一致，得到的单例中的参数总是第一次调用时传递的，这会对调用者产生迷惑。\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton(int paramA, int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n\n  public synchronized static Singleton getInstance(int paramA, int paramB) {\n    if (instance == null) {\n      instance = new Singleton(paramA, paramB);\n    }\n    return instance;\n  }\n}\n\nSingleton singleton = Singleton.getInstance(10, 50);\n```\n\n方式三：将参数放置在另一个全局变量 Config 类中。Config 存储的变量可以是静态定义，也可以从配置文件中加载。这种方式是推荐的方式 。\n\n```java\npublic class Config{\n\tpublic static final int PARAM_A = 123; // 静态定义\n\tpublic static final int PARAM_B = 456;\n}\n\npublic class Singleton {\n\tprivate static Singleton instance = null;\n\tprivate final int paramA;\n\tprivate final int paramB;\n\n\tprivate Singleton(){\n\t\tthis.paramA = Config.PARAM_A;\n\t\tthis.paramB = Config.PARAM_B;\n\t}\n\n\tpublic synchronized static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t  instance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n在 [[单例模式的应用——为 Java 程序应用全局配置]] 文章中，展示了单例模式实现方式一、方式三的初始化方式。\n\n# 替代单例模式的解决方案\n\n上一节提到了单例模式中的很多问题，但是如果不用单例模式，有什么其他的替代方案保证类的实例全局唯一？\n\n我们可以使用静态方法实现。但是这种方式比单例更不灵活，他无法支持延迟加载。\n\n```java\n// 静态方法实现方式\npublic class IdGenerator {\n  private static AtomicLong id = new AtomicLong(0);\n  \n  public static long getId() { \n    return id.incrementAndGet();\n  }\n}\n// 使用举例\nlong id = IdGenerator.getId();\n```\n\n也可以通过 [[工厂模式（简单工厂、静态工厂、抽象工厂）|工厂模式]]、IOC 容器保证类的全局唯一性，也可以通过程序员自己来保证不创建两个对象的实例（让程序员为代码做承诺不稀奇，毕竟在 C++ 中，程序员也是要保证内存对象的正确释放的）。\n\n# 单例模式的唯一性\n\n单例模式是指，一个类只允许创建唯一一个对象。这个唯一指的是**进程唯一**的。新老进程中的单例对象并不是同一个对象。\n\n单例是进程唯一的，该进程下的线程间也都使用同一个单例。**线程唯一**指的是在同一个进程上，不同线程使用各自不同的单例。实现线程唯一的例子：\n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n\n  private static final ConcurrentHashMap<Long, IdGenerator> instances\n          = new ConcurrentHashMap<>();\n\n  private IdGenerator() {}\n\n  public static IdGenerator getInstance() {\n    Long currentThreadId = Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n  }\n\n  public long getId() {\n    return id.incrementAndGet();\n  }\n}\n```\n\nJava 本身提供了 `ThreadLocal` 工具类，可以更加轻松地实现线程唯一的单例。不过，`ThreadLocal` 的底层实现原理也是基于上面的 `HashMap`。\n\n集群可以理解为多个进程构成的集合。集群唯一的单例是指，在同一个集群内的进程都共享同一个单例。实现的具体方式为，把这个单例对象序列化并存储到外部共享存储区（如文件），进程间在使用这个单例对象的时候，先从外部共享存储区中将它读到内存，并反序列化为对象然后再使用，使用完成后需要再存储回外部共享存储区。这个过程中，我们需要对对象进行加锁/解锁操作，以及显示从内存中删除已经使用过的单例的操作。\n\n```java\npublic class IdGenerator {\n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址，或者这里可以使用 redis 之类的*/);\n  private static DistributedLock lock = new DistributedLock();\n  \n  private IdGenerator() {}\n\n  public synchronized static IdGenerator getInstance() \n    if (instance == null) {\n      lock.lock();\n      instance = storage.load(IdGenerator.class);\n    }\n    return instance;\n  }\n  \n  public synchroinzed void freeInstance() {\n    storage.save(this, IdGeneator.class);\n    instance = null; //释放对象\n    lock.unlock();\n  }\n  \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nIdGenerator idGeneator = IdGenerator.getInstance();\nlong id = idGenerator.getId();\nIdGenerator.freeInstance(); // 显示删除内存\n```\n\n# 实现一个多例模式\n\n这里的多例模式是指一个类可以创建有数量限制的多个对象。\n\n简易实现如下：\n\n```java\npublic class BackendServer {\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT = 3;\n  private static final Map<Long, BackendServer> serverInstances = new HashMap<>();\n\n  static {\n    serverInstances.put(1L, new BackendServer(1L, \"192.134.22.138:8080\"));\n    serverInstances.put(2L, new BackendServer(2L, \"192.134.22.139:8080\"));\n    serverInstances.put(3L, new BackendServer(3L, \"192.134.22.140:8080\"));\n  }\n\n  private BackendServer(long serverNo, String serverAddress) {\n    this.serverNo = serverNo;\n    this.serverAddress = serverAddress;\n  }\n\n  public BackendServer getInstance(long serverNo) {\n    return serverInstances.get(serverNo);\n  }\n\n  public BackendServer getRandomInstance() {\n    Random r = new Random();\n    int no = r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  }\n}\n```\n\n对于多例模式的另一种理解为：同一个类型的只能创建一个对象，不同类型的可以创建多个对象。代码如下：\n\n```java\npublic class Logger {\n  private static final ConcurrentHashMap<String, Logger> instances\n          = new ConcurrentHashMap<>();\n\n  private Logger() {}\n\n  public static Logger getInstance(String loggerName) {\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  }\n\n  public void log() {\n    //...\n  }\n}\n\n//l1==l2, l1!=l3\nLogger l1 = Logger.getInstance(\"User.class\");\nLogger l2 = Logger.getInstance(\"User.class\");\nLogger l3 = Logger.getInstance(\"Order.class\");\n```\n\n这种多例模式的理解方式有点类似以下两个设计模式：\n\n- 工厂模式。与之不同的是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象\n- 享元模式。\n\n枚举类型其实也相当于多例模式：一个类型只能对应一个对象，一个类可以创建多个对象。\n\n# 与单例模式相关的设计模式\n\n在多数情况下，[[工厂模式（简单工厂、静态工厂、抽象工厂）|抽象工厂 Abstract Factory]]、Builder 模式、门面模式 Facade、Prototype 模式只会生成一个单例。\n\n# 本文 PlantUML 代码存档\n\n```plantuml\nclass Singleton{\n\t- {static} singleton\n\t{method} - Singleton\n\t{method} + {static} getInstance\n}\n```\n\n# 本文参考\n\n- 《图解设计模式》第 5 章单例模式\n- [软件设计模式与体系结构--单例模式_软件设计模式与体系结构电子版-CSDN博客](https://blog.csdn.net/qq_40685457/article/details/82891884)\n- [单例模式之双重检测锁 - ring977 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ring2/p/11401809.html)\n- IBM 公司高级软件工程师 Peter Haggar 2004 年在 IBM developerWorks 上发表了一篇名为《_双重检查锁定及单例模式——全面理解这一失效的编程习语_》的文章，对 JDK 1.5 之前的双重检查锁定及单例模式进行了全面分析和阐述。JDK 1.5 版本之前加入的 volatile 关键字不生效。中文翻译（我猜的）：[Java单例模式中双重检查锁的问题_java单例模式双重锁-CSDN博客](https://blog.csdn.net/chenchaofuck1/article/details/51702129)\n- [Updates (oswego.edu)](https://gee.cs.oswego.edu/dl/cpj/updates.html) 说明了 JDK 1.5 版本之后 volatile 关键字生效。\n- [63-单例模式的双重检查锁模式为什么必须加 volatile？_double-checked locking 为什么要加volatile-CSDN博客](https://blog.csdn.net/Rinvay_Cui/article/details/111059024)\n- [单例陷阱——双重检查锁中的指令重排问题 - Nauyus - 博客园 (cnblogs.com)](https://www.cnblogs.com/lkxsnow/p/12293791.html)\n- [单例模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/singleton-pattern.html)\n- [IoDH实现的单例模式-CSDN博客](https://blog.csdn.net/ritterliu/article/details/49744397)\n- [黑马程序员深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16J411h7Rd?spm_id_from=333.788.player.switch&vd_source=e03d48176855fc5349b27aef691f9cdb&p=1)\n- 极客时间专栏 - 设计模式之美 - 王争（[开源文档地址](https://gitee.com/buxsren/design-pattern-books/blob/master/docs/196790.md)）","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"单例模式","api":"api/tags/单例模式.json"}]},"api":"api/posts/p/f7f6f747.json"}