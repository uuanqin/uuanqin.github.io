{"data":{"title":"代理模式：爱因斯坦和他的司机","slug":"高质量代码及设计模式/代理模式：爱因斯坦和他的司机","description":"只在必要时生成实例","date":"2025-08-10T16:52:22.000Z","updated":"2025-08-18T12:53:10.404Z","language":"zh-CN","comments":true,"url":"p/ba3851cf/","cover":"https://cdn.gallery.uuanqin.top/img/202508110052894.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240725155040.webp\" alt=\"img\" width=\"375px\" /></p>\n<blockquote>\n<p>🍐⚱️：（代理模式举例）爱因斯坦和他司机的故事——司机负责演讲，有人提问的时候就叫爱因斯坦起来回答问题 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n</blockquote>\n\n<details class=\"callout\" data-callout=\"cite\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-quote\"><path d=\"M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z\"/><path d=\"M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">小故事：爱因斯坦和他的司机</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>爱因斯坦提出相对论后，震惊世界，于是被很多大学邀请去做报告，爱因斯坦因此而被弄得疲惫不堪。</p>\n<p>有一天，司机对他说：“你太累了，今天我帮你作报告吧？”</p>\n<p>爱因斯坦问：“你能行吗？”</p>\n<p>司机说：“我闭着眼睛都能背出来。”</p>\n<p>那天司机上台，果然讲得滴水不漏。</p>\n<p>但刚想下台时，一位博士站了起来，然后提了一个非常深奥刁钻的问题。</p>\n<p>司机不知怎么作答，幸好脑瓜转得快：“你这问题太简单了，我司机都能回答。”</p>\n<p>爱因斯坦站起来，几句话就解决了问题。</p>\n<p>博士惊呆了：“没想到他的司机也远胜于我。”</p>\n<p>但在回去的路上，司机对爱因斯坦说：“我知道的只是概念，你懂得的才是知识。”</p>\n</div></details><p>代理模式可以在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>\n<p>登场角色：</p>\n<ul>\n<li><code>Subject</code>（主体）：<code>Subject</code> 角色定义了使 <code>Proxy</code> 角色和 <code>RealSubject</code> 角色之间具有一致性的接口。由于存在 <code>Subject</code> 角色，所以 <code>Client</code> 角色不必在意它所使用的究竟是 <code>Proxy</code> 角色还是 <code>RealSubject</code> 角色。</li>\n<li><code>Proxy</code>（代理人)：<code>Proxy</code> 角色会尽量处理来自 <code>Client</code> 角色的请求。只有当自己不能处理时，它才会将工作交给 <code>RealSubject</code> 角色。<code>Proxy</code> 角色只有在必要时才会生成 <code>RealSubject</code> 角色。<code>Proxy</code> 角色实现了在 <code>Subject</code> 角色中定义的接口（API）。在示例程序中，由 <code>PrinterProxy</code> 类扮演此角色。</li>\n<li><code>RealSubject</code>（实际的主体、被代理类)：“本人”<code>RealSubject</code> 角色会在「代理人 <code>Proxy</code>」角色无法胜任工作时出场。它与 <code>Proxy</code> 角色一样，也实现了在 <code>Subject</code> 角色中定义的接口（API）。<code>RealSubject</code> 并不知道 <code>Proxy</code> 的存在。</li>\n<li><code>Client</code>（请求者）：使用 <code>Proxy</code> 模式的角色。在 GoF 书中，<code>Client</code> 角色并不包含在代理模式中。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508080009615.webp\" alt=\"image.png\" /></p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request1</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request2</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request3</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;被代理类执行 request 1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;被代理类执行 request 2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;被代理类执行 request 3&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">RealSubject</span> <span class=\"variable\">realSubject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>(); <span class=\"comment\">// 构造函数或IoC容器注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 写自己的逻辑 */</span></span><br><span class=\"line\">        realSubject.request1();</span><br><span class=\"line\">        <span class=\"comment\">/* 写自己的逻辑 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realSubject.request2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        realSubject.request3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>();</span><br><span class=\"line\">\tsubject.request1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\">Proxy 代理类的自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\">被代理类执行 request 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>代理模式在访问实际对象时引入一定程度的间接性，利用这种间接性我们可以附加多种用途。拓展思路：</p>\n<ul>\n<li>使用代理人来提升处理速度</li>\n<li>我们可以不划分 <code>Proxy</code> 类和 <code>RealSubject</code> 类，而是直接在 <code>RealSubject</code> 类中加入惰性求值功能（即只有必要时才生成实例的功能）。不过划分 <code>Proxy</code> 和 <code>RealSubject</code> 角色可以使它们成为独立的组件，在修改的时候也不会互相之间产生影响（分而治之）。</li>\n<li>代理与委托。代理人只代理他能解决的问题。当遇到他不能解决的问题时，还是会「委托」给本人去解决。（在现实世界中，应当是本人将事情委托给代理人负责，而在设计模式中则是反过来的。）</li>\n<li>透明性。在 <code>Main</code> 中 <code>Client</code> 直接使用 <code>Subject</code> 接口，<code>Main</code> 不必在意调用的究竟是哪个类。在这种情况下，可以说 <code>Proxy</code> 类是具有「<a href=\"https://blog.csdn.net/weixin_51350847/article/details/141818403\">透明性</a>」的。</li>\n<li>各种代理模式：代理模式有很多种变化形式。\n<ul>\n<li>Virtual Proxy（虚拟代理）：Virtual Proxy 就是本章节演示的代理模式。只有当真正需要实例时，它才生成和初始化实例。</li>\n<li>Remote Proxy（远程代理）：Remote Proxy 可以让我们完全不必在意 RealSubject 角色是否在远程网络上，可以如同它在自己身边一样（透明性地）调用它的方法。Java 的 RMI （Remote Method Invocation 远程方法调用） 就相当于 Remote Proxy。或者 RPC 框架。</li>\n<li>Access Proxy：Access Proxy 用于在调用 RealSubject 角色的功能时设置访问限制。例如，这种代理可以只允许指定的用户调用方法，而当其他用户调用方法时则报错。</li>\n</ul>\n</li>\n</ul>\n\n<details class=\"callout\" data-callout=\"example\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">打印机案例</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240725160455.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<ul>\n<li><code>Printer</code> 打印机 <code>print()</code> 函数调用了 <code>heavyJob</code> 函数。</li>\n<li><code>PrinterProxy</code> 不实现真正的 <code>print</code> 函数。 <code>realize</code> 函数用于实现真正的打印机，这个函数只在调用了代理类的 <code>print</code> 函数时调用。不论 <code>setPrinterName</code> 方法和 <code>getPrinterName</code> 方法被调用多少次，都不会生成 <code>Printer</code> 类的实例。只有当真正需要本人时，才会生成 <code>Printer</code> 类的实例。</li>\n<li>上图疑似有误：<code>Client</code> 应当使用抽象 <code>Subject</code> 才对</li>\n</ul>\n</div></details><p>相关的设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>适配器模式</a>：适配器模式适配了两种具有不同接口（API）的对象，以使它们可以一同工作。而在 代理模式中，<code>Proxy</code> 角色与 <code>RealSubject</code> 角色的接口（API）是相同的（透明性）。</li>\n<li>装饰者模式 Decorator：Decorator 模式与代理模式在实现上很相似，不过它们的使用目的不同。Decorator 模式的目的在于增加新的功能。而在 Proxy 模式中，与增加新功能相比，它更注重通过设置代理人的方式来减轻本人的工作负担。</li>\n</ul>\n<h1 id=\"通过继承的方式代理第三方类\"><a class=\"markdownIt-Anchor\" href=\"#通过继承的方式代理第三方类\"></a> 通过继承的方式代理第三方类</h1>\n<p>在上面的例子中，代理类 <code>Proxy</code> 和被代理类 <code>RealSubject</code> 都继承同一个接口。如果被代理类没有定义接口，且无法修改源码（如第三方类库的类），我们就不能用上面的方法实现代理模式。</p>\n<p>解决方案：继承。让代理类继承原始类，然后扩展附加功能。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508080010513.webp\" alt=\"image.png\" /></p>\n<p>代理类 <code>Proxy</code> 通过 <code>super.request1()</code> 的方式委托被代理类。</p>\n<h1 id=\"动态代理-dynamic-proxy\"><a class=\"markdownIt-Anchor\" href=\"#动态代理-dynamic-proxy\"></a> 动态代理 Dynamic Proxy</h1>\n<p>由程序员创建或特定工具自动生成代理模式的源代码，即在编译前就已经将接口，被代理类，代理类等确定下来的代理方式，叫做静态代理。</p>\n<p>如果通过静态代理的方式实现代理模式，对于每个代理类 <code>Proxy</code>，我们都需要将被代理类的所有方法重新实现一遍，且代理类 <code>Proxy</code> 每个方法都有相似的代码逻辑。如果被代理类很多，那么代理类也会很多，增加代码的维护成本。</p>\n<p>动态代理：不事先为每个原始类编写代理类，而是在运行的时候，根据我们在 Java 代码中的「指示」，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</p>\n<table>\n<thead>\n<tr>\n<th>代理方式</th>\n<th>静态代理</th>\n<th>动态代理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JVM</td>\n<td>编译时生成代理类的 class 文件</td>\n<td>运行时动态生成类字节码并加载到 JVM</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>🔴接口一旦新增加方法，目标对象和代理对象都要进行修改</td>\n<td>🟢不需要针对每个目标类都创建一个代理类</td>\n</tr>\n</tbody>\n</table>\n<p>Java 标准库提供了动态代理机制，可以在运行期动态创建某个 <code>interface</code> 的实例，不用编写实现类。动态代理依赖 Java <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c8dc9bbd/\"><span class=\"yukari\">站内文章</span>反射</a> 语法。</p>\n<p>Java 常用的动态代理实现方式有：</p>\n<table>\n<thead>\n<tr>\n<th>动态代理</th>\n<th>JDK</th>\n<th>CGLIB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代理对象</td>\n<td>实现了接口的类或者直接代理接口</td>\n<td>未实现任何接口的类</td>\n</tr>\n<tr>\n<td>效率</td>\n<td>🟢</td>\n<td>🟡</td>\n</tr>\n<tr>\n<td>特点</td>\n<td>简单易用</td>\n<td>引入第三方库</td>\n</tr>\n</tbody>\n</table>\n<p>在 Spring 中的 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e036b68e/\"><span class=\"yukari\">站内文章</span>AOP</a> 模块中，如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>\n<h2 id=\"jdk-动态代理\"><a class=\"markdownIt-Anchor\" href=\"#jdk-动态代理\"></a> JDK 动态代理</h2>\n<p>假设，代理类 <code>Proxy</code> 在调用被代理类前都需要执行前置方法和后置方法。在静态代理方式，我们需要将 <code>Proxy</code> 的 <code>request1</code>、<code>request2</code>、<code>request3</code> 都改动代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RealSubject realSubject; <span class=\"comment\">// 省略注入逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        beforeMethod();         <span class=\"comment\">// 前置方法</span></span><br><span class=\"line\">\t\trealSubject.request1(); <span class=\"comment\">// 调用被代理类方法</span></span><br><span class=\"line\">\t\tafterMethod();          <span class=\"comment\">// 后置方法</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略 request2，request3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在 Java 的 <code>java.lang.reflect</code> 包下提供了一个 <code>Proxy</code> 类和一个 <code>InvocationHandler</code> 接口，通过这个类和这个接口可以生成 JDK 动态代理类和动态代理对象。</p>\n<p>JDK 动态代理类使用步骤：</p>\n<ol>\n<li>定义一个接口及其实现类；</li>\n<li>自定义 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>\n<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>\n</ol>\n<p>下面是示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyInvocationHandler</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    T target; <span class=\"comment\">// 被代理对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyInvocationHandler</span><span class=\"params\">(T target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\tproxy :动态生成的代理类</span></span><br><span class=\"line\"><span class=\"comment\">\t\tmethod : 与代理类对象调用的方法相对应</span></span><br><span class=\"line\"><span class=\"comment\">\t\targs : 当前 method 方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;MyInvocationHandler 执行 &quot;</span> + method.getName() + <span class=\"string\">&quot; 方法&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 编写调用方法前逻辑</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法执行前，代理类执行自定义逻辑&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行被代理类的方法</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        <span class=\"comment\">// 编写调用方法前逻辑</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法执行后，代理类执行自定义逻辑\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主函数使用动态代理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 被代理对象</span></span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyInvocationHandler</span>&lt;&gt;(subject);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Subject) java.lang.reflect.Proxy</span><br><span class=\"line\">                .newProxyInstance(</span><br><span class=\"line\">                        Subject.class.getClassLoader(), <span class=\"comment\">// 传入ClassLoader，通常就是接口类的`ClassLoader`</span></span><br><span class=\"line\">                        <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;Subject.class&#125;,    <span class=\"comment\">// 传入要实现的接口，即被代理类实现的接口，可能会有多个</span></span><br><span class=\"line\">                        handler  <span class=\"comment\">// 传入处理调用方法的InvocationHandler</span></span><br><span class=\"line\">                );</span><br><span class=\"line\"></span><br><span class=\"line\">        proxy.request1();</span><br><span class=\"line\">        proxy.request2();</span><br><span class=\"line\">        proxy.request3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\">MyInvocationHandler 执行 request1方法</span></span><br><span class=\"line\"><span class=\"comment\">方法执行前，代理类执行自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\">被代理类执行 request 1</span></span><br><span class=\"line\"><span class=\"comment\">方法执行后，代理类执行自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">MyInvocationHandler 执行 request2方法</span></span><br><span class=\"line\"><span class=\"comment\">方法执行前，代理类执行自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\">被代理类执行 request 2</span></span><br><span class=\"line\"><span class=\"comment\">方法执行后，代理类执行自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">MyInvocationHandler 执行 request3方法</span></span><br><span class=\"line\"><span class=\"comment\">方法执行前，代理类执行自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\">被代理类执行 request 3</span></span><br><span class=\"line\"><span class=\"comment\">方法执行后，代理类执行自定义逻辑</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 <code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>\n<p>此处动态代理的优势体现为：可以方便对代理类的函数进行统一处理，不用修改代理类中的方法。因为代理类中的方法，是通过 <code>InvocationHandler</code> 中的 <code>invoke</code> 方法调用的，所以我们只要在 <code>invoke</code> 方法中统一处理，就可以对所有被代理的方法进行相同的操作了。</p>\n<h3 id=\"优化使用工厂创建代理类\"><a class=\"markdownIt-Anchor\" href=\"#优化使用工厂创建代理类\"></a> 优化：使用工厂创建代理类</h3>\n<p>在上面的 <code>main</code> 代码调用中，我们创建实现了 <code>Subject</code> 接口的代理类还能通过 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"yukari\">站内文章</span>引入工厂</a> 进一步优化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SubjectProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Subject <span class=\"title function_\">getProxy</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Subject) java.lang.reflect.Proxy.newProxyInstance(</span><br><span class=\"line\">                target.getClass().getClassLoader(), <span class=\"comment\">// 目标类的类加载器</span></span><br><span class=\"line\">                target.getClass().getInterfaces(),  <span class=\"comment\">// 代理需要实现的接口，可指定多个</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">MyInvocationHandler</span>&lt;&gt;(target)   <span class=\"comment\">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>main</code> 代码的调用简化为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>();</span><br><span class=\"line\"><span class=\"type\">Subject</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> SubjectProxyFactory.getProxy(subject);</span><br></pre></td></tr></table></figure>\n<h3 id=\"源码浅析真的很浅\"><a class=\"markdownIt-Anchor\" href=\"#源码浅析真的很浅\"></a> 源码浅析（真的很浅）</h3>\n<p>通读 JDK 动态代理实现源码，我们可以简单理解为 JVM 帮我们自动编写了一个下面的类。这个类时动态生成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个代码是对源码的极大压缩和简化，实际的代理类生成很复杂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    InvocationHandler handler; <span class=\"comment\">// 中介类</span></span><br><span class=\"line\">    <span class=\"comment\">// 动态代理类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DynamicProxy</span><span class=\"params\">(InvocationHandler handler)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.handler.invoke(</span><br><span class=\"line\">           <span class=\"built_in\">this</span>,</span><br><span class=\"line\">           Subject.class.getMethod(<span class=\"string\">&quot;request1&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[<span class=\"number\">0</span>]),</span><br><span class=\"line\">           <span class=\"literal\">null</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面 JVM 动态生成的代码中 <code>implements Subject</code> 注定了 JDK 动态代理方式只能代理接口，而不能代理类。</p>\n<h2 id=\"cglib-动态代理\"><a class=\"markdownIt-Anchor\" href=\"#cglib-动态代理\"></a> CGLIB 动态代理</h2>\n<p>CGLIB（Code Generation Library）是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。</p>\n<p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>\n<p>CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 <code>final</code> 类型的类和方法，<code>private</code> 方法也无法代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被代理类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;被代理类执行 request 1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;被代理类执行 request 2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;被代理类执行 request 3&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> objects     方法入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodProxy 用于调用原始方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after method &quot;</span> + method.getName() + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CglibProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建动态代理增强类</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 设置类加载器</span></span><br><span class=\"line\">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class=\"line\">        <span class=\"comment\">// 设置被代理类</span></span><br><span class=\"line\">        enhancer.setSuperclass(clazz);</span><br><span class=\"line\">        <span class=\"comment\">// 设置方法拦截器</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">MyMethodInterceptor</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> uuanqin</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTestCGLIB</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 代理类</span></span><br><span class=\"line\">        <span class=\"type\">RealSubject</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (RealSubject) CglibProxyFactory.getProxy(RealSubject.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        proxy.request1();</span><br><span class=\"line\">        proxy.request2();</span><br><span class=\"line\">        proxy.request3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"代理模式的应用\"><a class=\"markdownIt-Anchor\" href=\"#代理模式的应用\"></a> 代理模式的应用</h1>\n<h2 id=\"与业务不太相关的附加功能\"><a class=\"markdownIt-Anchor\" href=\"#与业务不太相关的附加功能\"></a> 与业务不太相关的附加功能</h2>\n<p>业务系统中存在一些附加功能，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们可以将将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。在 Spring 中，这部分的工作可以交给 AOP 完成。</p>\n<h2 id=\"rpc-框架\"><a class=\"markdownIt-Anchor\" href=\"#rpc-框架\"></a> RPC 框架</h2>\n<p>详看文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>简易 RPC 调用框架的实现</a></p>\n<h2 id=\"缓存\"><a class=\"markdownIt-Anchor\" href=\"#缓存\"></a> 缓存</h2>\n<p>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。</p>\n<p>参考实现方式：在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 <code>http://...?..&amp;cached=true</code>），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</p>\n<h1 id=\"本文-plantuml-归档\"><a class=\"markdownIt-Anchor\" href=\"#本文-plantuml-归档\"></a> 本文 PlantUML 归档</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Subject&#123;</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; request1</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; request2</span><br><span class=\"line\">\t&#123;method&#125; &#123;abstract&#125; request3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy&#123;</span><br><span class=\"line\">\trealSubject</span><br><span class=\"line\">\t&#123;method&#125; request1</span><br><span class=\"line\">\t&#123;method&#125; request2</span><br><span class=\"line\">\t&#123;method&#125; request3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class RealSubject&#123;</span><br><span class=\"line\">\t&#123;method&#125; request1</span><br><span class=\"line\">\t&#123;method&#125; request2</span><br><span class=\"line\">\t&#123;method&#125; request3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Client&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Subject &lt;|.. Proxy</span><br><span class=\"line\">Subject &lt;|.. RealSubject</span><br><span class=\"line\">Proxy o- RealSubject : Uses</span><br><span class=\"line\"></span><br><span class=\"line\">Client -&gt; Subject : Uses</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class RealSubject&#123;</span><br><span class=\"line\">\t&#123;method&#125; request1</span><br><span class=\"line\">\t&#123;method&#125; request2</span><br><span class=\"line\">\t&#123;method&#125; request3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy&#123;</span><br><span class=\"line\">\trealSubject</span><br><span class=\"line\">\t&#123;method&#125; request1</span><br><span class=\"line\">\t&#123;method&#125; request2</span><br><span class=\"line\">\t&#123;method&#125; request3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Client&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">RealSubject &lt;|-- Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">Client -&gt; Proxy : Uses</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》21 章</li>\n<li><a href=\"https://liaoxuefeng.com/books/java/reflection/proxy/index.html\">动态代理 - Java教程 - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/gonjan-blog/p/6685611.html\">java动态代理实现与原理详细分析 - Gonjian - 博客园</a></li>\n<li><a href=\"https://javaguide.cn/java/basis/proxy.html#_3-1-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6\">Java 代理模式详解 | JavaGuide</a></li>\n</ul>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>其实这个故事的主角有多个版本，详看这篇文章：<a href=\"https://quoteinvestigator.com/2023/06/05/chauffeur/\">Anecdote Origin: Your Question Is Quite Simple. Hence, I’m Going To Ask My Chauffeur To Respond – Quote Investigator®</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","raw":"---\ntitle: 代理模式：爱因斯坦和他的司机\ntags:\n  - 设计模式\n  - Java\n  - 动态代理\n  - 反射\n  - AOP\n  - CGLIB\n  - JDK\ncover: 'https://cdn.gallery.uuanqin.top/img/202508110052894.webp'\ndescription: 只在必要时生成实例\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: ba3851cf\ndate: 2025-08-11 00:52:22\ntop_img:\n---\n\n![img|375](https://cdn.gallery.uuanqin.top/img/20240725155040.webp)\n\n> 🍐⚱️：（代理模式举例）爱因斯坦和他司机的故事——司机负责演讲，有人提问的时候就叫爱因斯坦起来回答问题 [^ed]。\n\n[^ed]: 其实这个故事的主角有多个版本，详看这篇文章：[Anecdote Origin: Your Question Is Quite Simple. Hence, I’m Going To Ask My Chauffeur To Respond – Quote Investigator®](https://quoteinvestigator.com/2023/06/05/chauffeur/)\n\n> [!cite]- 小故事：爱因斯坦和他的司机\n> 爱因斯坦提出相对论后，震惊世界，于是被很多大学邀请去做报告，爱因斯坦因此而被弄得疲惫不堪。\n>\n> 有一天，司机对他说：“你太累了，今天我帮你作报告吧？”\n>\n> 爱因斯坦问：“你能行吗？”\n>\n> 司机说：“我闭着眼睛都能背出来。”\n>\n> 那天司机上台，果然讲得滴水不漏。\n>\n> 但刚想下台时，一位博士站了起来，然后提了一个非常深奥刁钻的问题。\n>\n> 司机不知怎么作答，幸好脑瓜转得快：“你这问题太简单了，我司机都能回答。”\n>\n> 爱因斯坦站起来，几句话就解决了问题。\n>\n> 博士惊呆了：“没想到他的司机也远胜于我。”\n>\n> 但在回去的路上，司机对爱因斯坦说：“我知道的只是概念，你懂得的才是知识。”\n\n代理模式可以在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。\n\n登场角色：\n\n- `Subject`（主体）：`Subject` 角色定义了使 `Proxy` 角色和 `RealSubject` 角色之间具有一致性的接口。由于存在 `Subject` 角色，所以 `Client` 角色不必在意它所使用的究竟是 `Proxy` 角色还是 `RealSubject` 角色。\n- `Proxy`（代理人)：`Proxy` 角色会尽量处理来自 `Client` 角色的请求。只有当自己不能处理时，它才会将工作交给 `RealSubject` 角色。`Proxy` 角色只有在必要时才会生成 `RealSubject` 角色。`Proxy` 角色实现了在 `Subject` 角色中定义的接口（API）。在示例程序中，由 `PrinterProxy` 类扮演此角色。\n- `RealSubject`（实际的主体、被代理类)：“本人”`RealSubject` 角色会在「代理人 `Proxy`」角色无法胜任工作时出场。它与 `Proxy` 角色一样，也实现了在 `Subject` 角色中定义的接口（API）。`RealSubject` 并不知道 `Proxy` 的存在。\n- `Client`（请求者）：使用 `Proxy` 模式的角色。在 GoF 书中，`Client` 角色并不包含在代理模式中。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202508080009615.webp)\n\n代码示例：\n\n```java\ninterface Subject {\n    void request1();\n\n    void request2();\n\n    void request3();\n}\n\n// 被代理类\nclass RealSubject implements Subject {\n\n    @Override\n    public void request1() {\n        System.out.println(\"被代理类执行 request 1\");\n    }\n\n    @Override\n    public void request2() {\n        System.out.println(\"被代理类执行 request 2\");\n    }\n\n    @Override\n    public void request3() {\n        System.out.println(\"被代理类执行 request 3\");\n    }\n}\n\n// 代理类\nclass Proxy implements Subject {\n    RealSubject realSubject = new RealSubject(); // 构造函数或IoC容器注入\n\n    @Override\n    public void request1() {\n        /* 写自己的逻辑 */\n        realSubject.request1();\n        /* 写自己的逻辑 */\n    }\n\n    @Override\n    public void request2() {\n        realSubject.request2();\n    }\n\n    @Override\n    public void request3() {\n        realSubject.request3();\n    }\n}\n```\n\n使用方式：\n\n```java\npublic static void main(String[] args) {\n\tSubject subject = new Proxy();\n\tsubject.request1();\n}\n/*\n输出：\nProxy 代理类的自定义逻辑\n被代理类执行 request 1\n*/\n```\n\n代理模式在访问实际对象时引入一定程度的间接性，利用这种间接性我们可以附加多种用途。拓展思路：\n\n- 使用代理人来提升处理速度\n- 我们可以不划分 `Proxy` 类和 `RealSubject` 类，而是直接在 `RealSubject` 类中加入惰性求值功能（即只有必要时才生成实例的功能）。不过划分 `Proxy` 和 `RealSubject` 角色可以使它们成为独立的组件，在修改的时候也不会互相之间产生影响（分而治之）。\n- 代理与委托。代理人只代理他能解决的问题。当遇到他不能解决的问题时，还是会「委托」给本人去解决。（在现实世界中，应当是本人将事情委托给代理人负责，而在设计模式中则是反过来的。）\n- 透明性。在 `Main` 中 `Client` 直接使用 `Subject` 接口，`Main` 不必在意调用的究竟是哪个类。在这种情况下，可以说 `Proxy` 类是具有「[透明性](https://blog.csdn.net/weixin_51350847/article/details/141818403)」的。\n- 各种代理模式：代理模式有很多种变化形式。\n\t- Virtual Proxy（虚拟代理）：Virtual Proxy 就是本章节演示的代理模式。只有当真正需要实例时，它才生成和初始化实例。\n\t- Remote Proxy（远程代理）：Remote Proxy 可以让我们完全不必在意 RealSubject 角色是否在远程网络上，可以如同它在自己身边一样（透明性地）调用它的方法。Java 的 RMI （Remote Method Invocation 远程方法调用） 就相当于 Remote Proxy。或者 RPC 框架。\n\t- Access Proxy：Access Proxy 用于在调用 RealSubject 角色的功能时设置访问限制。例如，这种代理可以只允许指定的用户调用方法，而当其他用户调用方法时则报错。\n\n> [!example]- 打印机案例\n> ![image.png|425](https://cdn.gallery.uuanqin.top/img/20240725160455.webp)\n> - `Printer` 打印机 `print()` 函数调用了 `heavyJob` 函数。\n> - `PrinterProxy` 不实现真正的 `print` 函数。 `realize` 函数用于实现真正的打印机，这个函数只在调用了代理类的 `print` 函数时调用。不论 `setPrinterName` 方法和 `getPrinterName` 方法被调用多少次，都不会生成 `Printer` 类的实例。只有当真正需要本人时，才会生成 `Printer` 类的实例。\n> - 上图疑似有误：`Client` 应当使用抽象 `Subject` 才对\n\n相关的设计模式：\n\n- [[适配器模式：转接头|适配器模式]]：适配器模式适配了两种具有不同接口（API）的对象，以使它们可以一同工作。而在 代理模式中，`Proxy` 角色与 `RealSubject` 角色的接口（API）是相同的（透明性）。\n- 装饰者模式 Decorator：Decorator 模式与代理模式在实现上很相似，不过它们的使用目的不同。Decorator 模式的目的在于增加新的功能。而在 Proxy 模式中，与增加新功能相比，它更注重通过设置代理人的方式来减轻本人的工作负担。\n\n# 通过继承的方式代理第三方类\n\n在上面的例子中，代理类 `Proxy` 和被代理类 `RealSubject` 都继承同一个接口。如果被代理类没有定义接口，且无法修改源码（如第三方类库的类），我们就不能用上面的方法实现代理模式。\n\n解决方案：继承。让代理类继承原始类，然后扩展附加功能。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202508080010513.webp)\n\n代理类 `Proxy` 通过 `super.request1()` 的方式委托被代理类。\n\n# 动态代理 Dynamic Proxy\n\n由程序员创建或特定工具自动生成代理模式的源代码，即在编译前就已经将接口，被代理类，代理类等确定下来的代理方式，叫做静态代理。\n\n如果通过静态代理的方式实现代理模式，对于每个代理类 `Proxy`，我们都需要将被代理类的所有方法重新实现一遍，且代理类 `Proxy` 每个方法都有相似的代码逻辑。如果被代理类很多，那么代理类也会很多，增加代码的维护成本。\n\n动态代理：不事先为每个原始类编写代理类，而是在运行的时候，根据我们在 Java 代码中的「指示」，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\n\n| 代理方式 | 静态代理                        | 动态代理                 |\n| ---- | --------------------------- | -------------------- |\n| JVM  | 编译时生成代理类的 class 文件            | 运行时动态生成类字节码并加载到 JVM   |\n| 灵活性  | 🔴接口一旦新增加方法，目标对象和代理对象都要进行修改 | 🟢不需要针对每个目标类都创建一个代理类 |\n\nJava 标准库提供了动态代理机制，可以在运行期动态创建某个 `interface` 的实例，不用编写实现类。动态代理依赖 Java [[Java 中的反射|反射]] 语法。\n\nJava 常用的动态代理实现方式有：\n\n| 动态代理 | JDK             | CGLIB     |\n| ---- | --------------- | --------- |\n| 代理对象 | 实现了接口的类或者直接代理接口 | 未实现任何接口的类 |\n| 效率   | 🟢              | 🟡        |\n| 特点   | 简单易用            | 引入第三方库    |\n\n在 Spring 中的 [[SpringBoot 中的面向切面编程（AOP）|AOP]] 模块中，如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。\n\n## JDK 动态代理\n\n假设，代理类 `Proxy` 在调用被代理类前都需要执行前置方法和后置方法。在静态代理方式，我们需要将 `Proxy` 的 `request1`、`request2`、`request3` 都改动代码。\n\n```java\npublic class Proxy implements Subject{\n\tprivate RealSubject realSubject; // 省略注入逻辑\n\n\tpublic void request1(){\n        beforeMethod();         // 前置方法\n\t\trealSubject.request1(); // 调用被代理类方法\n\t\tafterMethod();          // 后置方法\n\t}\n\t// 省略 request2，request3\n}\n\n```\n\n在 Java 的 `java.lang.reflect` 包下提供了一个 `Proxy` 类和一个 `InvocationHandler` 接口，通过这个类和这个接口可以生成 JDK 动态代理类和动态代理对象。\n\nJDK 动态代理类使用步骤：\n\n1. 定义一个接口及其实现类；\n2. 自定义 `InvocationHandler` 并重写 `invoke` 方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；\n3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；\n\n下面是示例代码：\n\n```java\nclass MyInvocationHandler<T> implements InvocationHandler {\n    T target; // 被代理对象\n\n    public MyInvocationHandler(T target) {\n        this.target = target;\n    }\n\n\t/**\n\t\tproxy :动态生成的代理类\n\t\tmethod : 与代理类对象调用的方法相对应\n\t\targs : 当前 method 方法的参数\n\t*/\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"MyInvocationHandler 执行 \" + method.getName() + \" 方法\");\n\n        // 编写调用方法前逻辑\n        System.out.println(\"方法执行前，代理类执行自定义逻辑\");\n        // 执行被代理类的方法\n        Object result = method.invoke(target, args);\n        // 编写调用方法前逻辑\n        System.out.println(\"方法执行后，代理类执行自定义逻辑\\n\");\n\n        return result;\n    }\n}\n```\n\n主函数使用动态代理：\n\n```java\npublic class ProxyTest {\n    public static void main(String[] args) {\n        // 被代理对象\n        Subject subject = new RealSubject();\n\n        //创建一个与代理对象相关联的InvocationHandler\n        InvocationHandler handler = new MyInvocationHandler<>(subject);\n\n        Subject proxy = (Subject) java.lang.reflect.Proxy\n                .newProxyInstance(\n                        Subject.class.getClassLoader(), // 传入ClassLoader，通常就是接口类的`ClassLoader`\n                        new Class[]{Subject.class},    // 传入要实现的接口，即被代理类实现的接口，可能会有多个\n                        handler  // 传入处理调用方法的InvocationHandler\n                );\n\n        proxy.request1();\n        proxy.request2();\n        proxy.request3();\n    }\n}\n\n/*\n输出：\nMyInvocationHandler 执行 request1方法\n方法执行前，代理类执行自定义逻辑\n被代理类执行 request 1\n方法执行后，代理类执行自定义逻辑\n\nMyInvocationHandler 执行 request2方法\n方法执行前，代理类执行自定义逻辑\n被代理类执行 request 2\n方法执行后，代理类执行自定义逻辑\n\nMyInvocationHandler 执行 request3方法\n方法执行前，代理类执行自定义逻辑\n被代理类执行 request 3\n方法执行后，代理类执行自定义逻辑\n*/\n```\n\n当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 `InvocationHandler` 接口类的 `invoke` 方法来调用。\n\n此处动态代理的优势体现为：可以方便对代理类的函数进行统一处理，不用修改代理类中的方法。因为代理类中的方法，是通过 `InvocationHandler` 中的 `invoke` 方法调用的，所以我们只要在 `invoke` 方法中统一处理，就可以对所有被代理的方法进行相同的操作了。\n\n### 优化：使用工厂创建代理类\n\n在上面的 `main` 代码调用中，我们创建实现了 `Subject` 接口的代理类还能通过 [[类的工厂|引入工厂]] 进一步优化。\n\n```java\nclass SubjectProxyFactory {\n    public static Subject getProxy(Object target) {\n        return (Subject) java.lang.reflect.Proxy.newProxyInstance(\n                target.getClass().getClassLoader(), // 目标类的类加载器\n                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个\n                new MyInvocationHandler<>(target)   // 代理对象对应的自定义 InvocationHandler\n        );\n    }\n}\n```\n\n`main` 代码的调用简化为：\n\n```java\nSubject subject = new RealSubject();\nSubject proxy = SubjectProxyFactory.getProxy(subject);\n```\n\n### 源码浅析（真的很浅）\n\n通读 JDK 动态代理实现源码，我们可以简单理解为 JVM 帮我们自动编写了一个下面的类。这个类时动态生成的。\n\n```java\n// 这个代码是对源码的极大压缩和简化，实际的代理类生成很复杂\npublic class DynamicProxy implements Subject {\n    InvocationHandler handler; // 中介类\n    // 动态代理类的构造函数\n    public DynamicProxy(InvocationHandler handler) {\n        this.handler = handler;\n    }\n    public void request1() {\n        this.handler.invoke(\n           this,\n           Subject.class.getMethod(\"request1\", new Class[0]),\n           null\n        );\n    }\n}\n```\n\n上面 JVM 动态生成的代码中 `implements Subject` 注定了 JDK 动态代理方式只能代理接口，而不能代理类。\n\n## CGLIB 动态代理\n\nCGLIB（Code Generation Library）是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。\n\n在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。\n\nCGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 `final` 类型的类和方法，`private` 方法也无法代理。\n\n```java\n// 被代理类\nclass RealSubject {\n\n    public void request1() {\n        System.out.println(\"被代理类执行 request 1\");\n    }\n\n    public void request2() {\n        System.out.println(\"被代理类执行 request 2\");\n    }\n\n    public void request3() {\n        System.out.println(\"被代理类执行 request 3\");\n    }\n}\n\nclass MyMethodInterceptor implements MethodInterceptor {\n\n    /**\n     * @param o           被代理的对象（需要增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param objects     方法入参\n     * @param methodProxy 用于调用原始方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method \" + method.getName());\n        Object object = methodProxy.invokeSuper(o, objects);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method \" + method.getName() + \"\\n\");\n        return object;\n    }\n}\n\nclass CglibProxyFactory {\n    public static Object getProxy(Class<?> clazz) {\n        // 创建动态代理增强类\n        Enhancer enhancer = new Enhancer();\n        // 设置类加载器\n        enhancer.setClassLoader(clazz.getClassLoader());\n        // 设置被代理类\n        enhancer.setSuperclass(clazz);\n        // 设置方法拦截器\n        enhancer.setCallback(new MyMethodInterceptor());\n        // 创建代理类\n        return enhancer.create();\n    }\n}\n\n/**\n * @author uuanqin\n */\npublic class ProxyTestCGLIB {\n    public static void main(String[] args) {\n        // 代理类\n        RealSubject proxy = (RealSubject) CglibProxyFactory.getProxy(RealSubject.class);\n\n        proxy.request1();\n        proxy.request2();\n        proxy.request3();\n    }\n}\n\n```\n\n# 代理模式的应用\n\n## 与业务不太相关的附加功能\n\n业务系统中存在一些附加功能，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们可以将将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。在 Spring 中，这部分的工作可以交给 AOP 完成。\n\n## RPC 框架\n\n详看文章：[[简易 RPC 调用框架的实现]]\n\n## 缓存\n\n假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。\n\n参考实现方式：在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 `http://...?..&cached=true`），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。\n\n# 本文 PlantUML 归档\n```plantuml\ninterface Subject{\n\t{method} {abstract} request1\n\t{method} {abstract} request2\n\t{method} {abstract} request3\n}\n\nclass Proxy{\n\trealSubject\n\t{method} request1\n\t{method} request2\n\t{method} request3\n}\n\nclass RealSubject{\n\t{method} request1\n\t{method} request2\n\t{method} request3\n}\n\nclass Client{\n\n}\n\nSubject <|.. Proxy\nSubject <|.. RealSubject\nProxy o- RealSubject : Uses\n\nClient -> Subject : Uses\n```\n\n```plantuml\nclass RealSubject{\n\t{method} request1\n\t{method} request2\n\t{method} request3\n}\n\nclass Proxy{\n\trealSubject\n\t{method} request1\n\t{method} request2\n\t{method} request3\n}\n\nclass Client{\n\n}\n\nRealSubject <|-- Proxy\n\nClient -> Proxy : Uses\n```\n\n# 本文参考\n\n- 《图解设计模式》21 章\n- [动态代理 - Java教程 - 廖雪峰的官方网站](https://liaoxuefeng.com/books/java/reflection/proxy/index.html)\n- [java动态代理实现与原理详细分析 - Gonjian - 博客园](https://www.cnblogs.com/gonjan-blog/p/6685611.html)\n- [Java 代理模式详解 | JavaGuide](https://javaguide.cn/java/basis/proxy.html#_3-1-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6)\n","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"AOP","api":"api/tags/AOP.json"},{"name":"反射","api":"api/tags/反射.json"},{"name":"动态代理","api":"api/tags/动态代理.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"CGLIB","api":"api/tags/CGLIB.json"},{"name":"JDK","api":"api/tags/JDK.json"}]},"api":"api/posts/p/ba3851cf.json"}