{"data":{"title":"Java 中的排序","slug":"计算机语言/Java 中的排序","description":"快速弄清楚各种写排序的方法","date":"2025-01-23T15:20:27.000Z","updated":"2025-08-28T13:49:48.205Z","language":"zh-CN","comments":true,"url":"p/72156dd2/","cover":"https://cdn.gallery.uuanqin.top/img/202501232322321.webp","images":[],"content":"<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"快速使用\"><a class=\"markdownIt-Anchor\" href=\"#快速使用\"></a> 快速使用</h1>\n<p>现有以下数组或集合的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\tList&lt;Integer&gt; ls = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;()&#123;&#123;</span><br><span class=\"line\">\t\tadd(<span class=\"number\">3</span>);add(<span class=\"number\">2</span>);add(<span class=\"number\">5</span>);add(<span class=\"number\">7</span>);add(<span class=\"number\">1</span>);add(<span class=\"number\">9</span>);</span><br><span class=\"line\">\t&#125;&#125;;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;nums: &quot;</span>+Arrays.toString(nums));</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;list: &quot;</span>+ls);</span><br><span class=\"line\">\t<span class=\"comment\">// 输出</span></span><br><span class=\"line\">\t<span class=\"comment\">// nums: [3, 2, 5, 7, 1, 9]</span></span><br><span class=\"line\">\t<span class=\"comment\">// list: [3, 2, 5, 7, 1, 9]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>排序方式</th>\n<th>Arrays</th>\n<th>Collections（以 ArrayList 举例）</th>\n<th>顺序类型</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简单使用 <code>sort</code> 排序</td>\n<td><code>Arrays.sort(nums);</code></td>\n<td><code>Collections.sort(ls);</code></td>\n<td rowspan=\"2\">正序</td>\n<td></td>\n</tr>\n<tr>\n<td><code>sort</code> 局部排序</td>\n<td><code>Arrays.sort(nums,3,6);</code></td>\n<td>-</td>\n<td>左闭右开</td>\n</tr>\n<tr>\n<td><code>reverse</code> 逆序</td>\n<td>-</td>\n<td><code>Collections.reverse(ls);</code></td>\n<td rowspan=\"3\">逆序</td>\n<td></td>\n</tr>\n<tr>\n<td>使用现成的 <code>Comparator</code>：<code>Collections.reverseOrder()</code></td>\n<td><code>Arrays.sort(nums,Collections.reverseOrder());</code></td>\n<td><code>Collections.sort(ls,Collections.reverseOrder());</code><br><code>ls.sort(Collections.reverseOrder());</code></td>\n<td rowspan=\"2\">数组要求是包装类型</td>\n</tr>\n<tr>\n<td>通过 Lambda 提供自定义 <code>Comparator</code>（最简写法）</td>\n<td><code>Arrays.sort(nums, (o1, o2) -&gt; o2 - o1);</code></td>\n<td><code>Collections.sort(ls,((o1, o2) -&gt; o2-o1));</code><br><code>ls.sort(((o1, o2) -&gt; o2 - o1));</code></td>\n</tr>\n</tbody>\n</table>\n<p>注意到，在使用 <code>Comparator</code> 进行排序时，被排序的数组要求为装箱类型。除了使用循环一个个自动装箱以外，我们还可以使用 <code>Arrays.stream</code> 完成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// int[] 转 Integer[]</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">Integer[] numsObject = Arrays.stream(nums).boxed().toArray(Integer[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Comparator 进行排序</span></span><br><span class=\"line\">Arrays.sort(numsObject, (a,b)-&gt; b-a); <span class=\"comment\">// 使用 Lambda 表达式实现倒序排序。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer[] 转 int[]</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] intArray = Arrays.stream(numsObject) <span class=\"comment\">// 转换为流</span></span><br><span class=\"line\">   .mapToInt(Integer::intValue) <span class=\"comment\">// 映射为基本类型 int</span></span><br><span class=\"line\">   .toArray(); <span class=\"comment\">// 收集为 int 数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">System.out.println(Arrays.toString(intArray));</span><br></pre></td></tr></table></figure>\n<p><code>Character[]</code>  <code>char[]</code> 互转：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Character[]转char[]</span></span><br><span class=\"line\">Character[] sc = &#123;<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>&#125;;</span><br><span class=\"line\">Stream&lt;Character&gt; stream = Arrays.stream(sc);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">collect</span> <span class=\"operator\">=</span> stream.map(String::valueOf).collect(Collectors.joining());</span><br><span class=\"line\"><span class=\"type\">char</span>[] chars1 = collect.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//char[]转Character[]</span></span><br><span class=\"line\"><span class=\"type\">char</span>[] a = &#123;<span class=\"string\">&#x27;j&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">IntStream</span> <span class=\"variable\">chars</span> <span class=\"operator\">=</span> String.valueOf(a).chars();</span><br><span class=\"line\">Stream&lt;Character&gt; characterStream1 = chars.mapToObj(b -&gt; (<span class=\"type\">char</span>) b);</span><br><span class=\"line\">Character[] characters = characterStream1.toArray(Character[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n<p>本文的热身部分结束。下面内容需要花时间消化理解。</p>\n<h1 id=\"温习lambda-表达式的简化写法\"><a class=\"markdownIt-Anchor\" href=\"#温习lambda-表达式的简化写法\"></a> 温习：Lambda 表达式的简化写法</h1>\n<p>具体简化过程详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c5c0eb2/\"><span class=\"bilink-pop-up\">站内文章</span>函数式编程与Java 中的 Lambda 表达式</a>。</p>\n<p>这里以为 <code>Arrays</code> 写一个自定义 <code>Comparator</code> 实现逆序排序为例。一般的代码写法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; myComparator = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o2 - o1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrays.sort(nums, myComparator);</span><br></pre></td></tr></table></figure>\n<p>简化为（进而得到表格中的写法）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; myComparator = (o1, o2) -&gt; o2 - o1;</span><br><span class=\"line\">Arrays.sort(nums, myComparator);</span><br></pre></td></tr></table></figure>\n<h1 id=\"分清楚-comparable-comparator-compare-compareto\"><a class=\"markdownIt-Anchor\" href=\"#分清楚-comparable-comparator-compare-compareto\"></a> 分清楚 <code>Comparable</code>、<code>Comparator</code>、<code>compare</code>、<code>compareTo</code>?</h1>\n<p>字面含义的基本区分：</p>\n<ul>\n<li><code>Comparator</code>「n. 比较器」。它以 <code>-or</code> 作为结尾，表示一个可执行某些动作的东西。它也是接口，它有多个待实现的方法，<code>compare</code> 是其中之一。</li>\n<li><code>Comparable</code> 「adj. 可比的」。它以 <code>-able</code> 作为结尾，表示具备某种能力，一般用作 Java 接口。只有一个待实现的方法 <code>compareTo</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span> <span class=\"comment\">// 支持 Lambda</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Comparator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(T o1, T o2)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/* 省略其他代码 */</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Comparable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(T o)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>compare</code> 和 <code>compareTo</code> 的行为非常类似，都是返回一个整数值：</p>\n<ul>\n<li>返回负数：当前对象小于传入对象</li>\n<li>返回 0：当前对象和传入对象相等</li>\n<li>返回正数：当前对象大于传入对象</li>\n</ul>\n<p>区别在于：</p>\n<ul>\n<li><code>compare</code> 需要传入两个参数表示两个对象。隐含地意思是，这种比较是一种「外部」的行为。</li>\n<li><code>compareTo</code> 只需传入一个参数，表示传入对象。那么当前对象在哪呢，答案是在类里面，它是类内部定义的比较。</li>\n</ul>\n<p>下面将通过自定义对象排序的例子说明这两种接口的使用异同。以及对「内部」「外部」的体会。</p>\n<h1 id=\"自定义对象的排序\"><a class=\"markdownIt-Anchor\" href=\"#自定义对象的排序\"></a> 自定义对象的排序</h1>\n<p>现自定义对象 <code>Person</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t\tString name;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> score;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name,<span class=\"type\">int</span> score)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name + <span class=\"string\">&quot; &quot;</span> + <span class=\"built_in\">this</span>.score;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tPerson[] team = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>[]&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;学渣&quot;</span>,<span class=\"number\">40</span>),</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;学霸&quot;</span>,<span class=\"number\">100</span>),</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;普通人&quot;</span>, <span class=\"number\">80</span>),</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;排序前：&quot;</span>+Arrays.toString(team));</span><br><span class=\"line\">\t<span class=\"comment\">// 输出：</span></span><br><span class=\"line\">\t<span class=\"comment\">// 排序前：[学渣 40, 学霸 100, 普通人 80]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们需要将它们按成绩倒序排序。</p>\n<h2 id=\"使用-comparator\"><a class=\"markdownIt-Anchor\" href=\"#使用-comparator\"></a> 使用 <code>Comparator</code></h2>\n<p>在 <code>main</code> 函数中增加以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Person&gt; personComparator = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Person p1, Person p2)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p2.score - p1.score;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrays.sort(team,personComparator);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;排序后：&quot;</span>+Arrays.toString(team));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 排序后：[学霸 100, 普通人 80, 学渣 40]</span></span><br></pre></td></tr></table></figure>\n<p>在以上示例中，我们没有动过 <code>Person</code> 类中的任何代码。我们是在外部自定义了一个 <code>Comparator</code> 对第三方类进行排序。也就是说通过 <code>Comparator</code> 接口可以实现和原有类的解耦，在不修改原有类的情况下实现排序功能，所以 <code>Comparator</code> 可以看作是「对外」提供排序的接口。</p>\n<p>另外读者可以回忆一下上文提到的 Lambda，试着把代码优化一下。</p>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">阿里巴巴 Java 开发手册对集合使用的相关要求</div>\n</div>\n<div class=\"callout-content\"><p>一、（六）15.【强制】 在 JDK7 版本及以上， <code>Comparator</code> 实现类要满足如下三个条件， 不然 <code>Arrays.sort</code>，<code>Collections.sort</code> 会抛 <code>IllegalArgumentException</code> 异常。<br />\n说明： 三个条件如下<br />\n1） x， y 的比较结果和 y， x 的比较结果相反。<br />\n2） x &gt; y， y &gt; z， 则 x &gt; z。<br />\n3） x = y， 则 x， z 比较结果和 y， z 比较结果相同。</p>\n</div></div><h2 id=\"使用-comparable\"><a class=\"markdownIt-Anchor\" href=\"#使用-comparable\"></a> 使用 <code>Comparable</code></h2>\n<p>使用 <code>Comparable</code> 接口时我们需要修改 <code>Person</code> 类的实现，使其具有「比较的能力」。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Comparable</span>&lt;Person&gt;&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> score;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name,<span class=\"type\">int</span> score)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name + <span class=\"string\">&quot; &quot;</span> + <span class=\"built_in\">this</span>.score;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(Person p)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p.score-<span class=\"built_in\">this</span>.score;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(team);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;排序后：&quot;</span>+Arrays.toString(team));</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 排序后：[学霸 100, 普通人 80, 学渣 40]</span></span><br></pre></td></tr></table></figure>\n<p>通过观察我们可以发现，使用 <code>Comparable</code> 接口我们需要「对内」修改类的实现，让类显式支持比较。且调用 <code>sort</code> 时不需要传入除了数组以外的其他参数。</p>\n<p>需要注意的是，如果不向 <code>sort</code> 传入 <code>Comparator</code>，且数组内对象没实现 <code>Comparable</code> 的话会报错。</p>\n<h1 id=\"string-字符串的排序\"><a class=\"markdownIt-Anchor\" href=\"#string-字符串的排序\"></a> String 字符串的排序</h1>\n<p>在这个部分中，我们需要实现对 <code>String</code> 数组的逆序排序。代码涵盖 <code>Comparable</code>、<code>Comparator</code>、<code>compare</code>、<code>compareTo</code>，你能分清楚吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] names = &#123;<span class=\"string\">&quot;Tom&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>, <span class=\"string\">&quot;Mike&quot;</span>, <span class=\"string\">&quot;Linda&quot;</span>, <span class=\"string\">&quot;Mary&quot;</span>&#125;;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;排序前：&quot;</span> + Arrays.toString(names));</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays.sort(names);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;正序排序：&quot;</span> + Arrays.toString(names));</span><br><span class=\"line\"></span><br><span class=\"line\">Comparator&lt;String&gt; nameComparator = <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(String s1, String s2)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (s2.compareTo(s1));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrays.sort(names, nameComparator);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;逆序排序：&quot;</span> + Arrays.toString(names));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    输出：</span></span><br><span class=\"line\"><span class=\"comment\">//    排序前：[Tom, Jack, Mike, Linda, Mary]</span></span><br><span class=\"line\"><span class=\"comment\">//    正序排序：[Jack, Linda, Mary, Mike, Tom]</span></span><br><span class=\"line\"><span class=\"comment\">//    逆序排序：[Tom, Mike, Mary, Linda, Jack]</span></span><br></pre></td></tr></table></figure>\n<p>附 <code>String</code> 类中 <code>compareTo</code> 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(String anotherString)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len1</span> <span class=\"operator\">=</span> value.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len2</span> <span class=\"operator\">=</span> anotherString.value.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">lim</span> <span class=\"operator\">=</span> Math.min(len1, len2);</span><br><span class=\"line\">\t<span class=\"type\">char</span> v1[] = value;</span><br><span class=\"line\">\t<span class=\"type\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> v1[k];</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> v2[k];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tk++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> len1 - len2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二维向量排序\"><a class=\"markdownIt-Anchor\" href=\"#二维向量排序\"></a> 二维向量排序</h1>\n<p>给定一堆向量，先按向量第一个参数排序，再按第二个参数进行排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[][] nums2d = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[][] &#123;&#123;<span class=\"number\">2</span>, <span class=\"number\">4</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">4</span>&#125;&#125;;</span><br><span class=\"line\">Arrays.sort(nums2d,(a,b) -&gt; a[<span class=\"number\">1</span>] == b[<span class=\"number\">1</span>] ? a[<span class=\"number\">0</span>]-b[<span class=\"number\">0</span>] : a[<span class=\"number\">1</span>]-b[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span>[] e:nums2d)&#123;</span><br><span class=\"line\">\tSystem.out.println(Arrays.toString(e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// [0, 2]</span></span><br><span class=\"line\"><span class=\"comment\">// [0, 4]</span></span><br><span class=\"line\"><span class=\"comment\">// [2, 4]</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">在上面的例子中，二维数组为什么不需要转换为包装类型？</div>\n</div>\n<div class=\"callout-content\"><p>Java 中的数组是引用类型，被排序的数组 <code>nums2d</code> 是个二维数组，数组元素是一个个的一维数组（本质上是一个个 <code>Object</code>）。<code>Comparator&lt;int[]&gt;</code> 是符合 Java 语法要求的。</p>\n</div></div>\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">在 Lambda 写复杂函数时，最后一行记得显式 <code>return</code>（不管代码会不会到达），否则报错。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h1 id=\"对-map-和-set-的排序\"><a class=\"markdownIt-Anchor\" href=\"#对-map-和-set-的排序\"></a> 对 <code>Map</code> 和 <code>Set</code> 的排序</h1>\n<p><code>SortedSet</code> 和 <code>SortedMap</code> 支持传入比较器实现自定义排序。在 <code>SortedMap</code> 中，我们自定义的是键的排序。</p>\n<p>对普通的 <code>Map</code>，我们还可以将键值对输出到列表中，再对列表进行自定义排序。下面这个例子展示对 <code>Map</code> 的键值对先按值排序，再按键排序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; ls = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(map.entrySet());</span><br><span class=\"line\">Collections.sort(ls,(e1,e2)-&gt;&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">k1</span> <span class=\"operator\">=</span> e1.getKey(),k2 = e2.getKey();</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">v1</span> <span class=\"operator\">=</span> e1.getValue(), v2 = e2.getValue();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v1==v2 ? k1-k2:v1-v2;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"相关题目\"><a class=\"markdownIt-Anchor\" href=\"#相关题目\"></a> 相关题目</h1>\n<p>相信阅读到这里的你已经很熟练了。要不尝试下面的练习？</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/sort-the-students-by-their-kth-score/description/\">2545. 根据第 K 场考试的分数排序 - 力扣（LeetCode）</a> 一行代码搞定。</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/custom-sort-string/description/\">791. 自定义字符串排序 - 力扣（LeetCode）</a> 指定了字符串排序顺序，就是包装类转化有点复杂。</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/sort-integers-by-the-power-value/description/?envType=daily-question&amp;envId=2024-12-22\">1387. 将整数按权重排序 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/rank-teams-by-votes/description/\">1366. 通过投票对团队排名 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.runoob.com/java/java8-lambda-expressions.html\">Java Lambda 表达式 | 菜鸟教程 (runoob.com)</a></li>\n<li>《Java 面向对象编程》孙卫琴 第 17 章</li>\n<li><a href=\"https://blog.csdn.net/weixin_72499901/article/details/136592073\">Java 中使用 sort() 方法排序：从基本原理到多种用法全面总结；sort()函数的使用_java sort-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/youanyyou/article/details/84846486\">Java 中初始化 List 集合的 6 种方式!_再list集合中初始化数据-CSDN博客</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1918856\">面试官：元素排序Comparable和Comparator有什么区别？-腾讯云开发者社区-腾讯云</a></li>\n<li><a href=\"https://www.jianshu.com/p/d855a1bb4952\">Character数组与char数组互转 - 简书</a></li>\n</ul>\n","raw":"---\ntitle: Java 中的排序\ncover: 'https://cdn.gallery.uuanqin.top/img/202501232322321.webp'\ntags:\n  - Java\n  - Collections\n  - Arrays\ndescription: 快速弄清楚各种写排序的方法\ncategories:\n  - 计算机语言\nabbrlink: 72156dd2\ndate: 2025-01-23 23:20:27\ntop_img:\n---\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 快速使用\n\n现有以下数组或集合的定义：\n\n```java\npublic static void main(String[] args) {\n\tint[] nums = new int[]{3,2,5,7,1,9};\n\tList<Integer> ls = new ArrayList<Integer>(){{\n\t\tadd(3);add(2);add(5);add(7);add(1);add(9);\n\t}};\n\tSystem.out.println(\"nums: \"+Arrays.toString(nums));\n\tSystem.out.println(\"list: \"+ls);\n\t// 输出\n\t// nums: [3, 2, 5, 7, 1, 9]\n\t// list: [3, 2, 5, 7, 1, 9]\n}\n```\n\n| 排序方式                                            | Arrays                                          | Collections（以 ArrayList 举例）                                                                    | 顺序类型 | 注释        |\n| ----------------------------------------------- | ----------------------------------------------- | -------------------------------------------------------------------------------------------- | ---- | --------- |\n| 简单使用 `sort` 排序                                  | `Arrays.sort(nums);`                            | `Collections.sort(ls);`                                                                      | 正序   |           |\n| `sort` 局部排序                                     | `Arrays.sort(nums,3,6);`                        | -                                                                                            | 正序   | 左闭右开      |\n| `reverse` 逆序                                    | -                                               | `Collections.reverse(ls);`                                                                   | 逆序   |           |\n| 使用现成的 `Comparator`：`Collections.reverseOrder()` | `Arrays.sort(nums,Collections.reverseOrder());` | `Collections.sort(ls,Collections.reverseOrder());`<br>`ls.sort(Collections.reverseOrder());` | 逆序   | 数组要求是包装类型 |\n| 通过 Lambda 提供自定义 `Comparator`（最简写法）              | `Arrays.sort(nums, (o1, o2) -> o2 - o1);`       | `Collections.sort(ls,((o1, o2) -> o2-o1));`<br>`ls.sort(((o1, o2) -> o2 - o1));`             | 逆序   | 数组要求是包装类型 |\n\n注意到，在使用 `Comparator` 进行排序时，被排序的数组要求为装箱类型。除了使用循环一个个自动装箱以外，我们还可以使用 `Arrays.stream` 完成：\n\n```java\n// int[] 转 Integer[]\nint[] nums = new int[]{4,5,2,7,3,1,0,6,8,9};\nInteger[] numsObject = Arrays.stream(nums).boxed().toArray(Integer[]::new);\n\n// 使用 Comparator 进行排序\nArrays.sort(numsObject, (a,b)-> b-a); // 使用 Lambda 表达式实现倒序排序。\n\n// Integer[] 转 int[]\nint[] intArray = Arrays.stream(numsObject) // 转换为流\n   .mapToInt(Integer::intValue) // 映射为基本类型 int\n   .toArray(); // 收集为 int 数组\n\n// 输出\nSystem.out.println(Arrays.toString(intArray));\n```\n\n`Character[]`  `char[]` 互转：\n\n```java\n//Character[]转char[]\nCharacter[] sc = {'d','a'};\nStream<Character> stream = Arrays.stream(sc);\nString collect = stream.map(String::valueOf).collect(Collectors.joining());\nchar[] chars1 = collect.toCharArray();\n\n//char[]转Character[]\nchar[] a = {'j','a'};\nIntStream chars = String.valueOf(a).chars();\nStream<Character> characterStream1 = chars.mapToObj(b -> (char) b);\nCharacter[] characters = characterStream1.toArray(Character[]::new);\n```\n\n本文的热身部分结束。下面内容需要花时间消化理解。\n\n# 温习：Lambda 表达式的简化写法\n\n具体简化过程详见：[[函数式编程与Java 中的 Lambda 表达式]]。\n\n这里以为 `Arrays` 写一个自定义 `Comparator` 实现逆序排序为例。一般的代码写法如下：\n\n```java\nComparator<Integer> myComparator = new Comparator<Integer>() {\n\t@Override\n\tpublic int compare(Integer o1, Integer o2) {\n\t\treturn o2 - o1;\n\t}\n};\nArrays.sort(nums, myComparator);\n```\n\n简化为（进而得到表格中的写法）：\n\n```java\nComparator<Integer> myComparator = (o1, o2) -> o2 - o1;\nArrays.sort(nums, myComparator);\n```\n\n# 分清楚 `Comparable`、`Comparator`、`compare`、`compareTo`?\n\n字面含义的基本区分：\n\n- `Comparator`「n. 比较器」。它以 `-or` 作为结尾，表示一个可执行某些动作的东西。它也是接口，它有多个待实现的方法，`compare` 是其中之一。\n- `Comparable` 「adj. 可比的」。它以 `-able` 作为结尾，表示具备某种能力，一般用作 Java 接口。只有一个待实现的方法 `compareTo`。\n\n```java\n@FunctionalInterface // 支持 Lambda\npublic interface Comparator<T> {\n    int compare(T o1, T o2);\n\t/* 省略其他代码 */ \n}\n```\n\n```java\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\n```\n\n`compare` 和 `compareTo` 的行为非常类似，都是返回一个整数值：\n\n- 返回负数：当前对象小于传入对象\n- 返回 0：当前对象和传入对象相等\n- 返回正数：当前对象大于传入对象\n\n区别在于：\n\n- `compare` 需要传入两个参数表示两个对象。隐含地意思是，这种比较是一种「外部」的行为。\n- `compareTo` 只需传入一个参数，表示传入对象。那么当前对象在哪呢，答案是在类里面，它是类内部定义的比较。\n\n下面将通过自定义对象排序的例子说明这两种接口的使用异同。以及对「内部」「外部」的体会。\n\n# 自定义对象的排序\n\n现自定义对象 `Person`：\n\n```java\npublic static void main(String[] args) {\n\tclass Person{\n\t\tString name;\n\t\tint score;\n\t\tpublic Person(String name,int score){\n\t\t\tthis.name = name;\n\t\t\tthis.score = score;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn this.name + \" \" + this.score;\n\t\t}\n\t}\n\tPerson[] team = new Person[]{\n\t\tnew Person(\"学渣\",40),\n\t\tnew Person(\"学霸\",100),\n\t\tnew Person(\"普通人\", 80),\n\t};\n\tSystem.out.println(\"排序前：\"+Arrays.toString(team));\n\t// 输出：\n\t// 排序前：[学渣 40, 学霸 100, 普通人 80]\n}\n```\n\n现在我们需要将它们按成绩倒序排序。\n\n## 使用 `Comparator`\n\n在 `main` 函数中增加以下代码：\n\n```java\nComparator<Person> personComparator = new Comparator<Person>() {\n\t@Override\n\tpublic int compare(Person p1, Person p2) {\n\t\treturn p2.score - p1.score;\n\t}\n};\nArrays.sort(team,personComparator);\nSystem.out.println(\"排序后：\"+Arrays.toString(team));\n\n// 输出：\n// 排序后：[学霸 100, 普通人 80, 学渣 40]\n```\n\n在以上示例中，我们没有动过 `Person` 类中的任何代码。我们是在外部自定义了一个 `Comparator` 对第三方类进行排序。也就是说通过 `Comparator` 接口可以实现和原有类的解耦，在不修改原有类的情况下实现排序功能，所以 `Comparator` 可以看作是「对外」提供排序的接口。\n\n另外读者可以回忆一下上文提到的 Lambda，试着把代码优化一下。\n\n> [!note] 阿里巴巴 Java 开发手册对集合使用的相关要求\n> 一、（六）15.【强制】 在 JDK7 版本及以上， `Comparator` 实现类要满足如下三个条件， 不然 `Arrays.sort`，`Collections.sort` 会抛 `IllegalArgumentException` 异常。\n> 说明： 三个条件如下\n> 1） x， y 的比较结果和 y， x 的比较结果相反。\n> 2） x > y， y > z， 则 x > z。\n> 3） x = y， 则 x， z 比较结果和 y， z 比较结果相同。\n\n## 使用 `Comparable`\n\n使用 `Comparable` 接口时我们需要修改 `Person` 类的实现，使其具有「比较的能力」。\n\n```java\nclass Person implements Comparable<Person>{\n\tString name;\n\tint score;\n\tpublic Person(String name,int score){\n\t\tthis.name = name;\n\t\tthis.score = score;\n\t}\n\n\t@Override\n\tpublic String toString(){\n\t\treturn this.name + \" \" + this.score;\n\t}\n\n\t@Override\n\tpublic int compareTo(Person p) {\n\t\treturn p.score-this.score;\n\t}\n}\n```\n\n使用方法：\n\n```java\nArrays.sort(team);\nSystem.out.println(\"排序后：\"+Arrays.toString(team));\n// 输出：\n// 排序后：[学霸 100, 普通人 80, 学渣 40]\n```\n\n通过观察我们可以发现，使用 `Comparable` 接口我们需要「对内」修改类的实现，让类显式支持比较。且调用 `sort` 时不需要传入除了数组以外的其他参数。\n\n需要注意的是，如果不向 `sort` 传入 `Comparator`，且数组内对象没实现 `Comparable` 的话会报错。\n\n# String 字符串的排序\n\n在这个部分中，我们需要实现对 `String` 数组的逆序排序。代码涵盖 `Comparable`、`Comparator`、`compare`、`compareTo`，你能分清楚吗？\n\n```java\nString[] names = {\"Tom\", \"Jack\", \"Mike\", \"Linda\", \"Mary\"};\nSystem.out.println(\"排序前：\" + Arrays.toString(names));\n\nArrays.sort(names);\nSystem.out.println(\"正序排序：\" + Arrays.toString(names));\n\nComparator<String> nameComparator = new Comparator<String>() {\n\t@Override\n\tpublic int compare(String s1, String s2) {\n\t\treturn (s2.compareTo(s1));\n\t}\n};\nArrays.sort(names, nameComparator);\nSystem.out.println(\"逆序排序：\" + Arrays.toString(names));\n\n//    输出：\n//    排序前：[Tom, Jack, Mike, Linda, Mary]\n//    正序排序：[Jack, Linda, Mary, Mike, Tom]\n//    逆序排序：[Tom, Mike, Mary, Linda, Jack]\n```\n\n附 `String` 类中 `compareTo` 的实现：\n\n```java\npublic int compareTo(String anotherString) {\n\tint len1 = value.length;\n\tint len2 = anotherString.value.length;\n\tint lim = Math.min(len1, len2);\n\tchar v1[] = value;\n\tchar v2[] = anotherString.value;\n\n\tint k = 0;\n\twhile (k < lim) {\n\t\tchar c1 = v1[k];\n\t\tchar c2 = v2[k];\n\t\tif (c1 != c2) {\n\t\t\treturn c1 - c2;\n\t\t}\n\t\tk++;\n\t}\n\treturn len1 - len2;\n}\n```\n\n# 二维向量排序\n\n给定一堆向量，先按向量第一个参数排序，再按第二个参数进行排序。\n\n```java\nint[][] nums2d = new int[][] {{2, 4}, {0, 2}, {0, 4}};\nArrays.sort(nums2d,(a,b) -> a[1] == b[1] ? a[0]-b[0] : a[1]-b[1]);\nfor(int[] e:nums2d){\n\tSystem.out.println(Arrays.toString(e));\n}\n\n// 输出：\n// [0, 2]\n// [0, 4]\n// [2, 4]\n```\n\n> [!question] 在上面的例子中，二维数组为什么不需要转换为包装类型？\n> Java 中的数组是引用类型，被排序的数组 `nums2d` 是个二维数组，数组元素是一个个的一维数组（本质上是一个个 `Object`）。`Comparator<int[]>` 是符合 Java 语法要求的。\n\n> [!note] 在 Lambda 写复杂函数时，最后一行记得显式 `return`（不管代码会不会到达），否则报错。\n\n# 对 `Map` 和 `Set` 的排序\n\n`SortedSet` 和 `SortedMap` 支持传入比较器实现自定义排序。在 `SortedMap` 中，我们自定义的是键的排序。\n\n对普通的 `Map`，我们还可以将键值对输出到列表中，再对列表进行自定义排序。下面这个例子展示对 `Map` 的键值对先按值排序，再按键排序：\n\n```java\nList<Map.Entry<Integer,Integer>> ls = new ArrayList<>(map.entrySet());\nCollections.sort(ls,(e1,e2)->{\n\tint k1 = e1.getKey(),k2 = e2.getKey();\n\tint v1 = e1.getValue(), v2 = e2.getValue();\n\treturn v1==v2 ? k1-k2:v1-v2;\n});\n```\n\n# 相关题目\n\n相信阅读到这里的你已经很熟练了。要不尝试下面的练习？\n\n- 🟨 [2545. 根据第 K 场考试的分数排序 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-the-students-by-their-kth-score/description/) 一行代码搞定。\n- 🟨 [791. 自定义字符串排序 - 力扣（LeetCode）](https://leetcode.cn/problems/custom-sort-string/description/) 指定了字符串排序顺序，就是包装类转化有点复杂。\n- 🟨 [1387. 将整数按权重排序 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-integers-by-the-power-value/description/?envType=daily-question&envId=2024-12-22)\n- 🟨 [1366. 通过投票对团队排名 - 力扣（LeetCode）](https://leetcode.cn/problems/rank-teams-by-votes/description/)\n\n# 本文参考\n\n- [Java Lambda 表达式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java8-lambda-expressions.html)\n- 《Java 面向对象编程》孙卫琴 第 17 章\n- [Java 中使用 sort() 方法排序：从基本原理到多种用法全面总结；sort()函数的使用_java sort-CSDN博客](https://blog.csdn.net/weixin_72499901/article/details/136592073)\n- [Java 中初始化 List 集合的 6 种方式!_再list集合中初始化数据-CSDN博客](https://blog.csdn.net/youanyyou/article/details/84846486)\n- [面试官：元素排序Comparable和Comparator有什么区别？-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1918856)\n- [Character数组与char数组互转 - 简书](https://www.jianshu.com/p/d855a1bb4952)","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"Collections","api":"api/tags/Collections.json"},{"name":"Arrays","api":"api/tags/Arrays.json"}]},"api":"api/posts/p/72156dd2.json"}