{"data":{"title":"桥接模式可以沟通功能层次与实现层次","slug":"高质量代码及设计模式/桥接模式可以沟通功能层次与实现层次","description":"将类的功能层次结构与实现层次结构分离。","date":"2025-08-17T09:29:43.000Z","updated":"2026-02-01T08:29:01.211Z","language":"zh-CN","comments":true,"url":"p/d9cc7566/","cover":"https://cdn.gallery.uuanqin.top/img/202508172014260.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311616300.webp\" alt=\"image.png\" width=\"425px\" /></p>\n\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">桥接模式 Bridge Design Pattern</div>\n</div>\n<div class=\"callout-content\"><p>Decouple an abstraction from its implementation so that the two can vary independently.——GoF<br />\n将抽象和实现解耦，让它们可以独立变化。</p>\n</div></div><p>关于桥接模式，很多资料中，还有另外一种理解方式：「一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。」通过组合关系来替代继承关系，避免继承层次的指数级爆炸，让 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M\\times N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个继承类缩减为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>+</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M+N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个继承类。关于这里的理解方式，可以看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/28239a8d/\"><span class=\"bilink-pop-up\">站内文章</span>面向对象编程 OOP</a> 中「多用组合少用继承」的章节。</p>\n<h1 id=\"理解类的层次结构的两个作用\"><a class=\"markdownIt-Anchor\" href=\"#理解类的层次结构的两个作用\"></a> 理解类的层次结构的两个作用</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311618645.webp\" alt=\"image.png\" width=\"375px\" /></p>\n<p>类层次结构的作用：</p>\n<ul>\n<li>增加新的功能</li>\n<li>增加新的实现</li>\n</ul>\n<h2 id=\"增加新的功能\"><a class=\"markdownIt-Anchor\" href=\"#增加新的功能\"></a> 增加新的功能</h2>\n<p>假设类 <code>Something</code> 要增加新功能（增加一个具体方法），会编写 <code>Something</code> 的子类（比如 <code>SomethingGood</code>）。这样就构成了小小的类层次结构：</p>\n<ul>\n<li>父类具有基本功能</li>\n<li>在子类中增加新的功能</li>\n</ul>\n<p>当要继续在 <code>SomethingGood</code> 增加新的功能时，依照这种方式，我们需要继续编写 <code>SomethingGood</code> 的子类 <code>SomethingBetter</code>，这样类的层次结构就加深了。</p>\n<p>如果还要继续增加新的功能，我们可以从各个层次的类中找出最符合自己需求的类，然后以它为父类编写子类，并在子类中增加新的功能。这种层次结构被称为「类的功能层次结构」 。</p>\n<p>通常来说，类的层次结构关系不应当过深。</p>\n<h2 id=\"增加新的实现\"><a class=\"markdownIt-Anchor\" href=\"#增加新的实现\"></a> 增加新的实现</h2>\n<p><strong>抽象类 <code>AbstractClass</code> 声明抽象方法，定义接口（API），子类 <code>ConcreteClass</code> 负责实现抽象方法</strong>，子父类的任务分担，才可以编写具有高可替换性的类。它们之间就构成了一个小小的层次结构：</p>\n<ul>\n<li>父类声明抽象方法定义接口（API）</li>\n<li>子类通过实现具体方法来实现接口（API）</li>\n</ul>\n<p>但是这里的类层次结构不是用于增加功能，而是实现任务分担。这种层次结构称为 「类的实现层次结构」。</p>\n<p>如果我们需要其他方式实现 <code>AbstractClass</code> 时，如要实现 <code>NewConcreteClass</code>，那么类的层次结构会发生变化。</p>\n<h2 id=\"类的层次结构的混杂与分离\"><a class=\"markdownIt-Anchor\" href=\"#类的层次结构的混杂与分离\"></a> 类的层次结构的混杂与分离</h2>\n<p>当我们想要编写子类时，我们需要先思考：我是要增加功能，还是要增加实现？当类的层次结构只有一层时，功能层次结构和实现层次结构是混杂在一个层次结构中的。这样很容易使类的层次结构变得复杂，也难以透彻理解类的层次结构。因为我们难以确定究竟应该在类的哪一个层次结构中去添加子类。</p>\n<p>因此，我们需要将「类的功能层次结构」与「类的实现层次结构」分离为两个独立的类层次结构，然后通过 Bridge 模式搭建桥梁。</p>\n<h1 id=\"桥梁模式\"><a class=\"markdownIt-Anchor\" href=\"#桥梁模式\"></a> 桥梁模式</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311616924.webp\" alt=\"image.png\" width=\"425px\" /></p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508311619987.webp\" alt=\"image.png\" width=\"475px\" /></p>\n<p>左边抽象，定义了类的功能层次结构；右边实现，构成类的实现层次结构。</p>\n<p><code>impl</code> 充当桥梁，通过左边的实现类的构造函数传入。左边的类中的方法就是简单的使用 <code>impl</code> 的方法。</p>\n<p><code>Main</code> 中的使用方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Abstraction</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Abstraction</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteImplementor1</span>());</span><br><span class=\"line\"><span class=\"type\">Abstraction</span> <span class=\"variable\">a2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RefinedAbstraction</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteImplementor2</span>());</span><br><span class=\"line\">a1.method1();</span><br><span class=\"line\">a2.refinedMethodA();</span><br></pre></td></tr></table></figure>\n<p>登场角色：</p>\n<ul>\n<li><code>Abstraction</code>（抽象部分）：该角色位于「类的功能层次结构」的最上层。它使用 <code>Implementor</code> 角色的方法定义了基本的功能。该角色中保存了 <code>Implementor</code> 角色的实例。</li>\n<li><code>Implementor</code>（实现部分）：该角色位于「类的实现层次结构」的最上层。它定义了用于实现 <code>Abstraction</code> 角色的接口（API）的方法。</li>\n<li><code>RefinedAbstraction</code>（精确抽象)：在 <code>Abstraction</code> 角色的基础上增加了新功能的角色。</li>\n<li><code>Concretelmplementor</code>（具体实现者）：该角色负责实现在 <code>Implementor</code> 角色中定义的接口（API）。</li>\n<li><code>Client</code>（客户端）：仅关心如何与抽象部分合作。但是，客户端需要将抽象对象与一个实现对象连接起来。</li>\n</ul>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202503050222849.webp\" alt=\"image.png\" width=\"300px\" /></p>\n<p>想增加功能时，只需要在「类的功能层次结构」一侧增加类。不必对「类的实现层次结构」做任何修改。</p>\n<blockquote>\n<p>继承是强关联关系，委托是弱关联关系。在设计类时，我们需要充分认识到这一点。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建与平台无关的类和程序。</td>\n<td>对高内聚的类使用该模式可能会让代码更加复杂。</td>\n</tr>\n<tr>\n<td>客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。</td>\n<td rowspan=\"3\"></td>\n</tr>\n<tr>\n<td>开闭原则。可以新增抽象部分和实现部分，且它们之间不会相互影响。</td>\n</tr>\n<tr>\n<td>单一职责原则。抽象部分专注于处理高层逻辑，实现部分处理平台细节。</td>\n</tr>\n</tbody>\n</table>\n<p>相关的设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e165ad61/\"><span class=\"bilink-pop-up\">站内文章</span>模板方法模式</a>：在模板方法模式中使用了「类的实现层次结构」。父类调用抽象方法，而子类实现抽象方法。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"bilink-pop-up\">站内文章</span>抽象工厂</a>：为了能够根据需求设计出良好的 <code>ConcreteImplementor</code> 角色，有时我们会使用抽象工厂模式。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>适配器模式</a>：使用桥梁模式可以达到类的功能层次结构与类的实现层次结构分离的目的，并在此基础上使这些层次结构结合起来。而使用适配器模式则可以结合那些功能上相似但是接口（API）不同的类。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>策略模式</a>：如果你需要在运行时切换不同实现方法，可使用桥接模式。注意这里不要和策略模式混淆。设计模式并不仅是一种对类进行组织的方式，它还能用于沟通意图和解决问题。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/5b8a11ae/\"><span class=\"bilink-pop-up\">站内文章</span>建造者模式</a>：主管类负责抽象工作，各种不同的生成器负责实现工作。</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》第 9 章</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/bridge\">桥接设计模式</a></li>\n</ul>\n","raw":"---\ntitle: 桥接模式可以沟通功能层次与实现层次\ntags:\n  - 设计模式\n  - Java\n  - 组合\n  - 委托\n  - 继承\ncover: https://cdn.gallery.uuanqin.top/img/202508172014260.webp\ndescription: 将类的功能层次结构与实现层次结构分离。\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: d9cc7566\nsummary: >-\n  桥接模式是一种设计模式，它可以将抽象部分与实现部分分离，使它们可以独立地变化。这种模式的主要目的是解耦，使得抽象和实现可以独立地进行扩展，而不是通过继承关系来实现。桥接模式通过创建一个实现接口，使得抽象类和具体实现类可以独立地进行变化，从而避免了继承层次的指数级爆炸。在实际应用中，类的层次结构可以分为两类：功能的层次结构和实现的层次结构。功能的层次结构主要用于增加新的功能，而实现的层次结构主要用于任务的分配和职责的分担。当这两种层次结构混杂在一起时，会使类的层次结构变得复杂且难以理解。因此，需要通过桥接模式将这两种层次结构分离，使得它们可以独立地进行变化。桥接模式的核心思想是通过组合关系来替代继承关系，从而减少继承层次的复杂性。通过这种方式，可以将多个继承关系简化为多个组合关系，从而使得系统的扩展性更强，更易于维护和修改。\ndate: 2025-08-17 17:29:43\ntop_img:\n---\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202508311616300.webp)\n\n> [!tldr] 桥接模式 Bridge Design Pattern\n> Decouple an abstraction from its implementation so that the two can vary independently.——GoF\n> 将抽象和实现解耦，让它们可以独立变化。\n\n关于桥接模式，很多资料中，还有另外一种理解方式：「一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。」通过组合关系来替代继承关系，避免继承层次的指数级爆炸，让 $M\\times N$ 个继承类缩减为 $M+N$ 个继承类。关于这里的理解方式，可以看 [[面向对象编程 OOP]] 中「多用组合少用继承」的章节。\n\n# 理解类的层次结构的两个作用\n\n![image.png|375](https://cdn.gallery.uuanqin.top/img/202508311618645.webp)\n\n类层次结构的作用：\n\n- 增加新的功能\n- 增加新的实现\n\n## 增加新的功能\n\n假设类 `Something` 要增加新功能（增加一个具体方法），会编写 `Something` 的子类（比如 `SomethingGood`）。这样就构成了小小的类层次结构：\n\n- 父类具有基本功能\n- 在子类中增加新的功能\n\n当要继续在 `SomethingGood` 增加新的功能时，依照这种方式，我们需要继续编写 `SomethingGood` 的子类 `SomethingBetter`，这样类的层次结构就加深了。\n\n如果还要继续增加新的功能，我们可以从各个层次的类中找出最符合自己需求的类，然后以它为父类编写子类，并在子类中增加新的功能。这种层次结构被称为「类的功能层次结构」 。\n\n通常来说，类的层次结构关系不应当过深。\n\n## 增加新的实现\n\n**抽象类 `AbstractClass` 声明抽象方法，定义接口（API），子类 `ConcreteClass` 负责实现抽象方法**，子父类的任务分担，才可以编写具有高可替换性的类。它们之间就构成了一个小小的层次结构：\n- 父类声明抽象方法定义接口（API）\n- 子类通过实现具体方法来实现接口（API）\n\n但是这里的类层次结构不是用于增加功能，而是实现任务分担。这种层次结构称为 「类的实现层次结构」。\n\n如果我们需要其他方式实现 `AbstractClass` 时，如要实现 `NewConcreteClass`，那么类的层次结构会发生变化。\n\n## 类的层次结构的混杂与分离\n\n当我们想要编写子类时，我们需要先思考：我是要增加功能，还是要增加实现？当类的层次结构只有一层时，功能层次结构和实现层次结构是混杂在一个层次结构中的。这样很容易使类的层次结构变得复杂，也难以透彻理解类的层次结构。因为我们难以确定究竟应该在类的哪一个层次结构中去添加子类。\n\n因此，我们需要将「类的功能层次结构」与「类的实现层次结构」分离为两个独立的类层次结构，然后通过 Bridge 模式搭建桥梁。\n\n# 桥梁模式\n\n![image.png|425](https://cdn.gallery.uuanqin.top/img/202508311616924.webp)\n\n![image.png|475](https://cdn.gallery.uuanqin.top/img/202508311619987.webp)\n\n左边抽象，定义了类的功能层次结构；右边实现，构成类的实现层次结构。\n\n`impl` 充当桥梁，通过左边的实现类的构造函数传入。左边的类中的方法就是简单的使用 `impl` 的方法。\n\n`Main` 中的使用方式：\n\n```java\nAbstraction a1 = new Abstraction(new ConcreteImplementor1());\nAbstraction a2 = new RefinedAbstraction(new ConcreteImplementor2());\na1.method1();\na2.refinedMethodA();\n```\n\n登场角色：\n\n- `Abstraction`（抽象部分）：该角色位于「类的功能层次结构」的最上层。它使用 `Implementor` 角色的方法定义了基本的功能。该角色中保存了 `Implementor` 角色的实例。\n- `Implementor`（实现部分）：该角色位于「类的实现层次结构」的最上层。它定义了用于实现 `Abstraction` 角色的接口（API）的方法。\n- `RefinedAbstraction`（精确抽象)：在 `Abstraction` 角色的基础上增加了新功能的角色。\n- `Concretelmplementor`（具体实现者）：该角色负责实现在 `Implementor` 角色中定义的接口（API）。\n- `Client`（客户端）：仅关心如何与抽象部分合作。但是，客户端需要将抽象对象与一个实现对象连接起来。\n\n![image.png|300](https://cdn.gallery.uuanqin.top/img/202503050222849.webp)\n\n想增加功能时，只需要在「类的功能层次结构」一侧增加类。不必对「类的实现层次结构」做任何修改。\n\n>继承是强关联关系，委托是弱关联关系。在设计类时，我们需要充分认识到这一点。\n\n| 优点                               | 缺点                     |\n| -------------------------------- | ---------------------- |\n| 创建与平台无关的类和程序。                    | 对高内聚的类使用该模式可能会让代码更加复杂。 |\n| 客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。  |                        |\n| 开闭原则。可以新增抽象部分和实现部分，且它们之间不会相互影响。  |                        |\n| 单一职责原则。抽象部分专注于处理高层逻辑，实现部分处理平台细节。 |                        |\n\n相关的设计模式：\n\n- [[模板方法模式与回调|模板方法模式]]：在模板方法模式中使用了「类的实现层次结构」。父类调用抽象方法，而子类实现抽象方法。\n- [[类的工厂|抽象工厂]]：为了能够根据需求设计出良好的 `ConcreteImplementor` 角色，有时我们会使用抽象工厂模式。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。\n- [[适配器模式：转接头|适配器模式]]：使用桥梁模式可以达到类的功能层次结构与类的实现层次结构分离的目的，并在此基础上使这些层次结构结合起来。而使用适配器模式则可以结合那些功能上相似但是接口（API）不同的类。\n- [[策略模式：符文槽|策略模式]]：如果你需要在运行时切换不同实现方法，可使用桥接模式。注意这里不要和策略模式混淆。设计模式并不仅是一种对类进行组织的方式，它还能用于沟通意图和解决问题。\n- [[建造者模式的两种不同实现方式|建造者模式]]：主管类负责抽象工作，各种不同的生成器负责实现工作。\n\n# 本文参考\n\n- 《图解设计模式》第 9 章\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [桥接设计模式](https://refactoringguru.cn/design-patterns/bridge)","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"组合","api":"api/tags/组合.json"},{"name":"委托","api":"api/tags/委托.json"},{"name":"继承","api":"api/tags/继承.json"}]},"api":"api/posts/p/d9cc7566.json"}