{"title":"单例模式一文通","tags":["设计模式","单例模式","Java"],"description":"单例模式——只有一个实例。除了具体实现外，还探讨单例模式的一些问题及解决方案","katex":false,"categories":["高质量代码及设计模式"],"abbrlink":"f7f6f747","date":"2025-06-11T23:49:21.000Z","cover":"https://cdn.gallery.uuanqin.top/img/202506120021808.webp","top_img":null,"summary":"想在程序中表示某个东西只会存在一个，比如表示程序所运行于那台计算机的类、表示软件系统相关设置的类、表示视窗系统（Window system）的类时，我们可以使用单例模式。 这种使用单例模式的类通常会占用较多的内存，或者示例的初始化过程比较冗长，如果随意创建这些类的示例会影响系统性能。我们使用单例模式的目的： 想确保任何情况下都绝对只有 1 个实例，在程序上表现出「只存在一个实例」 处理资源访问冲突 单例模式的实现方法 设计单例时需要考虑的要点： 构造方法为私有 注意线程安全问题 考虑是否延时加载 考虑获取单例 `getInstance()` 的性能是否够高 | 实现方法 | 基本饿汉式 | 线程不安全的懒汉式 | 线程安全但锁粒度大的懒汉式 | DCL | IoDH | 枚举 | | ------ | ------- | --------- | ------------- | -------- | ----------------------- | ------------ | | 饿汉/懒汉 | 饿汉 | 懒汉 | 懒汉 | 懒汉 | 懒汉 | 饿汉 | | JDK 版本 | | | | JDK1.5 起 | | JDK1.5 起 | | 延迟加载 | 🟥 | 🟩 | 🟩 | 🟩 | 🟩 | 🟥 | | 线程安全 | 🟩 | 🟥 | 🟩 | 🟩 | 🟩 | 🟩 | | 实现难度 | 🟩 | 🟩 | 🟩 | 🟥 | 🟥 | 🟩 | | 应用场景 | 一般情况下使用 | 不建议 | 不建议 | 存在特殊需求时 | 在要明确实现 lazy loading 效果时 | 涉及到反序列化创建对象时 | 基本饿汉模式 基于 classloader 机制避免了多线程的同步问题。 `instance` 前的关键字加上了 `final` 关键字的原因：防止子类不恰当的方法覆盖单例。 构造方法为私有 `private` 的原因：禁止从 `Singleton` 类外部调用构造函数。只有自己才能 `new` 自己。外部只能通过类的静态方法使用。但是不能防止反射创建新的实例。 如果 `Singleton` 实现了序列化接口，我们还需要增加以下代码防止反序列化破坏单例： 这样的初始化是可以保证单例对象创建时的线程安全。..."}