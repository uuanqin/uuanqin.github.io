{"data":{"title":"SpringBoot 中的 IoC & DI 入门","slug":"技术学习/SpringBoot 中的 IoC & DI 入门","description":"入门案例感受 IOC 容器的基本工作方式。","date":"2024-08-01T16:40:03.000Z","updated":"2025-07-28T16:24:24.197Z","language":"zh-CN","comments":true,"url":"p/66216cb4/","cover":"https://cdn.gallery.uuanqin.top/img/202409050030052.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">SpringBoot 的两大核心</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ol>\n<li>IoC：控制反转</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e036b68e/\"><span class=\"yukari\">站内文章</span>AOP</a>：面向切面编程</li>\n</ol>\n</div></div><h1 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\"></a> 基本概念</h1>\n<h2 id=\"控制反转-inversion-of-control\"><a class=\"markdownIt-Anchor\" href=\"#控制反转-inversion-of-control\"></a> 控制反转 Inversion of Control</h2>\n<p><strong>控制反转（Inversion of Control，IoC）</strong> 即控制反转/反转控制。它是一种设计思想，而不是一个技术实现。它描述的是 Java 开发领域对象的创建以及管理的问题。这种设计思想可以用来指导框架层面的设计。</p>\n<ul>\n<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力，对程序执行流程的控制。</li>\n<li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）。在没有反转之前，程序员自己控制整个程序的执行。在使用某个控制反转框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员「反转」到了框架。</li>\n</ul>\n<h2 id=\"依赖注入-dependency-injection\"><a class=\"markdownIt-Anchor\" href=\"#依赖注入-dependency-injection\"></a> 依赖注入 Dependency Injection</h2>\n<p>IoC 最常见以及最合理的实现方式叫做 <strong>依赖注入（Dependency Injection，DI）</strong>。它是一种具体的编码技巧：不通过 <code>new</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>\n<p>下面通过简单例子展示 DI：手机类 <code>Phone</code> 存在内部成员 <code>SIMCard</code> 卡。插入 <code>SIMCard</code> 的手机才能使用，调用 <code>SIMCard</code> 类中的方法。</p>\n<p>下面展示 <code>Phone</code> 非依赖注入实现的过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非依赖注入实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Phone</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> SIMCard card;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Phone</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.card = <span class=\"keyword\">new</span> <span class=\"title class_\">SIMCard</span>(); <span class=\"comment\">// 构造函数创建了SIM卡，有点硬编码</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMsg</span><span class=\"params\">(String text)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.card.send(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SIMCard</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String text)</span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Phone 时</span></span><br><span class=\"line\"><span class=\"type\">Phone</span> <span class=\"variable\">phone</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Phone</span>()</span><br></pre></td></tr></table></figure>\n<p>依赖注入的实现过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖注入实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Phone</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> SIMCard card;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Phone</span><span class=\"params\">(SIMCard card)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.card = card;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMsg</span><span class=\"params\">(String text)</span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Phone</span></span><br><span class=\"line\"><span class=\"type\">SIMCard</span> <span class=\"variable\">card</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SIMCard</span>();</span><br><span class=\"line\"><span class=\"type\">Phone</span> <span class=\"variable\">phone</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Phone</span>(card); <span class=\"comment\">//通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"依赖注入框架-di-framework\"><a class=\"markdownIt-Anchor\" href=\"#依赖注入框架-di-framework\"></a> 依赖注入框架 DI Framework</h1>\n<p>在上面的手机和 SIM 的例子中，依赖注入的实现过程虽然不存在硬编码在 <code>Phone</code> 内部创建 <code>SIMCard</code> 类的方式，但是 <code>SIMCard</code> 类的创建、组装（注入）<code>Phone</code> 的工作仅仅是被移动到了更加上层的代码而已，还是需要我们程序员自己来实现。</p>\n<p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。这个框架就是「依赖注入框架」。</p>\n<p>现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。</p>\n<p>Spring 是依赖注入框架，而它自称是控制反转容器（Inversion Of Control Container）。这两种说法都没错。控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。</p>\n<h2 id=\"依赖反转原则-dependency-inversion-principle\"><a class=\"markdownIt-Anchor\" href=\"#依赖反转原则-dependency-inversion-principle\"></a> 依赖反转原则 Dependency Inversion Principle</h2>\n<p>详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>设计原则</a></p>\n<h1 id=\"spring-中-iocdi-的使用\"><a class=\"markdownIt-Anchor\" href=\"#spring-中-iocdi-的使用\"></a> Spring 中 IoC/DI 的使用</h1>\n<p>Bean 对象：IoC 容器中创建、管理的对象，称之为 bean。</p>\n<p>基础使用：</p>\n<ul>\n<li><code>@Component</code>：将当前类（Service 层、Dao 层）交给 IoC 容器管理，成为 IoC 容器中的 bean。实现控制反转。</li>\n<li><code>@Autowired</code>：（为 Controller 和 Service 注入）运行时，IoC 容器会提供该类型的 bean 对象，并赋值给该变量。实现依赖注入。</li>\n</ul>\n<blockquote>\n<p>所以说，切换业务实现类时，直接把需要用的实现类上加上 <code>@Component</code> 就行。</p>\n</blockquote>\n<p>SpringBoot 中 Bean 的声明：</p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n<th>位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@Component</code></td>\n<td>声明 bean 的基础注解</td>\n<td>不属于以下三类时，用此注解（比如一些工具类）</td>\n</tr>\n<tr>\n<td><code>@Controller</code></td>\n<td rowspan=\"3\"><code>@Component</code> 的衍生注解</td>\n<td>标注在控制器类上</td>\n</tr>\n<tr>\n<td><code>@Service</code></td>\n<td>标注在业务类上</td>\n</tr>\n<tr>\n<td><code>@Repository</code></td>\n<td>标注在数据访问类上（由于与 mybatis 整合，用的少）</td>\n</tr>\n</tbody>\n</table>\n<p>声明 bean 的时候，可以通过 value 属性指定 bean 的名字，如果没有指定，默认为类名首字母小写。</p>\n<p>使用以上四个注解都可以声明 bean，但是在 Springboot 集成 web 开发中，声明控制器 bean 只能用 <code>@Controller</code>。</p>\n<blockquote>\n<p><code>@RestController</code> 中包含 <code>@Controller</code> 注解。</p>\n</blockquote>\n<p>Bean 组件扫描：</p>\n<ul>\n<li>前面声明 bean 的四大注解，要想生效，还需要被组件扫描注解 <code>@Componentscan</code> 扫描。<code>@ComponentScan</code> 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 <code>@SpringBootApplication</code> 中，默认扫描的范围是启动类所在包及其子包。</li>\n<li>【不推荐】我们可以在启动类上增加 <code>@ComponentScan</code> 注解，手动设置扫描包的范围。注意检查有没有覆盖掉默认的薮猫范围，可以自己手动添加上。</li>\n</ul>\n<p>Bean 注入：</p>\n<ul>\n<li><code>@Autowired</code> 注解，默认是按照类型进行。也就是在 IoC 容器中找这个类型的 Bean 对象然后再注入。</li>\n<li>如果存在多个相同类型的 bean，将会报错，可以使用以下方案解决：\n<ul>\n<li><code>@Primary</code>。在 Bean 上面再加上这个注解，可以让该 Bean 优先生效。</li>\n<li><code>@Autowired</code>+<code>@Qualifier(&quot;&lt;beanName&gt;&quot;)</code>。使该名字的 Bean 生效。</li>\n<li><code>@Resource(name=&quot;&lt;beanName&gt;&quot;)</code>。使该名字的 Bean 生效。</li>\n</ul>\n</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">【高频面试题】<code>@Resource</code> 与 <code>@Autowired</code> 区别：</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li><code>@Autowired</code> 是 Spring 框架提供的注解，而 <code>@Resource</code> 是 JDK 提供的注解，</li>\n<li><code>@Autowired</code> 默认是按照类型注入，而 <code>@Resource</code> 默认是按照名称注入。</li>\n</ul>\n</div></div><h1 id=\"示例工程\"><a class=\"markdownIt-Anchor\" href=\"#示例工程\"></a> 示例工程</h1>\n<p>一个工程目录示例：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240508230449.webp\" alt=\"image.png\" width=\"350px\" /></p>\n<p>示例 Mapper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DeptMapper</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 基于注解方式编写SQL语句</span></span><br><span class=\"line\">\t<span class=\"meta\">@Select(&quot;select * from user&quot;)</span></span><br><span class=\"line\">\tList&lt;dept&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例 Service 接口类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DeptService</span>&#123;</span><br><span class=\"line\">\tList&lt;Dept&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例 Service 的实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeptServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DeptService</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 注入Mapper</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DeptMapper deptMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 实现接口</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> List&lt;Dept&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> deptMapper.list();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例 Controller 的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span> <span class=\"comment\">// 使用日志</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeptController</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// @Slf4j 将省略下面这一行</span></span><br><span class=\"line\">\t<span class=\"comment\">// private static Logger log = LoggerFactory.getLogger(DeptController.class);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Service的注入</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DeptService deptService;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// @GetMapping 作用和下面这条相同</span></span><br><span class=\"line\">\t<span class=\"comment\">// @RequestMapping(vaue = &quot;/depts&quot;,method = RequestMethod.GET)</span></span><br><span class=\"line\">\t<span class=\"meta\">@GetMapping(&quot;/depts&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Result <span class=\"title function_\">list</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tlog.info(<span class=\"string\">&quot;查询部门数据&quot;</span>);</span><br><span class=\"line\">\t\tList&lt;Dept&gt; deptList = deptService.list();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Result.success(deptList); <span class=\"comment\">// 结果类Result是自己定义的</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"bean-管理\"><a class=\"markdownIt-Anchor\" href=\"#bean-管理\"></a> Bean 管理</h1>\n<h2 id=\"获取-bean\"><a class=\"markdownIt-Anchor\" href=\"#获取-bean\"></a> 获取 Bean</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拿到 IoC 容器的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ApplicationContext applicationContext; <span class=\"comment\">// IoC容器对象</span></span><br></pre></td></tr></table></figure>\n<p><strong>默认情况下</strong>，Spring 项目启动时，会把 bean 都创建好放在 IoC 容器中 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，如果想要<strong>主动</strong>获取这些 bean，可以通过如下方式使用 <code>ApplicationContext</code> 的方法：</p>\n<ul>\n<li>根据 name 获取 bean：<code>Object getBean(String name)</code></li>\n<li>根据类型获取 bean：<code>&lt;T&gt; T getBean(Class&lt;T&gt; requiredType)</code></li>\n<li>根据 name 获取 bean（带类型转换）：<code>&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType)</code></li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationTests</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ApplicationContext applicationContext; <span class=\"comment\">// IoC容器对象</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testGetBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//根据bean的名称获取</span></span><br><span class=\"line\">\t<span class=\"type\">DeptController</span> <span class=\"variable\">bean1</span> <span class=\"operator\">=</span> (DeptController) applicationContext.getBean(<span class=\"string\">&quot;deptController&quot;</span>);</span><br><span class=\"line\">\tSystem.out.println(bean1);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//根据bean的类型获取</span></span><br><span class=\"line\">\t<span class=\"type\">DeptController</span> <span class=\"variable\">bean2</span> <span class=\"operator\">=</span> applicationContext.getBean(DeptController.class);</span><br><span class=\"line\">\tSystem.out.println(bean2);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//根据bean的名称及类型获取</span></span><br><span class=\"line\">\t<span class=\"type\">DeptController</span> <span class=\"variable\">bean3</span> <span class=\"operator\">=</span> applicationContext.getBean(<span class=\"string\">&quot;deptController&quot;</span>,DeptController.class);</span><br><span class=\"line\">\tSystem.out.println(bean3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果发现三个 bean 对象都是同一个对象，说明此时 bean 是单例的。</p>\n<h2 id=\"bean-的作用域\"><a class=\"markdownIt-Anchor\" href=\"#bean-的作用域\"></a> Bean 的作用域</h2>\n<p>Spring 支持五种作用域，后三种在 web 环境才生效：</p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>singleton</code></td>\n<td>容器内同名称的 bean 只有一个实例（单例）（默认）</td>\n</tr>\n<tr>\n<td><code>prototype</code></td>\n<td>每次使用该 bean 时会创建新的实例（非单例）</td>\n</tr>\n<tr>\n<td><code>request</code></td>\n<td>每个请求范围内会创建新的实例（web 环境中，了解即可）</td>\n</tr>\n<tr>\n<td><code>session</code></td>\n<td>每个会话范围内会创建新的实例（web 环境中，了解即可）</td>\n</tr>\n<tr>\n<td><code>application</code></td>\n<td>每个应用范围内会创建新的实例（web 环境中，了解即可）</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过 <code>@Scope</code> 注解来进行配置作用域：<code>@Scope(&quot;prototype&quot;)</code>。</p>\n<p>默认 <code>singleton</code> 的 bean，在容器启动时被创建，可以使用 <code>@Lazy</code> 注解来延迟初始化（延迟到第一次使用时），<code>prototype</code> 的 bean，每一次使用该 bean 的时候都会创建一个新的实例。</p>\n<p>实际开发当中，绝大部分的 Bean 是单例的，也就是说绝大部分 Bean 不需要配置 scope 属性。</p>\n<h2 id=\"第三方-bean\"><a class=\"markdownIt-Anchor\" href=\"#第三方-bean\"></a> 第三方 Bean</h2>\n<p>如果要管理的 bean 对象来自于第三方（不是自定义的），是无法用 <code>@Component</code> 及衍生注解声明 bean 的（第三方某些类的源码定义中我们无法改动），就需要用到 <code>@Bean</code> 注解。若要管理的第三方 bean 对象，建议对这些 bean 进行集中分类配置，可以通过 <code>@Configuration</code> 注解声明一个配置类。</p>\n<blockquote>\n<p><code>@Configuration</code> 底层也是 <code>@Component</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：【不推荐】定义在启动类中</span></span><br><span class=\"line\"><span class=\"comment\">// 这样导致启动类不纯粹</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringbootWebConfig2Application</span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span> <span class=\"comment\">//将方法返回值交给IoC容器管理，成为IoC容器的bean对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：声明一个配置类</span></span><br><span class=\"line\"><span class=\"comment\">// 通过@Bean注解的name/value属性指定bean名称，如果未指定，默认是方法名</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonConfig</span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 Bean 时直接注入即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MyBean mybean;</span><br></pre></td></tr></table></figure>\n<p>如果第三方 bean 需要依赖其它 bean 对象，直接在 bean 定义方法中设置形参即可，容器会根据类型自动装配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonConfig</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// SpringBoot容器会根据参数类型MyService自动装配Bean对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">(MyService myService)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 省略一些使用myService的操作</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Component</code> 及衍生注解与 <code>@Bean</code> 注解使用场景?</p>\n<ul>\n<li>项目中自定义的，使用 <code>@Component</code> 及其衍生注解</li>\n<li>项目中引入第三方的，使用 <code>@Bean</code> 注解</li>\n</ul>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<p>下面你可以立即移步这篇文章加深上面所学知识的印象：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/21b7da2d/\"><span class=\"yukari\">站内文章</span>SpringBoot 的原理以及写一个自定义 Starter</a>。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1m84y1w7Tb?p=75&amp;vd_source=e03d48176855fc5349b27aef691f9cdb\">Day05-09. 分层解耦-三层架构_哔哩哔哩_bilibili</a></li>\n<li><a href=\"https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#ioc-inversion-of-control\">IoC &amp; AOP详解（快速搞懂） | JavaGuide</a></li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/docs/177444.md\">设计模式之美 - 王争 - 极客时间专栏</a></li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n</ul>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>这还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的 bean 而言。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","raw":"---\ntitle: SpringBoot 中的 IoC & DI 入门\ntags:\n  - SpringBoot\n  - Java\n  - Bean\n  - IoC\n  - DI\ncover: 'https://cdn.gallery.uuanqin.top/img/202409050030052.webp'\ndescription: 入门案例感受 IOC 容器的基本工作方式。\ncategories:\n  - 技术学习\nabbrlink: 66216cb4\ndate: 2024-08-02 00:40:03\ntop_img:\n---\n\n> [!notice] SpringBoot 的两大核心\n>\n> 1. IoC：控制反转\n> 2. [[SpringBoot 中的面向切面编程（AOP）|AOP]]：面向切面编程\n\n# 基本概念\n\n## 控制反转 Inversion of Control\n\n**控制反转（Inversion of Control，IoC）** 即控制反转/反转控制。它是一种设计思想，而不是一个技术实现。它描述的是 Java 开发领域对象的创建以及管理的问题。这种设计思想可以用来指导框架层面的设计。\n\n- **控制** ：指的是对象创建（实例化、管理）的权力，对程序执行流程的控制。\n- **反转** ：控制权交给外部环境（IoC 容器）。在没有反转之前，程序员自己控制整个程序的执行。在使用某个控制反转框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员「反转」到了框架。\n\n## 依赖注入 Dependency Injection\n\nIoC 最常见以及最合理的实现方式叫做 **依赖注入（Dependency Injection，DI）**。它是一种具体的编码技巧：不通过 `new` 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n\n下面通过简单例子展示 DI：手机类 `Phone` 存在内部成员 `SIMCard` 卡。插入 `SIMCard` 的手机才能使用，调用 `SIMCard` 类中的方法。\n\n下面展示 `Phone` 非依赖注入实现的过程：\n\n```java\n// 非依赖注入实现方式\npublic class Phone{\n\tprivate SIMCard card;\n\tpublic Phone(){\n\t\tthis.card = new SIMCard(); // 构造函数创建了SIM卡，有点硬编码\n\t}\n\tpublic void sendMsg(String text){\n\t\tthis.card.send(text);\n\t}\n}\n\npublic class SIMCard{\n\tpublic void send(String text){/* ... */}\n}\n\n// 使用 Phone 时\nPhone phone = new Phone()\n```\n\n依赖注入的实现过程：\n\n```java\n// 依赖注入实现方式\npublic class Phone{\n\tprivate SIMCard card;\n\tpublic Phone(SIMCard card){\n\t\tthis.card = card;\n\t}\n\tpublic void sendMsg(String text){/* ... */}\n}\n\n// 使用 Phone\nSIMCard card = new SIMCard();\nPhone phone = new Phone(card); //通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。\n```\n\n# 依赖注入框架 DI Framework\n\n在上面的手机和 SIM 的例子中，依赖注入的实现过程虽然不存在硬编码在 `Phone` 内部创建 `SIMCard` 类的方式，但是 `SIMCard` 类的创建、组装（注入）`Phone` 的工作仅仅是被移动到了更加上层的代码而已，还是需要我们程序员自己来实现。\n\n在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。这个框架就是「依赖注入框架」。\n\n现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。\n\nSpring 是依赖注入框架，而它自称是控制反转容器（Inversion Of Control Container）。这两种说法都没错。控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。\n\n## 依赖反转原则 Dependency Inversion Principle\n\n详见：[[设计原则]]\n\n# Spring 中 IoC/DI 的使用\n\nBean 对象：IoC 容器中创建、管理的对象，称之为 bean。\n\n基础使用：\n\n- `@Component`：将当前类（Service 层、Dao 层）交给 IoC 容器管理，成为 IoC 容器中的 bean。实现控制反转。\n- `@Autowired`：（为 Controller 和 Service 注入）运行时，IoC 容器会提供该类型的 bean 对象，并赋值给该变量。实现依赖注入。\n\n> 所以说，切换业务实现类时，直接把需要用的实现类上加上 `@Component` 就行。\n\nSpringBoot 中 Bean 的声明：\n\n| 注解            | 说明                 | 位置                            |\n| ------------- | ------------------ | ----------------------------- |\n| `@Component`  | 声明 bean 的基础注解      | 不属于以下三类时，用此注解（比如一些工具类）        |\n| `@Controller` | `@Component` 的衍生注解 | 标注在控制器类上                      |\n| `@Service`    | `@Component` 的衍生注解 | 标注在业务类上                       |\n| `@Repository` | `@Component` 的衍生注解 | 标注在数据访问类上（由于与 mybatis 整合，用的少） |\n\n声明 bean 的时候，可以通过 value 属性指定 bean 的名字，如果没有指定，默认为类名首字母小写。\n\n使用以上四个注解都可以声明 bean，但是在 Springboot 集成 web 开发中，声明控制器 bean 只能用 `@Controller`。\n\n> `@RestController` 中包含 `@Controller` 注解。\n\nBean 组件扫描：\n\n- 前面声明 bean 的四大注解，要想生效，还需要被组件扫描注解 `@Componentscan` 扫描。`@ComponentScan` 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 `@SpringBootApplication` 中，默认扫描的范围是启动类所在包及其子包。\n- 【不推荐】我们可以在启动类上增加 `@ComponentScan` 注解，手动设置扫描包的范围。注意检查有没有覆盖掉默认的薮猫范围，可以自己手动添加上。\n\nBean 注入：\n\n- `@Autowired` 注解，默认是按照类型进行。也就是在 IoC 容器中找这个类型的 Bean 对象然后再注入。\n- 如果存在多个相同类型的 bean，将会报错，可以使用以下方案解决：\n\t- `@Primary`。在 Bean 上面再加上这个注解，可以让该 Bean 优先生效。\n\t- `@Autowired`+`@Qualifier(\"<beanName>\")`。使该名字的 Bean 生效。\n\t- `@Resource(name=\"<beanName>\")`。使该名字的 Bean 生效。\n\n> [!example] 【高频面试题】`@Resource` 与 `@Autowired` 区别：\n> - `@Autowired` 是 Spring 框架提供的注解，而 `@Resource` 是 JDK 提供的注解，\n> - `@Autowired` 默认是按照类型注入，而 `@Resource` 默认是按照名称注入。\n\n# 示例工程\n\n一个工程目录示例：\n\n![image.png|350](https://cdn.gallery.uuanqin.top/img/20240508230449.webp)\n\n示例 Mapper：\n\n```java\n@Mapper\npublic interface DeptMapper{\n\t// 基于注解方式编写SQL语句\n\t@Select(\"select * from user\")\n\tList<dept> list();\n}\n```\n\n示例 Service 接口类：\n\n```java\npublic interface DeptService{\n\tList<Dept> list();\n}\n```\n\n示例 Service 的实现类：\n\n```java\n@Service\npublic class DeptServiceImpl implements DeptService{\n\t// 注入Mapper\n\t@Autowired\n\tprivate DeptMapper deptMapper;\n\n\t// 实现接口\n\t@Override\n\tpublic List<Dept> list(){\n\t\treturn deptMapper.list();\n\t}\n}\n```\n\n示例 Controller 的写法：\n\n```java\n@Slf4j // 使用日志\n@RestController\npublic class DeptController{\n\t// @Slf4j 将省略下面这一行\n\t// private static Logger log = LoggerFactory.getLogger(DeptController.class);\n\n\t// Service的注入\n\t@Autowired\n\tprivate DeptService deptService;\n\n\t// @GetMapping 作用和下面这条相同\n\t// @RequestMapping(vaue = \"/depts\",method = RequestMethod.GET)\n\t@GetMapping(\"/depts\")\n\tpublic Result list(){\n\t\tlog.info(\"查询部门数据\");\n\t\tList<Dept> deptList = deptService.list();\n\t\treturn Result.success(deptList); // 结果类Result是自己定义的\n\t}\n}\n```\n\n# Bean 管理\n\n## 获取 Bean\n\n```java\n// 拿到 IoC 容器的方法\n@Autowired\nprivate ApplicationContext applicationContext; // IoC容器对象\n```\n\n**默认情况下**，Spring 项目启动时，会把 bean 都创建好放在 IoC 容器中 [^ioc]，如果想要**主动**获取这些 bean，可以通过如下方式使用 `ApplicationContext` 的方法：\n- 根据 name 获取 bean：`Object getBean(String name)`\n- 根据类型获取 bean：`<T> T getBean(Class<T> requiredType)`\n- 根据 name 获取 bean（带类型转换）：`<T> T getBean(String name, Class<T> requiredType)`\n\n[^ioc]: 这还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的 bean 而言。\n\n示例：\n\n```java\n@SpringBootTest\nclass ApplicationTests{\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext; // IoC容器对象\n\t\n\t@Test\n\tpublic void testGetBean(){\n\t\n\t//根据bean的名称获取\n\tDeptController bean1 = (DeptController) applicationContext.getBean(\"deptController\");\n\tSystem.out.println(bean1);\n\t\n\t//根据bean的类型获取\n\tDeptController bean2 = applicationContext.getBean(DeptController.class);\n\tSystem.out.println(bean2);\n\t\n\t//根据bean的名称及类型获取\n\tDeptController bean3 = applicationContext.getBean(\"deptController\",DeptController.class);\n\tSystem.out.println(bean3);\n}\n```\n\n输出结果发现三个 bean 对象都是同一个对象，说明此时 bean 是单例的。\n\n## Bean 的作用域\n\nSpring 支持五种作用域，后三种在 web 环境才生效：\n\n| 作用域           | 说明                           |\n| ------------- | ---------------------------- |\n| `singleton`   | 容器内同名称的 bean 只有一个实例（单例）（默认）  |\n| `prototype`   | 每次使用该 bean 时会创建新的实例（非单例）     |\n| `request`     | 每个请求范围内会创建新的实例（web 环境中，了解即可） |\n| `session`     | 每个会话范围内会创建新的实例（web 环境中，了解即可） |\n| `application` | 每个应用范围内会创建新的实例（web 环境中，了解即可） |\n\n可以通过 `@Scope` 注解来进行配置作用域：`@Scope(\"prototype\")`。\n\n默认 `singleton` 的 bean，在容器启动时被创建，可以使用 `@Lazy` 注解来延迟初始化（延迟到第一次使用时），`prototype` 的 bean，每一次使用该 bean 的时候都会创建一个新的实例。\n\n实际开发当中，绝大部分的 Bean 是单例的，也就是说绝大部分 Bean 不需要配置 scope 属性。\n\n## 第三方 Bean\n\n如果要管理的 bean 对象来自于第三方（不是自定义的），是无法用 `@Component` 及衍生注解声明 bean 的（第三方某些类的源码定义中我们无法改动），就需要用到 `@Bean` 注解。若要管理的第三方 bean 对象，建议对这些 bean 进行集中分类配置，可以通过 `@Configuration` 注解声明一个配置类。\n\n> `@Configuration` 底层也是 `@Component`。\n\n```java\n// 方法一：【不推荐】定义在启动类中\n// 这样导致启动类不纯粹\n@SpringBootApplication\npublic class SpringbootWebConfig2Application{\n\t@Bean //将方法返回值交给IoC容器管理，成为IoC容器的bean对象\n\tpublic MyBean myBean(){\n\t\treturn new MyBean();\n\t}\n}\n\n// 方法二：声明一个配置类\n// 通过@Bean注解的name/value属性指定bean名称，如果未指定，默认是方法名\n@Configuration\npublic class CommonConfig{\n\t@Bean\n\tpublic MyBean myBean(){\n\t\treturn new MyBean();\n\t}\n}\n```\n\n使用 Bean 时直接注入即可：\n\n```java\n@Autowired\nprivate MyBean mybean;\n```\n\n如果第三方 bean 需要依赖其它 bean 对象，直接在 bean 定义方法中设置形参即可，容器会根据类型自动装配。\n\n```java\n@Configuration\npublic class CommonConfig{\n\n\t// SpringBoot容器会根据参数类型MyService自动装配Bean对象\n\t@Bean\n\tpublic MyBean myBean(MyService myService){\n\t\t// 省略一些使用myService的操作\n\t\treturn new MyBean();\n\t}\n}\n```\n\n`@Component` 及衍生注解与 `@Bean` 注解使用场景?\n\n- 项目中自定义的，使用 `@Component` 及其衍生注解\n- 项目中引入第三方的，使用 `@Bean` 注解\n\n# 后记\n\n下面你可以立即移步这篇文章加深上面所学知识的印象：[[SpringBoot 的原理以及写一个自定义 Starter]]。\n\n# 本文参考\n- [Day05-09. 分层解耦-三层架构_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1m84y1w7Tb?p=75&vd_source=e03d48176855fc5349b27aef691f9cdb)\n- [IoC & AOP详解（快速搞懂） | JavaGuide](https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#ioc-inversion-of-control)\n- [设计模式之美 - 王争 - 极客时间专栏](https://gitee.com/buxsren/design-pattern-books/blob/master/docs/177444.md)\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️","categories":[{"name":"技术学习","api":"api/categories/技术学习.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"SpringBoot","api":"api/tags/SpringBoot.json"},{"name":"Bean","api":"api/tags/Bean.json"},{"name":"IoC","api":"api/tags/IoC.json"},{"name":"DI","api":"api/tags/DI.json"}]},"api":"api/posts/p/66216cb4.json"}