{"data":{"title":"前后缀分解的应用","slug":"算法与数据结构/前后缀分解的应用","description":"动态规划的简单运用，打遍「连续子数组」「接雨水」","date":"2024-09-21T11:12:16.000Z","updated":"2025-10-16T16:24:57.142Z","language":"zh-CN","comments":true,"url":"p/59af443f/","cover":"https://cdn.gallery.uuanqin.top/img/202409220021307.webp","images":[],"content":"<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"前缀和\"><a class=\"markdownIt-Anchor\" href=\"#前缀和\"></a> 前缀和</h1>\n<p>对于「连续子数组问题」一般可以通过前缀和方式解决。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/subarray-sum-equals-k/description/\">560. 和为 K 的子数组 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。</p>\n<p>子数组是数组中元素的连续非空序列。</p>\n</div></div><p>暴力枚举：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的长度。枚举子数组开头和结尾需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 的时间，其中求和需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间复杂度，因此总时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。只需要常数空间存放若干变量。</li>\n</ul>\n<p>下面介绍前缀和 + 哈希表优化方法。</p>\n<p>定义 <code>pre[i]</code> 为 <code>[0..i]</code> 里所有数的和，则 <code>pre[i]</code> 可以由 <code>pre[i−1]</code> 递推而来，即：<code>pre[i]=pre[i−1]+nums[i]</code>。</p>\n<p>那么「<code>[j..i]</code> 这个子数组和为 <code>k</code> 」这个条件我们可以转化为 <code>pre[i]−pre[j−1]==k</code>。</p>\n<p>因此我们可以在遍历的同时计算前缀和 <code>pre[i]</code> 时，找一下哈希表中有没有存有 <code>pre[j−1]</code> 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">subarraySum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, pre = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tHashMap &lt; Integer, Integer &gt; mp = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span> &lt; &gt; ();</span><br><span class=\"line\">\tmp.put(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">// 考虑到答案是整个前缀本身的情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\tpre += nums[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mp.containsKey(pre - k)) &#123;</span><br><span class=\"line\">\t\t\tcount += mp.get(pre - k);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmp.put(pre, mp.getOrDefault(pre, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的长度。我们遍历数组的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，中间利用哈希表查询删除的复杂度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，因此总时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的空间复杂度。</li>\n</ul>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/\">974. 和可被 K 整除的子数组 - 力扣（LeetCode）</a> 对 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/7602b79c/\"><span class=\"bilink-pop-up\">站内文章</span>同余定理</a> 的考察。</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/continuous-subarray-sum/description/\">523. 连续的子数组和 - 力扣（LeetCode）</a> 对 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/7602b79c/\"><span class=\"bilink-pop-up\">站内文章</span>同余定理</a> 的考察，并且限制了数组长度，不需要统计符合条件的个数。</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/maximum-subarray/description/\">53. 最大子数组和 - 力扣（LeetCode）</a>。解法详看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/19c8c246/\"><span class=\"bilink-pop-up\">站内文章</span>最大子数组问题</a>。</li>\n</ul>\n<h1 id=\"前缀条件和\"><a class=\"markdownIt-Anchor\" href=\"#前缀条件和\"></a> 前缀「条件」和</h1>\n<p>我这里起名前缀「条件」和，是因为这里 <code>nums</code> 元素必须满足一定条件，才统计入前缀和。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/count-number-of-nice-subarrays/description/\">1248. 统计「优美子数组」 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个整数数组 <code>nums</code> 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>\n<p>请返回这个数组中 「优美子数组」 的数目。</p>\n</div></div><p>本题和上题十分相像。与前缀和解法不同的是，我们定义的前缀数组累积的是符合特定条件（在本题里为奇数数字）的元素数目。</p>\n<p>我们定义 <code>pre[i]</code> 为 <code>[0..i]</code> 中奇数的个数，则 <code>pre[i]</code> 可以由 <code>pre[i−1]</code> 递推而来，即：<code>pre[i]=pre[i−1]+(nums[i]&amp;1)</code>。</p>\n<p>那么「<code>[j..i]</code> 这个子数组里的奇数个数恰好为 k 」这个条件我们可以转化为 <code>pre[i]−pre[j−1]==k</code>。</p>\n<p>因此我们可以在遍历的同时计算前缀和 <code>pre[i]</code> 时，找一下哈希表中有没有存有 <code>pre[j−1]</code> 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numberOfSubarrays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, pre = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tHashMap &lt; Integer, Integer &gt; mp = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span> &lt; &gt; ();</span><br><span class=\"line\">\tmp.put(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">// 考虑到答案是整个前缀本身的情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\tpre += nums[i]&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mp.containsKey(pre - k)) &#123;</span><br><span class=\"line\">\t\t\tres += mp.get(pre - k);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmp.put(pre, mp.getOrDefault(pre, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析:</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的大小。我们只需要遍历一遍数组即可求得答案。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 为数组的大小。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的空间复杂度。</li>\n</ul>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/?envType=problem-list-v2&amp;envId=two-pointers\">795. 区间子数组个数 - 力扣（LeetCode）</a> 稍微复杂的前缀特征</li>\n</ul>\n<h1 id=\"前缀特征\"><a class=\"markdownIt-Anchor\" href=\"#前缀特征\"></a> 前缀特征</h1>\n<p>所谓前缀特征指的就是 <code>pre[i]</code> 代表 <code>nums[0]</code> 到 <code>nums[i]</code> 中的一个特征值是多少。比如：</p>\n<ul>\n<li><code>pre[i]</code> 代表 <code>nums[0]</code> 到 <code>nums[i]</code> 中的最大值/最小值。</li>\n<li><code>pre[i]</code> 代表 <code>nums[0]</code> 到 <code>nums[i]</code> 中最后一次满足 xxx 条件的值。</li>\n</ul>\n<p>从这里开始，<strong>动态规划</strong>的味道就开始上来了。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/?envType=problem-list-v2&amp;envId=two-pointers\">795. 区间子数组个数 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>给你一个整数数组 <code>nums</code> 和两个整数：<code>left</code> 及 <code>right</code> 。找出 <code>nums</code> 中连续、非空且其中最大元素在范围 <code>[left, right]</code> 内的子数组，并返回满足条件的子数组的个数。</p>\n<p>生成的测试用例保证结果符合 <strong>32-bit</strong> 整数范围。</p>\n</div></div><p>一个子数组的最大值范围在 <code>[left,right]</code> 表示子数组中不能含有大于 right 的元素，且至少含有一个处于 <code>[left,right]</code> 区间的元素。</p>\n<p>我们可以将数组中的元素分为三类，并分别用 0, 1, 2 来表示：</p>\n<ul>\n<li>小于 <code>left</code>，用 0 表示；</li>\n<li>大于等于 <code>left</code> 且小于等于 <code>right</code>，用 1 表示；</li>\n<li>大于 <code>right</code>，用 2 表示。</li>\n</ul>\n<p>那么本题可以转换为求解不包含 2，且至少包含一个 1 的子数组数目。我们遍历 i，并将右端点固定在 i，求解有多少合法的子区间。过程中需要维护两个变量：</p>\n<ul>\n<li><code>last1</code>，表示上一次 1 出现的位置，如果不存在则为 −1；</li>\n<li><code>last2</code>，表示上一次 2 出现的位置，如果不存在则为 −1。</li>\n</ul>\n<p>如果 <code>last1 != −1</code>，那么子数组若以 i 为右端点，合法的左端点可以落在 <code>(last2,last1]</code> 之间。这样的左端点共有 <code>last1−last2</code> 个。</p>\n<p>因此，我们遍历 <code>i</code>：</p>\n<ul>\n<li>如果 <code>left≤nums[i]≤right</code>，令 <code>last1=i</code>；</li>\n<li>否则如果 <code>nums[i]&gt;right</code>，令 <code>last2=i, last1=−1</code>。</li>\n</ul>\n<p>然后将 <code>last1−last2</code> 累加到答案中即可。最后的总和即为题目所求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numSubarrayBoundedMax</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, last2 = -<span class=\"number\">1</span>, last1 = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt;= left &amp;&amp; nums[i] &lt;= right) &#123;</span><br><span class=\"line\">                last1 = i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i] &gt; right) &#123;</span><br><span class=\"line\">                last2 = i;</span><br><span class=\"line\">                last1 = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last1 != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res += last1 - last2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"前后缀特征\"><a class=\"markdownIt-Anchor\" href=\"#前后缀特征\"></a> 前后缀特征</h1>\n<p>有一些题目需要综合运用前后缀特征进行求解。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟩 <a href=\"https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/description/\">2908. 元素和最小的山形三元组 I - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>给你一个下标从 0 开始的整数数组 nums 。</p>\n<p>如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：</p>\n<ul>\n<li><code>i &lt; j &lt; k</code></li>\n<li><code>nums[i] &lt; nums[j]</code> 且 <code>nums[k] &lt; nums[j]</code></li>\n</ul>\n<p>请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。</p>\n</div></div><p>除了暴力方法外，还有什么别的方法使时间复杂度将为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>？</p>\n<p>思路：枚举中间的数 <code>nums[j]</code>，找到 <code>nums[j]</code> 左边最小的值和右边最小的值，然后检查这三个数是否符合要求，再更新答案。</p>\n<p>定义 <code>preMin[i]</code> 表示从 <code>nums[0]</code> 到 <code>nums[i]</code> 的最小值，定义 <code>sufMin[i]</code> 表示 <code>nums[i]</code> 到 <code>nums[n-1]</code> 的最小值。我们可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间内完成计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minimumSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 计算 preMin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>[] preMin = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n]; <span class=\"comment\">// 前缀</span></span><br><span class=\"line\">\tpreMin[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\tpreMin[i] = Math.min(preMin[i - <span class=\"number\">1</span>], nums[i]); <span class=\"comment\">// 这其实是一种动态规划思想</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 计算 sufMin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>[] sufMin = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n]; <span class=\"comment\">// 后缀最小值</span></span><br><span class=\"line\">\tsufMin[n - <span class=\"number\">1</span>] = nums[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> n - <span class=\"number\">2</span>; i &gt; <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">\t\tsufMin[i] = Math.min(sufMin[i + <span class=\"number\">1</span>], nums[i]); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 计算最终答案</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(preMin[i-<span class=\"number\">1</span>]&lt;nums[i] &amp;&amp; nums[i]&gt;sufMin[i+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\tres = Math.min(res,preMin[i-<span class=\"number\">1</span>]+nums[i]+sufMin[i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res == Integer.MAX_VALUE? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">思考题：你可以将计算 <code>preMin</code> 与探索答案的过程结合起来，以减少遍历次数和空间吗？</div>\n</div>\n<div class=\"callout-content\"><p>这种将 <code>preMin</code> 和答案遍历过程结合起来的做法相当于 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/41280b89/\"><span class=\"bilink-pop-up\">站内文章</span>买卖股票的最佳时机</a> 中的一次遍历做法。</p>\n</div></div><p>相关题目：</p>\n<ul>\n<li>🟩 <a href=\"https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/description/\">2873. 有序三元组中的最大值 I - 力扣（LeetCode）</a></li>\n<li>🟩 <a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/\">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/sum-of-beauty-in-the-array/description/?envType=daily-question&amp;envId=2025-03-11\">2012. 数组美丽值求和 - 力扣（LeetCode）</a></li>\n</ul>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟥 <a href=\"https://leetcode.cn/problems/trapping-rain-water/description/\">42. 接雨水 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</div></div><p>思路：每一个位置 i 能接到的雨水，相当于左侧最大值与右侧最大值中较小的那个值，减去自身的高度。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202409212140018.webp\" alt=\"image.png\" /></p>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是数组 <code>height</code> 的长度。计算数组 <code>leftMax</code> 和 <code>rightMax</code> 的元素值各需要遍历数组 <code>height</code> 一次，计算能接的雨水总量还需要遍历一次。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是数组 <code>height</code> 的长度。需要创建两个长度为 n 的数组 <code>leftMax</code> 和 <code>rightMax</code>。</li>\n</ul>\n<h1 id=\"前后缀和积\"><a class=\"markdownIt-Anchor\" href=\"#前后缀和积\"></a> 前后缀和/积</h1>\n<p>相关题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/product-of-array-except-self/description/\">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/construct-product-matrix/description/\">2906. 构造乘积矩阵 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2493551/on-zuo-fa-mei-ju-numsjqian-hou-zhui-fen-xweo4/\">2908. 元素和最小的山形三元组 I  题解：O(n) 前后缀分解，附题单 - 力扣（LeetCode）</a></li>\n<li>LeetCode 相关题解</li>\n</ul>\n","raw":"---\ntitle: 前后缀分解的应用\ntags:\n  - LeetCode\n  - 前缀和\n  - 动态规划\n  - 哈希表\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202409220021307.webp'\ncategories:\n  - 算法与数据结构\nabbrlink: 59af443f\ndescription: 动态规划的简单运用，打遍「连续子数组」「接雨水」\nkatex: true\ndate: 2024-09-21 19:12:16\ntop_img:\n---\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 前缀和\n\n对于「连续子数组问题」一般可以通过前缀和方式解决。\n\n> [!example] 题目：🟨 [560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/)\n> 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。\n>\n> 子数组是数组中元素的连续非空序列。\n\n暴力枚举：\n\n- 时间复杂度：$O(n^2)$，其中 n 为数组的长度。枚举子数组开头和结尾需要 $O(n^2)$ 的时间，其中求和需要 $O(1)$ 的时间复杂度，因此总时间复杂度为 $O(n^2)$。\n- 空间复杂度：$O(1)$。只需要常数空间存放若干变量。\n\n下面介绍前缀和 + 哈希表优化方法。\n\n定义 `pre[i]` 为 `[0..i]` 里所有数的和，则 `pre[i]` 可以由 `pre[i−1]` 递推而来，即：`pre[i]=pre[i−1]+nums[i]`。\n\n那么「`[j..i]` 这个子数组和为 `k` 」这个条件我们可以转化为 `pre[i]−pre[j−1]==k`。\n\n因此我们可以在遍历的同时计算前缀和 `pre[i]` 时，找一下哈希表中有没有存有 `pre[j−1]` 即可。\n\n```java\npublic int subarraySum(int[] nums, int k) {\n\tint count = 0, pre = 0;\n\tHashMap < Integer, Integer > mp = new HashMap < > ();\n\tmp.put(0, 1); // 考虑到答案是整个前缀本身的情况\n\tfor (int i = 0; i < nums.length; i++) {\n\t\tpre += nums[i];\n\t\tif (mp.containsKey(pre - k)) {\n\t\t\tcount += mp.get(pre - k);\n\t\t}\n\t\tmp.put(pre, mp.getOrDefault(pre, 0) + 1);\n\t}\n\treturn count;\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 为数组的长度。我们遍历数组的时间复杂度为 $O(n)$，中间利用哈希表查询删除的复杂度均为 $O(1)$，因此总时间复杂度为 $O(n)$。\n- 空间复杂度：$O(n)$，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 $O(n)$ 的空间复杂度。\n\n相关题目：\n\n- 🟨 [974. 和可被 K 整除的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/) 对 [[【数论】整除、模运算和同余|同余定理]] 的考察。\n- 🟨 [523. 连续的子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/continuous-subarray-sum/description/) 对 [[【数论】整除、模运算和同余|同余定理]] 的考察，并且限制了数组长度，不需要统计符合条件的个数。\n- 🟨 [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)。解法详看 [[最大子数组问题]]。\n\n# 前缀「条件」和\n\n我这里起名前缀「条件」和，是因为这里 `nums` 元素必须满足一定条件，才统计入前缀和。\n\n> [!example] 题目：🟨 [1248. 统计「优美子数组」 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-nice-subarrays/description/)\n> 给你一个整数数组 `nums` 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。\n>\n> 请返回这个数组中 「优美子数组」 的数目。\n\n本题和上题十分相像。与前缀和解法不同的是，我们定义的前缀数组累积的是符合特定条件（在本题里为奇数数字）的元素数目。\n\n我们定义 `pre[i]` 为 `[0..i]` 中奇数的个数，则 `pre[i]` 可以由 `pre[i−1]` 递推而来，即：`pre[i]=pre[i−1]+(nums[i]&1)`。\n\n那么「`[j..i]` 这个子数组里的奇数个数恰好为 k 」这个条件我们可以转化为 `pre[i]−pre[j−1]==k`。\n\n因此我们可以在遍历的同时计算前缀和 `pre[i]` 时，找一下哈希表中有没有存有 `pre[j−1]` 即可。\n\n```java\npublic int numberOfSubarrays(int[] nums, int k) {\n\tint res = 0, pre = 0;\n\tHashMap < Integer, Integer > mp = new HashMap < > ();\n\tmp.put(0, 1); // 考虑到答案是整个前缀本身的情况\n\tfor (int i = 0; i < nums.length; i++) {\n\t\tpre += nums[i]&1;\n\t\tif (mp.containsKey(pre - k)) {\n\t\t\tres += mp.get(pre - k);\n\t\t}\n\t\tmp.put(pre, mp.getOrDefault(pre, 0) + 1);\n\t}\n\treturn res;\n}\n```\n\n复杂度分析:\n\n- 时间复杂度：$O(n)$，其中 n 为数组的大小。我们只需要遍历一遍数组即可求得答案。\n- 空间复杂度：$O(n)$，其中 n 为数组的大小。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 $O(n)$ 的空间复杂度。\n\n相关题目：\n\n- 🟨 [795. 区间子数组个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/?envType=problem-list-v2&envId=two-pointers) 稍微复杂的前缀特征\n\n# 前缀特征\n\n所谓前缀特征指的就是 `pre[i]` 代表 `nums[0]` 到 `nums[i]` 中的一个特征值是多少。比如：\n\n- `pre[i]` 代表 `nums[0]` 到 `nums[i]` 中的最大值/最小值。\n- `pre[i]` 代表 `nums[0]` 到 `nums[i]` 中最后一次满足 xxx 条件的值。\n\n从这里开始，**动态规划**的味道就开始上来了。\n\n> [!example] 题目：🟨 [795. 区间子数组个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/?envType=problem-list-v2&envId=two-pointers)\n>\n> 给你一个整数数组 `nums` 和两个整数：`left` 及 `right` 。找出 `nums` 中连续、非空且其中最大元素在范围 `[left, right]` 内的子数组，并返回满足条件的子数组的个数。\n>\n> 生成的测试用例保证结果符合 **32-bit** 整数范围。\n\n一个子数组的最大值范围在 `[left,right]` 表示子数组中不能含有大于 right 的元素，且至少含有一个处于 `[left,right]` 区间的元素。\n\n我们可以将数组中的元素分为三类，并分别用 0, 1, 2 来表示：\n\n- 小于 `left`，用 0 表示；\n- 大于等于 `left` 且小于等于 `right`，用 1 表示；\n- 大于 `right`，用 2 表示。\n\n那么本题可以转换为求解不包含 2，且至少包含一个 1 的子数组数目。我们遍历 i，并将右端点固定在 i，求解有多少合法的子区间。过程中需要维护两个变量：\n\n- `last1`，表示上一次 1 出现的位置，如果不存在则为 −1；\n- `last2`，表示上一次 2 出现的位置，如果不存在则为 −1。\n\n如果 `last1 != −1`，那么子数组若以 i 为右端点，合法的左端点可以落在 `(last2,last1]` 之间。这样的左端点共有 `last1−last2` 个。\n\n因此，我们遍历 `i`：\n\n- 如果 `left≤nums[i]≤right`，令 `last1=i`；\n- 否则如果 `nums[i]>right`，令 `last2=i, last1=−1`。\n\n然后将 `last1−last2` 累加到答案中即可。最后的总和即为题目所求。\n\n```java\nclass Solution {\n    public int numSubarrayBoundedMax(int[] nums, int left, int right) {\n        int res = 0, last2 = -1, last1 = -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] >= left && nums[i] <= right) {\n                last1 = i;\n            } else if (nums[i] > right) {\n                last2 = i;\n                last1 = -1;\n            }\n            if (last1 != -1) {\n                res += last1 - last2;\n            }\n        }\n        return res;\n    }\n}\n```\n\n# 前后缀特征\n\n有一些题目需要综合运用前后缀特征进行求解。\n\n> [!example] 题目：🟩 [2908. 元素和最小的山形三元组 I - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/description/)\n>\n> 给你一个下标从 0 开始的整数数组 nums 。\n>\n> 如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：\n> - `i < j < k`\n> - `nums[i] < nums[j]` 且 `nums[k] < nums[j]`\n>\n> 请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。\n\n除了暴力方法外，还有什么别的方法使时间复杂度将为 $O(n)$？\n\n思路：枚举中间的数 `nums[j]`，找到 `nums[j]` 左边最小的值和右边最小的值，然后检查这三个数是否符合要求，再更新答案。\n\n定义 `preMin[i]` 表示从 `nums[0]` 到 `nums[i]` 的最小值，定义 `sufMin[i]` 表示 `nums[i]` 到 `nums[n-1]` 的最小值。我们可以在 $O(n)$ 的时间内完成计算。\n\n```java\npublic int minimumSum(int[] nums) {\n\tint n = nums.length;\n\n\t// 计算 preMin\n\tint[] preMin = new int[n]; // 前缀\n\tpreMin[0] = nums[0];\n\tfor (int i = 1; i < n-1; i++) {\n\t\tpreMin[i] = Math.min(preMin[i - 1], nums[i]); // 这其实是一种动态规划思想\n\t}\n\n\t// 计算 sufMin\n\tint[] sufMin = new int[n]; // 后缀最小值\n\tsufMin[n - 1] = nums[n - 1];\n\tfor (int i = n - 2; i > 1; i--) {\n\t\tsufMin[i] = Math.min(sufMin[i + 1], nums[i]); \n\t}\n\n\t// 计算最终答案\n\tint res = Integer.MAX_VALUE;\n\tfor(int i=1;i<n-1;i++){\n\t\tif(preMin[i-1]<nums[i] && nums[i]>sufMin[i+1]){\n\t\t\tres = Math.min(res,preMin[i-1]+nums[i]+sufMin[i+1]);\n\t\t}\n\t}\n\treturn res == Integer.MAX_VALUE? -1 : res;\n}\n```\n\n> [!example] 思考题：你可以将计算 `preMin` 与探索答案的过程结合起来，以减少遍历次数和空间吗？\n> 这种将 `preMin` 和答案遍历过程结合起来的做法相当于 [[买卖股票的最佳时机]] 中的一次遍历做法。\n\n相关题目：\n\n- 🟩 [2873. 有序三元组中的最大值 I - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/description/)\n- 🟩 [121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)\n- 🟨 [2012. 数组美丽值求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-beauty-in-the-array/description/?envType=daily-question&envId=2025-03-11)\n\n\n> [!example] 题目：🟥 [42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/description/)\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n思路：每一个位置 i 能接到的雨水，相当于左侧最大值与右侧最大值中较小的那个值，减去自身的高度。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202409212140018.webp)\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 是数组 `height` 的长度。计算数组 `leftMax` 和 `rightMax` 的元素值各需要遍历数组 `height` 一次，计算能接的雨水总量还需要遍历一次。\n- 空间复杂度：$O(n)$，其中 n 是数组 `height` 的长度。需要创建两个长度为 n 的数组 `leftMax` 和 `rightMax`。\n\n# 前后缀和/积\n\n相关题目：\n\n- 🟨 [238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/)\n- 🟨 [2906. 构造乘积矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-product-matrix/description/)\n\n# 本文参考\n\n- [2908. 元素和最小的山形三元组 I  题解：O(n) 前后缀分解，附题单 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2493551/on-zuo-fa-mei-ju-numsjqian-hou-zhui-fen-xweo4/)\n- LeetCode 相关题解\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"哈希表","api":"api/tags/哈希表.json"},{"name":"动态规划","api":"api/tags/动态规划.json"},{"name":"前缀和","api":"api/tags/前缀和.json"}]},"api":"api/posts/p/59af443f.json"}