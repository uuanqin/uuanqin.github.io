{"data":{"title":"面向对象编程 OOP","slug":"高质量代码及设计模式/面向对象编程 OOP","description":"这门课不知道看了多少遍了","date":"2021-11-17T13:26:10.000Z","updated":"2025-08-28T13:49:20.249Z","language":"zh-CN","comments":true,"url":"p/28239a8d/","cover":"https://cdn.gallery.uuanqin.top/img/202506102236358.webp","images":[],"content":"<p>英文缩略语概览：</p>\n<ul>\n<li>面向对象编程：OOP Object Oriented Programming</li>\n<li>面向对象编程语言：OOPL Object Oriented Programming Language</li>\n<li>面向对象分析：OOA Object Oriented Analysis</li>\n<li>面向对象设计：OOD Object Oriented Design</li>\n</ul>\n<p>OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。</p>\n<h1 id=\"四大特性\"><a class=\"markdownIt-Anchor\" href=\"#四大特性\"></a> 四大特性</h1>\n<p>面向对象的四大特性：继承、多态、封装、抽象。但有些人认为抽象不算特性之一。</p>\n<h2 id=\"封装\"><a class=\"markdownIt-Anchor\" href=\"#封装\"></a> 封装</h2>\n<p>信息隐藏或者数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（函数）来访问内部信息或数据，保证数据的一致性。</p>\n<p>获取类的信息时，我们尽量只能通过对象变量来访问这个对象的变量或方法，不通过引用变量就无法访问其中的变量或方法。对于访问者而言，这个对象是封装成一个整体的，这正体现了面向对象的程序设计的「封装性」。</p>\n<p>对于封装的特性，编程语言需要一定的语法机制支持。Java 中的修饰符 <code>public</code>，<code>private</code>，<code>protected</code> 可实现封装。</p>\n<p>封装的意义在于保护数据不被修改，提高代码的可维护性。仅暴露有限的必要接口，提供更少的承诺，提高类的易用性。这样的封装并不是在自己防自己，只要多一个人开发就要设防，防止傻瓜操作影响到自己的类。</p>\n<h2 id=\"抽象\"><a class=\"markdownIt-Anchor\" href=\"#抽象\"></a> 抽象</h2>\n<p>隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。</p>\n<p>抽象可以通过接口类或者抽象类来实现，但其实也并不需要特殊的语法机制来支持，比如一般编程语言中的函数机制也可理解为抽象。Java 中使用 <code>interface</code> 和 <code>abstract</code> 关键字实现。</p>\n<p>意义在于提高代码的可扩展性，可维护性，修改实现不需要改变定义，减少代码的改动范围；它也是处理复杂系统的有效手段，能够有效地过滤不必要关注的信息。</p>\n<blockquote>\n<p>面向对象中，有时并不愿意把抽象当做特性，是因为抽象是一个非常通用的设计思想，并不需要编程语言提供特殊的语法机制支持，没有很强的“特异性”。</p>\n</blockquote>\n<h2 id=\"继承\"><a class=\"markdownIt-Anchor\" href=\"#继承\"></a> 继承</h2>\n<p>继承表示类之间的 is-a 关系，分两种模式：单继承和多继承。</p>\n<ul>\n<li>单继承：一个子类只继承一个父类。</li>\n<li>多继承：一个子类可以继承多个父类。</li>\n</ul>\n<p>编程语言中的单继承与多重继承：</p>\n<ul>\n<li>只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等</li>\n<li>既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。</li>\n</ul>\n<blockquote>\n<p>C++ 有同名覆盖原则。子类方法与父类方法同名（不需要参数类型都相同），父类方法会被屏蔽。</p>\n</blockquote>\n<p>继承的作用在于代码的复用，但是过度使用继承，如继承层次过深过复杂，会导致代码可读性变差。在继承使用过程中开发子类的人员需要阅读父类的代码，这属于耦合了。</p>\n<h2 id=\"多态\"><a class=\"markdownIt-Anchor\" href=\"#多态\"></a> 多态</h2>\n<p>多态即子类可以替换父类，它的基础是继承。</p>\n<p>在实际代码运行过程中，将父类的指针（或引用）指向子类的实例。父类的引用指向不同的子类实例时，根据子类实例中方法的更新版本去调用。父类尽可能要少说，定义父类时可以不实现方法。Java 中所有的非 <code>final</code>/<code>static</code>/<code>private</code> 方法都可以实现多态。</p>\n<p>多态的特性需要编程语言提供特殊的语法机制来实现，主要实现方式：</p>\n<ul>\n<li>继承 + 方法重写。Java 中为 <code>extends</code> 和 <code>@Override</code></li>\n<li>利用接口类语法。比如 Java 中的 <code>interface</code> 和 <code>implements</code> 关键字</li>\n<li>duck-typing 鸭子类型：它是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由「当前方法和属性的集合」决定。「当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。」使用该方式的编程语言有 Python、JavaScript。</li>\n</ul>\n<p>Java 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal animal=<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">Dog dog=(Dog)animal;</span><br><span class=\"line\"><span class=\"comment\">//向下转型，把Animal类型转换为Dog类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">Creature creature=animal;<span class=\"comment\">//自动类型转换</span></span><br><span class=\"line\"><span class=\"comment\">//向上转型，把Animal类型转换成Creature类型</span></span><br></pre></td></tr></table></figure>\n<p>下面给出鸭子类型实现多态的示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">record</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DB</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">record</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">recorder</span>):</span><br><span class=\"line\">\trecorder.record()</span><br><span class=\"line\"></span><br><span class=\"line\">logger = Logger()</span><br><span class=\"line\">db = DB()</span><br><span class=\"line\">test(logger)</span><br><span class=\"line\">test(db)</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，Logger 和 DB 没有任何关系。只要都实现了 record 方法，都可以传到 test 中。</p>\n<p>多态特性能提高代码的可扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p>\n<h1 id=\"面向对象的编程-oop\"><a class=\"markdownIt-Anchor\" href=\"#面向对象的编程-oop\"></a> 面向对象的编程 OOP</h1>\n<p>面向过程编程的特点是数据和操纵数据的方法是分离的。</p>\n<p>面向对象的编程 OOP 和面向对象编程语言 OOPL 的区别：</p>\n<ul>\n<li>面向对象的编程是一种编程范式或编程风格，以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。</li>\n<li>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的四大特性的编程语言。</li>\n<li>面向对象的编程是一种思想，和具体语言没关系。用 OOPL 不一定就使用 OOP 思想，例子详看下文；使用非 OOPL 也可以运用 OOP 思想，只不过代码成本比较高。</li>\n</ul>\n<p>下面列出违反面向对象编程风格的典型代码设计的案例，有一些是错误需要避免，有一些是有意的：</p>\n<ol>\n<li>滥用 <code>getter</code>、<code>setter</code> 方法\n<ul>\n<li><code>setter</code> 暴露了直接修改数据的方法，可能破坏数据的一致性。我们必须在使用 setter 时可以保证数据的一致。非必要的情况下尽量不要给属性定义 setter 方法。</li>\n<li>如果数据公开，<code>getter</code> 也要限制！因为可能返回给用户的引用（一个地址），用户可以通过地址修改。\n<ul>\n<li>如果变量是一个对象，<code>getter</code> 应该返回这个对象的副本。</li>\n<li><code>getter</code> 可返回 <code>Collections.unmodifiableList()</code> 方法防止数据被篡改。但这样集合容器中存储的引用地址还是可以被非法使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>滥用全局变量和全局方法，静态变量和静态方法。\n<ul>\n<li>不允许修改，只可以只读，常见于 <code>Constants</code> 类和 <code>Utils</code> 类</li>\n<li>将 <code>Constants</code> 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 <code>MysqlConstants</code> 类中；跟 Redis 配置相关的常量，我们放到 <code>RedisConstants</code> 类中。</li>\n<li>不单独地设计 <code>Constants</code> 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，<code>RedisConfig</code> 类用到了 <code>Redis</code> 配置相关的常量，那我们就直接将这些常量定义在 <code>RedisConfig</code> 中。如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。</li>\n<li>设计 <code>Utils</code> 类的时候，最好也能细化一下，针对不同的功能，设计不同的 <code>Utils</code> 类，比如 <code>FileUtils</code>、<code>IOUtils</code>、<code>StringUtils</code>、<code>UrlUtils</code> 等，不要设计一个过于大而全的 <code>Utils</code> 类。</li>\n</ul>\n</li>\n<li>定义数据和方法分离的类\n<ul>\n<li>传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。</li>\n<li>在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。</li>\n<li>一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 <code>Controller</code> 类、<code>Service</code> 类、<code>Repository</code> 类中。</li>\n<li>这就是典型的面向过程的编程风格：贫血模型</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"interface-接口-vs-抽象类\"><a class=\"markdownIt-Anchor\" href=\"#interface-接口-vs-抽象类\"></a> <code>interface</code> 接口 vs 抽象类</h1>\n<p>抽象类：</p>\n<ul>\n<li>抽象类不允许被实例化，只能被继承</li>\n<li>它可以包含属性和方法。方法既可以包含代码的实现，也可以不包含代码实现。不包含代码实现的方法叫做抽象方法。</li>\n<li>子类（具体类）继承抽象类，必须实现抽象类中的所有抽象方法。</li>\n</ul>\n<p>接口（指的是狭义接口，即 Java interface）：</p>\n<ul>\n<li>不包含属性</li>\n<li>接口和抽象类都可以叫接口</li>\n<li>接口只能声明方法，方法不能包含代码实现</li>\n<li>类实现接口的时候，必须实现接口中声明的所有方法</li>\n</ul>\n<p>抽象类和接口存在的意义：</p>\n<ul>\n<li>抽象类是对成员变量和方法的抽象是一种 is-a 关系。是为了解决代码复用问题。</li>\n<li>接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</li>\n</ul>\n<p>抽象类和接口选用规则：</p>\n<ul>\n<li>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，就用抽象类；</li>\n<li>如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那就用接口。</li>\n</ul>\n<p>C++ 中只有抽象类，没有接口，我们可以进行用抽象类模拟：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Strategy</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t~<span class=\"built_in\">Strategy</span>();</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">algorithm</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">Strategy</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基于接口而非实现编程\"><a class=\"markdownIt-Anchor\" href=\"#基于接口而非实现编程\"></a> 基于接口而非实现编程</h1>\n<p>“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。</p>\n<p>这条原则可以将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要改动，以此来降低耦合性，提高扩展性。</p>\n<p>另一个表述方式：基于抽象而非实现编程。设计得越抽象就越能够适应变化。具体实践中，函数的命名使用抽象的命名方式不暴露细节（当然内部代码也应当没有特异化的实现，或直接不实现）是体现这一思想的案例。</p>\n<p>如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。</p>\n<h1 id=\"多用组合少用继承\"><a class=\"markdownIt-Anchor\" href=\"#多用组合少用继承\"></a> 多用组合少用继承</h1>\n<p>组合优于继承，多用组合少用继承。继承表示类之间的 is-a，支持多态特性，代码复用。但继承层次过深、过复杂，也会影响到代码的可维护性。</p>\n<p>继承的一些作用可以被其他技术代替：</p>\n<ul>\n<li>is-a 关系：用组合和接口的 has-a 关系替代</li>\n<li>支持多态：利用接口实现</li>\n<li>代码复用。用组合和委托来实现</li>\n</ul>\n<p>下面通过例子展示继承缺点以及替代继承的方法。这是一个关于鸟的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBird</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractBird</span>&#123; <span class=\"comment\">// 鸵鸟</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnSupportedMethodException</span>(<span class=\"string\">&quot;我不会飞&quot;</span>);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于并不是所有的鸟都会飞，所以并不是所有的鸟都应该实现 <code>fly()</code> 方法，所以我们把抽象的鸟再继续分类，分成会飞的和不会飞的，然后对应的子类继承正确的父类：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506102225769.webp\" alt=\"image.png\" width=\"450px\" /></p>\n<p>如果考虑到鸟会不会叫，会不会下蛋等因素，问题变得越来越复杂了…</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202506102225350.webp\" alt=\"image.png\" /></p>\n<p>对此，我们可以使用接口来优化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable&#123; <span class=\"comment\">// 鸵鸟</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>&#123;<span class=\"comment\">/* ... */</span>&#125;;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>&#123;<span class=\"comment\">/* ... */</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sparrow</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Flyable</span>, Tweetable, EggLayable&#123; <span class=\"comment\">// 鸵鸟</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>&#123;<span class=\"comment\">/* ... */</span>&#125;;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>&#123;<span class=\"comment\">/* ... */</span>&#125;;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>&#123;<span class=\"comment\">/* ... */</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但即使通过接口优化，我们还需要再每个类实现对应的方法。对此，我们可以通过组合 + 委托复用代码。</p>\n\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">关于委托</div>\n</div>\n<div class=\"callout-content\"><p>「委托」这个词可能过于正式，说得通俗点就是「交给其他人」。比如，当我们无法出席重要会议时，可以写一份委任书，说明一下「我无法出席会议，安排李华代替我出席」。委托跟委任的意思是一样的。在 Java 语言中，委托就是指将某个方法中的实际处理交给其他实例的方法。</p>\n</div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Flyable</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyAbility</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span>&#123;<span class=\"comment\">/* ... */</span>&#125;;  <span class=\"comment\">// 编写具体方法实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Tweetable</span>, EggLayable&#123; <span class=\"comment\">// 鸵鸟</span></span><br><span class=\"line\">\t<span class=\"comment\">// 组合</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">TweetAbility</span> <span class=\"variable\">tweetAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TweetAbility</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">EggLaytAbility</span> <span class=\"variable\">eggLayAbility</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EggLayAbility</span>();</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tweet</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\ttweetAbility.tweet(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">layEgg</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\teggLayAbility.layEgg(); <span class=\"comment\">// 委托</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如何判断该用组合还是继承？</p>\n<ul>\n<li>层次潜浅的使用继承；复杂的用组合代替。</li>\n<li>除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</li>\n</ul>\n<h1 id=\"继承和委托中的一致性\"><a class=\"markdownIt-Anchor\" href=\"#继承和委托中的一致性\"></a> 继承和委托中的一致性</h1>\n<p>一致性：可以将不同的东西当作同一种东西看待。</p>\n<h2 id=\"继承父类和子类的一致性\"><a class=\"markdownIt-Anchor\" href=\"#继承父类和子类的一致性\"></a> 继承——父类和子类的一致性</h2>\n<p>子类和父类具有一致性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">parentMethod</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">childMethod</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，<code>Child</code> 类的实例可以被保存在 <code>Parent</code> 类型的变量中，也可以调用从 <code>Parent</code> 类中继承的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Parent</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">obj.parentMethod() ;</span><br></pre></td></tr></table></figure>\n<p>也就是说，可以像操作 <code>Parent</code> 类的实例一样操作 <code>Child</code> 类的实例。这是将子类当作父类看待的一个例子。</p>\n<p>但是，反过来，如果想将父类当作子类一样操作，则需要先进行类型转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Parent</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">((Child)obj).childMethod();</span><br></pre></td></tr></table></figure>\n<h2 id=\"委托自己和被委托对象的一致性\"><a class=\"markdownIt-Anchor\" href=\"#委托自己和被委托对象的一致性\"></a> 委托——自己和被委托对象的一致性</h2>\n<p>使用委托让接口具有透明性时，自己和被委托对象具有一致性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rose</span>&#123;</span><br><span class=\"line\">\tViolet obj= <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tobj.method();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Violet</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Rose</code> 和 <code>Violet</code> 都有相同的 <code>method</code> 方法。<code>Rose</code> 将 <code>method</code> 方法的处理委托给了 <code>Violet</code>。这样，会让人有一种好像这两个类有所关联，又好像没有关联的感觉。</p>\n<p>要说有什么奇怪的地方，那就是这两个类虽然都有 <code>method</code> 方法，但是却没有明确地在代码中体现出这个「共通性」。如果要明确地表示 <code>method</code> 方法是共通的，只需要像下面这样编写一个共通的抽象类 <code>Flower</code> 就可以了（或者把 <code>Flower</code> 变为接口）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Flower</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rose</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Flower</span>&#123;</span><br><span class=\"line\">\tViolet obj= <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tobj.method();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Violet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Flower</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们可能会产生这样的疑问，即 <code>Rose</code> 类中的 <code>obj</code> 字段被指定为具体类型 <code>Violet</code> 真的好吗?如果指定为抽象类型 <code>Flower</code> 会不会更好呢?……究竟应该怎么做才好呢？其实没有固定答案，需求不同，做法也不同。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》</li>\n<li>本科生课程《设计模式＆程序设计中级实践》课程笔记。教师：TJU - 🍐⚱️。</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n</ul>\n","raw":"---\ntitle: 面向对象编程 OOP\ntags:\n  - Java\n  - Python\n  - 多态\n  - 设计模式\n  - OOP\n  - 面向对象编程\n  - 面向过程编程\ndescription: 这门课不知道看了多少遍了\nkatex: false\nabbrlink: 28239a8d\ncover: 'https://cdn.gallery.uuanqin.top/img/202506102236358.webp'\ncategories:\n  - 高质量代码及设计模式\ndate: 2021-11-17 21:26:10\ntop_img:\n---\n\n英文缩略语概览：\n\n- 面向对象编程：OOP Object Oriented Programming\n- 面向对象编程语言：OOPL Object Oriented Programming Language\n- 面向对象分析：OOA Object Oriented Analysis\n- 面向对象设计：OOD Object Oriented Design\n\nOOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。\n\n# 四大特性\n\n面向对象的四大特性：继承、多态、封装、抽象。但有些人认为抽象不算特性之一。\n\n## 封装\n\n信息隐藏或者数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（函数）来访问内部信息或数据，保证数据的一致性。\n\n获取类的信息时，我们尽量只能通过对象变量来访问这个对象的变量或方法，不通过引用变量就无法访问其中的变量或方法。对于访问者而言，这个对象是封装成一个整体的，这正体现了面向对象的程序设计的「封装性」。\n\n对于封装的特性，编程语言需要一定的语法机制支持。Java 中的修饰符 `public`，`private`，`protected` 可实现封装。\n\n封装的意义在于保护数据不被修改，提高代码的可维护性。仅暴露有限的必要接口，提供更少的承诺，提高类的易用性。这样的封装并不是在自己防自己，只要多一个人开发就要设防，防止傻瓜操作影响到自己的类。\n\n## 抽象\n\n隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。\n\n抽象可以通过接口类或者抽象类来实现，但其实也并不需要特殊的语法机制来支持，比如一般编程语言中的函数机制也可理解为抽象。Java 中使用 `interface` 和 `abstract` 关键字实现。\n\n意义在于提高代码的可扩展性，可维护性，修改实现不需要改变定义，减少代码的改动范围；它也是处理复杂系统的有效手段，能够有效地过滤不必要关注的信息。\n\n> 面向对象中，有时并不愿意把抽象当做特性，是因为抽象是一个非常通用的设计思想，并不需要编程语言提供特殊的语法机制支持，没有很强的“特异性”。\n\n## 继承\n\n继承表示类之间的 is-a 关系，分两种模式：单继承和多继承。\n\n- 单继承：一个子类只继承一个父类。\n- 多继承：一个子类可以继承多个父类。\n\n编程语言中的单继承与多重继承：\n\n- 只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等\n- 既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。\n\n> C++ 有同名覆盖原则。子类方法与父类方法同名（不需要参数类型都相同），父类方法会被屏蔽。\n\n继承的作用在于代码的复用，但是过度使用继承，如继承层次过深过复杂，会导致代码可读性变差。在继承使用过程中开发子类的人员需要阅读父类的代码，这属于耦合了。\n\n## 多态\n\n多态即子类可以替换父类，它的基础是继承。\n\n在实际代码运行过程中，将父类的指针（或引用）指向子类的实例。父类的引用指向不同的子类实例时，根据子类实例中方法的更新版本去调用。父类尽可能要少说，定义父类时可以不实现方法。Java 中所有的非 `final`/`static`/`private` 方法都可以实现多态。\n\n多态的特性需要编程语言提供特殊的语法机制来实现，主要实现方式：\n\n- 继承 + 方法重写。Java 中为 `extends` 和 `@Override`\n- 利用接口类语法。比如 Java 中的 `interface` 和 `implements` 关键字\n- duck-typing 鸭子类型：它是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由「当前方法和属性的集合」决定。「当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。」使用该方式的编程语言有 Python、JavaScript。\n\nJava 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。\n\n```java\nAnimal animal=new Dog();\nDog dog=(Dog)animal;\n//向下转型，把Animal类型转换为Dog类型\n\nCreature creature=animal;//自动类型转换\n//向上转型，把Animal类型转换成Creature类型\n```\n\n下面给出鸭子类型实现多态的示例：\n\n```python\nclass Logger:\n\tdef record(self):\n\t\tprint(\"1\")\n\nclass DB:\n\tdef record(self):\n\t\tprint(\"2\")\n\ndef test(recorder):\n\trecorder.record()\n\nlogger = Logger()\ndb = DB()\ntest(logger)\ntest(db)\n```\n\n上面的代码中，Logger 和 DB 没有任何关系。只要都实现了 record 方法，都可以传到 test 中。\n\n多态特性能提高代码的可扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。\n\n# 面向对象的编程 OOP\n\n\n\n\n面向过程编程的特点是数据和操纵数据的方法是分离的。\n\n面向对象的编程 OOP 和面向对象编程语言 OOPL 的区别：\n\n- 面向对象的编程是一种编程范式或编程风格，以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。\n- 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的四大特性的编程语言。\n- 面向对象的编程是一种思想，和具体语言没关系。用 OOPL 不一定就使用 OOP 思想，例子详看下文；使用非 OOPL 也可以运用 OOP 思想，只不过代码成本比较高。\n\n下面列出违反面向对象编程风格的典型代码设计的案例，有一些是错误需要避免，有一些是有意的：\n\n1. 滥用 `getter`、`setter` 方法\n\t- `setter` 暴露了直接修改数据的方法，可能破坏数据的一致性。我们必须在使用 setter 时可以保证数据的一致。非必要的情况下尽量不要给属性定义 setter 方法。\n\t- 如果数据公开，`getter` 也要限制！因为可能返回给用户的引用（一个地址），用户可以通过地址修改。\n\t\t- 如果变量是一个对象，`getter` 应该返回这个对象的副本。\n\t\t- `getter` 可返回 `Collections.unmodifiableList()` 方法防止数据被篡改。但这样集合容器中存储的引用地址还是可以被非法使用。\n2. 滥用全局变量和全局方法，静态变量和静态方法。\n\t- 不允许修改，只可以只读，常见于 `Constants` 类和 `Utils` 类\n\t- 将 `Constants` 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 `MysqlConstants` 类中；跟 Redis 配置相关的常量，我们放到 `RedisConstants` 类中。\n\t- 不单独地设计 `Constants` 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，`RedisConfig` 类用到了 `Redis` 配置相关的常量，那我们就直接将这些常量定义在 `RedisConfig` 中。如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。\n\t- 设计 `Utils` 类的时候，最好也能细化一下，针对不同的功能，设计不同的 `Utils` 类，比如 `FileUtils`、`IOUtils`、`StringUtils`、`UrlUtils` 等，不要设计一个过于大而全的 `Utils` 类。\n3. 定义数据和方法分离的类\n\t- 传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。\n\t- 在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。\n\t- 一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 `Controller` 类、`Service` 类、`Repository` 类中。\n\t- 这就是典型的面向过程的编程风格：贫血模型\n\n#  `interface` 接口 vs 抽象类\n\n抽象类：\n\n- 抽象类不允许被实例化，只能被继承\n- 它可以包含属性和方法。方法既可以包含代码的实现，也可以不包含代码实现。不包含代码实现的方法叫做抽象方法。\n- 子类（具体类）继承抽象类，必须实现抽象类中的所有抽象方法。\n\n接口（指的是狭义接口，即 Java interface）：\n\n- 不包含属性\n- 接口和抽象类都可以叫接口\n- 接口只能声明方法，方法不能包含代码实现\n- 类实现接口的时候，必须实现接口中声明的所有方法\n\n抽象类和接口存在的意义：\n\n- 抽象类是对成员变量和方法的抽象是一种 is-a 关系。是为了解决代码复用问题。\n- 接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。\n\n抽象类和接口选用规则：\n\n- 如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，就用抽象类；\n- 如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那就用接口。\n\nC++ 中只有抽象类，没有接口，我们可以进行用抽象类模拟：\n\n```C++\nclass Strategy{\n\tpublic:\n\t\t~Strategy();\n\t\tvirtual void algorithm()=0;\n\tprotected:\n\t\tStrategy();\n}\n```\n\n# 基于接口而非实现编程\n\n“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。\n\n这条原则可以将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要改动，以此来降低耦合性，提高扩展性。\n\n另一个表述方式：基于抽象而非实现编程。设计得越抽象就越能够适应变化。具体实践中，函数的命名使用抽象的命名方式不暴露细节（当然内部代码也应当没有特异化的实现，或直接不实现）是体现这一思想的案例。\n\n如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。\n\n# 多用组合少用继承\n\n组合优于继承，多用组合少用继承。继承表示类之间的 is-a，支持多态特性，代码复用。但继承层次过深、过复杂，也会影响到代码的可维护性。\n\n继承的一些作用可以被其他技术代替：\n\n- is-a 关系：用组合和接口的 has-a 关系替代\n- 支持多态：利用接口实现\n- 代码复用。用组合和委托来实现\n\n下面通过例子展示继承缺点以及替代继承的方法。这是一个关于鸟的类：\n\n```java\npublic class AbstractBird{\n\tpublic void fly(){}\n}\n\npublic class Ostrich extends AbstractBird{ // 鸵鸟\n\tpublic void fly(){\n\t\tthrow new UnSupportedMethodException(\"我不会飞\");\n\t}\t\n}\n```\n\n由于并不是所有的鸟都会飞，所以并不是所有的鸟都应该实现 `fly()` 方法，所以我们把抽象的鸟再继续分类，分成会飞的和不会飞的，然后对应的子类继承正确的父类：\n\n![image.png|450](https://cdn.gallery.uuanqin.top/img/202506102225769.webp)\n\n如果考虑到鸟会不会叫，会不会下蛋等因素，问题变得越来越复杂了…\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202506102225350.webp)\n\n对此，我们可以使用接口来优化：\n\n```java\npublic class Ostrich implements Tweetable, EggLayable{ // 鸵鸟\n\t@Override\n\tpublic void tweet(){/* ... */};\n\t@Override\n\tpublic void layEgg(){/* ... */};\n}\n\npublic class Sparrow implements Flyable, Tweetable, EggLayable{ // 鸵鸟\n\t@Override\n\tpublic void fly(){/* ... */};\n\t@Override\n\tpublic void tweet(){/* ... */};\n\t@Override\n\tpublic void layEgg(){/* ... */};\n}\n```\n\n但即使通过接口优化，我们还需要再每个类实现对应的方法。对此，我们可以通过组合 + 委托复用代码。\n\n> [!notice] 关于委托\n> 「委托」这个词可能过于正式，说得通俗点就是「交给其他人」。比如，当我们无法出席重要会议时，可以写一份委任书，说明一下「我无法出席会议，安排李华代替我出席」。委托跟委任的意思是一样的。在 Java 语言中，委托就是指将某个方法中的实际处理交给其他实例的方法。\n\n\n```java\npublic interface Flyable{\n\tvoid fly();\n}\n\npublic class FlyAbility implements Flyable {\n\t@Override\n\tpublic void fly(){/* ... */};  // 编写具体方法实现\n}\n\npublic class Ostrich implements Tweetable, EggLayable{ // 鸵鸟\n\t// 组合\n\tprivate TweetAbility tweetAbility = new TweetAbility();\n\tprivate EggLaytAbility eggLayAbility = new EggLayAbility();\n\t@Override\n\tpublic void tweet(){\n\t\ttweetAbility.tweet(); // 委托\n\t};\n\t@Override\n\tpublic void layEgg(){\n\t\teggLayAbility.layEgg(); // 委托\n\t};\n}\n```\n\n如何判断该用组合还是继承？\n\n- 层次潜浅的使用继承；复杂的用组合代替。\n- 除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。\n\n# 继承和委托中的一致性\n\n一致性：可以将不同的东西当作同一种东西看待。\n\n## 继承——父类和子类的一致性\n\n子类和父类具有一致性。\n\n```java\nclass Parent {\n\t...\n\tvoid parentMethod(){}\n}\n\nclass Child extends Parent {\n\t...\n\tvoid childMethod(){}\n}\n```\n\n此时，`Child` 类的实例可以被保存在 `Parent` 类型的变量中，也可以调用从 `Parent` 类中继承的方法。\n\n```java\nParent obj = new Child();\nobj.parentMethod() ;\n```\n\n也就是说，可以像操作 `Parent` 类的实例一样操作 `Child` 类的实例。这是将子类当作父类看待的一个例子。\n\n但是，反过来，如果想将父类当作子类一样操作，则需要先进行类型转换。\n\n```java\nParent obj = new Child();\n((Child)obj).childMethod();\n```\n\n## 委托——自己和被委托对象的一致性\n\n使用委托让接口具有透明性时，自己和被委托对象具有一致性。\n\n```java\nclass Rose{\n\tViolet obj= // ...\n\tvoid method(){\n\t\tobj.method();\n\t}\n}\n\nclass Violet{\n\tvoid method(){\n\t\t// ...\n\t}\n}\n```\n\n`Rose` 和 `Violet` 都有相同的 `method` 方法。`Rose` 将 `method` 方法的处理委托给了 `Violet`。这样，会让人有一种好像这两个类有所关联，又好像没有关联的感觉。\n\n要说有什么奇怪的地方，那就是这两个类虽然都有 `method` 方法，但是却没有明确地在代码中体现出这个「共通性」。如果要明确地表示 `method` 方法是共通的，只需要像下面这样编写一个共通的抽象类 `Flower` 就可以了（或者把 `Flower` 变为接口）。\n\n```java\nabstract class Flower{\n\tabstract void method();\n}\n\nclass Rose extends Flower{\n\tViolet obj= // ...\n\tvoid method(){\n\t\tobj.method();\n\t}\n}\n\nclass Violet extends Flower{\n\tvoid method(){\n\t\t...\n\t}\n}\n```\n\n至此，我们可能会产生这样的疑问，即 `Rose` 类中的 `obj` 字段被指定为具体类型 `Violet` 真的好吗?如果指定为抽象类型 `Flower` 会不会更好呢?……究竟应该怎么做才好呢？其实没有固定答案，需求不同，做法也不同。\n\n# 本文参考\n\n- 《图解设计模式》\n- 本科生课程《设计模式＆程序设计中级实践》课程笔记。教师：TJU - 🍐⚱️。\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Python","api":"api/tags/Python.json"},{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"多态","api":"api/tags/多态.json"},{"name":"OOP","api":"api/tags/OOP.json"},{"name":"面向对象编程","api":"api/tags/面向对象编程.json"},{"name":"面向过程编程","api":"api/tags/面向过程编程.json"}]},"api":"api/posts/p/28239a8d.json"}