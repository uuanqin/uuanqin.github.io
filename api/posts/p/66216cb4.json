{"data":{"title":"SpringBoot 中的 IoC & DI 入门","slug":"技术学习/SpringBoot 中的 IoC & DI 入门","description":"入门案例感受 IOC 容器的基本工作方式。","date":"2024-08-01T16:40:03.000Z","updated":"2025-06-11T16:08:12.779Z","language":"zh-CN","comments":true,"url":"p/66216cb4/","cover":"https://cdn.gallery.uuanqin.top/img/202409050030052.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">SpringBoot 的两大核心</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ol>\n<li>IoC：控制反转</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/e036b68e/\"><span class=\"yukari\">站内文章</span>AOP</a>：面向切面编程</li>\n</ol>\n</div></div><h1 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\"></a> 基本概念</h1>\n<p>IoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是 Java 开发领域对象的创建以及管理的问题</p>\n<ul>\n<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>\n<li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li>\n</ul>\n<p>IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。</p>\n<p>三层架构：</p>\n<ol>\n<li>Controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。</li>\n<li>Service：业务逻辑层，处理具体的业务逻辑。</li>\n<li>Dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。</li>\n</ol>\n<p>分层解耦：</p>\n<ul>\n<li>内聚：软件中各个功能模块内部的功能联系。</li>\n<li>耦合：衡量软件中各个层/模块之间的依赖、关联的程度。</li>\n<li>软件设计原则：高内聚低耦合</li>\n</ul>\n<p>重要概念：</p>\n<ul>\n<li>控制反转：Inversion Of Control，简称 IoC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。这个容器我们称为 IoC 容器，或者 Spring 容器。</li>\n<li>依赖注入：Dependency Injection，简称 Dl。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</li>\n<li>Bean 对象：IoC 容器中创建、管理的对象，称之为 bean。</li>\n</ul>\n<h1 id=\"iocdi-的使用\"><a class=\"markdownIt-Anchor\" href=\"#iocdi-的使用\"></a> IoC/DI 的使用</h1>\n<p>基础使用：</p>\n<ul>\n<li><code>@Component</code>：将当前类（Service 层、Dao 层）交给 IoC 容器管理，成为 IoC 容器中的 bean。实现控制反转。</li>\n<li><code>@Autowired</code>：（为 Controller 和 Service 注入）运行时，IoC 容器会提供该类型的 bean 对象，并赋值给该变量。实现依赖注入。</li>\n</ul>\n<blockquote>\n<p>所以说，切换业务实现类时，直接把需要用的实现类上加上 <code>@Component</code> 就行。</p>\n</blockquote>\n<p>SpringBoot 中 Bean 的声明：</p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n<th>位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@Component</code></td>\n<td>声明 bean 的基础注解</td>\n<td>不属于以下三类时，用此注解（比如一些工具类）</td>\n</tr>\n<tr>\n<td><code>@Controller</code></td>\n<td rowspan=\"3\"><code>@Component</code> 的衍生注解</td>\n<td>标注在控制器类上</td>\n</tr>\n<tr>\n<td><code>@Service</code></td>\n<td>标注在业务类上</td>\n</tr>\n<tr>\n<td><code>@Repository</code></td>\n<td>标注在数据访问类上（由于与 mybatis 整合，用的少）</td>\n</tr>\n</tbody>\n</table>\n<p>声明 bean 的时候，可以通过 value 属性指定 bean 的名字，如果没有指定，默认为类名首字母小写。</p>\n<p>使用以上四个注解都可以声明 bean，但是在 Springboot 集成 web 开发中，声明控制器 bean 只能用 <code>@Controller</code>。</p>\n<blockquote>\n<p><code>@RestController</code> 中包含 <code>@Controller</code> 注解。</p>\n</blockquote>\n<p>Bean 组件扫描：</p>\n<ul>\n<li>前面声明 bean 的四大注解，要想生效，还需要被组件扫描注解 <code>@Componentscan</code> 扫描。<code>@ComponentScan</code> 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 <code>@SpringBootApplication</code> 中，默认扫描的范围是启动类所在包及其子包。</li>\n<li>【不推荐】我们可以在启动类上增加 <code>@ComponentScan</code> 注解，手动设置扫描包的范围。注意检查有没有覆盖掉默认的薮猫范围，可以自己手动添加上。</li>\n</ul>\n<p>Bean 注入：</p>\n<ul>\n<li><code>@Autowired</code> 注解，默认是按照类型进行。也就是在 IoC 容器中找这个类型的 Bean 对象然后再注入。</li>\n<li>如果存在多个相同类型的 bean，将会报错，可以使用以下方案解决：\n<ul>\n<li><code>@Primary</code>。在 Bean 上面再加上这个注解，可以让该 Bean 优先生效。</li>\n<li><code>@Autowired</code>+<code>@Qualifier(&quot;&lt;beanName&gt;&quot;)</code>。使该名字的 Bean 生效。</li>\n<li><code>@Resource(name=&quot;&lt;beanName&gt;&quot;)</code>。使该名字的 Bean 生效。</li>\n</ul>\n</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">【高频面试题】<code>@Resource</code> 与 <code>@Autowired</code> 区别：</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li><code>@Autowired</code> 是 Spring 框架提供的注解，而 <code>@Resource</code> 是 JDK 提供的注解，</li>\n<li><code>@Autowired</code> 默认是按照类型注入，而 <code>@Resource</code> 默认是按照名称注入。</li>\n</ul>\n</div></div><h1 id=\"示例工程\"><a class=\"markdownIt-Anchor\" href=\"#示例工程\"></a> 示例工程</h1>\n<p>一个工程目录示例：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240508230449.webp\" alt=\"image.png\" width=\"350px\" /></p>\n<p>示例 Mapper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DeptMapper</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 基于注解方式编写SQL语句</span></span><br><span class=\"line\">\t<span class=\"meta\">@Select(&quot;select * from user&quot;)</span></span><br><span class=\"line\">\tList&lt;dept&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例 Service 接口类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DeptService</span>&#123;</span><br><span class=\"line\">\tList&lt;Dept&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例 Service 的实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeptServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DeptService</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 注入Mapper</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DeptMapper deptMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 实现接口</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> List&lt;Dept&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> deptMapper.list();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例 Controller 的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span> <span class=\"comment\">// 使用日志</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeptController</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// @Slf4j 将省略下面这一行</span></span><br><span class=\"line\">\t<span class=\"comment\">// private static Logger log = LoggerFactory.getLogger(DeptController.class);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Service的注入</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DeptService deptService;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// @GetMapping 作用和下面这条相同</span></span><br><span class=\"line\">\t<span class=\"comment\">// @RequestMapping(vaue = &quot;/depts&quot;,method = RequestMethod.GET)</span></span><br><span class=\"line\">\t<span class=\"meta\">@GetMapping(&quot;/depts&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Result <span class=\"title function_\">list</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tlog.info(<span class=\"string\">&quot;查询部门数据&quot;</span>);</span><br><span class=\"line\">\t\tList&lt;Dept&gt; deptList = deptService.list();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Result.success(deptList); <span class=\"comment\">// 结果类Result是自己定义的</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"bean-管理\"><a class=\"markdownIt-Anchor\" href=\"#bean-管理\"></a> Bean 管理</h1>\n<h2 id=\"获取-bean\"><a class=\"markdownIt-Anchor\" href=\"#获取-bean\"></a> 获取 Bean</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拿到 IoC 容器的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ApplicationContext applicationContext; <span class=\"comment\">// IoC容器对象</span></span><br></pre></td></tr></table></figure>\n<p><strong>默认情况下</strong>，Spring 项目启动时，会把 bean 都创建好放在 IoC 容器中 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，如果想要<strong>主动</strong>获取这些 bean，可以通过如下方式使用 <code>ApplicationContext</code> 的方法：</p>\n<ul>\n<li>根据 name 获取 bean：<code>Object getBean(String name)</code></li>\n<li>根据类型获取 bean：<code>&lt;T&gt; T getBean(Class&lt;T&gt; requiredType)</code></li>\n<li>根据 name 获取 bean（带类型转换）：<code>&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType)</code></li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationTests</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ApplicationContext applicationContext; <span class=\"comment\">// IoC容器对象</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testGetBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//根据bean的名称获取</span></span><br><span class=\"line\">\t<span class=\"type\">DeptController</span> <span class=\"variable\">bean1</span> <span class=\"operator\">=</span> (DeptController) applicationContext.getBean(<span class=\"string\">&quot;deptController&quot;</span>);</span><br><span class=\"line\">\tSystem.out.println(bean1);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//根据bean的类型获取</span></span><br><span class=\"line\">\t<span class=\"type\">DeptController</span> <span class=\"variable\">bean2</span> <span class=\"operator\">=</span> applicationContext.getBean(DeptController.class);</span><br><span class=\"line\">\tSystem.out.println(bean2);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//根据bean的名称及类型获取</span></span><br><span class=\"line\">\t<span class=\"type\">DeptController</span> <span class=\"variable\">bean3</span> <span class=\"operator\">=</span> applicationContext.getBean(<span class=\"string\">&quot;deptController&quot;</span>,DeptController.class);</span><br><span class=\"line\">\tSystem.out.println(bean3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果发现三个 bean 对象都是同一个对象，说明此时 bean 是单例的。</p>\n<h2 id=\"bean-的作用域\"><a class=\"markdownIt-Anchor\" href=\"#bean-的作用域\"></a> Bean 的作用域</h2>\n<p>Spring 支持五种作用域，后三种在 web 环境才生效：</p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>singleton</code></td>\n<td>容器内同名称的 bean 只有一个实例（单例）（默认）</td>\n</tr>\n<tr>\n<td><code>prototype</code></td>\n<td>每次使用该 bean 时会创建新的实例（非单例）</td>\n</tr>\n<tr>\n<td><code>request</code></td>\n<td>每个请求范围内会创建新的实例（web 环境中，了解即可）</td>\n</tr>\n<tr>\n<td><code>session</code></td>\n<td>每个会话范围内会创建新的实例（web 环境中，了解即可）</td>\n</tr>\n<tr>\n<td><code>application</code></td>\n<td>每个应用范围内会创建新的实例（web 环境中，了解即可）</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过 <code>@Scope</code> 注解来进行配置作用域：<code>@Scope(&quot;prototype&quot;)</code>。</p>\n<p>默认 <code>singleton</code> 的 bean，在容器启动时被创建，可以使用 <code>@Lazy</code> 注解来延迟初始化（延迟到第一次使用时），<code>prototype</code> 的 bean，每一次使用该 bean 的时候都会创建一个新的实例。</p>\n<p>实际开发当中，绝大部分的 Bean 是单例的，也就是说绝大部分 Bean 不需要配置 scope 属性。</p>\n<h2 id=\"第三方-bean\"><a class=\"markdownIt-Anchor\" href=\"#第三方-bean\"></a> 第三方 Bean</h2>\n<p>如果要管理的 bean 对象来自于第三方（不是自定义的），是无法用 <code>@Component</code> 及衍生注解声明 bean 的（第三方某些类的源码定义中我们无法改动），就需要用到 <code>@Bean</code> 注解。若要管理的第三方 bean 对象，建议对这些 bean 进行集中分类配置，可以通过 <code>@Configuration</code> 注解声明一个配置类。</p>\n<blockquote>\n<p><code>@Configuration</code> 底层也是 <code>@Component</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：【不推荐】定义在启动类中</span></span><br><span class=\"line\"><span class=\"comment\">// 这样导致启动类不纯粹</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringbootWebConfig2Application</span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span> <span class=\"comment\">//将方法返回值交给IoC容器管理，成为IoC容器的bean对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：声明一个配置类</span></span><br><span class=\"line\"><span class=\"comment\">// 通过@Bean注解的name/value属性指定bean名称，如果未指定，默认是方法名</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonConfig</span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 Bean 时直接注入即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MyBean mybean;</span><br></pre></td></tr></table></figure>\n<p>如果第三方 bean 需要依赖其它 bean 对象，直接在 bean 定义方法中设置形参即可，容器会根据类型自动装配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CommonConfig</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// SpringBoot容器会根据参数类型MyService自动装配Bean对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">(MyService myService)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 省略一些使用myService的操作</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Component</code> 及衍生注解与 <code>@Bean</code> 注解使用场景?</p>\n<ul>\n<li>项目中自定义的，使用 <code>@Component</code> 及其衍生注解</li>\n<li>项目中引入第三方的，使用 <code>@Bean</code> 注解</li>\n</ul>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<p>下面你可以立即移步这篇文章加深上面所学知识的印象：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/21b7da2d/\"><span class=\"yukari\">站内文章</span>SpringBoot 的原理以及写一个自定义 Starter</a>。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1m84y1w7Tb?p=75&amp;vd_source=e03d48176855fc5349b27aef691f9cdb\">Day05-09. 分层解耦-三层架构_哔哩哔哩_bilibili</a></li>\n<li><a href=\"https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#ioc-inversion-of-control\">IoC &amp; AOP详解（快速搞懂） | JavaGuide</a></li>\n</ul>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>这还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的 bean 而言。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","raw":"---\ntitle: SpringBoot 中的 IoC & DI 入门\ntags:\n  - SpringBoot\n  - Java\n  - Bean\n  - IoC\n  - DI\ncover: 'https://cdn.gallery.uuanqin.top/img/202409050030052.webp'\ndescription: 入门案例感受 IOC 容器的基本工作方式。\ncategories:\n  - 技术学习\nabbrlink: 66216cb4\ndate: 2024-08-02 00:40:03\ntop_img:\n---\n\n> [!notice] SpringBoot 的两大核心\n>\n> 1. IoC：控制反转\n> 2. [[SpringBoot 中的面向切面编程（AOP）|AOP]]：面向切面编程\n\n# 基本概念\n\nIoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是 Java 开发领域对象的创建以及管理的问题\n\n- **控制** ：指的是对象创建（实例化、管理）的权力\n- **反转** ：控制权交给外部环境（IoC 容器）\n\nIoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。\n\n三层架构：\n\n1. Controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。\n2. Service：业务逻辑层，处理具体的业务逻辑。\n3. Dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。\n\n分层解耦：\n\n- 内聚：软件中各个功能模块内部的功能联系。\n- 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。\n- 软件设计原则：高内聚低耦合\n\n重要概念：\n\n- 控制反转：Inversion Of Control，简称 IoC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。这个容器我们称为 IoC 容器，或者 Spring 容器。\n- 依赖注入：Dependency Injection，简称 Dl。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\n- Bean 对象：IoC 容器中创建、管理的对象，称之为 bean。\n\n# IoC/DI 的使用\n\n基础使用：\n\n- `@Component`：将当前类（Service 层、Dao 层）交给 IoC 容器管理，成为 IoC 容器中的 bean。实现控制反转。\n- `@Autowired`：（为 Controller 和 Service 注入）运行时，IoC 容器会提供该类型的 bean 对象，并赋值给该变量。实现依赖注入。\n\n> 所以说，切换业务实现类时，直接把需要用的实现类上加上 `@Component` 就行。\n\nSpringBoot 中 Bean 的声明：\n\n| 注解            | 说明                 | 位置                            |\n| ------------- | ------------------ | ----------------------------- |\n| `@Component`  | 声明 bean 的基础注解      | 不属于以下三类时，用此注解（比如一些工具类）        |\n| `@Controller` | `@Component` 的衍生注解 | 标注在控制器类上                      |\n| `@Service`    | `@Component` 的衍生注解 | 标注在业务类上                       |\n| `@Repository` | `@Component` 的衍生注解 | 标注在数据访问类上（由于与 mybatis 整合，用的少） |\n\n声明 bean 的时候，可以通过 value 属性指定 bean 的名字，如果没有指定，默认为类名首字母小写。\n\n使用以上四个注解都可以声明 bean，但是在 Springboot 集成 web 开发中，声明控制器 bean 只能用 `@Controller`。\n\n> `@RestController` 中包含 `@Controller` 注解。\n\nBean 组件扫描：\n\n- 前面声明 bean 的四大注解，要想生效，还需要被组件扫描注解 `@Componentscan` 扫描。`@ComponentScan` 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 `@SpringBootApplication` 中，默认扫描的范围是启动类所在包及其子包。\n- 【不推荐】我们可以在启动类上增加 `@ComponentScan` 注解，手动设置扫描包的范围。注意检查有没有覆盖掉默认的薮猫范围，可以自己手动添加上。\n\nBean 注入：\n\n- `@Autowired` 注解，默认是按照类型进行。也就是在 IoC 容器中找这个类型的 Bean 对象然后再注入。\n- 如果存在多个相同类型的 bean，将会报错，可以使用以下方案解决：\n\t- `@Primary`。在 Bean 上面再加上这个注解，可以让该 Bean 优先生效。\n\t- `@Autowired`+`@Qualifier(\"<beanName>\")`。使该名字的 Bean 生效。\n\t- `@Resource(name=\"<beanName>\")`。使该名字的 Bean 生效。\n\n> [!example] 【高频面试题】`@Resource` 与 `@Autowired` 区别：\n> - `@Autowired` 是 Spring 框架提供的注解，而 `@Resource` 是 JDK 提供的注解，\n> - `@Autowired` 默认是按照类型注入，而 `@Resource` 默认是按照名称注入。\n\n# 示例工程\n\n一个工程目录示例：\n\n![image.png|350](https://cdn.gallery.uuanqin.top/img/20240508230449.webp)\n\n示例 Mapper：\n\n```java\n@Mapper\npublic interface DeptMapper{\n\t// 基于注解方式编写SQL语句\n\t@Select(\"select * from user\")\n\tList<dept> list();\n}\n```\n\n示例 Service 接口类：\n\n```java\npublic interface DeptService{\n\tList<Dept> list();\n}\n```\n\n示例 Service 的实现类：\n\n```java\n@Service\npublic class DeptServiceImpl implements DeptService{\n\t// 注入Mapper\n\t@Autowired\n\tprivate DeptMapper deptMapper;\n\n\t// 实现接口\n\t@Override\n\tpublic List<Dept> list(){\n\t\treturn deptMapper.list();\n\t}\n}\n```\n\n示例 Controller 的写法：\n\n```java\n@Slf4j // 使用日志\n@RestController\npublic class DeptController{\n\t// @Slf4j 将省略下面这一行\n\t// private static Logger log = LoggerFactory.getLogger(DeptController.class);\n\n\t// Service的注入\n\t@Autowired\n\tprivate DeptService deptService;\n\n\t// @GetMapping 作用和下面这条相同\n\t// @RequestMapping(vaue = \"/depts\",method = RequestMethod.GET)\n\t@GetMapping(\"/depts\")\n\tpublic Result list(){\n\t\tlog.info(\"查询部门数据\");\n\t\tList<Dept> deptList = deptService.list();\n\t\treturn Result.success(deptList); // 结果类Result是自己定义的\n\t}\n}\n```\n\n# Bean 管理\n\n## 获取 Bean\n\n```java\n// 拿到 IoC 容器的方法\n@Autowired\nprivate ApplicationContext applicationContext; // IoC容器对象\n```\n\n**默认情况下**，Spring 项目启动时，会把 bean 都创建好放在 IoC 容器中 [^ioc]，如果想要**主动**获取这些 bean，可以通过如下方式使用 `ApplicationContext` 的方法：\n- 根据 name 获取 bean：`Object getBean(String name)`\n- 根据类型获取 bean：`<T> T getBean(Class<T> requiredType)`\n- 根据 name 获取 bean（带类型转换）：`<T> T getBean(String name, Class<T> requiredType)`\n\n[^ioc]: 这还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的 bean 而言。\n\n示例：\n\n```java\n@SpringBootTest\nclass ApplicationTests{\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext; // IoC容器对象\n\t\n\t@Test\n\tpublic void testGetBean(){\n\t\n\t//根据bean的名称获取\n\tDeptController bean1 = (DeptController) applicationContext.getBean(\"deptController\");\n\tSystem.out.println(bean1);\n\t\n\t//根据bean的类型获取\n\tDeptController bean2 = applicationContext.getBean(DeptController.class);\n\tSystem.out.println(bean2);\n\t\n\t//根据bean的名称及类型获取\n\tDeptController bean3 = applicationContext.getBean(\"deptController\",DeptController.class);\n\tSystem.out.println(bean3);\n}\n```\n\n输出结果发现三个 bean 对象都是同一个对象，说明此时 bean 是单例的。\n\n## Bean 的作用域\n\nSpring 支持五种作用域，后三种在 web 环境才生效：\n\n| 作用域           | 说明                           |\n| ------------- | ---------------------------- |\n| `singleton`   | 容器内同名称的 bean 只有一个实例（单例）（默认）  |\n| `prototype`   | 每次使用该 bean 时会创建新的实例（非单例）     |\n| `request`     | 每个请求范围内会创建新的实例（web 环境中，了解即可） |\n| `session`     | 每个会话范围内会创建新的实例（web 环境中，了解即可） |\n| `application` | 每个应用范围内会创建新的实例（web 环境中，了解即可） |\n\n可以通过 `@Scope` 注解来进行配置作用域：`@Scope(\"prototype\")`。\n\n默认 `singleton` 的 bean，在容器启动时被创建，可以使用 `@Lazy` 注解来延迟初始化（延迟到第一次使用时），`prototype` 的 bean，每一次使用该 bean 的时候都会创建一个新的实例。\n\n实际开发当中，绝大部分的 Bean 是单例的，也就是说绝大部分 Bean 不需要配置 scope 属性。\n\n## 第三方 Bean\n\n如果要管理的 bean 对象来自于第三方（不是自定义的），是无法用 `@Component` 及衍生注解声明 bean 的（第三方某些类的源码定义中我们无法改动），就需要用到 `@Bean` 注解。若要管理的第三方 bean 对象，建议对这些 bean 进行集中分类配置，可以通过 `@Configuration` 注解声明一个配置类。\n\n> `@Configuration` 底层也是 `@Component`。\n\n```java\n// 方法一：【不推荐】定义在启动类中\n// 这样导致启动类不纯粹\n@SpringBootApplication\npublic class SpringbootWebConfig2Application{\n\t@Bean //将方法返回值交给IoC容器管理，成为IoC容器的bean对象\n\tpublic MyBean myBean(){\n\t\treturn new MyBean();\n\t}\n}\n\n// 方法二：声明一个配置类\n// 通过@Bean注解的name/value属性指定bean名称，如果未指定，默认是方法名\n@Configuration\npublic class CommonConfig{\n\t@Bean\n\tpublic MyBean myBean(){\n\t\treturn new MyBean();\n\t}\n}\n```\n\n使用 Bean 时直接注入即可：\n\n```java\n@Autowired\nprivate MyBean mybean;\n```\n\n如果第三方 bean 需要依赖其它 bean 对象，直接在 bean 定义方法中设置形参即可，容器会根据类型自动装配。\n\n```java\n@Configuration\npublic class CommonConfig{\n\n\t// SpringBoot容器会根据参数类型MyService自动装配Bean对象\n\t@Bean\n\tpublic MyBean myBean(MyService myService){\n\t\t// 省略一些使用myService的操作\n\t\treturn new MyBean();\n\t}\n}\n```\n\n`@Component` 及衍生注解与 `@Bean` 注解使用场景?\n\n- 项目中自定义的，使用 `@Component` 及其衍生注解\n- 项目中引入第三方的，使用 `@Bean` 注解\n\n# 后记\n\n下面你可以立即移步这篇文章加深上面所学知识的印象：[[SpringBoot 的原理以及写一个自定义 Starter]]。\n\n# 本文参考\n- [Day05-09. 分层解耦-三层架构_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1m84y1w7Tb?p=75&vd_source=e03d48176855fc5349b27aef691f9cdb)\n- [IoC & AOP详解（快速搞懂） | JavaGuide](https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#ioc-inversion-of-control)\n","categories":[{"name":"技术学习","api":"api/categories/技术学习.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"SpringBoot","api":"api/tags/SpringBoot.json"},{"name":"Bean","api":"api/tags/Bean.json"},{"name":"IoC","api":"api/tags/IoC.json"},{"name":"DI","api":"api/tags/DI.json"}]},"api":"api/posts/p/66216cb4.json"}