{"data":{"title":"Java 中的反射","slug":"计算机语言/Java 中的反射","description":"用 Java 开一个侏罗纪公园","date":"2024-07-25T06:34:23.000Z","updated":"2025-08-07T15:45:10.710Z","language":"zh-CN","comments":true,"url":"p/c8dc9bbd/","cover":"https://cdn.gallery.uuanqin.top/img/20240725183636.webp","images":[],"content":"<h1 id=\"反射-reflection\"><a class=\"markdownIt-Anchor\" href=\"#反射-reflection\"></a> 反射 Reflection</h1>\n<p>Java 的反射是指程序在运行期可以拿到一个对象的所有信息。正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例。反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>\n<p>除了 <code>int</code> 等基本类型外，Java 的其他类型全部都是 <code>class</code>（包括 <code>interface</code>）。例如：<code>String</code>、<code>Object</code>、<code>Runnable</code>、<code>Exception</code> 等等。</p>\n<p>我们可以得出结论：<code>class</code>（包括 <code>interface</code>）的本质是数据类型 <code>Type</code>。无继承关系的数据类型无法赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无继承关系的数据类型无法赋值</span></span><br><span class=\"line\"><span class=\"type\">Number</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(<span class=\"number\">123.456</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(<span class=\"number\">123.456</span>); <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n<p>JVM 持有的每个 <code>Class</code> 实例都指向一个数据类型（<code>class</code> 或 <code>interface</code>）：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240725161638.webp\" alt=\"image.png\" width=\"271px\" /></p>\n<p>一个 <code>Class</code> 实例包含了该 <code>class</code> 的所有完整信息：<img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240725161706.webp\" alt=\"image.png\" width=\"267px\" /></p>\n<p>由于 JVM 为每个加载的 <code>class</code> 创建了对应的 <code>Class</code> 实例，并在实例中保存了该 <code>class</code> 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等。因此，如果获取了某个 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应的 <code>class</code> 的所有信息。</p>\n<p>这种通过 <code>Class</code> 实例获取 <code>class</code> 信息的方法称为反射（Reflection）。</p>\n<h1 id=\"动态加载\"><a class=\"markdownIt-Anchor\" href=\"#动态加载\"></a> 动态加载</h1>\n<p>JVM 在执行 Java 程序的时候，并不是一次性把所有用到的 <code>class</code> 全部加载到内存，而是第一次需要用到 <code>class</code> 时才加载。动态加载 <code>class</code> 的特性对于 Java 程序非常重要。利用 JVM 动态加载 <code>class</code> 的特性，我们才能在运行期根据条件加载不同的实现类。</p>\n<h1 id=\"访问字段\"><a class=\"markdownIt-Anchor\" href=\"#访问字段\"></a> 访问字段</h1>\n\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">本文案例使用的实体类 <code>Student</code> 详见文末。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>Class 类提供了以下几个方法来获取字段：</p>\n<ul>\n<li><code>Field getField(name)</code>：根据字段名获取某个 <code>public</code> 的 field（包括父类）</li>\n<li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个 field（不包括父类）</li>\n<li><code>Field[] getFields()</code>：获取所有 <code>public</code> 的 field（包括父类）</li>\n<li><code>Field[] getDeclaredFields()</code>：获取当前类的所有 field（不包括父类）</li>\n</ul>\n<p>一个 Field 对象包含了一个字段的所有信息：</p>\n<ul>\n<li><code>getName()</code>：返回字段名称，例如，“name”；</li>\n<li><code>getType()</code>：返回字段类型，也是一个 <code>Class</code> 实例，例如，<code>String.class</code>；</li>\n<li><code>getModifiers()</code>：返回字段的修饰符，它是一个 <code>int</code>，不同的 bit 表示不同的含义。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;Lingling&quot;</span>,<span class=\"number\">775</span>); </span><br><span class=\"line\">\t\tstudent.sayHello();</span><br><span class=\"line\">\t\tdynamicFieldSet(student,<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;LiHua&quot;</span>);</span><br><span class=\"line\">\t\tstudent.sayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dynamicFieldSet</span><span class=\"params\">(Object obj, String fieldName, Object value)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取得所有public类型的属性</span></span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> obj.getClass().getField(fieldName);</span><br><span class=\"line\">        <span class=\"comment\">//直接设置属性值</span></span><br><span class=\"line\">        field.set(obj, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello my name is Lingling</span><br><span class=\"line\">hello my name is LiHua</span><br></pre></td></tr></table></figure>\n<p>注意，这种方法设置属性值时对应属性不能是 <code>private</code>。获取 <code>private</code> 修饰的变量时，可以先 <code>field.setAccessible(true)</code>，作用是不管这个字段是不是 <code>public</code>，一律允许访问 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n\n<div class=\"callout\" data-callout=\"question\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-help-circle\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"/><path d=\"M12 17h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">如果使用反射可以获取 <code>private</code> 字段的值，那么类的封装还有什么意义？</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>正常情况下，我们总是通过 <code>p.name</code> 来访问 <code>Person</code> 的 <code>name</code> 字段，编译器会根据 public、protected 和 private 决定是否允许访问字段，这样就达到了数据封装的目的。</p>\n<p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>\n</div></div><p>获取字段的值示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t<span class=\"type\">Object</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;李华&quot;</span>,<span class=\"number\">333</span>);</span><br><span class=\"line\">\t<span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> student.getClass().getField(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> field.get(student);</span><br><span class=\"line\">\tSystem.out.println(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"调用方法\"><a class=\"markdownIt-Anchor\" href=\"#调用方法\"></a> 调用方法</h1>\n<p>Class 类提供了以下几个方法来获取 Method：</p>\n<ul>\n<li><code>Method getMethod(name, Class...)</code>：获取某个 <code>public</code> 的 <code>Method</code>（包括父类）</li>\n<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个 Method（不包括父类）</li>\n<li><code>Method[] getMethods()</code>：获取所有 <code>public</code> 的 <code>Method</code>（包括父类）</li>\n<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有 <code>Method</code>（不包括父类）</li>\n</ul>\n<p>一个 <code>Method</code> 对象包含一个方法的所有信息：</p>\n<ul>\n<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>\n<li><code>getReturnType()</code>：返回方法返回值类型，也是一个 <code>Class</code> 实例，例如：<code>String.class</code>；</li>\n<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个 <code>Class</code> 数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>\n<li><code>getModifiers()</code>：返回方法的修饰符，它是一个 <code>int</code>，不同的 bit 表示不同的含义。</li>\n</ul>\n<p>对 <code>Method</code> 实例调用 <code>invoke</code> 就相当于调用该方法，<code>invoke</code> 的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>\n<p>如果获取到的 <code>Method</code> 表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 <code>invoke</code> 方法传入的第一个参数永远为 <code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;Daming&quot;</span>,<span class=\"number\">4456</span>);</span><br><span class=\"line\">\t\tdynamicInvokeMethodWithNoParams(student,<span class=\"string\">&quot;sayHello&quot;</span>);</span><br><span class=\"line\">\t\tdynamicInvokeMethodWithParams(student,<span class=\"string\">&quot;sayLocation&quot;</span>,<span class=\"string\">&quot;London&quot;</span>,<span class=\"number\">557</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">dynamicInvokeMethodWithNoParams</span><span class=\"params\">(Object obj, String methodName)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> obj.getClass().getMethod(methodName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">dynamicInvokeMethodWithParams</span><span class=\"params\">(Object obj, String methodName, Object... values)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        Class[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[values.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 参数包含原始数据类型的需要进行调整</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (values[i] <span class=\"keyword\">instanceof</span> Integer) &#123;</span><br><span class=\"line\">\t\t        <span class=\"comment\">// int 对应的类 int.class 或者 Integer.Type</span></span><br><span class=\"line\">                classes[i] = Integer.TYPE;  <span class=\"comment\">// int.class</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                classes[i] = values[i].getClass();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> obj.getClass().getMethod(methodName,classes);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(obj,values);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello my name is Daming</span><br><span class=\"line\">I am in London 557</span><br></pre></td></tr></table></figure>\n<p>对于非 <code>public</code> 方法，我们虽然可以通过 <code>Class.getDeclaredMethod()</code> 获取该方法实例，但直接对其调用将得到一个 <code>IllegalAccessException</code>。为了调用非 <code>public</code> 方法，我们通过 <code>Method.setAccessible(true)</code> 允许其调用 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1:1\">[1:1]</a></sup>。</p>\n<p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型（如果存在）的覆写方法。</p>\n<h1 id=\"构造一个类调用构造方法\"><a class=\"markdownIt-Anchor\" href=\"#构造一个类调用构造方法\"></a> 构造一个类（调用构造方法）</h1>\n<p>获取一个 <code>class</code> 的 <code>Class</code> 实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：直接通过一个class的静态变量class获取</span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> String.class;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> s.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取</span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>因为 Class 实例在 JVM 中是唯一的，所以，上述方法获取的 Class 实例是同一个实例。可以用 <code>==</code> 比较两个 Class 实例。</p>\n<blockquote>\n<p>用 <code>instanceof</code> 不但匹配指定类型，还匹配指定类型的子类。而用 <code>==</code> 判断 <code>class</code> 实例可以精确地判断数据类型，但不能作子类型比较。</p>\n</blockquote>\n<p>JVM 为每一种基本类型，如 <code>int</code>，也创建了 <code>Class</code> 实例，通过 <code>int.class</code> 访问。</p>\n<p>如果获取到了一个 <code>Class</code> 实例，我们就可以通过该 <code>Class</code> 实例来创建对应类型的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取String的Class实例：</span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> String.class;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个String实例：</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> (String) cls.newInstance();</span><br><span class=\"line\"><span class=\"comment\">// newInstance() 局限是，它只能调用该类的public无参数构造方法。</span></span><br></pre></td></tr></table></figure>\n<p>为了调用任意的构造方法，Java 的反射 API 提供了 <code>Constructor</code> 对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code> 对象和 <code>Method</code> 非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例。</p>\n<p>通过 <code>Class</code> 实例获取 <code>Constructor</code> 的方法如下：</p>\n<ul>\n<li><code>getConstructor(Class...)</code>：获取某个 <code>public</code> 的 <code>Constructor</code></li>\n<li><code>getDeclaredConstructor(Class...)</code>：获取某个 <code>Constructor</code></li>\n<li><code>getConstructors()</code>：获取所有 <code>public</code> 的 <code>Constructor</code></li>\n<li><code>getDeclaredConstructors()</code>：获取所有 <code>Constructor</code></li>\n</ul>\n<p>注意 <code>Constructor</code> 总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>\n<p>调用非 <code>public</code> 的 <code>Constructor</code> 时，必须首先通过 <code>setAccessible(true)</code> 设置允许访问，但可能会失败 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1:2\">[1:2]</a></sup>。</p>\n<p>无参数构造方法演示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;top.uuanqin.Student&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 无参数构造方法</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;**** 无参数构造方法演示 ****&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(className);</span><br><span class=\"line\">\t\t<span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\">\t\t<span class=\"comment\">//  或者：Object obj = clazz.getConstructor(new Class[0]).newInstance();</span></span><br><span class=\"line\">\t\t<span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> (Student) obj;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;obj.class=&quot;</span> + obj.getClass().toString());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;student.class=&quot;</span> + student.getClass().toString()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有参数构造方法演示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;top.uuanqin.Student&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 有参数构造方法1</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;**** 有参数构造方法1演示 ****&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(className);</span><br><span class=\"line\">\t\tClass[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tclasses[<span class=\"number\">0</span>] = String.class;</span><br><span class=\"line\">\t\tclasses[<span class=\"number\">1</span>] = Integer.class;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 寻找Student的带有参数的构造函数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 且构造函数的第一个是参数String,第二个是Integer。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// .newInstance(&quot;tom&quot;, 123)： 用&quot;tom&quot;, 123 实例化</span></span><br><span class=\"line\">\t\t<span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.getConstructor(classes).newInstance(<span class=\"string\">&quot;tom&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> (Student) obj;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;obj.class=&quot;</span> + obj.getClass().toString());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;student.class=&quot;</span> + student.getClass().toString());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Student Name: &quot;</span> + student.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Student Id: &quot;</span> + student.getId());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有参数构造方法2（就是把上面的方法写成更加通用的方法）</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;**** 有参数构造方法2演示 ****&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> createObjectUsingParams(className, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> (Student) obj;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;obj.class=&quot;</span> + obj.getClass().toString());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;student.class=&quot;</span> + student.getClass().toString());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Student Name: &quot;</span> + student.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;Student Id: &quot;</span> + student.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">createObjectUsingParams</span><span class=\"params\">(String className, Object... values)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(className);</span><br><span class=\"line\">        Class[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[values.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; classes.length; i++) &#123;</span><br><span class=\"line\">            classes[i] = values[i].getClass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.getConstructor(classes).newInstance(values);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**** 无参数构造方法演示 ****</span><br><span class=\"line\">obj.class=class top.uuanqin.Student</span><br><span class=\"line\">student.class=class top.uuanqin.Student</span><br><span class=\"line\">**** 有参数构造方法1演示 ****</span><br><span class=\"line\">obj.class=class top.uuanqin.Student</span><br><span class=\"line\">student.class=class top.uuanqin.Student</span><br><span class=\"line\">Student Name: tom</span><br><span class=\"line\">Student Id: 123</span><br><span class=\"line\">**** 有参数构造方法2演示 ****</span><br><span class=\"line\">obj.class=class top.uuanqin.Student</span><br><span class=\"line\">student.class=class top.uuanqin.Student</span><br><span class=\"line\">Student Name: Alice</span><br><span class=\"line\">Student Id: 456</span><br></pre></td></tr></table></figure>\n<h1 id=\"获取继承关系\"><a class=\"markdownIt-Anchor\" href=\"#获取继承关系\"></a> 获取继承关系</h1>\n<p>获取类的继承和实现关系：</p>\n<ul>\n<li>获取父类的 <code>Class</code>：<code>getSuperclass()</code>。返回类型 <code>Class</code>。</li>\n<li>获取 <code>interface</code>：<code>getInterfaces()</code>。由于一个类可能实现一个或多个接口，返回类型 <code>Class[]</code>。注意，只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</li>\n</ul>\n<p>用 <code>instanceof</code> 操作符判断一个实例是否是某个类型。</p>\n<p>如果是两个 <code>Class</code> 实例，要判断一个向上转型是否成立，可以调用 <code>isAssignableFrom()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Integer i = ?</span></span><br><span class=\"line\">Integer.class.isAssignableFrom(Integer.class); <span class=\"comment\">// true，因为Integer可以赋值给Integer</span></span><br><span class=\"line\"><span class=\"comment\">// Number n = ?</span></span><br><span class=\"line\">Number.class.isAssignableFrom(Integer.class); <span class=\"comment\">// true，因为Integer可以赋值给Number</span></span><br><span class=\"line\"><span class=\"comment\">// Object o = ?</span></span><br><span class=\"line\">Object.class.isAssignableFrom(Integer.class); <span class=\"comment\">// true，因为Integer可以赋值给Object</span></span><br><span class=\"line\"><span class=\"comment\">// Integer i = ?</span></span><br><span class=\"line\">Integer.class.isAssignableFrom(Number.class); <span class=\"comment\">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<h2 id=\"本文使用的实体类-student\"><a class=\"markdownIt-Anchor\" href=\"#本文使用的实体类-student\"></a> 本文使用的实体类 <code>Student</code></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(<span class=\"string\">&quot;unset&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String name, Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Student [name=&quot;</span> + name + <span class=\"string\">&quot;, id=&quot;</span> + id + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello my name is &quot;</span> + <span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayLocation</span><span class=\"params\">(String location, <span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am in &quot;</span> + location + <span class=\"string\">&quot; &quot;</span> + num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"知识点java-中的不定长参数\"><a class=\"markdownIt-Anchor\" href=\"#知识点java-中的不定长参数\"></a> 知识点：Java 中的不定长参数</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; List&lt;T&gt; <span class=\"title function_\">asList</span><span class=\"params\">(T... a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//不定长参数 a是一个数组</span></span><br><span class=\"line\">\tjava.util.ArrayList&lt;T&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;T&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">\t\tlist.add(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"我的碎碎念\"><a class=\"markdownIt-Anchor\" href=\"#我的碎碎念\"></a> 我的碎碎念</h2>\n<p>我感觉反射很奇妙，也很强大。有点像借尸还魂的感觉。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>本科生课程面向对象对象程序设计课件第 11 章</li>\n<li><a href=\"https://blog.csdn.net/u010887744/article/details/51192530\">Java反射异常：java.lang.NoSuchFieldException-CSDN博客</a></li>\n<li><a href=\"https://liaoxuefeng.com/books/java/reflection/class/index.html\">Class类 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></li>\n</ul>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><code>setAccessible(true)</code> 可能会失败。如果 JVM 运行期存在 <code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code>。例如，某个 <code>SecurityManager</code> 可能不允许对 java 和 javax 开头的 package 的类调用 <code>setAccessible(true)</code>，这样可以保证 JVM 核心库的安全。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a> <a href=\"#fnref1:1\" class=\"footnote-backref\">↩︎</a> <a href=\"#fnref1:2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","raw":"---\ntitle: Java 中的反射\ntags:\n  - Java\n  - 反射\n  - 动态代理\ncover: 'https://cdn.gallery.uuanqin.top/img/20240725183636.webp'\ndescription: 用 Java 开一个侏罗纪公园\ncategories:\n  - 计算机语言\nabbrlink: c8dc9bbd\ndate: 2024-07-25 14:34:23\ntop_img:\n---\n\n# 反射 Reflection\n\nJava 的反射是指程序在运行期可以拿到一个对象的所有信息。正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例。反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。\n\n除了 `int` 等基本类型外，Java 的其他类型全部都是 `class`（包括 `interface`）。例如：`String`、`Object`、`Runnable`、`Exception` 等等。\n\n我们可以得出结论：`class`（包括 `interface`）的本质是数据类型 `Type`。无继承关系的数据类型无法赋值。\n\n```java\n// 无继承关系的数据类型无法赋值\nNumber n = new Double(123.456); // OK\nString s = new Double(123.456); // compile error!\n```\n\nJVM 持有的每个 `Class` 实例都指向一个数据类型（`class` 或 `interface`）：\n\n![image.png|271](https://cdn.gallery.uuanqin.top/img/20240725161638.webp)\n\n一个 `Class` 实例包含了该 `class` 的所有完整信息：![image.png|267](https://cdn.gallery.uuanqin.top/img/20240725161706.webp)\n\n由于 JVM 为每个加载的 `class` 创建了对应的 `Class` 实例，并在实例中保存了该 `class` 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等。因此，如果获取了某个 `Class` 实例，我们就可以通过这个 `Class` 实例获取到该实例对应的 `class` 的所有信息。\n\n这种通过 `Class` 实例获取 `class` 信息的方法称为反射（Reflection）。\n\n# 动态加载\n\nJVM 在执行 Java 程序的时候，并不是一次性把所有用到的 `class` 全部加载到内存，而是第一次需要用到 `class` 时才加载。动态加载 `class` 的特性对于 Java 程序非常重要。利用 JVM 动态加载 `class` 的特性，我们才能在运行期根据条件加载不同的实现类。\n\n# 访问字段\n\n> [!hint] 本文案例使用的实体类 `Student` 详见文末。\n\nClass 类提供了以下几个方法来获取字段：\n\n- `Field getField(name)`：根据字段名获取某个 `public` 的 field（包括父类）\n- `Field getDeclaredField(name)`：根据字段名获取当前类的某个 field（不包括父类）\n- `Field[] getFields()`：获取所有 `public` 的 field（包括父类）\n- `Field[] getDeclaredFields()`：获取当前类的所有 field（不包括父类）\n\n一个 Field 对象包含了一个字段的所有信息：\n\n- `getName()`：返回字段名称，例如，\"name\"；\n- `getType()`：返回字段类型，也是一个 `Class` 实例，例如，`String.class`；\n- `getModifiers()`：返回字段的修饰符，它是一个 `int`，不同的 bit 表示不同的含义。\n\n```java\npackage top.uuanqin;\n\nimport java.lang.reflect.Field;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Student student = new Student(\"Lingling\",775); \n\t\tstudent.sayHello();\n\t\tdynamicFieldSet(student,\"name\",\"LiHua\");\n\t\tstudent.sayHello();\n    }\n\n    public static void dynamicFieldSet(Object obj, String fieldName, Object value) throws Exception {\n        //取得所有public类型的属性\n        Field field = obj.getClass().getField(fieldName);\n        //直接设置属性值\n        field.set(obj, value);\n    }\n}\n\n```\n\n输出：\n\n```\nhello my name is Lingling\nhello my name is LiHua\n```\n\n注意，这种方法设置属性值时对应属性不能是 `private`。获取 `private` 修饰的变量时，可以先 `field.setAccessible(true)`，作用是不管这个字段是不是 `public`，一律允许访问 [^setacc]。\n\n[^setacc]: `setAccessible(true)` 可能会失败。如果 JVM 运行期存在 `SecurityManager`，那么它会根据规则进行检查，有可能阻止 `setAccessible(true)`。例如，某个 `SecurityManager` 可能不允许对 java 和 javax 开头的 package 的类调用 `setAccessible(true)`，这样可以保证 JVM 核心库的安全。\n\n> [!question] 如果使用反射可以获取 `private` 字段的值，那么类的封装还有什么意义？\n>\n> 正常情况下，我们总是通过 `p.name` 来访问 `Person` 的 `name` 字段，编译器会根据 public、protected 和 private 决定是否允许访问字段，这样就达到了数据封装的目的。\n>\n> 而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。\n\n获取字段的值示例：\n\n```java\n public static void main(String[] args) throws Exception {\n\tObject student = new Student(\"李华\",333);\n\tField field = student.getClass().getField(\"name\");\n\tObject value = field.get(student);\n\tSystem.out.println(value);\n}\n```\n\n# 调用方法\n\nClass 类提供了以下几个方法来获取 Method：\n\n- `Method getMethod(name, Class...)`：获取某个 `public` 的 `Method`（包括父类）\n- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个 Method（不包括父类）\n- `Method[] getMethods()`：获取所有 `public` 的 `Method`（包括父类）\n- `Method[] getDeclaredMethods()`：获取当前类的所有 `Method`（不包括父类）\n\n一个 `Method` 对象包含一个方法的所有信息：\n\n- `getName()`：返回方法名称，例如：`\"getScore\"`；\n- `getReturnType()`：返回方法返回值类型，也是一个 `Class` 实例，例如：`String.class`；\n- `getParameterTypes()`：返回方法的参数类型，是一个 `Class` 数组，例如：`{String.class, int.class}`；\n- `getModifiers()`：返回方法的修饰符，它是一个 `int`，不同的 bit 表示不同的含义。\n\n对 `Method` 实例调用 `invoke` 就相当于调用该方法，`invoke` 的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。\n\n如果获取到的 `Method` 表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 `invoke` 方法传入的第一个参数永远为 `null`。\n\n```java\npackage top.uuanqin;\n\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n\t\tStudent student = new Student(\"Daming\",4456);\n\t\tdynamicInvokeMethodWithNoParams(student,\"sayHello\");\n\t\tdynamicInvokeMethodWithParams(student,\"sayLocation\",\"London\",557);\n    }\n\n    public static Object dynamicInvokeMethodWithNoParams(Object obj, String methodName) throws Exception {\n        Method method = obj.getClass().getMethod(methodName);\n        return method.invoke(obj);\n    }\n\n    public static Object dynamicInvokeMethodWithParams(Object obj, String methodName, Object... values) throws Exception {\n        Class[] classes = new Class[values.length];\n        for (int i = 0; i < values.length; i++) {\n            // 参数包含原始数据类型的需要进行调整\n            if (values[i] instanceof Integer) {\n\t\t        // int 对应的类 int.class 或者 Integer.Type\n                classes[i] = Integer.TYPE;  // int.class\n            } else {\n                classes[i] = values[i].getClass();\n            }\n        }\n        Method method = obj.getClass().getMethod(methodName,classes);\n        return method.invoke(obj,values);\n    }\n}\n\n```\n\n输出：\n\n```\nhello my name is Daming\nI am in London 557\n```\n\n对于非 `public` 方法，我们虽然可以通过 `Class.getDeclaredMethod()` 获取该方法实例，但直接对其调用将得到一个 `IllegalAccessException`。为了调用非 `public` 方法，我们通过 `Method.setAccessible(true)` 允许其调用 [^setacc]。\n\n使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型（如果存在）的覆写方法。\n\n# 构造一个类（调用构造方法）\n\n获取一个 `class` 的 `Class` 实例：\n\n```java\n// 方法一：直接通过一个class的静态变量class获取\nClass cls = String.class;\n\n// 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取\nString s = \"Hello\";\nClass cls = s.getClass();\n\n// 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取\nClass cls = Class.forName(\"java.lang.String\");\n```\n\n因为 Class 实例在 JVM 中是唯一的，所以，上述方法获取的 Class 实例是同一个实例。可以用 `==` 比较两个 Class 实例。\n\n> 用 `instanceof` 不但匹配指定类型，还匹配指定类型的子类。而用 `==` 判断 `class` 实例可以精确地判断数据类型，但不能作子类型比较。\n\nJVM 为每一种基本类型，如 `int`，也创建了 `Class` 实例，通过 `int.class` 访问。\n\n如果获取到了一个 `Class` 实例，我们就可以通过该 `Class` 实例来创建对应类型的实例：\n\n```java\n// 获取String的Class实例：\nClass cls = String.class;\n// 创建一个String实例：\nString s = (String) cls.newInstance();\n// newInstance() 局限是，它只能调用该类的public无参数构造方法。\n```\n\n为了调用任意的构造方法，Java 的反射 API 提供了 `Constructor` 对象，它包含一个构造方法的所有信息，可以创建一个实例。`Constructor` 对象和 `Method` 非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例。\n\n通过 `Class` 实例获取 `Constructor` 的方法如下：\n\n- `getConstructor(Class...)`：获取某个 `public` 的 `Constructor`\n- `getDeclaredConstructor(Class...)`：获取某个 `Constructor`\n- `getConstructors()`：获取所有 `public` 的 `Constructor`\n- `getDeclaredConstructors()`：获取所有 `Constructor`\n\n注意 `Constructor` 总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。\n\n调用非 `public` 的 `Constructor` 时，必须首先通过 `setAccessible(true)` 设置允许访问，但可能会失败 [^setacc]。\n\n无参数构造方法演示：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String className = \"top.uuanqin.Student\";\n\n        // 无参数构造方法\n\t\tSystem.out.println(\"**** 无参数构造方法演示 ****\");\n\t\tClass clazz = Class.forName(className);\n\t\tObject obj = clazz.newInstance();\n\t\t//  或者：Object obj = clazz.getConstructor(new Class[0]).newInstance();\n\t\tStudent student = (Student) obj;\n\t\tSystem.out.println(\"obj.class=\" + obj.getClass().toString());\n\t\tSystem.out.println(\"student.class=\" + student.getClass().toString()); \n    }\n}\n```\n\n有参数构造方法演示：\n\n```java\npackage top.uuanqin;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String className = \"top.uuanqin.Student\";\n        // 有参数构造方法1\n\t\tSystem.out.println(\"**** 有参数构造方法1演示 ****\");\n\t\tClass clazz = Class.forName(className);\n\t\tClass[] classes = new Class[2];\n\t\tclasses[0] = String.class;\n\t\tclasses[1] = Integer.class;\n\t\t// 寻找Student的带有参数的构造函数\n\t\t// 且构造函数的第一个是参数String,第二个是Integer。\n\t\t// .newInstance(\"tom\", 123)： 用\"tom\", 123 实例化\n\t\tObject obj = clazz.getConstructor(classes).newInstance(\"tom\", 123);\n\t\tStudent student = (Student) obj;\n\t\tSystem.out.println(\"obj.class=\" + obj.getClass().toString());\n\t\tSystem.out.println(\"student.class=\" + student.getClass().toString());\n\t\tSystem.out.println(\"Student Name: \" + student.getName());\n\t\tSystem.out.println(\"Student Id: \" + student.getId());\n\n\n        // 有参数构造方法2（就是把上面的方法写成更加通用的方法）\n\t\tSystem.out.println(\"**** 有参数构造方法2演示 ****\");\n\t\tObject obj = createObjectUsingParams(className, \"Alice\", 456);\n\t\tStudent student = (Student) obj;\n\t\tSystem.out.println(\"obj.class=\" + obj.getClass().toString());\n\t\tSystem.out.println(\"student.class=\" + student.getClass().toString());\n\t\tSystem.out.println(\"Student Name: \" + student.getName());\n\t\tSystem.out.println(\"Student Id: \" + student.getId());\n    }\n\n    public static Object createObjectUsingParams(String className, Object... values) throws Exception {\n        Class clazz = Class.forName(className);\n        Class[] classes = new Class[values.length];\n        for (int i = 0; i < classes.length; i++) {\n            classes[i] = values[i].getClass();\n        }\n        Object obj = clazz.getConstructor(classes).newInstance(values);\n        return obj;\n    }\n}\n\n```\n\n输出：\n\n```\n**** 无参数构造方法演示 ****\nobj.class=class top.uuanqin.Student\nstudent.class=class top.uuanqin.Student\n**** 有参数构造方法1演示 ****\nobj.class=class top.uuanqin.Student\nstudent.class=class top.uuanqin.Student\nStudent Name: tom\nStudent Id: 123\n**** 有参数构造方法2演示 ****\nobj.class=class top.uuanqin.Student\nstudent.class=class top.uuanqin.Student\nStudent Name: Alice\nStudent Id: 456\n```\n\n# 获取继承关系\n\n获取类的继承和实现关系：\n\n- 获取父类的 `Class`：`getSuperclass()`。返回类型 `Class`。\n- 获取 `interface`：`getInterfaces()`。由于一个类可能实现一个或多个接口，返回类型 `Class[]`。注意，只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。\n\n用 `instanceof` 操作符判断一个实例是否是某个类型。\n\n如果是两个 `Class` 实例，要判断一个向上转型是否成立，可以调用 `isAssignableFrom()`：\n\n```java\n// Integer i = ?\nInteger.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer\n// Number n = ?\nNumber.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number\n// Object o = ?\nObject.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object\n// Integer i = ?\nInteger.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer\n```\n\n# 后记\n\n## 本文使用的实体类 `Student`\n\n```java\npackage top.uuanqin;\n\npublic class Student {\n    private String name;\n\n    private Integer id;\n\n    public Student() {\n        this(\"unset\", 0);\n    }\n\n    public Student(String name, Integer id) {\n        super();\n        this.name = name;\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student [name=\" + name + \", id=\" + id + \"]\";\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public void sayHello() {\n        System.out.println(\"hello my name is \" + this.name);\n    }\n\n    public void sayLocation(String location, int num) {\n        System.out.println(\"I am in \" + location + \" \" + num);\n    }\n}\n```\n\n## 知识点：Java 中的不定长参数\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t//不定长参数 a是一个数组\n\tjava.util.ArrayList<T> list = new ArrayList<T>();\n\tfor (int i = 0; i < a.length; i++) {\n\t\tlist.add(a[i]);\n\t}\n\treturn list;\n}\n```\n\n## 我的碎碎念\n\n我感觉反射很奇妙，也很强大。有点像借尸还魂的感觉。\n\n# 本文参考\n\n- 本科生课程面向对象对象程序设计课件第 11 章\n- [Java反射异常：java.lang.NoSuchFieldException-CSDN博客](https://blog.csdn.net/u010887744/article/details/51192530)\n- [Class类 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/java/reflection/class/index.html)\n","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"反射","api":"api/tags/反射.json"},{"name":"动态代理","api":"api/tags/动态代理.json"}]},"api":"api/posts/p/c8dc9bbd.json"}