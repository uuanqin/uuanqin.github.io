{"data":{"title":"函数式编程与 Java 中的 Lambda 表达式","slug":"计算机语言/函数式编程与 Java 中的 Lambda 表达式","description":"函数式编程为我们打开了一扇大门","date":"2025-08-12T16:05:41.000Z","updated":"2025-09-06T01:38:20.962Z","language":"zh-CN","comments":true,"url":"p/2c5c0eb2/","cover":"https://cdn.gallery.uuanqin.top/img/202508120100998.webp","images":[],"content":"<h1 id=\"函数式编程-functional-programming\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程-functional-programming\"></a> 函数式编程 Functional Programming</h1>\n<p>函数式编程，早在 50 多年前就已经出现，近几年又逐渐引人关注，出现了很多新的函数式编程语言，比如 Clojure、Scala、Erlang 等。</p>\n<p>一些非函数式编程语言也加入了很多特性、语法、类库来支持函数式编程，比如 Java、Python、Ruby、JavaScript 等。除此之外，Google Guava 也有对函数式编程的增强功能。</p>\n<p>严格上来讲，函数式编程中的「函数」，并不是指我们编程语言中的「函数」概念，而是指数学「函数」或者「表达式」，比如，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">y=f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>。不过，在编程实现的时候，对于数学「函数」或「表达式」，我们一般习惯性地将它们设计成函数。所以，如果不深究的话，函数式编程中的数学概念「函数」也可以理解为编程语言中的「函数」。</p>\n<p>在科学计算、数据处理、统计分析这些领域，程序往往比较容易用数学表达式来表示，比起非函数式编程，实现同样的功能，函数式编程可以用很少的代码就能搞定。</p>\n<p>函数式编程的核心特点是，函数作为一段功能代码，可以像变量一样进行引用和传递，以便在有需要的时候进行调用。</p>\n<h2 id=\"函数式编程和面向过程编程的区别\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程和面向过程编程的区别\"></a> 函数式编程和面向过程编程的区别</h2>\n<p>函数式编程的代码实现跟面向过程编程一样，也是以函数作为组织代码的单元。它跟面向过程编程的区别在于，函数式编程的函数是无状态的。函数内部涉及的变量都是局部变量，不会像 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/28239a8d/\"><span class=\"bilink-pop-up\">站内文章</span>面向对象编程</a> 那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有状态函数: 执行结果依赖b的值是多少，即便入参相同，多次执行函数，函数的返回值有可能不同，因为b值有可能不同。</span></span><br><span class=\"line\"><span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">increase</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无状态函数：执行结果不依赖任何外部变量值，只要入参相同，不管执行多少次，函数的返回值就相同</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">increase</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"java-中的函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#java-中的函数式编程\"></a> Java 中的函数式编程</h1>\n<p>Google Guava 对函数式编程的使用是很谨慎的，认为过度地使用函数式编程，会导致代码可读性变差，强调不要滥用。</p>\n\n<details class=\"callout\" data-callout=\"cite\" data-callout-fold=\"-\">\n<summary class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-quote\"><path d=\"M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z\"/><path d=\"M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><a href=\"https://github.com/google/guava/wiki/FunctionalExplained\">Functional Explained</a> —— Google Guava</div>\n<div class=\"callout-fold\"></div>\n</summary>\n<div class=\"callout-content\"><p>Excessive use of Guava’s functional programming idioms can lead to verbose, confusing, unreadable, and inefficient code. These are by far the most easily (and most commonly) abused parts of Guava, and when you go to preposterous lengths to make your code “a one-liner,” the Guava team weeps.</p>\n</div></details><h2 id=\"函数类型与-functionalinterface\"><a class=\"markdownIt-Anchor\" href=\"#函数类型与-functionalinterface\"></a> 函数类型与 <code>@FunctionalInterface</code></h2>\n<p>C 语言支持函数指针，它可以把函数直接当变量来使用。Java 没有函数指针这样的语法，所以它通过函数接口，将函数包裹在接口中当作变量来使用。</p>\n<p>Java 对函数式编程的支持，本质是通过接口机制来实现的。首先定义一个<strong>仅声明一个方法</strong>的接口，然后对接口冠以 <code>@FunctionalInterface</code> 注解，那么这个接口就可以作为「函数类型」，可以接收一段以 <strong>Lambda 表达式</strong>，或者<strong>方法引用</strong>予以承载的逻辑代码。</p>\n<p>被 <code>@FunctionalInterface</code> 标注的接口仅声明一个方法，一旦这个函数定义好，它能执行的功能是确定的，就是调用和不调用的区别。显然，这个方法可以用来代表「函数类型」所能执行的功能，接口中声明的方法就是和函数体定义一一对应的。</p>\n<p><code>@FunctionalInterface</code> 下只能声明一个未实现的方法，多一个、少一个都不能编译通过。但有以下例外：</p>\n<ul>\n<li>覆写 <code>Object</code> 中 <code>toString/equals</code> 的方法不受此个数限制。</li>\n<li><code>default</code> 方法和 <code>static</code> 方法因为带有实现体，所以也不受此限制。</li>\n</ul>\n<p><code>@FunctionalInterface</code> 注解不是必须的，不加这个注解的接口（前提是只包含一个方法）一样可以作为函数类型。不过，显而易见的是，加了这个注解表意更明确、更直观，是更被推荐的做法。</p>\n<h2 id=\"jdk-提供的函数类型\"><a class=\"markdownIt-Anchor\" href=\"#jdk-提供的函数类型\"></a> JDK 提供的函数类型</h2>\n<p><code>java.util.function</code> 包下预定义了常用的函数类型，包括：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无参无返回型函数可以使用 Runnable 接口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Consumer</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(T t)</span>; <span class=\"comment\">//接收一个类型为T（泛型）的参数，无返回值；所以叫消费者</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(T t, U u)</span>;<span class=\"comment\">//接收2个参数，无返回值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Supplier</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    T <span class=\"title function_\">get</span><span class=\"params\">()</span>;<span class=\"comment\">//无参数，有返回值（所以叫提供者）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意没有BiSupplier，因为返回值只能有1个，不会有2个</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Function</span>&lt;T, R&gt; &#123;</span><br><span class=\"line\">    R <span class=\"title function_\">apply</span><span class=\"params\">(T t)</span>;<span class=\"comment\">//一个输入（参数），一个输出（返回值）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class=\"line\">    R <span class=\"title function_\">apply</span><span class=\"params\">(T t, U u)</span>;<span class=\"comment\">//两个输入T和U，一个输出R</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UnaryOperator</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span>&lt;T, T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class=\"title function_\">identity</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//一元操作，输入原样返回给输出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> t -&gt; t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BinaryOperator</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">BiFunction</span>&lt;T,T,T&gt; &#123;<span class=\"comment\">//二元操作，输入输出类型相同</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class=\"title function_\">minBy</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(comparator);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a, b) -&gt; comparator.compare(a, b) &lt;= <span class=\"number\">0</span> ? a : b;<span class=\"comment\">//传入比较器，返回较小者</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class=\"title function_\">maxBy</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(comparator);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class=\"number\">0</span> ? a : b;<span class=\"comment\">//传入比较器，返回较大者</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些个定义，都是在参数个数（0、1、2 个）和有无返回值上做文章。另外还有一些将泛型类型具体化的衍生接口，比如 <code>Predicate</code>、<code>LongSupplier</code> 等等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Predicate</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">test</span><span class=\"params\">(T t)</span>;<span class=\"comment\">//输入1个参数，返回boolean，就好比是预言家，预言你这个输入是真还是假</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">LongSupplier</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">getAsLong</span><span class=\"params\">()</span>;<span class=\"comment\">//没有输入，输出long类型（long类型的提供者）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"lambda-表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式\"></a> Lambda 表达式</h2>\n<h3 id=\"lambda-表达式写法\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式写法\"></a> Lambda 表达式写法</h3>\n<p>遍历集合除了 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>基本的方式</a> 以外，还可以使用 Lambda 表达式。Lambda 表达式又称函数式表达，是 Java 中典型的语法糖。</p>\n<p>Lambda 表达式语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Type parameter, ... ) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>\n<p><code>parameters</code> 是参数列表， <code>&#123; statements; &#125;</code> 是 Lambda 表达式的主体。</p>\n<p>简化写法：</p>\n<ul>\n<li>参数简化：\n<ul>\n<li><code>parameters</code> 如果只有一个参数，可以省略小括号 <code>()</code>；如果没有参数，也需要空括号 <code>()</code>。</li>\n<li><code>parameters</code> 可以省略参数类型。</li>\n</ul>\n</li>\n<li>语句简化：\n<ul>\n<li>无返回值：<code>statements;</code> 只包含一条语句，无返回值，可省略大括号 <code>&#123;&#125;</code>、分号 <code>;</code></li>\n<li>有返回值：\n<ul>\n<li>一般写法：<code>(int x)-&gt;&#123;return x*x;&#125;</code></li>\n<li>普通的表达式：<code>(int i,int j)-&gt;(i*j+2)</code></li>\n<li>可省略括号：<code>x-&gt;x*x</code></li>\n<li>❌错误写法：<code>x-&gt;return x*x</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lambda-表达式代替匿名内部类\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式代替匿名内部类\"></a> Lambda 表达式代替匿名内部类</h3>\n<p><code>@FunctionalInterface</code> 声明了函数类型，Lambda 表达式就用来定义函数类型的实现体。在介绍 Lambda 简化原理之前，首先回忆以下关于 Java 接口的知识。</p>\n<p>Java 的 <code>interface</code> 接口有以下特点：</p>\n<ul>\n<li>接口不能被实例化，只能通过它的实现类来实现。</li>\n<li>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量引用实现了这个接口类的实例。如：<code>Photographable t=new Camera();</code>，其中 <code>Photographable</code> 为接口类型，<code>Camera</code> 为实现了这个接口的类。</li>\n<li>可以使用匿名内部类创建接口类型的引用变量。匿名内部类中必须实现接口的所有方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Flyable 为接口类型</span></span><br><span class=\"line\"><span class=\"type\">Flyable</span> <span class=\"variable\">fly</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Flyable</span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">laugh</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在没有 Lambda 之前，有些方法要求传入接口类型的参数。我们需要先用匿名内部类创建接口类型的引用变量，再把它传进去。现在 Java 8 中可以通过 Lambda 语法糖快速实现一个<strong>单方法</strong>的匿名内部类。</p>\n<p>更详细地说，Lambda 表达式只能赋值给声明为函数式接口的 Java 类型的变量（注解 <code>@FunctionalInterface</code>）。下文例子中的 <code>Runnable</code>、<code>Consumer</code>、<code>Comparator</code> 都是被 <code>@FunctionalInterface</code> 标注的函数式接口，因此可以接受 Lambda 表达式。</p>\n<h4 id=\"例子-1线程的创建\"><a class=\"markdownIt-Anchor\" href=\"#例子-1线程的创建\"></a> 例子 1：线程的创建</h4>\n<p>详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>Java 并发编程</a></p>\n<h4 id=\"例子-2foreach\"><a class=\"markdownIt-Anchor\" href=\"#例子-2foreach\"></a> 例子 2：foreach</h4>\n<p>Java 集合都实现了 <code>java.util.Iterable</code> 接口。<code>forEach()</code> 方法有一个 <code>Consumer</code> 接口类型的 <code>action</code> 参数，它包含了对集合中每个元素的具体操作行为。<code>action</code> 参数所引用的 <code>Consumer</code> 实例必须实现 <code>Consumer</code> 接口的 <code>accept(T t)</code> 方法，在该方法中指定对参数 <code>t</code> 所执行的具体操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java Iterable 接口源代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (T t : <span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            action.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    List&lt;Person&gt; persons = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Person&gt;()&#123;  </span><br><span class=\"line\">      &#123;  <span class=\"comment\">//匿名类初始化代码  </span></span><br><span class=\"line\">        add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Tom&quot;</span>,<span class=\"number\">21</span>)); </span><br><span class=\"line\">        add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Mike&quot;</span>,<span class=\"number\">32</span>));  </span><br><span class=\"line\">        add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Linda&quot;</span>,<span class=\"number\">19</span>));</span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    persons.forEach( (Person p) -&gt;&#123;  <span class=\"comment\">//Lambda表达式，相当于是Consumer类型的匿名对象</span></span><br><span class=\"line\">\t\t\t <span class=\"comment\">//指定对每个元素的具体操作</span></span><br><span class=\"line\">\t\t\t p.setAge(p.getAge()+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t System.out.println(p.getName()+<span class=\"string\">&quot;:&quot;</span>+p.getAge()); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    );        </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以上 Lambda 表达式相当于创建了一个 <code>Consumer</code> 类型的匿名对象，并实现了 <code>Consumer</code> 接口的 <code>accept(T t)</code> 方法，此处传给 <code>accept(T t)</code> 方法的参数为 <code>Person</code> 对象。在 Lambda 表达式中符号 <code>-&gt;</code> 后的可执行语句块相当于 <code>accept(T t)</code> 方法的方法体。</p>\n<h4 id=\"例子-3排序\"><a class=\"markdownIt-Anchor\" href=\"#例子-3排序\"></a> 例子 3：排序</h4>\n<p>详看文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/72156dd2/\"><span class=\"bilink-pop-up\">站内文章</span>Java 中的排序</a>。</p>\n<h4 id=\"例-4与-stream-api-连用\"><a class=\"markdownIt-Anchor\" href=\"#例-4与-stream-api-连用\"></a> 例 4：与 Stream API 连用</h4>\n<p><code>Collection</code> 接口的 <code>stream()</code> 方法返回一个 <code>Stream</code> 对象，程序可以通过这个 <code>Stream</code> 对象操纵集合中的元素。</p>\n<h3 id=\"lambda-表达式可操纵的变量作用域\"><a class=\"markdownIt-Anchor\" href=\"#lambda-表达式可操纵的变量作用域\"></a> Lambda 表达式可操纵的变量作用域</h3>\n<p><code>this</code> 关键字实际上引用的是外部类的实例。</p>\n<p>在 Lambda 表达式中访问的局部变量必须符合以下两个条件之一：</p>\n<ul>\n<li>条件一：最终局部变量，即用 <code>final</code> 修饰的局部变量。</li>\n<li>条件二：实际上的最终局部变量，即虽然没有被 <code>final</code> 修饰，但在程序中不会改变局部变量的值。</li>\n</ul>\n<h2 id=\"方法引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用\"></a> 方法引用</h2>\n<p>在编译器能根据上下文来推断 Lambda 表达式的参数的场合，可以在 Lambda 表达式中省略参数，直接通过 <code>::</code> 符号来引用方法。</p>\n<p>方法引用就是对一个类中已经存在的方法加以引用，分以下类型：</p>\n<ol>\n<li>引用类的静态方法\n<ul>\n<li>对类构造方法的引用，如 <code>ClassName::new</code>。</li>\n<li>对类静态方法的引用，如 <code>ClassName::staticMethodName</code>。编译器会根据上下文推断到底用哪个对象的实例方法。</li>\n</ul>\n</li>\n<li>引用实例方法\n<ul>\n<li><code>objectName::instanceMethod</code>，或者 <code>new Test()::instanceMethod</code></li>\n<li><code>ClassName::instanceMethod</code>。编译器会根据上下文推断到底用哪个对象的实例方法。</li>\n</ul>\n</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(x) <span class=\"comment\">// 等同于 BigDecimal::new</span></span><br><span class=\"line\">x-&gt;System.out.println(x) <span class=\"comment\">// 引用实例方法 相当于 System.out::println</span></span><br><span class=\"line\">(x,y)-&gt;Math.max(x,y)     <span class=\"comment\">// 引用静态方法 相当于 Math::max</span></span><br><span class=\"line\">x-&gt;x.toLowerCase()       <span class=\"comment\">// 引用实例方法 相当于 String::toLowerCase </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下两种 Lambda 表达式等价：</span></span><br><span class=\"line\">names.forEach((name)-&gt;System.out.println(name));</span><br><span class=\"line\">names.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://www.runoob.com/java/java8-lambda-expressions.html\">Java Lambda 表达式 | 菜鸟教程 (runoob.com)</a></li>\n<li>《Java 面向对象编程》孙卫琴</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://blog.csdn.net/linysuccess/article/details/104751843\">彻底弄懂@FunctionalInterface、Lambda表达式和方法引用_functionalinterface 可以额外定义static方法-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/MeatLoveJK/article/details/95891087\">实例化接口的几种方式_接口实例化-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/wuhenzhidu/p/anonymous.html\">JAVA匿名内部类(Anonymous Classes) - 无恨之都 - 博客园</a></li>\n</ul>\n","raw":"---\ntitle: 函数式编程与 Java 中的 Lambda 表达式\ntags:\n  - Java\n  - Lambda\ncover: 'https://cdn.gallery.uuanqin.top/img/202508120100998.webp'\ndescription: 函数式编程为我们打开了一扇大门\nkatex: false\ncategories:\n  - 计算机语言\nabbrlink: 2c5c0eb2\ndate: 2025-08-13 00:05:41\ntop_img:\n---\n\n# 函数式编程 Functional Programming\n\n函数式编程，早在 50 多年前就已经出现，近几年又逐渐引人关注，出现了很多新的函数式编程语言，比如 Clojure、Scala、Erlang 等。\n\n一些非函数式编程语言也加入了很多特性、语法、类库来支持函数式编程，比如 Java、Python、Ruby、JavaScript 等。除此之外，Google Guava 也有对函数式编程的增强功能。\n\n严格上来讲，函数式编程中的「函数」，并不是指我们编程语言中的「函数」概念，而是指数学「函数」或者「表达式」，比如，$y=f(x)$。不过，在编程实现的时候，对于数学「函数」或「表达式」，我们一般习惯性地将它们设计成函数。所以，如果不深究的话，函数式编程中的数学概念「函数」也可以理解为编程语言中的「函数」。\n\n在科学计算、数据处理、统计分析这些领域，程序往往比较容易用数学表达式来表示，比起非函数式编程，实现同样的功能，函数式编程可以用很少的代码就能搞定。\n\n函数式编程的核心特点是，函数作为一段功能代码，可以像变量一样进行引用和传递，以便在有需要的时候进行调用。\n\n## 函数式编程和面向过程编程的区别\n\n函数式编程的代码实现跟面向过程编程一样，也是以函数作为组织代码的单元。它跟面向过程编程的区别在于，函数式编程的函数是无状态的。函数内部涉及的变量都是局部变量，不会像 [[面向对象编程 OOP|面向对象编程]] 那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。\n\n```java\n// 有状态函数: 执行结果依赖b的值是多少，即便入参相同，多次执行函数，函数的返回值有可能不同，因为b值有可能不同。\nint b;\nint increase(int a) {\n  return a + b;\n}\n\n// 无状态函数：执行结果不依赖任何外部变量值，只要入参相同，不管执行多少次，函数的返回值就相同\nint increase(int a, int b) {\n  return a + b;\n}\n```\n\n# Java 中的函数式编程\n\nGoogle Guava 对函数式编程的使用是很谨慎的，认为过度地使用函数式编程，会导致代码可读性变差，强调不要滥用。\n\n> [!cite]- [Functional Explained](https://github.com/google/guava/wiki/FunctionalExplained) —— Google Guava\n> Excessive use of Guava's functional programming idioms can lead to verbose, confusing, unreadable, and inefficient code. These are by far the most easily (and most commonly) abused parts of Guava, and when you go to preposterous lengths to make your code \"a one-liner,\" the Guava team weeps.\n\n## 函数类型与 `@FunctionalInterface`\n\nC 语言支持函数指针，它可以把函数直接当变量来使用。Java 没有函数指针这样的语法，所以它通过函数接口，将函数包裹在接口中当作变量来使用。\n\nJava 对函数式编程的支持，本质是通过接口机制来实现的。首先定义一个**仅声明一个方法**的接口，然后对接口冠以 `@FunctionalInterface` 注解，那么这个接口就可以作为「函数类型」，可以接收一段以 **Lambda 表达式**，或者**方法引用**予以承载的逻辑代码。\n\n被 `@FunctionalInterface` 标注的接口仅声明一个方法，一旦这个函数定义好，它能执行的功能是确定的，就是调用和不调用的区别。显然，这个方法可以用来代表「函数类型」所能执行的功能，接口中声明的方法就是和函数体定义一一对应的。\n\n`@FunctionalInterface` 下只能声明一个未实现的方法，多一个、少一个都不能编译通过。但有以下例外：\n\n- 覆写 `Object` 中 `toString/equals` 的方法不受此个数限制。\n- `default` 方法和 `static` 方法因为带有实现体，所以也不受此限制。\n\n`@FunctionalInterface` 注解不是必须的，不加这个注解的接口（前提是只包含一个方法）一样可以作为函数类型。不过，显而易见的是，加了这个注解表意更明确、更直观，是更被推荐的做法。\n\n## JDK 提供的函数类型\n\n`java.util.function` 包下预定义了常用的函数类型，包括：\n\n```java\n// 无参无返回型函数可以使用 Runnable 接口\n\n@FunctionalInterface\npublic interface Consumer<T> {\n    void accept(T t); //接收一个类型为T（泛型）的参数，无返回值；所以叫消费者\n}\n\n@FunctionalInterface\npublic interface BiConsumer<T, U> {\n    void accept(T t, U u);//接收2个参数，无返回值\n}\n\n@FunctionalInterface\npublic interface Supplier<T> {\n    T get();//无参数，有返回值（所以叫提供者）\n}\n\n//注意没有BiSupplier，因为返回值只能有1个，不会有2个\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);//一个输入（参数），一个输出（返回值）\n}\n\n@FunctionalInterface\npublic interface BiFunction<T, U, R> {\n    R apply(T t, U u);//两个输入T和U，一个输出R\n}\n\n@FunctionalInterface\npublic interface UnaryOperator<T> extends Function<T, T> {\n    static <T> UnaryOperator<T> identity() {//一元操作，输入原样返回给输出\n        return t -> t;\n    }\n}\n\n@FunctionalInterface\npublic interface BinaryOperator<T> extends BiFunction<T,T,T> {//二元操作，输入输出类型相同\n    public static <T> BinaryOperator<T> minBy(Comparator<? super T> comparator) {\n        Objects.requireNonNull(comparator);\n        return (a, b) -> comparator.compare(a, b) <= 0 ? a : b;//传入比较器，返回较小者\n    }\n    public static <T> BinaryOperator<T> maxBy(Comparator<? super T> comparator) {\n        Objects.requireNonNull(comparator);\n        return (a, b) -> comparator.compare(a, b) >= 0 ? a : b;//传入比较器，返回较大者\n    }\n}\n```\n\n这些个定义，都是在参数个数（0、1、2 个）和有无返回值上做文章。另外还有一些将泛型类型具体化的衍生接口，比如 `Predicate`、`LongSupplier` 等等。\n\n```java\n@FunctionalInterface\npublic interface Predicate<T> {\n    boolean test(T t);//输入1个参数，返回boolean，就好比是预言家，预言你这个输入是真还是假\n}\n\n@FunctionalInterface\npublic interface LongSupplier {\n    long getAsLong();//没有输入，输出long类型（long类型的提供者）\n}\n```\n\n## Lambda 表达式\n\n### Lambda 表达式写法\n\n遍历集合除了 [[迭代器模式：游标|基本的方式]] 以外，还可以使用 Lambda 表达式。Lambda 表达式又称函数式表达，是 Java 中典型的语法糖。\n\nLambda 表达式语法：\n\n```java\n(Type parameter, ... ) ->{ statements; }\n```\n\n`parameters` 是参数列表， `{ statements; }` 是 Lambda 表达式的主体。\n\n简化写法：\n\n- 参数简化：\n\t- `parameters` 如果只有一个参数，可以省略小括号 `()`；如果没有参数，也需要空括号 `()`。\n\t- `parameters` 可以省略参数类型。\n- 语句简化：\n\t- 无返回值：`statements;` 只包含一条语句，无返回值，可省略大括号 `{}`、分号 `;`\n\t- 有返回值：\n\t\t- 一般写法：`(int x)->{return x*x;}`\n\t\t- 普通的表达式：`(int i,int j)->(i*j+2)`\n\t\t- 可省略括号：`x->x*x`\n\t\t- ❌错误写法：`x->return x*x`\n\n### Lambda 表达式代替匿名内部类\n\n`@FunctionalInterface` 声明了函数类型，Lambda 表达式就用来定义函数类型的实现体。在介绍 Lambda 简化原理之前，首先回忆以下关于 Java 接口的知识。\n\nJava 的 `interface` 接口有以下特点：\n\n- 接口不能被实例化，只能通过它的实现类来实现。\n- 不允许创建接口的实例，但允许定义接口类型的引用变量，该变量引用实现了这个接口类的实例。如：`Photographable t=new Camera();`，其中 `Photographable` 为接口类型，`Camera` 为实现了这个接口的类。\n- 可以使用匿名内部类创建接口类型的引用变量。匿名内部类中必须实现接口的所有方法。\n\n```java\n// Flyable 为接口类型\nFlyable fly = new Flyable() {\n\t@Override\n\tpublic void shit() {\n\t\t// TODO Auto-generated method stub\n\t}\n\t\n\t@Override\n\tpublic void laugh() {\n\t\t// TODO Auto-generated method stub\n\t}\n\t\n\t@Override\n\tpublic void fly() {\n\t\t// TODO Auto-generated method stub\n\t}\n};\n```\n\n在没有 Lambda 之前，有些方法要求传入接口类型的参数。我们需要先用匿名内部类创建接口类型的引用变量，再把它传进去。现在 Java 8 中可以通过 Lambda 语法糖快速实现一个**单方法**的匿名内部类。\n\n更详细地说，Lambda 表达式只能赋值给声明为函数式接口的 Java 类型的变量（注解 `@FunctionalInterface`）。下文例子中的 `Runnable`、`Consumer`、`Comparator` 都是被 `@FunctionalInterface` 标注的函数式接口，因此可以接受 Lambda 表达式。\n\n#### 例子 1：线程的创建\n\n详看：[[Java 并发编程]]\n\n#### 例子 2：foreach\n\nJava 集合都实现了 `java.util.Iterable` 接口。`forEach()` 方法有一个 `Consumer` 接口类型的 `action` 参数，它包含了对集合中每个元素的具体操作行为。`action` 参数所引用的 `Consumer` 实例必须实现 `Consumer` 接口的 `accept(T t)` 方法，在该方法中指定对参数 `t` 所执行的具体操作。\n\n```java\n// Java Iterable 接口源代码\npublic interface Iterable<T> {\n    default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n    \n    // ...\n}\n```\n\n示例：\n\n```java\npublic static void main(String[] args) {\n  \n    List<Person> persons = new ArrayList<Person>(){  \n      {  //匿名类初始化代码  \n        add(new Person(\"Tom\",21)); \n        add(new Person(\"Mike\",32));  \n        add(new Person(\"Linda\",19));\n      }  \n    };\n\n    persons.forEach( (Person p) ->{  //Lambda表达式，相当于是Consumer类型的匿名对象\n\t\t\t //指定对每个元素的具体操作\n\t\t\t p.setAge(p.getAge()+1);\n\t\t\t System.out.println(p.getName()+\":\"+p.getAge()); \n\t\t}\n    );        \n  }\n```\n\n以上 Lambda 表达式相当于创建了一个 `Consumer` 类型的匿名对象，并实现了 `Consumer` 接口的 `accept(T t)` 方法，此处传给 `accept(T t)` 方法的参数为 `Person` 对象。在 Lambda 表达式中符号 `->` 后的可执行语句块相当于 `accept(T t)` 方法的方法体。\n\n#### 例子 3：排序\n\n详看文章：[[Java 中的排序]]。\n\n#### 例 4：与 Stream API 连用\n\n`Collection` 接口的 `stream()` 方法返回一个 `Stream` 对象，程序可以通过这个 `Stream` 对象操纵集合中的元素。\n\n### Lambda 表达式可操纵的变量作用域\n\n`this` 关键字实际上引用的是外部类的实例。\n\n在 Lambda 表达式中访问的局部变量必须符合以下两个条件之一：\n\n- 条件一：最终局部变量，即用 `final` 修饰的局部变量。\n- 条件二：实际上的最终局部变量，即虽然没有被 `final` 修饰，但在程序中不会改变局部变量的值。\n\n## 方法引用\n\n在编译器能根据上下文来推断 Lambda 表达式的参数的场合，可以在 Lambda 表达式中省略参数，直接通过 `::` 符号来引用方法。\n\n方法引用就是对一个类中已经存在的方法加以引用，分以下类型：\n\n1. 引用类的静态方法\n\t- 对类构造方法的引用，如 `ClassName::new`。\n\t- 对类静态方法的引用，如 `ClassName::staticMethodName`。编译器会根据上下文推断到底用哪个对象的实例方法。\n2. 引用实例方法\n\t- `objectName::instanceMethod`，或者 `new Test()::instanceMethod`\n\t- `ClassName::instanceMethod`。编译器会根据上下文推断到底用哪个对象的实例方法。\n\n示例：\n\n```java\nx -> new BigDecimal(x) // 等同于 BigDecimal::new\nx->System.out.println(x) // 引用实例方法 相当于 System.out::println\n(x,y)->Math.max(x,y)     // 引用静态方法 相当于 Math::max\nx->x.toLowerCase()       // 引用实例方法 相当于 String::toLowerCase \n\n\n// 以下两种 Lambda 表达式等价：\nnames.forEach((name)->System.out.println(name));\nnames.forEach(System.out::println);\n```\n\n# 本文参考\n\n- [Java Lambda 表达式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java8-lambda-expressions.html)\n- 《Java 面向对象编程》孙卫琴\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [彻底弄懂@FunctionalInterface、Lambda表达式和方法引用_functionalinterface 可以额外定义static方法-CSDN博客](https://blog.csdn.net/linysuccess/article/details/104751843)\n- [实例化接口的几种方式_接口实例化-CSDN博客](https://blog.csdn.net/MeatLoveJK/article/details/95891087)\n- [JAVA匿名内部类(Anonymous Classes) - 无恨之都 - 博客园](https://www.cnblogs.com/wuhenzhidu/p/anonymous.html)","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"Lambda","api":"api/tags/Lambda.json"}]},"api":"api/posts/p/2c5c0eb2.json"}