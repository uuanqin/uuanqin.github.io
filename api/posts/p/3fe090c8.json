{"data":{"title":"最小差值问题的贪心理解","slug":"算法与数据结构/最小差值问题的贪心理解","description":"尝试自证贪心算法的正确性","date":"2024-09-19T10:16:50.000Z","updated":"2025-09-26T16:05:51.038Z","language":"zh-CN","comments":true,"url":"p/3fe090c8/","cover":"https://cdn.gallery.uuanqin.top/img/202409192134284.webp","images":[],"content":"<p>今天带来的两道最小差值问题的解决方案。重点讨论「最小差值 II」中贪心算法的证明，因为 LeetCode 关于这道题的题解写得十分晦涩，生怕别人看懂。</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"最小差值-ik-是可伸缩的\"><a class=\"markdownIt-Anchor\" href=\"#最小差值-ik-是可伸缩的\"></a> 「最小差值 I」：k 是可伸缩的</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟩 <a href=\"https://leetcode.cn/problems/smallest-range-i/description/\">908. 最小差值 I - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个整数数组 <code>nums</code>，和一个整数 <code>k</code> 。</p>\n<p>在一个操作中，您可以选择 <code>0 &lt;= i &lt; nums.length</code> 的任何索引 i 。将 <code>nums[i]</code> 改为 <code>nums[i] + x</code> ，其中 <code>x</code> 是一个范围为 <code>[-k, k]</code> 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。</p>\n<p><code>nums</code> 的 <strong>分数</strong> 是 <code>nums</code> 中最大和最小元素的差值。</p>\n<p>在对 <code>nums</code> 中的每个索引最多应用一次上述操作后，返回 <code>nums</code> 的最低 <strong>分数</strong> 。</p>\n</div></div><p>假设整数数组 nums 的最小值为 minNum，最大值为 maxNum。使用数学方法不难证明以下定理：</p>\n\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">定理：如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mtext>minNum</mtext><mo>≤</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-\\text{minNum}≤2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，那么我们总可以将整数数组 nums 的所有元素都改为同一个整数，因此更改后的整数数组 nums 的最低分数为 0。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>证明：因为 maxNum-\\text{minNum}≤2k，所以存在整数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy=\"false\">[</mo><mtext>minNum</mtext><mo separator=\"true\">,</mo><mtext>maxNum</mtext><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">x\\in [\\text{minNum},\\text{maxNum}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mclose\">]</span></span></span></span>，使得 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>−</mo><mtext>minNum</mtext><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">x-\\text{minNum}\\le k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mi>x</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-x≤k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。那么整数数组 nums 的所有元素与整数 x 的绝对差值都不超过 k，即所有元素都可以改为 x。</p>\n</div></div>\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">定理：如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mtext>minNum</mtext><mo>&gt;</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-\\text{minNum}&gt;2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，那么更改后的整数数组 nums 的最低分数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mtext>minNum</mtext><mo>−</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-\\text{minNum}-2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>证明：对于 <code>minNum</code> 和 <code>maxNum</code> 两个元素，我们将 <code>minNum</code> 改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>minNum</mtext><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{minNum}+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，<code>maxNum</code> 改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，此时两个元素的绝对差值最小。因此更改后的整数数组 <code>nums</code> 的最低分数大于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mtext>minNum</mtext><mo>−</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-\\text{minNum}-2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n<p>对于整数数组 <code>nums</code> 中的元素 x，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mtext>minNum</mtext><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">x&lt;\\text{minNum}+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，那么 x 可以更改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>minNum</mtext><mo>+</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{minNum}+k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mtext>maxNum</mtext><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">x&gt;\\text{maxNum}-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，那么 x 可以更改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，因此整数数组 <code>nums</code> 的所有元素都可以改为区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mtext>minNum</mtext><mo>+</mo><mi>k</mi><mo separator=\"true\">,</mo><mtext>maxNum</mtext><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\text{minNum}+k,\\text{maxNum}-k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span> 的整数，所以更改后的整数数组 <code>nums</code> 的最低分数小于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mtext>minNum</mtext><mo>−</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-\\text{minNum}-2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n<p>综上所述，更改后的整数数组 <code>nums</code> 的最低分数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>maxNum</mtext><mo>−</mo><mtext>minNum</mtext><mo>−</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\text{maxNum}-\\text{minNum}-2k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">maxNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord text\"><span class=\"mord\">minNum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>。</p>\n</div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">smallestRangeI</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到最大最小值minNum，maxNum</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> minNum=Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> e:nums)&#123;</span><br><span class=\"line\">\t\tminNum = Math.min(min,e);</span><br><span class=\"line\">\t\tmaxNum = Math.max(max,e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> maxNum - minNum;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res&lt;=<span class=\"number\">2</span>*k ? <span class=\"number\">0</span> : res - <span class=\"number\">2</span>*k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，其中 n 是整数数组 <code>nums</code> 的长度。需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间遍历数组 nums 得到最小值和最大值，然后需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间计算最低分数。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<h1 id=\"最小差值-iik-是不可伸缩的\"><a class=\"markdownIt-Anchor\" href=\"#最小差值-iik-是不可伸缩的\"></a> 「最小差值 II」：k 是不可伸缩的</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">题目：🟨 <a href=\"https://leetcode.cn/problems/smallest-range-ii/description/\">910. 最小差值 II - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个整数数组 <code>nums</code>，和一个整数 k 。</p>\n<p>对于每个下标 i（<code>0 &lt;= i &lt; nums.length</code>），将 <code>nums[i]</code> 变成 <code>nums[i] + k</code> 或 <code>nums[i] - k</code> 。</p>\n<p><code>nums</code> 的 分数 是 <code>nums</code> 中最大元素和最小元素的差值。</p>\n<p>在更改每个下标对应的值之后，返回 <code>nums</code> 的最小 <strong>分数</strong> 。</p>\n</div></div><p>首先我们考虑将数字 <code>nums</code> 排一下序。</p>\n<p>假设将全部数字都 +k 或都 -k，<strong>分数</strong>是不变的。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202409191933810.webp\" alt=\"image.png\" /></p>\n<p>一个最朴素的思路是，将小的数 +k，将大的数 -k，试图减少 nums 的<strong>分数</strong>。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202409192058262.webp\" alt=\"image.png\" /></p>\n<p>我们的目标就是将排好序的 <code>nums</code> 中间「切一刀」，让左边的数 +k，右边的数都 -k，然后检查数组 <code>nums</code> 的<strong>分数</strong>。根据这个思路，我们可以从左到右遍历不断的「切」从而找到答案。至于为什么这种想法是对的，可以继续看下面的思考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">smallestRangeII</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tArrays.sort(nums);</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>]+k,max = nums[len-<span class=\"number\">1</span>]-k;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> nums[len-<span class=\"number\">1</span>]-nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">high</span> <span class=\"operator\">=</span> Math.max(nums[i]+k,max);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">low</span> <span class=\"operator\">=</span> Math.min(nums[i+<span class=\"number\">1</span>]-k,min);</span><br><span class=\"line\">\t\tres = Math.min(res,high-low);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N \\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，其中 N 是 <code>A</code> 的长度。</li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，额外空间就是自带排序算法的空间。</li>\n</ul>\n<p>在上面的算法中，我们在寻找「切一刀」的位置时，相当于只是考察了左边的数都 +k，右边的数都 -k 的情况。那么，我们需不需要考察这样一种情况：+k 的数和 -k 的数并不分居两侧，而是穿插交替进行，比如下面的这样一个情况。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202409192042114.webp\" alt=\"image.png\" width=\"400px\" /></p>\n<p>答案是不需要的。上图中，设最右边的选择 +k 的数 <code>nums[k]</code> 的左侧存在一个进行了 -k 操作的数——比如 <code>nums[i]</code>。将 <code>nums[i]</code> 转变为 +k 操作总是有利的——因为它不会增大当前照片中 <code>nums</code> 的分数 <code>res</code>：</p>\n<ul>\n<li>假设 <code>nums[i]-k</code> 是当前数组最小值，转变为 +k 操作后，<strong>可能</strong>会将当前数组 <code>nums</code> 的最小值提高。</li>\n<li>假设 <code>nums[i]-k</code> 不是当前数组最小值，转变为 +k 操作后，不会影响当前数组 <code>nums</code> 的最小值。</li>\n<li>将 <code>nums[i]</code> 转换为 +k 操作后，<code>nums[i]+k</code> 不可能大于 <code>nums[k]+k</code>（因为 <code>nums[i]</code> 在 <code>nums[k]</code> 的左侧，所以 <code>nums[i]&lt;=nums[k]</code>，所以 <code>nums[i]+k&lt;=nums[k]+k</code>）。也就是说这个操作不会增大当前数组 <code>nums</code> 的最大值。</li>\n<li>因此，这种转变操作总是有益的。</li>\n</ul>\n<p>就这样，我们将 <code>nums[k]</code> 左边的所有进行了 -k 操作的数全都掰正，转换为 +k 操作，最终得到了一张这样的照片：数组中左侧的数字全都进行了 +k 操作，右侧全都进行了 -k 操作。</p>\n<p>总结起来就是：我们不需要考察 +k 操作 -k 操作交替时的情况，因为这些情况都会转换为左侧全部 +k，右侧全部 -k 的情况。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/smallest-range-ii/solutions/102309/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/\">910. 最小差值 II 题解：太难了，只能画图凭直觉 - likai123 - 力扣（LeetCode）</a></li>\n</ul>\n","raw":"---\ntitle: 最小差值问题的贪心理解\ntags:\n  - LeetCode\n  - 贪心\n  - Java\ncover: 'https://cdn.gallery.uuanqin.top/img/202409192134284.webp'\ndescription: 尝试自证贪心算法的正确性\ncategories:\n  - 算法与数据结构\nabbrlink: 3fe090c8\nkatex: true\ndate: 2024-09-19 18:16:50\ntop_img:\n---\n\n今天带来的两道最小差值问题的解决方案。重点讨论「最小差值 II」中贪心算法的证明，因为 LeetCode 关于这道题的题解写得十分晦涩，生怕别人看懂。\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 「最小差值 I」：k 是可伸缩的\n\n> [!example] 题目：🟩 [908. 最小差值 I - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-range-i/description/)\n> 给你一个整数数组 `nums`，和一个整数 `k` 。\n>\n> 在一个操作中，您可以选择 `0 <= i < nums.length` 的任何索引 i 。将 `nums[i]` 改为 `nums[i] + x` ，其中 `x` 是一个范围为 `[-k, k]` 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。\n>\n> `nums` 的 **分数** 是 `nums` 中最大和最小元素的差值。\n>\n> 在对 `nums` 中的每个索引最多应用一次上述操作后，返回 `nums` 的最低 **分数** 。\n\n假设整数数组 nums 的最小值为 minNum，最大值为 maxNum。使用数学方法不难证明以下定理：\n\n> [!tldr] 定理：如果 $\\text{maxNum}-\\text{minNum}≤2k$，那么我们总可以将整数数组 nums 的所有元素都改为同一个整数，因此更改后的整数数组 nums 的最低分数为 0。\n>\n> 证明：因为 maxNum-\\text{minNum}≤2k，所以存在整数 $x\\in [\\text{minNum},\\text{maxNum}]$，使得 $x-\\text{minNum}\\le k$ 且 $\\text{maxNum}-x≤k$。那么整数数组 nums 的所有元素与整数 x 的绝对差值都不超过 k，即所有元素都可以改为 x。\n\n> [!tldr] 定理：如果 $\\text{maxNum}-\\text{minNum}>2k$，那么更改后的整数数组 nums 的最低分数为 $\\text{maxNum}-\\text{minNum}-2k$。\n>\n> 证明：对于 `minNum` 和 `maxNum` 两个元素，我们将 `minNum` 改为 $\\text{minNum}+k$，`maxNum` 改为 $\\text{maxNum}-k$，此时两个元素的绝对差值最小。因此更改后的整数数组 `nums` 的最低分数大于等于 $\\text{maxNum}-\\text{minNum}-2k$。\n>\n> 对于整数数组 `nums` 中的元素 x，如果 $x<\\text{minNum}+k$，那么 x 可以更改为 $\\text{minNum}+k$，如果 $x>\\text{maxNum}-k$，那么 x 可以更改为 $\\text{maxNum}-k$，因此整数数组 `nums` 的所有元素都可以改为区间 $[\\text{minNum}+k,\\text{maxNum}-k]$ 的整数，所以更改后的整数数组 `nums` 的最低分数小于等于 $\\text{maxNum}-\\text{minNum}-2k$。\n>\n> 综上所述，更改后的整数数组 `nums` 的最低分数为 $\\text{maxNum}-\\text{minNum}-2k$。\n\n```java\npublic int smallestRangeI(int[] nums, int k) {\n\t// 找到最大最小值minNum，maxNum\n\tint minNum=Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;\n\tfor(int e:nums){\n\t\tminNum = Math.min(min,e);\n\t\tmaxNum = Math.max(max,e);\n\t}\n\tint res = maxNum - minNum;\n\treturn res<=2*k ? 0 : res - 2*k;\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(n)$，其中 n 是整数数组 `nums` 的长度。需要 $O(n)$ 的时间遍历数组 nums 得到最小值和最大值，然后需要 $O(1)$ 的时间计算最低分数。\n- 空间复杂度：$O(1)$。\n\n\n# 「最小差值 II」：k 是不可伸缩的\n\n\n> [!example] 题目：🟨 [910. 最小差值 II - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-range-ii/description/)\n> 给你一个整数数组 `nums`，和一个整数 k 。\n>\n> 对于每个下标 i（`0 <= i < nums.length`），将 `nums[i]` 变成 `nums[i] + k` 或 `nums[i] - k` 。\n>\n> `nums` 的 分数 是 `nums` 中最大元素和最小元素的差值。\n>\n> 在更改每个下标对应的值之后，返回 `nums` 的最小 **分数** 。\n\n首先我们考虑将数字 `nums` 排一下序。\n\n假设将全部数字都 +k 或都 -k，**分数**是不变的。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202409191933810.webp)\n\n一个最朴素的思路是，将小的数 +k，将大的数 -k，试图减少 nums 的**分数**。\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202409192058262.webp)\n\n我们的目标就是将排好序的 `nums` 中间「切一刀」，让左边的数 +k，右边的数都 -k，然后检查数组 `nums` 的**分数**。根据这个思路，我们可以从左到右遍历不断的「切」从而找到答案。至于为什么这种想法是对的，可以继续看下面的思考。\n\n```java\npublic int smallestRangeII(int[] nums, int k) {\n\tint len = nums.length;\n\tif(len==1)return 0;\n\tArrays.sort(nums);\n\tint min = nums[0]+k,max = nums[len-1]-k;\n\tint res = nums[len-1]-nums[0];\n\tfor(int i=0;i<len-1;i++){\n\t\tint high = Math.max(nums[i]+k,max);\n\t\tint low = Math.min(nums[i+1]-k,min);\n\t\tres = Math.min(res,high-low);\n\t}\n\treturn res;\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(N \\log N)$，其中 N 是 `A` 的长度。\n- 空间复杂度：$O(1)$，额外空间就是自带排序算法的空间。\n\n在上面的算法中，我们在寻找「切一刀」的位置时，相当于只是考察了左边的数都 +k，右边的数都 -k 的情况。那么，我们需不需要考察这样一种情况：+k 的数和 -k 的数并不分居两侧，而是穿插交替进行，比如下面的这样一个情况。\n\n![image.png|400](https://cdn.gallery.uuanqin.top/img/202409192042114.webp)\n\n答案是不需要的。上图中，设最右边的选择 +k 的数 `nums[k]` 的左侧存在一个进行了 -k 操作的数——比如 `nums[i]`。将 `nums[i]` 转变为 +k 操作总是有利的——因为它不会增大当前照片中 `nums` 的分数 `res`：\n\n- 假设 `nums[i]-k` 是当前数组最小值，转变为 +k 操作后，**可能**会将当前数组 `nums` 的最小值提高。\n- 假设 `nums[i]-k` 不是当前数组最小值，转变为 +k 操作后，不会影响当前数组 `nums` 的最小值。\n- 将 `nums[i]` 转换为 +k 操作后，`nums[i]+k` 不可能大于 `nums[k]+k`（因为 `nums[i]` 在 `nums[k]` 的左侧，所以 `nums[i]<=nums[k]`，所以 `nums[i]+k<=nums[k]+k`）。也就是说这个操作不会增大当前数组 `nums` 的最大值。\n- 因此，这种转变操作总是有益的。\n\n就这样，我们将 `nums[k]` 左边的所有进行了 -k 操作的数全都掰正，转换为 +k 操作，最终得到了一张这样的照片：数组中左侧的数字全都进行了 +k 操作，右侧全都进行了 -k 操作。\n\n总结起来就是：我们不需要考察 +k 操作 -k 操作交替时的情况，因为这些情况都会转换为左侧全部 +k，右侧全部 -k 的情况。\n\n# 本文参考\n- [910. 最小差值 II 题解：太难了，只能画图凭直觉 - likai123 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-range-ii/solutions/102309/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/)\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"贪心","api":"api/tags/贪心.json"}]},"api":"api/posts/p/3fe090c8.json"}