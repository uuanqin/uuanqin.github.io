{"data":{"title":"并查集——帮派的建立","slug":"算法与数据结构/并查集——帮派的建立","description":"一个简单精巧的数据结构","date":"2024-05-25T10:16:06.000Z","updated":"2026-02-01T06:19:56.801Z","language":"zh-CN","comments":true,"url":"p/6d40357b/","cover":"https://cdn.gallery.uuanqin.top/img/202511040001417.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"info\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-info\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><path d=\"M12 16v-4\"/><path d=\"M12 8h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">本文创建于 <code>240525</code>，于 <code>251104</code> 从笔记中进行迁移补充，让🌱长成了🌼。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h1 id=\"并查集介绍\"><a class=\"markdownIt-Anchor\" href=\"#并查集介绍\"></a> 并查集介绍</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032227373.webp\" alt=\"image.png\" /></p>\n<p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。<strong>每棵树的根结点的值，代表着一个集合。</strong></p>\n<p>并查集支持两种操作：</p>\n<ul>\n<li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合。</li>\n<li>合并（Unite）：合并两个元素所属集合（合并对应的树）。判断两个元素是否同属于一个集合，只需要分别找出它们的根节点，比较根节点是否相同即可。</li>\n</ul>\n<p>应用：</p>\n<ul>\n<li>图的 Kruskal 算法，判断两个顶点是否同属于一个集合（加入这条边是否形成回路）</li>\n<li>判断无向图连通性</li>\n</ul>\n<h2 id=\"基本操作即解释\"><a class=\"markdownIt-Anchor\" href=\"#基本操作即解释\"></a> 基本操作即解释</h2>\n<p>我们可以把集合比喻成帮派，而代表元素（树的根结点）则是帮主。一开始（并查集初始化阶段），所有大侠各自为战。他们各自的帮主自然就是自己。对于只有一个元素的集合，代表元素自然是唯一的那个元素。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032232017.webp\" alt=\"image.png\" width=\"300px\" /></p>\n<p>每个人互相比拼，谁输了就认谁为帮主。比如下图展示了当前只剩两个帮派：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032234380.webp\" alt=\"image.png\" width=\"300px\" /></p>\n<p>假设两个帮派中，2 号和 6 号需要比武，那么他们各自派出帮主，即 1 和 4，进行比武。输的那一方认赢的那一方为帮主。假设 1 号为赢家，那么 4 号带领的帮派将认 1 号为帮主。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032236389.webp\" alt=\"image.png\" width=\"275px\" /></p>\n<p>整个过程就展示了并查集查找根结点（Find，即找帮主）以及集合合并（Unite，帮派打架）的基本过程。</p>\n<p>并查集的存储结构为一个父指针数组 <code>fa</code>。<code>fa[i]</code> 的值为 <code>v</code> 表示编号为 <code>i</code> 的元素的父结点为 <code>v</code>。</p>\n<p>初始化方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] fa[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tfa[i] = i; <span class=\"comment\">// 所有结点的帮主就是他自己</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查询：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032253952.webp\" alt=\"image.png\" width=\"113px\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无路径优化</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[x] == x ? x : find(fa[x]); <span class=\"comment\">// 不断向上找根结点的过程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>合并：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032254906.webp\" alt=\"image.png\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">merge</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span>&#123;</span><br><span class=\"line\">\tfa[find(i)] = find(j); <span class=\"comment\">// 将谁设置为父结点不重要</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"路径优化\"><a class=\"markdownIt-Anchor\" href=\"#路径优化\"></a> 路径优化</h1>\n<p>在并查集结点合并的过程中，我们可能会合成一条很长很长的链。这会导致以后在使用 <code>find</code> 函数时的时间效率不高。</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202511032247315.webp\" alt=\"image.png\" width=\"58px\" /></p>\n<p>未做路径优化的并查集在最坏情况下的高度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>解决方法为，在递归查询的过程中，退栈时，顺带把找到的根结点结果传回给递归链路中的结点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路径压缩</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[x] == x ? x : (fa[x] = find(fa[x]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果只使用路径压缩的查找方法，并不意味着任何时刻每一棵树的最大深度为 1，即每一个树不一定就是一朵「菊花」。</p>\n</blockquote>\n<h1 id=\"启发式合并\"><a class=\"markdownIt-Anchor\" href=\"#启发式合并\"></a> 启发式合并</h1>\n<p>除了在查找过程中尝试进行路径压缩，我们还可以在合并过程中优化效率。</p>\n<p>合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将：</p>\n<ul>\n<li>节点较少的树连到另一棵</li>\n<li>深度较小的树连到另一棵</li>\n</ul>\n<p>具体实现可看后文代码。</p>\n<h1 id=\"相关题目\"><a class=\"markdownIt-Anchor\" href=\"#相关题目\"></a> 相关题目</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://www.luogu.com.cn/problem/P3367\">P3367 【模板】并查集 - 洛谷</a></div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>使用了路径压缩 + 启发式合并（结点数）。不使用启发式合并也可以过。注意，使用 Java 语言时需要写一些技巧性的输出输出方式（详看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/bb11ee89/\"><span class=\"bilink-pop-up\">站内文章</span>Java 在 ACM 模式下的输入输出</a>）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] fa ;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] size;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        fa = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        size = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(size,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            fa[i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> fa[x] == x ? x : (fa[x] = find(fa[x]));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">merge</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> j)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> find(i);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> find(j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==y)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size[x]&lt;size[y])&#123;</span><br><span class=\"line\">            fa[x] = y;</span><br><span class=\"line\">            size[y]+=size[x];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            fa[y] = x;</span><br><span class=\"line\">            size[x]+=size[y];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">        init(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">z</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(z==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                merge(x,y);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> find(x) == find(y);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(b)os.println(<span class=\"string\">&quot;Y&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> os.println(<span class=\"string\">&quot;N&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        os.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">StreamTokenizer</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StreamTokenizer</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)));</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">PrintWriter</span> <span class=\"variable\">os</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrintWriter</span>(System.out);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">nextInt</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        sc.nextToken();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) sc.nval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">nextLong</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        sc.nextToken();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">long</span>) sc.nval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他题目：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/satisfiability-of-equality-equations/description/\">990. 等式方程的可满足性 - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"后续改进\"><a class=\"markdownIt-Anchor\" href=\"#后续改进\"></a> 后续改进</h1>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 本文夜间模式不友好，部分图片在夜间模式下不清晰</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>408 思维导图解耦</li>\n<li><a href=\"https://oi-wiki.org/ds/dsu/#__tabbed_6_2\">并查集 - OI Wiki</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/93647900\">算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36667170/article/details/84142019\">树的高度和深度 | 结点的高度和深度_树的深度怎么算-CSDN博客</a></li>\n</ul>\n","raw":"---\ntitle: 并查集——帮派的建立\ntags:\n  - 树\n  - 集合\n  - Java\n  - LeetCode\n  - 洛谷\ncover: https://cdn.gallery.uuanqin.top/img/202511040001417.webp\ndescription: 一个简单精巧的数据结构\nkatex: true\ncategories:\n  - 算法与数据结构\nabbrlink: 6d40357b\nsummary: >-\n  并查集是一种数据结构，用于管理元素所属集合，形成一棵有根树的森林，每个集合的根节点代表该集合。它支持两种主要操作：查询（Find）和合并（Unite）。查询操作用于确定元素所属集合的根节点，而合并操作则用于将两个集合合并。并查集广泛应用于图的Kruskal算法和判断无向图的连通性。为实现高效操作，通常采用路径压缩和启发式合并技术。路径压缩通过减少查找过程中的树高来提高效率，启发式合并则通过选择合适的树根节点来优化合并操作。本文还介绍了相关题目和后续改进方向，并提供了参考文献列表。\ndate: 2024-05-25 18:16:06\ntop_img:\n---\n\n> [!info] 本文创建于 `240525`，于 `251104` 从笔记中进行迁移补充，让🌱长成了🌼。\n\n# 并查集介绍\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202511032227373.webp)\n\n并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。**每棵树的根结点的值，代表着一个集合。**\n\n并查集支持两种操作：\n\n- 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合。\n- 合并（Unite）：合并两个元素所属集合（合并对应的树）。判断两个元素是否同属于一个集合，只需要分别找出它们的根节点，比较根节点是否相同即可。\n\n应用：\n\n- 图的 Kruskal 算法，判断两个顶点是否同属于一个集合（加入这条边是否形成回路）\n- 判断无向图连通性\n\n## 基本操作即解释\n\n我们可以把集合比喻成帮派，而代表元素（树的根结点）则是帮主。一开始（并查集初始化阶段），所有大侠各自为战。他们各自的帮主自然就是自己。对于只有一个元素的集合，代表元素自然是唯一的那个元素。\n\n![image.png|300](https://cdn.gallery.uuanqin.top/img/202511032232017.webp)\n\n每个人互相比拼，谁输了就认谁为帮主。比如下图展示了当前只剩两个帮派：\n\n![image.png|300](https://cdn.gallery.uuanqin.top/img/202511032234380.webp)\n\n假设两个帮派中，2 号和 6 号需要比武，那么他们各自派出帮主，即 1 和 4，进行比武。输的那一方认赢的那一方为帮主。假设 1 号为赢家，那么 4 号带领的帮派将认 1 号为帮主。\n\n![image.png|275](https://cdn.gallery.uuanqin.top/img/202511032236389.webp)\n\n整个过程就展示了并查集查找根结点（Find，即找帮主）以及集合合并（Unite，帮派打架）的基本过程。\n\n并查集的存储结构为一个父指针数组 `fa`。`fa[i]` 的值为 `v` 表示编号为 `i` 的元素的父结点为 `v`。\n\n初始化方式：\n\n```java\npublic static int[] fa[MAXN];\npublic static void init(int n){\n\tfor(int i=1;i<=n;i++){\n\t\tfa[i] = i; // 所有结点的帮主就是他自己\n\t}\n}\n```\n\n查询：\n\n![image.png|113](https://cdn.gallery.uuanqin.top/img/202511032253952.webp)\n\n```java\n// 无路径优化\npublic static int find(int x){\n\treturn fa[x] == x ? x : find(fa[x]); // 不断向上找根结点的过程\n}\n```\n\n合并：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202511032254906.webp)\n\n```java\npublic static void merge(int i, int j){\n\tfa[find(i)] = find(j); // 将谁设置为父结点不重要\n}\n```\n\n# 路径优化\n\n在并查集结点合并的过程中，我们可能会合成一条很长很长的链。这会导致以后在使用 `find` 函数时的时间效率不高。\n\n![image.png|58](https://cdn.gallery.uuanqin.top/img/202511032247315.webp)\n\n未做路径优化的并查集在最坏情况下的高度为 $O(n)$，时间复杂度 $O(n)$。\n\n解决方法为，在递归查询的过程中，退栈时，顺带把找到的根结点结果传回给递归链路中的结点：\n\n```java\n// 路径压缩\npublic static int find(int x){\n\treturn fa[x] == x ? x : (fa[x] = find(fa[x]));\n}\n```\n\n> 如果只使用路径压缩的查找方法，并不意味着任何时刻每一棵树的最大深度为 1，即每一个树不一定就是一朵「菊花」。\n\n# 启发式合并\n\n除了在查找过程中尝试进行路径压缩，我们还可以在合并过程中优化效率。\n\n合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将：\n\n- 节点较少的树连到另一棵\n- 深度较小的树连到另一棵\n\n具体实现可看后文代码。\n\n# 相关题目\n\n> [!example] 🟨 [P3367 【模板】并查集 - 洛谷](https://www.luogu.com.cn/problem/P3367)\n\n使用了路径压缩 + 启发式合并（结点数）。不使用启发式合并也可以过。注意，使用 Java 语言时需要写一些技巧性的输出输出方式（详看 [[Java 在 ACM 模式下的输入输出]]）。\n\n```java\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    public static int[] fa ;\n    public static int[] size;\n    public static void init(int n) {\n        fa = new int[n+1];\n        size = new int[n+1];\n        Arrays.fill(size,1);\n        for (int i = 0; i <= n; i++) {\n            fa[i] = i;\n        }\n    }\n\n    public static int find(int x) {\n        int res = fa[x] == x ? x : (fa[x] = find(fa[x]));\n        return res;\n    }\n\n    public static void merge(int i,int j){\n        int x = find(i);\n        int y = find(j);\n        if(x==y)return;\n        if(size[x]<size[y]){\n            fa[x] = y;\n            size[y]+=size[x];\n        }else{\n            fa[y] = x;\n            size[x]+=size[y];\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        init(n);\n        for(int i=0;i<m;i++){\n            int z = nextInt();\n            int x = nextInt();\n            int y = nextInt();\n            if(z==1){\n                merge(x,y);\n            }else{\n                boolean b = find(x) == find(y);\n                if(b)os.println(\"Y\");\n                else os.println(\"N\");\n            }\n        }\n        os.flush();\n    }\n\n    static StreamTokenizer sc = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    static PrintWriter os = new PrintWriter(System.out);\n\n    static int nextInt() throws IOException {\n        sc.nextToken();\n        return (int) sc.nval;\n    }\n    \n    static long nextLong() throws IOException {\n        sc.nextToken();\n        return (long) sc.nval;\n    }\n}\n```\n\n其他题目：\n\n- 🟨 [990. 等式方程的可满足性 - 力扣（LeetCode）](https://leetcode.cn/problems/satisfiability-of-equality-equations/description/)\n\n# 后续改进\n\n- [ ] 本文夜间模式不友好，部分图片在夜间模式下不清晰\n\n# 本文参考\n\n- 408 思维导图解耦\n- [并查集 - OI Wiki](https://oi-wiki.org/ds/dsu/#__tabbed_6_2)\n- [算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93647900)\n- [树的高度和深度 | 结点的高度和深度_树的深度怎么算-CSDN博客](https://blog.csdn.net/qq_36667170/article/details/84142019)","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"树","api":"api/tags/树.json"},{"name":"集合","api":"api/tags/集合.json"},{"name":"洛谷","api":"api/tags/洛谷.json"}]},"api":"api/posts/p/6d40357b.json"}