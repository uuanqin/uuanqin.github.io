{"data":{"title":"Java 不可变类与不变模式","slug":"计算机语言/Java 不可变类与不变模式","description":"资源节约与线程安全的手段","date":"2025-08-27T14:54:00.000Z","updated":"2025-08-31T10:42:59.890Z","language":"zh-CN","comments":true,"url":"p/e0b8ae0b/","cover":"https://cdn.gallery.uuanqin.top/img/202508311842104.webp","images":[],"content":"<h1 id=\"java-中的不可变类\"><a class=\"markdownIt-Anchor\" href=\"#java-中的不可变类\"></a> Java 中的不可变类</h1>\n<p>不可变类：当创建了这个类的实例后，就不允许修改它的属性值。在 JDK 的基本类库中，所有基本类型的包装类，如 <code>Integer</code> 和 <code>Long</code> 类，都是不可变类。<code>String</code> 也是不可变类。</p>\n<p>用户在创建自己的不可变类时，可以考虑采用以下设计模式：</p>\n<ul>\n<li>把属性定义为 <code>private final</code> 类型。</li>\n<li>不对外公开用于修改属性的 <code>setXXX()</code> 方法</li>\n<li>只对外公开用于读取属性的 <code>getXXX()</code> 方法</li>\n<li>在构造方法中初始化所有属性。</li>\n<li>覆盖 <code>Object</code> 类的 <code>equals()</code> 和 <code>hashCode()</code> 方法，在 <code>equals()</code> 方法中根据对象的属性值来比较两个对象是否相等，并且保证用 <code>equals()</code> 方法判断为相等的两个对象的 <code>hashCode()</code> 方法的返回值也相等，这可以保证这些对象能正确地放到 <code>HashMap</code> 或 <code>HashSet</code> 集合中。</li>\n<li>如果需要的话，提供实例缓存和静态工厂方法，允许用户根据特定参数获得与之匹配的实例。</li>\n</ul>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\"><code>String</code> 类是不可变的</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li><code>String</code> 类由 <code>final</code> 修饰，说明其不可继承。</li>\n<li>字符数组 <code>char value[]</code> 是由 <code>private final</code> 修饰的，保证引用地址不可变。（不保证数组内容不可变）</li>\n<li><code>String</code> 类中，没有公开修改内部成员字段的方法。</li>\n<li>读取 <code>value</code> 数组时，采用了保护性拷贝 <code>Arrays.copyof()</code></li>\n</ul>\n<p>实际上，可以通过反射修改 <code>value</code> 属性。</p>\n</div></div><p>不可变类的实例在整个生命周期中永远保持初始化的状态，它没有任何状态变化，简化了与其他对象之间的关系。不可变类具有以下优点：</p>\n<ul>\n<li>不可变类能使程序更加安全，不容易出错；</li>\n<li>不可变类是<strong>线程安全</strong>的，当多个线程访问不可变类的同一个实例时，无须进行线程的同步。</li>\n</ul>\n<p>把不可变类实例属性的 <code>final</code> 修饰符去除，增加 <code>public</code> 类型的 <code>set</code> 方法就变成了可变类。使用可变类更容易使程序代码出错。因为随意改变一个可变类对象的状态，有可能会导致与之关联的其他对象的状态被错误地改变。</p>\n<p>由此可见，应该优先考虑把类设计为不可变类，假使必须使用可变类，也应该把可变类的尽可能多的属性设计为不可变的，即用 <code>final</code> 修饰符来修饰，并且不对外公开用于改变这些属性的方法。</p>\n<p>在创建不可变类时，假如它的属性所属的类是可变类，在必要的情况下，必须提供保护性复制，否则，这个不可变类的实例的属性仍然有可能被错误地修改。即使可变类属性已经用 <code>final</code> 修饰，也必须提供保护性复制。</p>\n<p>保护性复制是一种防御性编程技术。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Schedule</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Date start;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Date end;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Schedule</span><span class=\"params\">(Date start,Date end)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不允许放假日期在开学日期的前面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start.compareTo(end)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(start +<span class=\"string\">&quot; after &quot;</span> +end);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.start=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(start.getTime());  <span class=\"comment\">//采用保护性拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.end=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(end.getTime());   <span class=\"comment\">//采用保护性拷贝</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Date <span class=\"title function_\">getStart</span><span class=\"params\">()</span>&#123;<span class=\"keyword\">return</span> (Date)start.clone();&#125;  <span class=\"comment\">//采用保护性拷贝</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Date <span class=\"title function_\">getEnd</span><span class=\"params\">()</span>&#123;<span class=\"keyword\">return</span> (Date)end.clone();&#125;  <span class=\"comment\">//采用保护性拷贝</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 嵌入Schedule的将不是别人给的可变类Date的引用，返回出去的Date也不会是实际存的引用，这样别人就不能改动可变类Date造成状态错误。</span></span><br></pre></td></tr></table></figure>\n<p>假如某个类中被 <code>final</code> 修饰的属性所属的类是不可变类，就无须提供保护性复制，因为该属性所引用的实例的值永远不会被改变，这进一步体现了不可变类的优点。</p>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">保护性拷贝：通过创建副本对象来避免共享的手段。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h2 id=\"具有实例缓存的不可变类\"><a class=\"markdownIt-Anchor\" href=\"#具有实例缓存的不可变类\"></a> 具有实例缓存的不可变类</h2>\n<blockquote>\n<p>推荐阅读：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"yukari\">站内文章</span>享元模式：共享实例</a> 中 Java 的 <code>Integer</code> 和 <code>String</code> 带缓存的不可变类的实现。</p>\n</blockquote>\n<p>不可变类的实例的状态不会变化，这样的实例可以安全地被其他与之关联的对象共享，还可以安全地被多个线程共享。为了节省内存空间，优化程序的性能，应该尽可能地重用不可变类的实例，避免重复创建具有相同属性值的不可变类的实例。</p>\n<p>缓存并没有固定的实现方式，完善的缓存实现不仅要考虑何时把实例加入缓存，还要考虑何时把不再使用的实例从缓存中及时清除，以保证有效合理地利用内存空间。一种简单的实现是直接用 Java 集合来作为实例缓存。</p>\n<p>另外要注意的是，没有必要为所有的不可变类提供实例缓存。随意创建大量实例缓存，反而会浪费内存空间，降低程序的运行性能。通常，只有满足以下条件的不可变类才需要实例缓存：</p>\n<ul>\n<li>不可变类的实例的数量有限。</li>\n<li>在程序运行过程中，需要频繁访问不可变类的一些特定实例。这些实例拥有与程序本身同样长的生命周期。</li>\n</ul>\n<h1 id=\"不变模式-immutable\"><a class=\"markdownIt-Anchor\" href=\"#不变模式-immutable\"></a> 不变模式 Immutable</h1>\n<p>不变模式：一个对象的状态在对象创建之后不再改变。涉及的 Java 类即不变类（Immutable Class），如果是对象则为不变对象（Immutable Object）。</p>\n<p>不变模式分为两类：</p>\n<ul>\n<li>普通不变模式：对象中包含的引用对象是可以改变的。如果不特别说明，通常我们所说的不变模式，指的就是普通的不变模式。</li>\n<li>深度不变模式：对象包含的引用对象也不可变</li>\n</ul>\n<p>它们之间的关系类似于 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/96a98120/\"><span class=\"yukari\">站内文章</span>深拷贝和浅拷贝</a> 之间的关系。</p>\n<p>不变模式使用到不可变类，而不可变类不存在线程问题，因此不变模式常用于多线程场景。所以，不变模式也常被归类为多线程设计模式。</p>\n<h1 id=\"不变集合\"><a class=\"markdownIt-Anchor\" href=\"#不变集合\"></a> 不变集合</h1>\n<p>不变集合是一种特殊的不变类。</p>\n<p>Google Guava 针对集合类 <code>Collection</code>、<code>List</code>、<code>Set</code>、<code>Map</code> 等提供了对应的不变集合类 <code>ImmutableCollection</code>、<code>ImmutableList</code>、<code>ImmutableSet</code>、<code>ImmutableMap</code>……</p>\n<p>Google Guava 提供的不变集合类属于普通不变模式，集合中的对象不会增删，但是对象的成员变量是可以改变的。</p>\n<p>JDK 中也提供了类似的集合，只不过它提供的是一个集合的「不可修改的视图」，而不是不变集合。当原始集合被修改后，<code>Collections.unmodifiableXXX</code> 里面的元素会跟着发生变化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tList&lt;String&gt; originalList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\toriginalList.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">\toriginalList.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">\toriginalList.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tList&lt;String&gt; jdkUnmodifiableList = Collections.unmodifiableList(originalList);</span><br><span class=\"line\">\tList&lt;String&gt; guavaImmutableList = ImmutableList.copyOf(originalList);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//jdkUnmodifiableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException</span></span><br><span class=\"line\">\t<span class=\"comment\">// guavaImmutableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException</span></span><br><span class=\"line\">\toriginalList.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprint(originalList); <span class=\"comment\">// a b c d</span></span><br><span class=\"line\">\tprint(jdkUnmodifiableList); <span class=\"comment\">// a b c d （发生了改变）</span></span><br><span class=\"line\">\tprint(guavaImmutableList); <span class=\"comment\">// a b c</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK 类库中提供的 <code>unmodifiableXXX</code> 方法存在以下不足：</p>\n<ul>\n<li>笨拙：代码量多；</li>\n<li>不安全：只有在不会引用到原来的集合情况下，才能保证集合唯一且永恒不变；</li>\n<li>效率很低：返回的不可修改的集合数据结构仍然具有可变集合的所有开销。</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《Java 面向对象编程》孙卫琴</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://www.jianshu.com/p/bf2623f18d6a\">理解不可变集合 | Guava Immutable与JDK unmodifiableList - 简书</a></li>\n</ul>\n","raw":"---\ntitle: Java 不可变类与不变模式\ntags:\n  - Java\n  - 多线程\ndescription: 资源节约与线程安全的手段\nkatex: false\ncategories:\n  - 计算机语言\nabbrlink: e0b8ae0b\ndate: 2025-08-27 22:54:00\ncover: https://cdn.gallery.uuanqin.top/img/202508311842104.webp\ntop_img:\n---\n\n# Java 中的不可变类\n\n不可变类：当创建了这个类的实例后，就不允许修改它的属性值。在 JDK 的基本类库中，所有基本类型的包装类，如 `Integer` 和 `Long` 类，都是不可变类。`String` 也是不可变类。\n\n用户在创建自己的不可变类时，可以考虑采用以下设计模式：\n\n- 把属性定义为 `private final` 类型。\n- 不对外公开用于修改属性的 `setXXX()` 方法\n- 只对外公开用于读取属性的 `getXXX()` 方法\n- 在构造方法中初始化所有属性。\n- 覆盖 `Object` 类的 `equals()` 和 `hashCode()` 方法，在 `equals()` 方法中根据对象的属性值来比较两个对象是否相等，并且保证用 `equals()` 方法判断为相等的两个对象的 `hashCode()` 方法的返回值也相等，这可以保证这些对象能正确地放到 `HashMap` 或 `HashSet` 集合中。\n- 如果需要的话，提供实例缓存和静态工厂方法，允许用户根据特定参数获得与之匹配的实例。\n\n> [!example] `String` 类是不可变的\n> - `String` 类由 `final` 修饰，说明其不可继承。\n> - 字符数组 `char value[]` 是由 `private final` 修饰的，保证引用地址不可变。（不保证数组内容不可变）\n> - `String` 类中，没有公开修改内部成员字段的方法。\n> - 读取 `value` 数组时，采用了保护性拷贝 `Arrays.copyof()`\n> \n> 实际上，可以通过反射修改 `value` 属性。\n\n不可变类的实例在整个生命周期中永远保持初始化的状态，它没有任何状态变化，简化了与其他对象之间的关系。不可变类具有以下优点：\n\n- 不可变类能使程序更加安全，不容易出错；\n- 不可变类是**线程安全**的，当多个线程访问不可变类的同一个实例时，无须进行线程的同步。\n\n把不可变类实例属性的 `final` 修饰符去除，增加 `public` 类型的 `set` 方法就变成了可变类。使用可变类更容易使程序代码出错。因为随意改变一个可变类对象的状态，有可能会导致与之关联的其他对象的状态被错误地改变。\n\n由此可见，应该优先考虑把类设计为不可变类，假使必须使用可变类，也应该把可变类的尽可能多的属性设计为不可变的，即用 `final` 修饰符来修饰，并且不对外公开用于改变这些属性的方法。\n\n在创建不可变类时，假如它的属性所属的类是可变类，在必要的情况下，必须提供保护性复制，否则，这个不可变类的实例的属性仍然有可能被错误地修改。即使可变类属性已经用 `final` 修饰，也必须提供保护性复制。\n\n保护性复制是一种防御性编程技术。\n\n例子：\n\n```java\npublic final class Schedule {\n  private final Date start;\n  private final Date end;\n  public Schedule(Date start,Date end){\n    //不允许放假日期在开学日期的前面\n    if(start.compareTo(end)>0)\n\t    throw new IllegalArgumentException(start +\" after \" +end);\n    this.start=new Date(start.getTime());  //采用保护性拷贝\n    this.end=new Date(end.getTime());   //采用保护性拷贝\n  }\n  public Date getStart(){return (Date)start.clone();}  //采用保护性拷贝\n  public Date getEnd(){return (Date)end.clone();}  //采用保护性拷贝\n}\n// 嵌入Schedule的将不是别人给的可变类Date的引用，返回出去的Date也不会是实际存的引用，这样别人就不能改动可变类Date造成状态错误。\n```\n\n假如某个类中被 `final` 修饰的属性所属的类是不可变类，就无须提供保护性复制，因为该属性所引用的实例的值永远不会被改变，这进一步体现了不可变类的优点。\n\n> [!note] 保护性拷贝：通过创建副本对象来避免共享的手段。\n\n## 具有实例缓存的不可变类\n\n> 推荐阅读：[[享元模式：共享实例]] 中 Java 的 `Integer` 和 `String` 带缓存的不可变类的实现。\n\n不可变类的实例的状态不会变化，这样的实例可以安全地被其他与之关联的对象共享，还可以安全地被多个线程共享。为了节省内存空间，优化程序的性能，应该尽可能地重用不可变类的实例，避免重复创建具有相同属性值的不可变类的实例。\n\n缓存并没有固定的实现方式，完善的缓存实现不仅要考虑何时把实例加入缓存，还要考虑何时把不再使用的实例从缓存中及时清除，以保证有效合理地利用内存空间。一种简单的实现是直接用 Java 集合来作为实例缓存。\n\n另外要注意的是，没有必要为所有的不可变类提供实例缓存。随意创建大量实例缓存，反而会浪费内存空间，降低程序的运行性能。通常，只有满足以下条件的不可变类才需要实例缓存：\n\n- 不可变类的实例的数量有限。\n- 在程序运行过程中，需要频繁访问不可变类的一些特定实例。这些实例拥有与程序本身同样长的生命周期。\n\n# 不变模式 Immutable\n\n不变模式：一个对象的状态在对象创建之后不再改变。涉及的 Java 类即不变类（Immutable Class），如果是对象则为不变对象（Immutable Object）。\n\n不变模式分为两类：\n\n- 普通不变模式：对象中包含的引用对象是可以改变的。如果不特别说明，通常我们所说的不变模式，指的就是普通的不变模式。\n- 深度不变模式：对象包含的引用对象也不可变\n\n它们之间的关系类似于 [[原型模式及深浅拷贝|深拷贝和浅拷贝]] 之间的关系。\n\n不变模式使用到不可变类，而不可变类不存在线程问题，因此不变模式常用于多线程场景。所以，不变模式也常被归类为多线程设计模式。\n\n# 不变集合\n\n不变集合是一种特殊的不变类。\n\nGoogle Guava 针对集合类 `Collection`、`List`、`Set`、`Map` 等提供了对应的不变集合类 `ImmutableCollection`、`ImmutableList`、`ImmutableSet`、`ImmutableMap`…...\n\nGoogle Guava 提供的不变集合类属于普通不变模式，集合中的对象不会增删，但是对象的成员变量是可以改变的。\n\nJDK 中也提供了类似的集合，只不过它提供的是一个集合的「不可修改的视图」，而不是不变集合。当原始集合被修改后，`Collections.unmodifiableXXX` 里面的元素会跟着发生变化。\n\n```java\npublic static void main(String[] args) {\n\tList<String> originalList = new ArrayList<>();\n\toriginalList.add(\"a\");\n\toriginalList.add(\"b\");\n\toriginalList.add(\"c\");\n\t\n\tList<String> jdkUnmodifiableList = Collections.unmodifiableList(originalList);\n\tList<String> guavaImmutableList = ImmutableList.copyOf(originalList);\n\t\n\t//jdkUnmodifiableList.add(\"d\"); // 抛出UnsupportedOperationException\n\t// guavaImmutableList.add(\"d\"); // 抛出UnsupportedOperationException\n\toriginalList.add(\"d\");\n\t\n\tprint(originalList); // a b c d\n\tprint(jdkUnmodifiableList); // a b c d （发生了改变）\n\tprint(guavaImmutableList); // a b c\n}\n```\n\nJDK 类库中提供的 `unmodifiableXXX` 方法存在以下不足：\n\n- 笨拙：代码量多；\n- 不安全：只有在不会引用到原来的集合情况下，才能保证集合唯一且永恒不变；\n- 效率很低：返回的不可修改的集合数据结构仍然具有可变集合的所有开销。\n\n# 本文参考\n\n- 《Java 面向对象编程》孙卫琴\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [理解不可变集合 | Guava Immutable与JDK unmodifiableList - 简书](https://www.jianshu.com/p/bf2623f18d6a)\n","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"多线程","api":"api/tags/多线程.json"}]},"api":"api/posts/p/e0b8ae0b.json"}