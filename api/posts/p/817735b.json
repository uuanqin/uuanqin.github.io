{"data":{"title":"为什么二分查找总是写不对？","slug":"算法与数据结构/为什么二分查找总是写不对？","description":"把握好循环不变量这个关键点就行","date":"2025-01-24T17:21:35.000Z","updated":"2025-06-09T17:19:40.762Z","language":"zh-CN","comments":true,"url":"p/817735b/","cover":"https://cdn.gallery.uuanqin.top/img/202501250127271.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"cite\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-quote\"><path d=\"M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z\"/><path d=\"M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">Cite</div>\n</div>\n<div class=\"callout-content\"><p>尽管第一个 <a href=\"https://so.csdn.net/so/search?q=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020\">二分查找算法</a> 于 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。</p>\n<p>—— Donald E.Knuth 《计算机程序设计艺术》第 3 卷《排序和查找》</p>\n</div></div><p>二分查找的逻辑本身并不复杂，但是在实际写代码的时候我们总是出错，要么少写个等于号，要么漏掉一个元素。出现这些问题的原因在于没有把握好对循环不变量的掌控。当对自己写出的循环没把握时，各种细节问题会频繁出现，从而成为我的二分恐惧症、快排恐惧症以及链表恐惧症的原因之一。</p>\n<p>本文通过红蓝染色法，通过对循环不变量的正确理解快速写出正确的二分查找代码。</p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"本文例题\"><a class=\"markdownIt-Anchor\" href=\"#本文例题\"></a> 本文例题</h1>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">🟨 <a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=problem-list-v2&amp;envId=binary-search\">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></div>\n</div>\n<div class=\"callout-content\"><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>\n<p>你必须设计并实现时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法解决此问题。</p>\n</div></div><p>利用数组有序的性质我们可以写出二分查找算法。</p>\n<p>在解这道题之前我们先考虑以下子问题：给定一个按照非递减顺序排列的整数数组 <code>nums</code> 和一个目标值 <code>target</code>，找出给定目标值在数组中的开始位置，即大于等于 <code>target</code> 的第一个数所表示的下标。</p>\n<blockquote>\n<p>这个子问题和 🟩 <a href=\"https://leetcode.cn/problems/search-insert-position/description/\">35. 搜索插入位置 - 力扣（LeetCode）</a> 十分类似。</p>\n</blockquote>\n<h1 id=\"三种区间写法\"><a class=\"markdownIt-Anchor\" href=\"#三种区间写法\"></a> 三种区间写法</h1>\n<p>在以下的代码中，<code>l</code> 表示左指针，<code>r</code> 表示右指针，<code>mid</code> 表示中点，指向被询问的数。</p>\n\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">中点选取的写法以防溢出</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<p>在选取中点时我们通常有：<code>int mid = (l+r)/2;</code>，但是为了避免在一些语言中（C、Java）加法出现溢出的状况，我们还可以这样写：<code>int mid = l+(r-l)/2;</code>。</p>\n<p>原理：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo><mo>=</mo><mo stretchy=\"false\">⌊</mo><mfrac><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>2</mn><mi>l</mi></mrow><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo><mo>=</mo><mo stretchy=\"false\">⌊</mo><mfrac><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mi>l</mi><mo stretchy=\"false\">⌋</mo><mo>=</mo><mi>l</mi><mo>+</mo><mo stretchy=\"false\">⌊</mo><mfrac><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{l+r}{2} \\rfloor = \\lfloor \\frac{r-l+2l}{2} \\rfloor = \\lfloor \\frac{r-l}{2} +l \\rfloor = l+ \\lfloor \\frac{r-l}{2}  \\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span></p>\n</div></div><p>红蓝染色法：对一个数组的数字进行染色，左边染红色，右边染蓝色。对应问题中来讲：染红色的表示 <code>false</code>，即表示 <code>&lt;target</code> 的数；染蓝色的表示 <code>true</code>，即表示 <code>&gt;=target</code> 的数。<code>right</code> 左移使右侧变蓝，<code>left</code> 右移使左侧变红。</p>\n<p>对于不同的区间表示方式，二分查找会有不同的写法，这也是为什么我们在看 LeetCode 题解时二分查找写法总是有一些细微差别的原因。</p>\n<h2 id=\"闭区间写法\"><a class=\"markdownIt-Anchor\" href=\"#闭区间写法\"></a> 闭区间写法</h2>\n<p>闭区间写法要求循环开始时 <code>l</code> 和 <code>r</code> 指向的「未确定颜色」区间是闭区间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lowerBound</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> target)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">0</span>,r = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;=r)&#123;          <span class=\"comment\">// 【要点】while中要求l,r表示的区间不为空</span></span><br><span class=\"line\">\t\tmid = l+ (r-l)/<span class=\"number\">2</span>; <span class=\"comment\">// 避免溢出问题</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 染色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&lt;target)   <span class=\"comment\">// 这里写的条件是判定染红色的条件</span></span><br><span class=\"line\">\t\t    <span class=\"comment\">// 染红色</span></span><br><span class=\"line\">\t\t\tl=mid+<span class=\"number\">1</span>;      <span class=\"comment\">// l-1 全都小于 k</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tr=mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l;             <span class=\"comment\">// 或 r+1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每一次循环后，<code>l-1</code> 前的数必定是红色的，<code>r+1</code> 以后的数必是蓝色的。这就是<strong>循环不变量</strong>！</p>\n<p>最终染色完毕得到以下结果：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202501240055648.webp\" alt=\"image.png\" width=\"450px\" /></p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">试一试：将 <code>if</code> 中的条件判定可以写成判定染蓝色的条件。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><h2 id=\"左闭右开写法\"><a class=\"markdownIt-Anchor\" href=\"#左闭右开写法\"></a> 左闭右开写法</h2>\n<p>把握好循环不变量，你可以轻松写出另一种写法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lowerBound2</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">0</span>,r = nums.length; <span class=\"comment\">// 变动点：r指向开区间边界</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> mid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;      <span class=\"comment\">// 变动点：把握区间不为空</span></span><br><span class=\"line\">\t\tmid = l+ (r-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&lt;k)&#123;</span><br><span class=\"line\">\t\t\tl=mid+<span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tr=mid;   <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l; <span class=\"comment\">// 或 r</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开区间写法\"><a class=\"markdownIt-Anchor\" href=\"#开区间写法\"></a> 开区间写法</h2>\n<p>开区间写法中，<code>l</code> 或 <code>r</code> 的变化不需要 +1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lowerBound3</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=-<span class=\"number\">1</span>,r = nums.length; <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> mid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l+<span class=\"number\">1</span>!=r)&#123;  <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">\t\tmid = l+ (r-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&lt;k)&#123;</span><br><span class=\"line\">\t\t\tl=mid; </span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tr=mid;  <span class=\"comment\">// 变动点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l+<span class=\"number\">1</span>;   <span class=\"comment\">// 或 r   // 变动点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>三种写法喜欢那种写那种，只要把握好循环不变量想写那种写那种，都不会混乱。</p>\n<h1 id=\"target-的类型\"><a class=\"markdownIt-Anchor\" href=\"#target-的类型\"></a> <code>target</code> 的类型</h1>\n<p>在前面的二分查找中，我们考虑的子问题是找出<strong>大于等于</strong> <code>target</code> 的第一个数所表示的下标。如果我们要求出<strong>大于/小于/小于等于</strong> <code>target</code> 的<strong>第一个数/最后一个数</strong>所表示的下标该怎么做？</p>\n<p>当数组中的数都是整数时，其实我们可以将<strong>大于/小于/小于等于</strong>转化为<strong>大于等于</strong>：</p>\n<ul>\n<li>大于 <code>target</code> 的第一个数的下标：大于等于 <code>target</code>+1 的数的下标</li>\n<li>小于 <code>target</code> 的最后一个数的下标：大于等于 <code>target</code> 的数下标 -1</li>\n<li>小于等于 <code>target</code> 的最后一个数的下标：大于等于 <code>target</code>+1 的数的下标 -1</li>\n</ul>\n<p>那回到题目 🟨 <a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=problem-list-v2&amp;envId=binary-search\">34. 在排序数组中查找元素的第一个和最后一个位置</a>，题目要求的就是：</p>\n<ul>\n<li>找出<strong>大于等于</strong> <code>target</code> 的第一个数所表示的下标</li>\n<li>找出<strong>小于</strong> <code>target</code>+1 的最后一个数所表示的下标</li>\n</ul>\n<p>我们就可以根据此写出相应的代码。</p>\n<h1 id=\"数组中不存在符合题意的数\"><a class=\"markdownIt-Anchor\" href=\"#数组中不存在符合题意的数\"></a> 数组中不存在符合题意的数</h1>\n<p>在题目🟨 <a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=problem-list-v2&amp;envId=binary-search\">34. 在排序数组中查找元素的第一个和最后一个位置</a> 中还有个要求就是，如果不存在 <code>target</code> 需要返回 <code>-1</code>，那么我们检查二分查找（<strong>大于等于</strong> <code>target</code> 的第一个数所表示的下标）返回的下标对应的数组是否是 <code>target</code> 即可。如果根本不存在<strong>大于等于</strong> <code>target</code> 的第一个数所表示的下标，<code>l</code> 最终会到达 <code>nums.length</code>，这时候返回 <code>-1</code> 即可。</p>\n<p>因此总的代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] searchRange(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;-<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span>  lowerBound(nums,target);</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lowerBound(nums,target+<span class=\"number\">1</span>)-<span class=\"number\">1</span>;</span><br><span class=\"line\">\ta = a&lt;nums.length&amp;&amp;nums[a]==target? a:-<span class=\"number\">1</span>;</span><br><span class=\"line\">\tb = b&gt;=<span class=\"number\">0</span>&amp;&amp;nums[b]==target? b:-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;a,b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lowerBound</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=-<span class=\"number\">1</span>,r = nums.length;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l+<span class=\"number\">1</span>!=r)&#123;</span><br><span class=\"line\">\t\tmid = l+ (r-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&lt;k)&#123;</span><br><span class=\"line\">\t\t\tl=mid; </span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tr=mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<h1 id=\"区间边界的传入\"><a class=\"markdownIt-Anchor\" href=\"#区间边界的传入\"></a> 区间边界的传入</h1>\n<p>可以把 <code>l</code> 或 <code>r</code> 作为参数传进二分查找的算法当中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lowerbound</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> target)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;=r)&#123;</span><br><span class=\"line\">\t\tmid = l+(r-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[mid]&lt;target)&#123;</span><br><span class=\"line\">\t\t\tl=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tr=mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"在-golang-中使用二分查找\"><a class=\"markdownIt-Anchor\" href=\"#在-golang-中使用二分查找\"></a> 在 Golang 中使用二分查找</h1>\n<p>Golang 中提供 <code>sort.Search</code> 方法快速找出蓝色区间的第一个元素。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort.Search(<span class=\"built_in\">len</span>(nums),<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mid <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nums[mid]&gt;=target</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>该函数使用二分查找的方法，会从 <code>[0, n)</code> 中取出一个值 <code>index</code>，<code>index</code> 为 <code>[0, n)</code> 中最小的使函数 <code>f(index)</code> 为 <code>True</code> 的值，并且 <code>f(index+1)</code> 也为 <code>True</code>。（即蓝色区间元素的第一个下标）。</p>\n<p>如果无法找到该 <code>index</code> 值，则该方法为返回 <code>n</code>。</p>\n<h1 id=\"相关题目\"><a class=\"markdownIt-Anchor\" href=\"#相关题目\"></a> 相关题目</h1>\n<p>二分查找难点：</p>\n<ul>\n<li>想不到使用二分查找解决\n<ul>\n<li>存在单调性质的数组（从而导致答案二值性）适合使用二分查找</li>\n<li>「最小化最大值」和「最大化最小值」是二分查找的关键词</li>\n</ul>\n</li>\n<li>编写染色函数困难</li>\n</ul>\n<p>练习题：</p>\n<ul>\n<li>🟩 <a href=\"https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/\">2529. 正整数和负整数的最大计数 - 力扣（LeetCode）</a> 要求使用时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的解法</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/\">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/count-the-number-of-fair-pairs/\">2563. 统计公平数对的数目 - 力扣（LeetCode）</a> 关键理解点在于排序不影响答案</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/h-index-ii/description/\">275. H 指数 II - 力扣（LeetCode）</a> 考察对于红蓝染色的灵活掌握</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/koko-eating-bananas/description/\">875. 爱吃香蕉的珂珂 - 力扣（LeetCode）</a> 考察染色函数编写</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/minimum-time-to-complete-trips/description/\">2187. 完成旅途的最少时间 - 力扣（LeetCode）</a> 和上题差不多</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/maximum-number-of-alloys/description/\">2861. 最大合金数 - 力扣（LeetCode）</a> 要点在于阅读理解题目含义</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/minimize-maximum-of-array/submissions/595040078/\">2439. 最小化数组中的最大值 - 力扣（LeetCode）</a> 「最小化最大值」就是二分答案的代名词。</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/\">2517. 礼盒的最大甜蜜度 - 力扣（LeetCode）</a></li>\n</ul>\n<p>进阶练习，在 0 到 n-2 中进行二分：</p>\n<ul>\n<li>🟨 <a href=\"https://leetcode.cn/problems/find-peak-element/description/\">162. 寻找峰值 - 力扣（LeetCode）</a> 注意到，可以利用「最右侧元素」一定是蓝色的特点优化二分</li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/\">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/search-in-rotated-sorted-array/description/\">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></li>\n<li>🟨 <a href=\"https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/\">81. 搜索旋转排序数组 II - 力扣（LeetCode）</a></li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>封面图：<a href=\"https://writings.sh/post/algorithm-binary-search\">单调数组上的二分查找算法 | 春水煎茶</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1AP41137w7/?vd_source=e03d48176855fc5349b27aef691f9cdb\">二分查找 红蓝染色法_哔哩哔哩_bilibili</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1QK411d76w/?vd_source=e03d48176855fc5349b27aef691f9cdb&amp;spm_id_from=333.788.videopod.sections\">数组峰值 搜索旋转排序数组【基础算法精讲 05】_哔哩哔哩_bilibili</a></li>\n<li><a href=\"https://blog.csdn.net/qq_45808700/article/details/129247507\">算法套路三:二分查找——红蓝染色法-CSDN博客</a></li>\n<li><a href=\"https://leetcode.cn/circle/discuss/SqopEo/\">分享丨【题单】二分算法（二分答案/最小化最大值/最大化最小值/第K小） - 力扣（LeetCode）</a></li>\n</ul>\n","raw":"---\ntitle: 为什么二分查找总是写不对？\ntags:\n  - 二分查找\n  - Java\n  - Golang\n  - LeetCode\ncover: 'https://cdn.gallery.uuanqin.top/img/202501250127271.webp'\ndescription: 把握好循环不变量这个关键点就行\ncategories:\n  - 算法与数据结构\nabbrlink: 817735b\nkatex: true\ndate: 2025-01-25 01:21:35\ntop_img:\n---\n\n> [!cite]\n> 尽管第一个 [二分查找算法](https://so.csdn.net/so/search?q=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020) 于 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。\n>\n> —— Donald E.Knuth 《计算机程序设计艺术》第 3 卷《排序和查找》\n\n二分查找的逻辑本身并不复杂，但是在实际写代码的时候我们总是出错，要么少写个等于号，要么漏掉一个元素。出现这些问题的原因在于没有把握好对循环不变量的掌控。当对自己写出的循环没把握时，各种细节问题会频繁出现，从而成为我的二分恐惧症、快排恐惧症以及链表恐惧症的原因之一。\n\n本文通过红蓝染色法，通过对循环不变量的正确理解快速写出正确的二分查找代码。\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# 本文例题\n\n> [!example] 🟨 [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=problem-list-v2&envId=binary-search)\n> 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n>\n> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n>\n> 你必须设计并实现时间复杂度为 $O(\\log n)$ 的算法解决此问题。\n\n利用数组有序的性质我们可以写出二分查找算法。\n\n在解这道题之前我们先考虑以下子问题：给定一个按照非递减顺序排列的整数数组 `nums` 和一个目标值 `target`，找出给定目标值在数组中的开始位置，即大于等于 `target` 的第一个数所表示的下标。\n\n> 这个子问题和 🟩 [35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/) 十分类似。\n\n# 三种区间写法\n\n在以下的代码中，`l` 表示左指针，`r` 表示右指针，`mid` 表示中点，指向被询问的数。\n\n> [!note] 中点选取的写法以防溢出\n>\n> 在选取中点时我们通常有：`int mid = (l+r)/2;`，但是为了避免在一些语言中（C、Java）加法出现溢出的状况，我们还可以这样写：`int mid = l+(r-l)/2;`。\n>\n> 原理：$\\lfloor \\frac{l+r}{2} \\rfloor = \\lfloor \\frac{r-l+2l}{2} \\rfloor = \\lfloor \\frac{r-l}{2} +l \\rfloor = l+ \\lfloor \\frac{r-l}{2}  \\rfloor$\n\n红蓝染色法：对一个数组的数字进行染色，左边染红色，右边染蓝色。对应问题中来讲：染红色的表示 `false`，即表示 `<target` 的数；染蓝色的表示 `true`，即表示 `>=target` 的数。`right` 左移使右侧变蓝，`left` 右移使左侧变红。\n\n对于不同的区间表示方式，二分查找会有不同的写法，这也是为什么我们在看 LeetCode 题解时二分查找写法总是有一些细微差别的原因。\n\n## 闭区间写法\n\n闭区间写法要求循环开始时 `l` 和 `r` 指向的「未确定颜色」区间是闭区间。\n\n```java\npublic int lowerBound(int[] nums,int target){\n\tint l=0,r = nums.length-1;\n\tint mid;\n\twhile(l<=r){          // 【要点】while中要求l,r表示的区间不为空\n\t\tmid = l+ (r-l)/2; // 避免溢出问题\n\t\t// 染色\n\t\tif(nums[mid]<target)   // 这里写的条件是判定染红色的条件\n\t\t    // 染红色\n\t\t\tl=mid+1;      // l-1 全都小于 k\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn l;             // 或 r+1\n}\n```\n\n每一次循环后，`l-1` 前的数必定是红色的，`r+1` 以后的数必是蓝色的。这就是**循环不变量**！\n\n最终染色完毕得到以下结果：\n\n![image.png|450](https://cdn.gallery.uuanqin.top/img/202501240055648.webp)\n\n> [!example] 试一试：将 `if` 中的条件判定可以写成判定染蓝色的条件。\n\n## 左闭右开写法\n\n把握好循环不变量，你可以轻松写出另一种写法。\n\n```java\npublic int lowerBound2(int[] nums,int k){\n\tint l=0,r = nums.length; // 变动点：r指向开区间边界\n\tint mid;\n\twhile(l<r){      // 变动点：把握区间不为空\n\t\tmid = l+ (r-l)/2;\n\t\tif(nums[mid]<k){\n\t\t\tl=mid+1; \n\t\t}else{\n\t\t\tr=mid;   // 变动点\n\t\t}\n\t}\n\treturn l; // 或 r\n}\n```\n\n## 开区间写法\n\n开区间写法中，`l` 或 `r` 的变化不需要 +1。\n\n```java\npublic int lowerBound3(int[] nums,int k){\n\tint l=-1,r = nums.length; // 变动点\n\tint mid;\n\twhile(l+1!=r){  // 变动点\n\t\tmid = l+ (r-l)/2;\n\t\tif(nums[mid]<k){\n\t\t\tl=mid; \n\t\t}else{\n\t\t\tr=mid;  // 变动点\n\t\t}\n\t}\n\treturn l+1;   // 或 r   // 变动点\n}\n```\n\n三种写法喜欢那种写那种，只要把握好循环不变量想写那种写那种，都不会混乱。\n\n# `target` 的类型\n\n在前面的二分查找中，我们考虑的子问题是找出**大于等于** `target` 的第一个数所表示的下标。如果我们要求出**大于/小于/小于等于** `target` 的**第一个数/最后一个数**所表示的下标该怎么做？\n\n当数组中的数都是整数时，其实我们可以将**大于/小于/小于等于**转化为**大于等于**：\n\n- 大于 `target` 的第一个数的下标：大于等于 `target`+1 的数的下标\n- 小于 `target` 的最后一个数的下标：大于等于 `target` 的数下标 -1\n- 小于等于 `target` 的最后一个数的下标：大于等于 `target`+1 的数的下标 -1\n\n那回到题目 🟨 [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=problem-list-v2&envId=binary-search)，题目要求的就是：\n\n- 找出**大于等于** `target` 的第一个数所表示的下标\n- 找出**小于** `target`+1 的最后一个数所表示的下标\n\n我们就可以根据此写出相应的代码。\n\n# 数组中不存在符合题意的数\n\n在题目🟨 [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=problem-list-v2&envId=binary-search) 中还有个要求就是，如果不存在 `target` 需要返回 `-1`，那么我们检查二分查找（**大于等于** `target` 的第一个数所表示的下标）返回的下标对应的数组是否是 `target` 即可。如果根本不存在**大于等于** `target` 的第一个数所表示的下标，`l` 最终会到达 `nums.length`，这时候返回 `-1` 即可。\n\n因此总的代码为：\n\n```java\npublic int[] searchRange(int[] nums, int target) {\n\tif(nums.length==0)return new int[]{-1,-1};\n\tint a =  lowerBound(nums,target);\n\tint b = lowerBound(nums,target+1)-1;\n\ta = a<nums.length&&nums[a]==target? a:-1;\n\tb = b>=0&&nums[b]==target? b:-1;\n\treturn new int[]{a,b};\n}\n\npublic int lowerBound(int[] nums,int k){\n\tint l=-1,r = nums.length;\n\tint mid;\n\twhile(l+1!=r){\n\t\tmid = l+ (r-l)/2;\n\t\tif(nums[mid]<k){\n\t\t\tl=mid; \n\t\t}else{\n\t\t\tr=mid;\n\t\t}\n\t}\n\treturn r;\n}\n```\n\n复杂度分析：\n\n- 时间复杂度：$O(\\log n)$\n- 空间复杂度：$O(1)$\n\n# 区间边界的传入\n\n可以把 `l` 或 `r` 作为参数传进二分查找的算法当中。\n\n```java\npublic int lowerbound(int[] nums,int l,int r,int target){\n\tint mid;\n\twhile(l<=r){\n\t\tmid = l+(r-l)/2;\n\t\tif(nums[mid]<target){\n\t\t\tl=mid+1;\n\t\t}else{\n\t\t\tr=mid-1;\n\t\t}\n\t}\n\treturn l;\n}\n```\n\n# 在 Golang 中使用二分查找\n\nGolang 中提供 `sort.Search` 方法快速找出蓝色区间的第一个元素。\n\n```go\nsort.Search(len(nums),func (mid int) bool{\n\treturn nums[mid]>=target\n})\n```\n\n该函数使用二分查找的方法，会从 `[0, n)` 中取出一个值 `index`，`index` 为 `[0, n)` 中最小的使函数 `f(index)` 为 `True` 的值，并且 `f(index+1)` 也为 `True`。（即蓝色区间元素的第一个下标）。\n\n如果无法找到该 `index` 值，则该方法为返回 `n`。\n\n# 相关题目\n\n二分查找难点：\n\n- 想不到使用二分查找解决\n\t- 存在单调性质的数组（从而导致答案二值性）适合使用二分查找\n\t- 「最小化最大值」和「最大化最小值」是二分查找的关键词\n- 编写染色函数困难\n\n练习题：\n\n- 🟩 [2529. 正整数和负整数的最大计数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/) 要求使用时间复杂度为 $O(\\log n)$ 的解法\n- 🟨 [2300. 咒语和药水的成功对数 - 力扣（LeetCode）](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)\n- 🟨 [2563. 统计公平数对的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-the-number-of-fair-pairs/) 关键理解点在于排序不影响答案\n- 🟨 [275. H 指数 II - 力扣（LeetCode）](https://leetcode.cn/problems/h-index-ii/description/) 考察对于红蓝染色的灵活掌握\n- 🟨 [875. 爱吃香蕉的珂珂 - 力扣（LeetCode）](https://leetcode.cn/problems/koko-eating-bananas/description/) 考察染色函数编写\n- 🟨 [2187. 完成旅途的最少时间 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-time-to-complete-trips/description/) 和上题差不多\n- 🟨 [2861. 最大合金数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-alloys/description/) 要点在于阅读理解题目含义\n- 🟨 [2439. 最小化数组中的最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-maximum-of-array/submissions/595040078/) 「最小化最大值」就是二分答案的代名词。\n- 🟨 [2517. 礼盒的最大甜蜜度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/)\n\n进阶练习，在 0 到 n-2 中进行二分：\n\n- 🟨 [162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/) 注意到，可以利用「最右侧元素」一定是蓝色的特点优化二分\n- 🟨 [153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)\n- 🟨 [33. 搜索旋转排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)\n- 🟨 [81. 搜索旋转排序数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)\n\n\n\n# 本文参考\n- 封面图：[单调数组上的二分查找算法 | 春水煎茶](https://writings.sh/post/algorithm-binary-search)\n- [二分查找 红蓝染色法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=e03d48176855fc5349b27aef691f9cdb)\n- [数组峰值 搜索旋转排序数组【基础算法精讲 05】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QK411d76w/?vd_source=e03d48176855fc5349b27aef691f9cdb&spm_id_from=333.788.videopod.sections)\n- [算法套路三:二分查找——红蓝染色法-CSDN博客](https://blog.csdn.net/qq_45808700/article/details/129247507)\n- [分享丨【题单】二分算法（二分答案/最小化最大值/最大化最小值/第K小） - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/SqopEo/)","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"二分查找","api":"api/tags/二分查找.json"},{"name":"Golang","api":"api/tags/Golang.json"}]},"api":"api/posts/p/817735b.json"}