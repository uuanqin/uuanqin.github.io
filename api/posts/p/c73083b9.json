{"data":{"title":"【索引】Java 代码刷题热身","slug":"计算机语言/【索引】Java 代码刷题热身","description":"刷题前看一遍，大脑切换一下编码模式","date":"2024-10-01T16:03:13.000Z","updated":"2025-10-14T16:54:40.621Z","language":"zh-CN","comments":true,"url":"p/c73083b9/","cover":"https://cdn.gallery.uuanqin.top/img/202412100351778.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"hint\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-flame\"><path d=\"M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z\"/></svg>\n</div>\n<div class=\"callout-title-inner\">这是一篇索引文章</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>由于各种原因，我在平时写代码或刷题时，每隔一定时期的就要进行语言切换（C、C++、Python、JavaScript、Java、Go），导致一些常用的语法或写题技巧老是记混，每次卡壳都要去搜一搜。</p>\n<p>本文将随着刷题进度持续记录一些使用 Java 语言刷题时必须记住的要素，快速解决在语法方面的障碍。如果你打算开始使用 Java 语言进行刷题时，可以通篇浏览实现快速热身。</p>\n<p>本文主要内容：</p>\n<ul>\n<li>必背写法与重要函数用法</li>\n<li>集合增删改查与字符串操作速查</li>\n<li>语言无关的通用技巧</li>\n</ul>\n<p>ACM 模式下的输入输出详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/bb11ee89/\"><span class=\"bilink-pop-up\">站内文章</span>Java 在 ACM 模式下的输入输出</a></p>\n<p>本文题目难度标识：🟩简单，🟨中等，🟥困难。</p>\n<h1 id=\"java-语法基础\"><a class=\"markdownIt-Anchor\" href=\"#java-语法基础\"></a> Java 语法基础</h1>\n<h2 id=\"代码风格\"><a class=\"markdownIt-Anchor\" href=\"#代码风格\"></a> 代码风格</h2>\n<blockquote>\n<p>看看爪哇代码长啥样先，试图唤起尘封的记忆 😅😅😅</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>&#123;                             <span class=\"comment\">// 惯例一个文件一个类，文件名与类名相同</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;        <span class=\"comment\">// main 函数的写法</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 变量的声明方式</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n=<span class=\"number\">1</span>,m;                                 <span class=\"comment\">// 声明变量+初始化</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_WIDTH</span> <span class=\"operator\">=</span> <span class=\"number\">800</span>; <span class=\"comment\">// 常量值</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">MOD</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000_007</span>; <span class=\"comment\">// 数字表示</span></span><br><span class=\"line\">\t\t<span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 空值</span></span><br><span class=\"line\">\t\tMap&lt;Integer,String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// 声明对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 迭代方式</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;&#125;;                    <span class=\"comment\">// 基础for循环</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> e:nums)&#123;&#125;;                         <span class=\"comment\">// foreach 语法格式</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"操作符\"><a class=\"markdownIt-Anchor\" href=\"#操作符\"></a> 操作符</h2>\n<p>一些注意点：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>右移操作</td>\n<td>算数右移：<code>&gt;&gt;</code><br>逻辑右移：<code>&gt;&gt;&gt;</code></td>\n<td>记得和别的语言进行区分</td>\n</tr>\n<tr>\n<td>取模运算</td>\n<td>由于 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正：<br><br><code>int modulus = (sum % k + k) % k;</code></td>\n<td>相关题目：🟨 <a href=\"https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/\">974. 和可被 K 整除的子数组 - 力扣（LeetCode）</a></td>\n</tr>\n<tr>\n<td>优先级</td>\n<td>恒等运算符优先级比位运算符更大，因此正确写法为：<br><code>(num&amp;mask)==0x01</code></td>\n<td>这是语言之间普遍的优先级</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"值传递\"><a class=\"markdownIt-Anchor\" href=\"#值传递\"></a> 值传递</h2>\n<blockquote>\n<p>有时候搞不清 Java 到底是引用传递还是值传递，根本原因是「值传递」没有理解透。</p>\n</blockquote>\n<p>Java 中的函数传递本质是值传递的。</p>\n<p>函数中如果传递的参数是对象 <code>Object</code>，那么传递的只是对象的引用。我们可以利用这个引用去修改对象，但如果在函数内重新 <code>new Object()</code>，函数返回时，主函数不会发生变化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">        modifyString(str);</span><br><span class=\"line\">        System.out.println(str);  <span class=\"comment\">// 输出：Hello</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">modifyString</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        str = <span class=\"string\">&quot;World&quot;</span>;  <span class=\"comment\">// str现在指向了一个新的字符串对象 &quot;World&quot;</span></span><br><span class=\"line\">        System.out.println(str); <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    Node(<span class=\"type\">int</span> value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">        modifyNode(node);</span><br><span class=\"line\">        System.out.println(node.value);  <span class=\"comment\">// 输出：20</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">modifyNode</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">        node.value = <span class=\"number\">20</span>;  <span class=\"comment\">// 修改 node 对象的 value 属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>此外需要注意的是 Java 在传递参数给方法前，都会计算参数的值。后文聊到 <code>Map</code> 的 <code>getOrDefault</code> 方法时会提到。</p>\n<h1 id=\"正确使用面向对象\"><a class=\"markdownIt-Anchor\" href=\"#正确使用面向对象\"></a> 正确使用面向对象</h1>\n<p>讨论类的定义和静态上下文的问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个文件可以有多个类，但只能有一个与文件名同名的public类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">ClassA</span>&#123;&#125; <span class=\"comment\">// 非静态内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassB</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果在静态方法中直接引用非静态成员，Java 编译器无法确定应该访问哪个实例的成员，因此会报错。</span></span><br><span class=\"line\"><span class=\"comment\">//        ClassA a = new ClassA(); // cannot be referenced from a static context</span></span><br><span class=\"line\">        <span class=\"type\">ClassB</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassB</span>();</span><br><span class=\"line\">        <span class=\"type\">ClassC</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassC</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">func</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ClassA</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassA</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span>&#123;&#125; <span class=\"comment\">// 包级私有类</span></span><br></pre></td></tr></table></figure>\n<p>在核心代码模式中，可以利用类的静态代码块实现预处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Integer&gt;[] PRE_LIST = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 预处理以避免重复运算</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">\t    PRE_LIST.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sulotion</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"数组-arrays\"><a class=\"markdownIt-Anchor\" href=\"#数组-arrays\"></a> 数组 Arrays</h1>\n<h2 id=\"声明与初始化\"><a class=\"markdownIt-Anchor\" href=\"#声明与初始化\"></a> 声明与初始化</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一维数组</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] nums1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];                   <span class=\"comment\">// 动态初始化 初始值 0、null（对于对象数组）</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] nums2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;         <span class=\"comment\">// 静态初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] nums3 = &#123;<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;                  <span class=\"comment\">// 省掉 new int[]</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] nums4 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;v,printInfo()&#125;;     <span class=\"comment\">// 静态初始化接受变量和返回值 </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二维数组</span></span><br><span class=\"line\"><span class=\"type\">int</span>[][] a = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;&#125;;   <span class=\"comment\">// 省掉 new int[][]</span></span><br><span class=\"line\"><span class=\"type\">int</span>[][] b = &#123;&#123;&#125;,&#123;<span class=\"number\">2</span>&#125;,&#123;&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;&#125;;              <span class=\"comment\">// 省掉 new int[][]</span></span><br><span class=\"line\"><span class=\"type\">int</span> [][]m = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>][];                   <span class=\"comment\">// 每列指向一个 null 值</span></span><br><span class=\"line\"><span class=\"type\">int</span> [][]n = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>][<span class=\"number\">2</span>];                  <span class=\"comment\">// 每格初始化为 0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"排序-arrayssort\"><a class=\"markdownIt-Anchor\" href=\"#排序-arrayssort\"></a> 排序 <code>Arrays.sort</code></h2>\n<p>详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/72156dd2/\"><span class=\"bilink-pop-up\">站内文章</span>Java 中的排序</a></p>\n<h2 id=\"流-arraysstream\"><a class=\"markdownIt-Anchor\" href=\"#流-arraysstream\"></a> 流 <code>Arrays.stream</code></h2>\n<p><code>Arrays.stream()</code> 可以将数组转换为流，以使用更多的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> Arrays.stream(arr1).sum();  </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Arrays.stream(arr1).max() <span class=\"comment\">// OptionalInt  </span></span><br><span class=\"line\">\t.getAsInt(); <span class=\"comment\">// int  </span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Arrays.stream(arr1).min().getAsInt();  </span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">avg</span> <span class=\"operator\">=</span> Arrays.stream(arr1).average().getAsDouble();</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a class=\"markdownIt-Anchor\" href=\"#其他\"></a> 其他</h2>\n<p>使用 <code>Arrays.equals(array1, array2);</code> 比较两个数组的元素是否相等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较两个数组是否相等</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span>[] array2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span>[] array3 = array1;</span><br><span class=\"line\">Arrays.equals(array1, array2); <span class=\"comment\">// 判断两个数组是否相等。以上3个数组使用Arrays.equals比较均为true</span></span><br></pre></td></tr></table></figure>\n<p><code>Arrays.copyOf()</code> 方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。<code>Arrays.copyOf()</code> 的第二个参数指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span>[] arr2 = Arrays.copyOf(arr1, <span class=\"number\">3</span>); <span class=\"comment\">// arr2 = [1,2,3]</span></span><br><span class=\"line\"><span class=\"type\">int</span>[] arr3 = Arrays.copyOf(arr1, <span class=\"number\">10</span>); <span class=\"comment\">// arr3 = [1,2,3,4,5,0,0,0,0,0]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>更多关于 <code>Arrays.copyOf()</code> 的源码解读详见文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/6b5aa645/\"><span class=\"bilink-pop-up\">站内文章</span>Java List 的 toArray 方法</a>。</p>\n</blockquote>\n<p><code>Arrays.fill()</code> 将指定的 int 值分配给指定 int 型数组的每个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">Arrays.fill(arr1, <span class=\"number\">9</span>); <span class=\"comment\">// arr = [9,9,9,9,9]</span></span><br></pre></td></tr></table></figure>\n<p><code>Arrays.setAll()</code> 将对数组的每个元素进行处理。<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/2c5c0eb2/\"><span class=\"bilink-pop-up\">站内文章</span>Lambda 表达式</a> 传入的参数表示当前元素的下标。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">Arrays.setAll(arr, i -&gt; i); <span class=\"comment\">// [0,1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串-string\"><a class=\"markdownIt-Anchor\" href=\"#字符串-string\"></a> 字符串 String</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串相等判断</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;                     <span class=\"comment\">// 定义字符串常量</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>);         </span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isEquals1</span> <span class=\"operator\">=</span> str1.equals(str2);     <span class=\"comment\">// 字符串的比较 true</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isEquals2</span> <span class=\"operator\">=</span> str1 == str2           <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th><code>String</code></th>\n<th><code>StringBuffer</code>/<code>StringBuilder</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>增</td>\n<td><code>+</code> 操作符。注意从左到右结合性</td>\n<td><code>sb.append(str);</code><br><code>sb.insert(int offset, str);</code></td>\n</tr>\n<tr>\n<td>删</td>\n<td>不可变类</td>\n<td><code>sb.delete(start, end)</code><br><code>sb.deleteCharAt()</code></td>\n</tr>\n<tr>\n<td>改（替换字符）</td>\n<td><code>replace(char oldChar, char newChar)</code>：返回新的字符串，原字符串不改变。<br><code>replaceAll(String regex, String replacement)</code> ：返回新的字符串，原字符串不改变。<br><code>replaceFirst(String regex, String replacement)</code>：返回新的字符串，原字符串不改变。</td>\n<td><code>sb.replace(start,end, str);</code>：将起始位置为 start，结束位置为 end-1 的子串替换为 str。<strong>不生成新的 StringBuilder 对象，在原来的 StringBuilder 对象上修改</strong>。<br><br><code>sb.setCharAt(index,c)</code></td>\n</tr>\n<tr>\n<td>查字符</td>\n<td><code>str.charAt(index);</code></td>\n<td>相同</td>\n</tr>\n<tr>\n<td rowspan=\"2\">查下标</td>\n<td>查字符第一次出现的位置 <code>str.indexOf(c)</code></td>\n<td>❌</td>\n</tr>\n<tr>\n<td>查字符串第一次出现的位置 <code>str.indexOf(str)</code></td>\n<td rowspan=\"2\">相同</td>\n</tr>\n<tr>\n<td>长度</td>\n<td><code>str.length();</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>StringBuilder</code> 还提供以下函数：</p>\n<ul>\n<li><code>sb.reverse()</code>：反转字符串</li>\n<li><code>sb.toString()</code>：返回字符串</li>\n<li><code>sb.capacity()</code>：返回当前容量。注意，和返回有效长度 <code>sb.length()</code> 不一样！</li>\n</ul>\n<p><code>String</code> 子串的获取：</p>\n<ul>\n<li><code>str.substring(int beginIndex)</code></li>\n<li><code>str.substring(int beginIndex，int endIndex)</code>。不含 <code>endIndex</code>。</li>\n</ul>\n<p><code>String</code> 大小写转换：</p>\n<ul>\n<li><code>str.toUpperCase()</code></li>\n<li><code>str.toLowerCase()</code></li>\n</ul>\n<p><code>String</code> 的拆解与合成：</p>\n<ul>\n<li><code>str.split(&quot;delimiter&quot;);</code></li>\n<li><code>String.join(&quot;delimiter&quot;,&quot;str1&quot;,&quot;str2&quot;);</code></li>\n</ul>\n<h2 id=\"字符-字符串与数字之间的转换\"><a class=\"markdownIt-Anchor\" href=\"#字符-字符串与数字之间的转换\"></a> 字符、字符串与数字之间的转换</h2>\n<p>单步骤转换：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202509102128414.webp\" alt=\"image.png\" /></p>\n<p>一招静态方法 <code>valueOf</code> 可以解决大部分转换难题。被转的放里面。</p>\n<blockquote>\n<p><code>Character[]</code>  <code>char[]</code> 互转详见：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/72156dd2/\"><span class=\"bilink-pop-up\">站内文章</span>Java 中的排序</a>。</p>\n</blockquote>\n<p>我们在处理输入输出字符串题目时的连招：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把字符串转换成字符数组处理，更丝滑。不然只能疯狂 s.charAt(i) 咯</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">mySolution</span><span class=\"params\">(String s)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>[] cc = s.toCharArray(); <span class=\"comment\">// 将题目输入字符串 `s` 转换为临时数组 `cc`</span></span><br><span class=\"line\">\t<span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t\t对数组 `cc` 进行处理 </span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(cc);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 中的构造方法和其他方法几乎是完全一样的。<code>StringBuilder</code> 非线程安全，但速度更快。<strong>一般情况下（比如刷题）推荐使用 <code>StringBuilder</code></strong>。</p>\n<p><code>String</code> 保留小数精度的处理可看 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/bb11ee89/\"><span class=\"bilink-pop-up\">站内文章</span>Java 在 ACM 模式下的输入输出</a>。</p>\n<h1 id=\"函数\"><a class=\"markdownIt-Anchor\" href=\"#函数\"></a> 函数</h1>\n<h2 id=\"函数返回双值\"><a class=\"markdownIt-Anchor\" href=\"#函数返回双值\"></a> 函数返回双值</h2>\n<p>Java 中没有类似 Python 那样直接返回多值函数的语法。一种常见的返回双值的函数写法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map.Entry&lt;String,String&gt; <span class=\"title function_\">func</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AbstractMap</span>.SimpleEntry&lt;&gt;(<span class=\"string\">&quot;key1&quot;</span>,<span class=\"string\">&quot;val1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">\tMap.Entry&lt;String,String&gt; keyAndValue = func();</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">param1</span> <span class=\"operator\">=</span> keyAndValue.getKey();</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">param2</span> <span class=\"operator\">=</span> keyAndValue.getValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基础函数\"><a class=\"markdownIt-Anchor\" href=\"#基础函数\"></a> 基础函数</h2>\n<p>数学函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数学与常量</span></span><br><span class=\"line\">Math.max(num1,num2);</span><br><span class=\"line\">Math.min(num1,num2);</span><br><span class=\"line\">Math.abs(num);</span><br><span class=\"line\">Math.pow(base, exp);</span><br><span class=\"line\">Math.log(num); <span class=\"comment\">// 以 e 为底。对于非常规底数可使用换底公式 log_x(y)=ln(y)/ln(x);</span></span><br><span class=\"line\">Math.floor(f);</span><br><span class=\"line\">Math.ceil(f);</span><br><span class=\"line\">Integer.MAX_VALUE;</span><br><span class=\"line\">Integer.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 随机数</span></span><br><span class=\"line\"><span class=\"type\">Random</span> <span class=\"variable\">rand</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>(); <span class=\"comment\">// java.util.Random</span></span><br><span class=\"line\">rand.nextInt(num); <span class=\"comment\">// int [0,num) </span></span><br><span class=\"line\">Math.random(); <span class=\"comment\">// double [0.0,1.0)</span></span><br></pre></td></tr></table></figure>\n<p>长度的获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 【知识点】长度的获取</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len1</span> <span class=\"operator\">=</span> nums.length;                    <span class=\"comment\">// 数组长度</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len2</span> <span class=\"operator\">=</span> str.length();                   <span class=\"comment\">// 字符串长度</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len3</span> <span class=\"operator\">=</span> map.size();                     <span class=\"comment\">// 集合类长度</span></span><br></pre></td></tr></table></figure>\n<p>当 <code>long</code> 不够用时，可以使用 <code>BigInteger</code> 。大整数 <code>BigInteger</code> 的使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;  <span class=\"comment\">// 记得导包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigInteger</span>(<span class=\"string\">&quot;123456789012345678901234567890&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> BigInteger.valueOf(<span class=\"number\">1234567890L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常量</span></span><br><span class=\"line\">BigInteger.ZERO     <span class=\"comment\">// 0</span></span><br><span class=\"line\">BigInteger.ONE      <span class=\"comment\">// 1</span></span><br><span class=\"line\">BigInteger.TEN      <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运算</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> a.add(b);<span class=\"comment\">// 加法</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">difference</span> <span class=\"operator\">=</span> a.subtract(b); <span class=\"comment\">// 减法</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> a.multiply(b);    <span class=\"comment\">// 乘法</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">quotient</span> <span class=\"operator\">=</span> a.divide(b);     <span class=\"comment\">// 除法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换为基本类型（可能丢失精度）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">intValue</span> <span class=\"operator\">=</span> a.intValue();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">longValue</span> <span class=\"operator\">=</span> a.longValue();</span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">floatValue</span> <span class=\"operator\">=</span> a.floatValue();</span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">doubleValue</span> <span class=\"operator\">=</span> a.doubleValue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换为字符串</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> a.toString();             <span class=\"comment\">// 十进制</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">binaryStr</span> <span class=\"operator\">=</span> a.toString(<span class=\"number\">2</span>);      <span class=\"comment\">// 二进制</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">hexStr</span> <span class=\"operator\">=</span> a.toString(<span class=\"number\">16</span>);        <span class=\"comment\">// 十六进制</span></span><br></pre></td></tr></table></figure>\n<p>大浮点数 <code>BigDecimal</code> 的使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;10.5&quot;</span>);  <span class=\"comment\">// 推荐使用字符串构造</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"number\">10.5</span>);    <span class=\"comment\">// 避免使用 double 构造，可能不精确（不推荐）</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">num3</span> <span class=\"operator\">=</span> BigDecimal.valueOf(<span class=\"number\">10.5</span>); <span class=\"comment\">// 推荐（内部优化）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运算</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> a.add(b); </span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">diff</span> <span class=\"operator\">=</span> a.subtract(b); </span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> a.multiply(b); </span><br><span class=\"line\"><span class=\"comment\">// 除法（需指定舍入模式）</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">quotient</span> <span class=\"operator\">=</span> a.divide(b, <span class=\"number\">2</span>, RoundingMode.HALF_UP); <span class=\"comment\">//（保留2位小数）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常用舍入模式</span></span><br><span class=\"line\">RoundingMode.HALF_UP <span class=\"comment\">//四舍五入（银行家舍入）</span></span><br><span class=\"line\">RoundingMode.UP      <span class=\"comment\">//向远离零的方向舍入</span></span><br><span class=\"line\">RoundingMode.DOWN    <span class=\"comment\">//向零方向舍入</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"集合-collectionmap\"><a class=\"markdownIt-Anchor\" href=\"#集合-collectionmap\"></a> 集合 <code>Collection</code>/<code>Map</code></h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202408161619164.webp\" alt=\"image.png\" /></p>\n<p>详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/182af697/\"><span class=\"bilink-pop-up\">站内文章</span>Java 集合的使用</a></p>\n<h1 id=\"调试\"><a class=\"markdownIt-Anchor\" href=\"#调试\"></a> 调试</h1>\n<p>指的是在机试过程中我们所能做的调试。</p>\n<h2 id=\"标准化输出方法\"><a class=\"markdownIt-Anchor\" href=\"#标准化输出方法\"></a> 标准化输出方法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(object); <span class=\"comment\">// 标准输出</span></span><br><span class=\"line\">System.out.print();         <span class=\"comment\">// 输出不换行</span></span><br><span class=\"line\"><span class=\"comment\">// 原理：String.valueOf(object) -&gt; object.toString() </span></span><br></pre></td></tr></table></figure>\n<h2 id=\"各式对象的-tostring\"><a class=\"markdownIt-Anchor\" href=\"#各式对象的-tostring\"></a> 各式对象的 <code>toString()</code></h2>\n<p><code>Object</code> 的 <code>toString()</code> 默认实现并不直观。</p>\n<p>对数组进行「友好」的字符串转换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.toString(arr);<span class=\"comment\">// 将数组转换为可视字符串</span></span><br></pre></td></tr></table></figure>\n<p><code>ArrayList</code>、<code>HashSet</code> 继承了 <code>AbstractCollection</code>，里面重写了 <code>toString</code> 。我们可以这样直观查看 <code>ArrayList</code> 中的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(c);</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3,4,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者炫技：</span></span><br><span class=\"line\">c.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>附 <code>AbstractCollection</code> 中 <code>toString</code> 源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tIterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (! it.hasNext())</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;[]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">\tsb.append(<span class=\"string\">&#x27;[&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">\t\t<span class=\"comment\">// sb.append 调用了 String.valueOf()</span></span><br><span class=\"line\">\t\tsb.append(e == <span class=\"built_in\">this</span> ? <span class=\"string\">&quot;(this Collection)&quot;</span> : e); </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (! it.hasNext())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> sb.append(<span class=\"string\">&#x27;]&#x27;</span>).toString();</span><br><span class=\"line\">\t\tsb.append(<span class=\"string\">&#x27;,&#x27;</span>).append(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"多线程编程\"><a class=\"markdownIt-Anchor\" href=\"#多线程编程\"></a> 多线程编程</h1>\n<p>本章节主要就是背单词！</p>\n<p>LeetCode 中的多线程编程题目不多，掌握以下同步模式可解决大部分的问题：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>同步模式——顺序控制</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>同步模式——交替输出</a></li>\n</ul>\n<h2 id=\"semaphore-信号量\"><a class=\"markdownIt-Anchor\" href=\"#semaphore-信号量\"></a> <code>Semaphore</code> 信号量</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Semaphore</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">s.acquire(); <span class=\"comment\">// s.acquire(2);</span></span><br><span class=\"line\">s.release(); <span class=\"comment\">// s.release(2);</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"语言无关的通用技巧\"><a class=\"markdownIt-Anchor\" href=\"#语言无关的通用技巧\"></a> 语言无关的通用技巧</h1>\n<p>数学常识详看：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/218b1b4c/\"><span class=\"bilink-pop-up\">站内文章</span>算法题常用数学算法和技巧</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// double计算时提高精度</span></span><br><span class=\"line\"><span class=\"type\">double</span> y;</span><br><span class=\"line\"><span class=\"type\">int</span> iy;</span><br><span class=\"line\">iy = (<span class=\"type\">int</span>)((y) + <span class=\"number\">0.5</span>) / <span class=\"number\">1.0</span>) <span class=\"comment\">// 先四舍五入到合适精度</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(Math.abs(iy-y)&lt;<span class=\"number\">0.0001</span>)y=iy;   <span class=\"comment\">// 视情况设范围</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用类型转换将字符类型对应到相应的数组位置。适用于字符串内容均为1种字符的情况。</span></span><br><span class=\"line\">arr1[str.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;   <span class=\"comment\">// a 放到数组下标 0，z放到数组下标 25</span></span><br><span class=\"line\">arr2[str.charAt(i)-<span class=\"string\">&#x27;0&#x27;</span>]++;</span><br><span class=\"line\">arr3[str.charAt(i)-<span class=\"string\">&#x27;A&#x27;</span>]++;</span><br></pre></td></tr></table></figure>\n<p>有时候有些对输入顺序有要求的，我们可以稍微调整一下顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数参数交换</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">foo</span><span class=\"params\">(<span class=\"type\">int</span> param1, <span class=\"type\">int</span> param2)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (...)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在指定条件下调换顺序，省去手动转移的麻烦</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> foo(param2, param1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t    按既定参数顺序的函数逻辑</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"魔数\"><a class=\"markdownIt-Anchor\" href=\"#魔数\"></a> 魔数</h2>\n<p>写题时常见的初始化最大最小值：</p>\n<ul>\n<li>最大值：<code>0x3f3f3f3f</code>。</li>\n<li>最小值：<code>0xc0c0c0c0</code>。</li>\n</ul>\n<p>根据不同题目要求，我们还可以将最大值设置为 <code>Integer.MAX_VALUE/2</code>（防止相加溢出）</p>\n\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">为什么 ACM 中经常使用 <code>0x3f3f3f3f</code> 作为整型的最大值？</div>\n</div>\n<div class=\"callout-content\"><p>原因如下：</p>\n<ol>\n<li><code>0x3f3f3f3f</code> 的十进制是 <code>1,061,109,567</code>，是 <code>10^9</code> 级别的，而一般场合下的数据都是小于 <code>10^9</code> 的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。而平时用的 <code>Integer.MAX_VALUE=0x7fffffff</code> 不能满足“无穷大加一个有穷的数依然是无穷大”这个条件，加上一个数后，根据补码规范它会变成了一个很小的负数。</li>\n<li><code>0x3f3f3f3f</code> 的 2 倍还是一个「无穷大」的数。</li>\n<li><code>0x3f3f3f3f</code> 的每 8 位（每个字节）都是相同的。我们在程序设计中经常需要使用 <code>memset(a, val, sizeof(a))</code> 初始化一个数组 <code>a</code>，该语句把数值 <code>val</code>（<code>0x00</code>~<code>0xFF</code>）填充到数组 <code>a</code> 的每个字节上，所以用 <code>memset</code> 只能赋值出“每 8 位都相同”的 <code>int</code>。当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 <code>memset(a, 0x3f, sizeof(a))</code> 给数组赋 <code>0x3f3f3f3f</code> 的值来代替。</li>\n</ol>\n</div></div><p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span> 次方级别的大质数：<code>1000000007</code>。在一些题目中会很有用：🟥 <a href=\"https://codeforces.com/problemset/problem/1632/D\">Problem - 1632D - Codeforces</a>。对于多数题目来说，这个数常用于将结果取余。</p>\n<h2 id=\"模板写法\"><a class=\"markdownIt-Anchor\" href=\"#模板写法\"></a> 模板写法</h2>\n<h3 id=\"单调栈队列\"><a class=\"markdownIt-Anchor\" href=\"#单调栈队列\"></a> 单调栈/队列</h3>\n<p>模板写法：</p>\n<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设数组A从左到右遍历</span></span><br><span class=\"line\">insert x <span class=\"comment\">// x 为数组中某一个元素</span></span><br><span class=\"line\"><span class=\"comment\">// 假设维护的是一个单调递增的栈（自栈顶向下单调递增）</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> !stack.empty() &amp;&amp; stack.top()&lt;x</span><br><span class=\"line\">    y = stack.pop() <span class=\"comment\">// 这也意味着y右侧第一个比y大的元素是x</span></span><br><span class=\"line\">stack.push(x)</span><br></pre></td></tr></table></figure>\n<p>更多内容参考：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/509c69f4/\"><span class=\"bilink-pop-up\">站内文章</span>一些特殊的栈：单调栈、最小栈</a>。</p>\n<h3 id=\"滑动窗口\"><a class=\"markdownIt-Anchor\" href=\"#滑动窗口\"></a> 滑动窗口</h3>\n<p>样例题：🟨 <a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&amp;envId=top-100-liked\">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">\tSet&lt;Character&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(); <span class=\"comment\">// 滑动窗口中的内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 左指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123; <span class=\"comment\">// 右指针</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(set.contains(s.charAt(i)))&#123;</span><br><span class=\"line\">\t\t\tset.remove(s.charAt(l)); <span class=\"comment\">// 弹出滑动窗口内容</span></span><br><span class=\"line\">\t\t\tl++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tset.add(s.charAt(i)); </span><br><span class=\"line\">\t\tres= Math.max(set.size(),res); <span class=\"comment\">// 更新答案</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方向移动\"><a class=\"markdownIt-Anchor\" href=\"#方向移动\"></a> 方向移动</h3>\n<p>如果需要物体在规定的棋盘下（比如 <code>n*n</code>）进行方向移动，可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义方向</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span>[][] directions = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[][]&#123;</span><br><span class=\"line\">\t&#123;-<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,-<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125; <span class=\"comment\">// 上下左右</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历方向</span></span><br><span class=\"line\"><span class=\"comment\">// 传入当前位置i,j，以及棋盘</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recursion</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> j, <span class=\"type\">int</span>[] board)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 省略此处递归边界判断 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;directions.length;k++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">newI</span> <span class=\"operator\">=</span> i + directions[k][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">newJ</span> <span class=\"operator\">=</span> j + directions[k][<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(newI&gt;=<span class=\"number\">0</span>&amp;&amp;newI&lt;n&amp;&amp;newJ&gt;=<span class=\"number\">0</span>&amp;&amp;newJ&lt;=n)&#123; <span class=\"comment\">// 边界判断</span></span><br><span class=\"line\">\t\t\trecursion(newI,newJ,board);        <span class=\"comment\">// 走下一步</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相关题目：🟨 <a href=\"https://leetcode.cn/problems/knight-probability-in-chessboard/description/\">688. 骑士在棋盘上的概率 - 力扣（LeetCode）</a></p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>我久远积灰的笔记</li>\n<li><a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95&amp;topicId=372\">牛客网在线编程_算法笔试_输入输出练习 (nowcoder.com)</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43312993/article/details/106348464\">java中String和StringBuilder的replace方法-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/qq_46634307/article/details/126283200\">Java-修改 String 指定位置的字符最全方法总结（StringBuilder 和 StringBuffer 的使用以及区别）_string替换指定位置字符-CSDN博客</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2155412\">Java保留两位小数的几种写法总结[通俗易懂]-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44015669/article/details/90113967\">Java：获取子字符串 substring()_java substring(10)-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/andy_gfz/article/details/78211180\">java.util.TreeSet.floor()方法和java.util.TreeSet.ceiling()方法_treeset的ceil和floor-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/ljxtt/p/13514346.html\">大质数表 - ljxtt - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/qq_31267769/article/details/88890612\">0x3f3f3f3f是什么意思？？？-CSDN博客</a></li>\n<li><a href=\"https://deepinout.com/java/java-collection/g_set-remove-method-in-java-with-examples.html\">Java中的Set remove()方法及其示例|极客笔记</a></li>\n<li><a href=\"https://blog.csdn.net/iamlihongwei/article/details/96110470\">Java中List，Set，数组的互相转换_java 1.8 list转set-CSDN博客</a></li>\n</ul>\n","raw":"---\ntitle: 【索引】Java 代码刷题热身\ntags:\n  - LeetCode\n  - Java\n  - 集合\n  - 字符串\n  - 牛客\ncover: 'https://cdn.gallery.uuanqin.top/img/202412100351778.webp'\ndescription: 刷题前看一遍，大脑切换一下编码模式\ncategories:\n  - 计算机语言\nabbrlink: c73083b9\ndate: 2024-10-02 00:03:13\ntop_img:\n---\n\n> [!hint] 这是一篇索引文章\n\n由于各种原因，我在平时写代码或刷题时，每隔一定时期的就要进行语言切换（C、C++、Python、JavaScript、Java、Go），导致一些常用的语法或写题技巧老是记混，每次卡壳都要去搜一搜。\n\n本文将随着刷题进度持续记录一些使用 Java 语言刷题时必须记住的要素，快速解决在语法方面的障碍。如果你打算开始使用 Java 语言进行刷题时，可以通篇浏览实现快速热身。\n\n本文主要内容：\n\n- 必背写法与重要函数用法\n- 集合增删改查与字符串操作速查\n- 语言无关的通用技巧\n\nACM 模式下的输入输出详看：[[Java 在 ACM 模式下的输入输出]]\n\n本文题目难度标识：🟩简单，🟨中等，🟥困难。\n\n# Java 语法基础\n\n## 代码风格\n\n> 看看爪哇代码长啥样先，试图唤起尘封的记忆 😅😅😅\n\n```java\npublic class Solution{                             // 惯例一个文件一个类，文件名与类名相同\n\tpublic static void main(String[] args){        // main 函数的写法\n\t\t// 变量的声明方式\n\t\tint n=1,m;                                 // 声明变量+初始化\n\t\tfinal int MAX_WIDTH = 800; // 常量值\n\t\tint MOD = 1_000_000_007; // 数字表示\n\t\tObject obj = null; // 空值\n\t\tMap<Integer,String> map = new HashMap<>(); // 声明对象\n\n\t\t// 迭代方式\n\t\tfor(int i=0;i<3;i++){};                    // 基础for循环\n\t\tfor(int e:nums){};                         // foreach 语法格式\n\t}\n}\n```\n\n## 操作符\n\n一些注意点：\n\n| 操作   | 说明                                                                             | 备注                                                                                                                 |\n| ---- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------ |\n| 右移操作 | 算数右移：`>>`<br>逻辑右移：`>>>`                                                        | 记得和别的语言进行区分                                                                                                        |\n| 取模运算 | 由于 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正：<br><br>`int modulus = (sum % k + k) % k;` | 相关题目：🟨 [974. 和可被 K 整除的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/) |\n| 优先级  | 恒等运算符优先级比位运算符更大，因此正确写法为：<br>`(num&mask)==0x01`                                 | 这是语言之间普遍的优先级                                                                                                       |\n\n## 值传递\n\n> 有时候搞不清 Java 到底是引用传递还是值传递，根本原因是「值传递」没有理解透。\n\nJava 中的函数传递本质是值传递的。\n\n函数中如果传递的参数是对象 `Object`，那么传递的只是对象的引用。我们可以利用这个引用去修改对象，但如果在函数内重新 `new Object()`，函数返回时，主函数不会发生变化。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Hello\";\n        modifyString(str);\n        System.out.println(str);  // 输出：Hello\n    }\n\n    public static void modifyString(String str) {\n        str = \"World\";  // str现在指向了一个新的字符串对象 \"World\"\n        System.out.println(str); // 输出：World\n    }\n}\n```\n\n```java\nclass Node {\n    int value;\n    Node(int value) {\n        this.value = value;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Node node = new Node(10);\n        modifyNode(node);\n        System.out.println(node.value);  // 输出：20\n    }\n\n    public static void modifyNode(Node node) {\n        node.value = 20;  // 修改 node 对象的 value 属性\n    }\n}\n\n```\n\n此外需要注意的是 Java 在传递参数给方法前，都会计算参数的值。后文聊到 `Map` 的 `getOrDefault` 方法时会提到。\n\n# 正确使用面向对象\n\n讨论类的定义和静态上下文的问题：\n\n```java\n// 一个文件可以有多个类，但只能有一个与文件名同名的public类\npublic class Solution{\n\n    class ClassA{} // 非静态内部类\n    static class ClassB{}\n    public static void main(String[] args){\n        // 如果在静态方法中直接引用非静态成员，Java 编译器无法确定应该访问哪个实例的成员，因此会报错。\n//        ClassA a = new ClassA(); // cannot be referenced from a static context\n        ClassB b = new ClassB();\n        ClassC c = new ClassC();\n    }\n\n    public void func(){\n        ClassA a = new ClassA();\n    }\n\n}\n\nclass ClassC{} // 包级私有类\n```\n\n在核心代码模式中，可以利用类的静态代码块实现预处理：\n\n```java\nclass Solution {\n    private static final List<Integer>[] PRE_LIST = new ArrayList[100];\n\n\t// 预处理以避免重复运算\n    static {\n\t    PRE_LIST.add(1);\n    }\n\n    public int sulotion(int[] nums, int k) {\n        int ans = 0;\n        // ...\n        return ans;\n    }\n}\n\n```\n\n# 数组 Arrays\n\n## 声明与初始化\n\n```java\n// 一维数组\nint[] nums1 = new int[n];                   // 动态初始化 初始值 0、null（对于对象数组）\nint[] nums2 = new int[]{1,2,3,4,5};         // 静态初始化\nint[] nums3 = {5,4,3,2,1};                  // 省掉 new int[]\nint[] nums4 = new int[]{v,printInfo()};     // 静态初始化接受变量和返回值 \n\n\n// 二维数组\nint[][] a = {{1,2,3},{4,5,6},{7,8,9,10}};   // 省掉 new int[][]\nint[][] b = {{},{2},{},{3,5}};              // 省掉 new int[][]\nint [][]m = new int[3][];                   // 每列指向一个 null 值\nint [][]n = new int[3][2];                  // 每格初始化为 0\n```\n\n## 排序 `Arrays.sort`\n\n详看：[[Java 中的排序]]\n\n## 流 `Arrays.stream`\n\n`Arrays.stream()` 可以将数组转换为流，以使用更多的操作。\n\n```java\nint[] arr1 = {1, 2, 3, 4, 5};  \nint sum = Arrays.stream(arr1).sum();  \nint max = Arrays.stream(arr1).max() // OptionalInt  \n\t.getAsInt(); // int  \nint min = Arrays.stream(arr1).min().getAsInt();  \ndouble avg = Arrays.stream(arr1).average().getAsDouble();\n```\n\n## 其他\n\n使用 `Arrays.equals(array1, array2);` 比较两个数组的元素是否相等。\n\n```java\n// 比较两个数组是否相等\nint[] array1 = new int[]{1,2,3};\nint[] array2 = new int[]{1,2,3};\nint[] array3 = array1;\nArrays.equals(array1, array2); // 判断两个数组是否相等。以上3个数组使用Arrays.equals比较均为true\n```\n\n`Arrays.copyOf()` 方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。`Arrays.copyOf()` 的第二个参数指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。\n\n```java\nint[] arr1 = {1, 2, 3, 4, 5};\nint[] arr2 = Arrays.copyOf(arr1, 3); // arr2 = [1,2,3]\nint[] arr3 = Arrays.copyOf(arr1, 10); // arr3 = [1,2,3,4,5,0,0,0,0,0]\n```\n\n> 更多关于 `Arrays.copyOf()` 的源码解读详见文章：[[Java List 的 toArray 方法]]。\n\n`Arrays.fill()` 将指定的 int 值分配给指定 int 型数组的每个元素。\n\n```java\nint[] arr1 = {1, 2, 3, 4, 5};  \nArrays.fill(arr1, 9); // arr = [9,9,9,9,9]\n```\n\n`Arrays.setAll()` 将对数组的每个元素进行处理。[[函数式编程与 Java 中的 Lambda 表达式|Lambda 表达式]] 传入的参数表示当前元素的下标。\n\n```java\nInteger[] arr = new Integer[10];  \nArrays.setAll(arr, i -> i); // [0,1,2,3,4,5,6,7,8,9]\n```\n\n# 字符串 String\n\n```java\n// 字符串相等判断\nString str1 = \"hello\";                     // 定义字符串常量\nString str2 = new String(\"hello\");         \nboolean isEquals1 = str1.equals(str2);     // 字符串的比较 true\nboolean isEquals2 = str1 == str2           // false\n```\n\n| 操作      | `String`                                                                                                                                                                                        | `StringBuffer`/`StringBuilder`                                                                                                                        |\n| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 增       | `+` 操作符。注意从左到右结合性                                                                                                                                                                               | `sb.append(str);`<br>`sb.insert(int offset, str);`                                                                                                    |\n| 删       | 不可变类                                                                                                                                                                                            | `sb.delete(start, end)`<br>`sb.deleteCharAt()`                                                                                                        |\n| 改（替换字符） | `replace(char oldChar, char newChar)`：返回新的字符串，原字符串不改变。<br>`replaceAll(String regex, String replacement)` ：返回新的字符串，原字符串不改变。<br>`replaceFirst(String regex, String replacement)`：返回新的字符串，原字符串不改变。 | `sb.replace(start,end, str);`：将起始位置为 start，结束位置为 end-1 的子串替换为 str。**不生成新的 StringBuilder 对象，在原来的 StringBuilder 对象上修改**。<br><br>`sb.setCharAt(index,c)` |\n| 查字符     | `str.charAt(index);`                                                                                                                                                                            | 相同                                                                                                                                                    |\n| 查下标     | 查字符第一次出现的位置 `str.indexOf(c)`                                                                                                                                                                    | ❌                                                                                                                                                     |\n| 查下标     | 查字符串第一次出现的位置 `str.indexOf(str)`                                                                                                                                                                 | 相同                                                                                                                                                    |\n| 长度      | `str.length();`                                                                                                                                                                                 | 相同                                                                                                                                                    |\n\n`StringBuilder` 还提供以下函数：\n\n- `sb.reverse()`：反转字符串\n- `sb.toString()`：返回字符串\n- `sb.capacity()`：返回当前容量。注意，和返回有效长度 `sb.length()` 不一样！\n\n`String` 子串的获取：\n\n- `str.substring(int beginIndex)`\n- `str.substring(int beginIndex，int endIndex)`。不含 `endIndex`。\n\n`String` 大小写转换：\n\n- `str.toUpperCase()`\n- `str.toLowerCase()`\n\n`String` 的拆解与合成：\n\n- `str.split(\"delimiter\");`\n- `String.join(\"delimiter\",\"str1\",\"str2\");`\n\n## 字符、字符串与数字之间的转换\n\n单步骤转换：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202509102128414.webp)\n\n一招静态方法 `valueOf` 可以解决大部分转换难题。被转的放里面。\n\n> `Character[]`  `char[]` 互转详见：[[Java 中的排序]]。\n\n我们在处理输入输出字符串题目时的连招：\n\n```java\n// 把字符串转换成字符数组处理，更丝滑。不然只能疯狂 s.charAt(i) 咯\npublic String mySolution(String s){\n\tchar[] cc = s.toCharArray(); // 将题目输入字符串 `s` 转换为临时数组 `cc`\n\t/* \n\t\t对数组 `cc` 进行处理 \n\t*/\n\treturn new String(cc);\n}\n```\n\n`StringBuffer` 和 `StringBuilder` 中的构造方法和其他方法几乎是完全一样的。`StringBuilder` 非线程安全，但速度更快。**一般情况下（比如刷题）推荐使用 `StringBuilder`**。\n\n`String` 保留小数精度的处理可看 [[Java 在 ACM 模式下的输入输出]]。\n\n# 函数\n\n## 函数返回双值\n\nJava 中没有类似 Python 那样直接返回多值函数的语法。一种常见的返回双值的函数写法如下：\n\n```java\npublic static Map.Entry<String,String> func() {\n\treturn new AbstractMap.SimpleEntry<>(\"key1\",\"val1\");\n}\n\npublic static void main(String[] args){\n\tMap.Entry<String,String> keyAndValue = func();\n\tString param1 = keyAndValue.getKey();\n\tString param2 = keyAndValue.getValue();\n}\n```\n\n## 基础函数\n\n数学函数：\n\n```java\n// 数学与常量\nMath.max(num1,num2);\nMath.min(num1,num2);\nMath.abs(num);\nMath.pow(base, exp);\nMath.log(num); // 以 e 为底。对于非常规底数可使用换底公式 log_x(y)=ln(y)/ln(x);\nMath.floor(f);\nMath.ceil(f);\nInteger.MAX_VALUE;\nInteger.MIN_VALUE;\n\n// 随机数\nRandom rand = new Random(); // java.util.Random\nrand.nextInt(num); // int [0,num) \nMath.random(); // double [0.0,1.0)\n```\n\n长度的获取：\n\n```java\n// 【知识点】长度的获取\nint len1 = nums.length;                    // 数组长度\nint len2 = str.length();                   // 字符串长度\nint len3 = map.size();                     // 集合类长度\n```\n\n当 `long` 不够用时，可以使用 `BigInteger` 。大整数 `BigInteger` 的使用：\n\n```java\nimport java.math.BigInteger;  // 记得导包\n\nBigInteger a = new BigInteger(\"123456789012345678901234567890\");\nBigInteger b = BigInteger.valueOf(1234567890L);\n\n// 常量\nBigInteger.ZERO     // 0\nBigInteger.ONE      // 1\nBigInteger.TEN      // 10\n\n// 运算\nBigInteger sum = a.add(b);// 加法\nBigInteger difference = a.subtract(b); // 减法\nBigInteger product = a.multiply(b);    // 乘法\nBigInteger quotient = a.divide(b);     // 除法\n\n// 转换为基本类型（可能丢失精度）\nint intValue = a.intValue();\nlong longValue = a.longValue();\nfloat floatValue = a.floatValue();\ndouble doubleValue = a.doubleValue();\n\n// 转换为字符串\nString str = a.toString();             // 十进制\nString binaryStr = a.toString(2);      // 二进制\nString hexStr = a.toString(16);        // 十六进制\n```\n\n大浮点数 `BigDecimal` 的使用：\n\n```java\nBigDecimal num1 = new BigDecimal(\"10.5\");  // 推荐使用字符串构造\nBigDecimal num2 = new BigDecimal(10.5);    // 避免使用 double 构造，可能不精确（不推荐）\nBigDecimal num3 = BigDecimal.valueOf(10.5); // 推荐（内部优化）\n\n// 运算\nBigDecimal sum = a.add(b); \nBigDecimal diff = a.subtract(b); \nBigDecimal product = a.multiply(b); \n// 除法（需指定舍入模式）\nBigDecimal quotient = a.divide(b, 2, RoundingMode.HALF_UP); //（保留2位小数）\n\n// 常用舍入模式\nRoundingMode.HALF_UP //四舍五入（银行家舍入）\nRoundingMode.UP      //向远离零的方向舍入\nRoundingMode.DOWN    //向零方向舍入\n```\n\n# 集合 `Collection`/`Map`\n\n![image.png](https://cdn.gallery.uuanqin.top/img/202408161619164.webp)\n\n详看：[[Java 集合的使用]]\n\n# 调试\n\n指的是在机试过程中我们所能做的调试。\n\n## 标准化输出方法\n\n```java\nSystem.out.println(object); // 标准输出\nSystem.out.print();         // 输出不换行\n// 原理：String.valueOf(object) -> object.toString() \n```\n\n## 各式对象的 `toString()`\n\n`Object` 的 `toString()` 默认实现并不直观。\n\n对数组进行「友好」的字符串转换：\n\n```java\nArrays.toString(arr);// 将数组转换为可视字符串\n```\n\n`ArrayList`、`HashSet` 继承了 `AbstractCollection`，里面重写了 `toString` 。我们可以这样直观查看 `ArrayList` 中的内容：\n\n```java\nSystem.out.println(c);\n// [1,2,3,4,5]\n\n// 或者炫技：\nc.forEach(System.out::println);\n```\n\n附 `AbstractCollection` 中 `toString` 源码：\n\n```java\npublic String toString() {\n\tIterator<E> it = iterator();\n\tif (! it.hasNext())\n\t\treturn \"[]\";\n\n\tStringBuilder sb = new StringBuilder();\n\tsb.append('[');\n\tfor (;;) {\n\t\tE e = it.next();\n\t\t// sb.append 调用了 String.valueOf()\n\t\tsb.append(e == this ? \"(this Collection)\" : e); \n\t\tif (! it.hasNext())\n\t\t\treturn sb.append(']').toString();\n\t\tsb.append(',').append(' ');\n\t}\n}\n```\n\n# 多线程编程\n\n本章节主要就是背单词！\n\nLeetCode 中的多线程编程题目不多，掌握以下同步模式可解决大部分的问题：\n\n- [[同步模式——顺序控制]]\n- [[同步模式——交替输出]]\n\n## `Semaphore` 信号量\n\n```java\nSemaphore s = new Semaphore(0);\ns.acquire(); // s.acquire(2);\ns.release(); // s.release(2);\n```\n\n# 语言无关的通用技巧\n\n数学常识详看：[[算法题常用数学算法和技巧]]\n\n```java\n// double计算时提高精度\ndouble y;\nint iy;\niy = (int)((y) + 0.5) / 1.0) // 先四舍五入到合适精度\nif(Math.abs(iy-y)<0.0001)y=iy;   // 视情况设范围\n\n// 利用类型转换将字符类型对应到相应的数组位置。适用于字符串内容均为1种字符的情况。\narr1[str.charAt(i)-'a']++;   // a 放到数组下标 0，z放到数组下标 25\narr2[str.charAt(i)-'0']++;\narr3[str.charAt(i)-'A']++;\n```\n\n有时候有些对输入顺序有要求的，我们可以稍微调整一下顺序。\n\n```java\n// 函数参数交换\npublic static Object foo(int param1, int param2) {\n    if (...){\n        // 在指定条件下调换顺序，省去手动转移的麻烦\n        return foo(param2, param1);\n    }\n    /*\n\t    按既定参数顺序的函数逻辑\n    */\n    return result;\n}\n```\n\n## 魔数\n\n写题时常见的初始化最大最小值：\n\n- 最大值：`0x3f3f3f3f`。\n- 最小值：`0xc0c0c0c0`。\n\n根据不同题目要求，我们还可以将最大值设置为 `Integer.MAX_VALUE/2`（防止相加溢出）\n\n> [!notice] 为什么 ACM 中经常使用 `0x3f3f3f3f` 作为整型的最大值？\n> 原因如下：\n> 1. `0x3f3f3f3f` 的十进制是 `1,061,109,567`，是 `10^9` 级别的，而一般场合下的数据都是小于 `10^9` 的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。而平时用的 `Integer.MAX_VALUE=0x7fffffff` 不能满足“无穷大加一个有穷的数依然是无穷大”这个条件，加上一个数后，根据补码规范它会变成了一个很小的负数。\n> 2. `0x3f3f3f3f` 的 2 倍还是一个「无穷大」的数。\n> 3. `0x3f3f3f3f` 的每 8 位（每个字节）都是相同的。我们在程序设计中经常需要使用 `memset(a, val, sizeof(a))` 初始化一个数组 `a`，该语句把数值 `val`（`0x00`~`0xFF`）填充到数组 `a` 的每个字节上，所以用 `memset` 只能赋值出“每 8 位都相同”的 `int`。当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 `memset(a, 0x3f, sizeof(a))` 给数组赋 `0x3f3f3f3f` 的值来代替。\n\n$10^9$ 次方级别的大质数：`1000000007`。在一些题目中会很有用：🟥 [Problem - 1632D - Codeforces](https://codeforces.com/problemset/problem/1632/D)。对于多数题目来说，这个数常用于将结果取余。\n\n## 模板写法\n\n### 单调栈/队列\n\n\n\n模板写法：\n\n```pascal\n// 假设数组A从左到右遍历\ninsert x // x 为数组中某一个元素\n// 假设维护的是一个单调递增的栈（自栈顶向下单调递增）\nwhile !stack.empty() && stack.top()<x\n    y = stack.pop() // 这也意味着y右侧第一个比y大的元素是x\nstack.push(x)\n```\n\n更多内容参考：[[一些特殊的栈：单调栈、最小栈]]。\n\n\n\n### 滑动窗口\n\n样例题：🟨 [3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n\tSet<Character> set = new HashSet<>(); // 滑动窗口中的内容\n\n\tint res = 0;\n\tint len = s.length();\n\tint l = 0; // 左指针\n\tfor(int i=0;i<len;i++){ // 右指针\n\t\twhile(set.contains(s.charAt(i))){\n\t\t\tset.remove(s.charAt(l)); // 弹出滑动窗口内容\n\t\t\tl++;\n\t\t}\n\t\tset.add(s.charAt(i)); \n\t\tres= Math.max(set.size(),res); // 更新答案\n\t}\n\treturn res;\n}\n```\n\n### 方向移动\n\n如果需要物体在规定的棋盘下（比如 `n*n`）进行方向移动，可以这样写：\n\n```java\n// 定义方向\nstatic int[][] directions = new int[][]{\n\t{-1,0},{1,0},{0,-1},{0,1} // 上下左右\n};\n\n// 遍历方向\n// 传入当前位置i,j，以及棋盘\npublic void recursion(int i,int j, int[] board){\n\t/* 省略此处递归边界判断 */\n\n\tfor(int k=0;k<directions.length;k++){\n\t\tint newI = i + directions[k][0];\n\t\tint newJ = j + directions[k][1];\n\t\tif(newI>=0&&newI<n&&newJ>=0&&newJ<=n){ // 边界判断\n\t\t\trecursion(newI,newJ,board);        // 走下一步\n\t\t}\n\t}\n}\n```\n\n相关题目：🟨 [688. 骑士在棋盘上的概率 - 力扣（LeetCode）](https://leetcode.cn/problems/knight-probability-in-chessboard/description/)\n\n# 本文参考\n\n- 我久远积灰的笔记\n- [牛客网在线编程_算法笔试_输入输出练习 (nowcoder.com)](https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95&topicId=372)\n- [java中String和StringBuilder的replace方法-CSDN博客](https://blog.csdn.net/weixin_43312993/article/details/106348464)\n- [Java-修改 String 指定位置的字符最全方法总结（StringBuilder 和 StringBuffer 的使用以及区别）_string替换指定位置字符-CSDN博客](https://blog.csdn.net/qq_46634307/article/details/126283200)\n- [Java保留两位小数的几种写法总结[通俗易懂]-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2155412)\n- [Java：获取子字符串 substring()_java substring(10)-CSDN博客](https://blog.csdn.net/weixin_44015669/article/details/90113967)\n- [java.util.TreeSet.floor()方法和java.util.TreeSet.ceiling()方法_treeset的ceil和floor-CSDN博客](https://blog.csdn.net/andy_gfz/article/details/78211180)\n- [大质数表 - ljxtt - 博客园](https://www.cnblogs.com/ljxtt/p/13514346.html)\n- [0x3f3f3f3f是什么意思？？？-CSDN博客](https://blog.csdn.net/qq_31267769/article/details/88890612)\n- [Java中的Set remove()方法及其示例|极客笔记](https://deepinout.com/java/java-collection/g_set-remove-method-in-java-with-examples.html)\n- [Java中List，Set，数组的互相转换_java 1.8 list转set-CSDN博客](https://blog.csdn.net/iamlihongwei/article/details/96110470)\n\n","categories":[{"name":"计算机语言","api":"api/categories/计算机语言.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"LeetCode","api":"api/tags/LeetCode.json"},{"name":"字符串","api":"api/tags/字符串.json"},{"name":"牛客","api":"api/tags/牛客.json"},{"name":"集合","api":"api/tags/集合.json"}]},"api":"api/posts/p/c73083b9.json"}