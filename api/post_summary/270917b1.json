{"title":"手写 LRU 缓存以理解 Java 中的 LinkedHashMap","tags":["LRU","Java","LeetCode","操作系统"],"cover":"https://cdn.gallery.uuanqin.top/img/202409050003261.webp","description":"一个围绕 LRU 的专题综合。","categories":["算法与数据结构"],"abbrlink":"270917b1","date":"2024-09-03T23:25:18.000Z","top_img":null,"summary":"最近最少使用（Least Recently Used，LRU），是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。 Java 中可以使用 `LinkedHashMap` 轻松实现一个 LRU 缓存。 > [!note] 页面置换算法 > 在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法（Page-Replacement Algorithms）。 > - 最佳置换算法（OPT） > - 先进先出置换算法（FIFO） > - 最少使用置换算法（LFU） > - 最近最少使用置换算法（LRU） > > 附：高速缓冲器替换算法有：随机算法、FIFO、LFU、LRU 本文题目难度标识：🟩简单，🟨中等，🟥困难。 手写 LRU 缓存 > [!example] 题目：🟨 146. LRU 缓存 - 力扣（LeetCode） > 请你设计并实现一个满足 LRU（最近最少使用）缓存 约束的数据结构。 > 实现 `LRUCache` 类： > - `LRUCache(int capacity)` 以 正整数 作为容量 `capacity` 初始化 LRU 缓存 > - `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 -1 。 > - `void put(int key, int value)` > - 如果关键字 `key` 已经存在，则变更其数据值 `value` > - 如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 `capacity` ，则应该 逐出 最久未使用的关键字。 > > 函数 `get` 和 `put` 必须以 $O(1)$ 的平均时间复杂度运行。 Java 实现要点： `HashMap` + 双向链表。`HashMap` 用于快速定位双向链表中的结点；双向链表用于区分缓存 `key` 的访问顺序。..."}