{"data":{"title":"位运算技巧总结","slug":"算法与数据结构/位运算技巧总结","description":"位运算的基础知识","date":"2023-11-30T13:23:09.000Z","updated":"2025-09-24T15:25:49.587Z","language":"zh-CN","comments":true,"url":"p/d155facc/","cover":"https://cdn.gallery.uuanqin.top/img/202509222304567.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"note\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">文章创作于 <code>231130</code>，<code>250922</code> 迁移至博客。</div>\n</div>\n<div class=\"callout-content\"><p></p>\n</div></div><p>更多 bit 处理技巧可尝试一下：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c5970284/\"><span class=\"bilink-pop-up\">站内文章</span>CSAPP LAB-1 位操作</a>。</p>\n<h1 id=\"逻辑表达式\"><a class=\"markdownIt-Anchor\" href=\"#逻辑表达式\"></a> 逻辑表达式</h1>\n<p>任意的命题公式都可以仅包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">¬</mi><mo separator=\"true\">,</mo><mo>∨</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ \\neg,\\vee \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">¬</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∨</span><span class=\"mclose\">}</span></span></span></span> 或 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">¬</mi><mo separator=\"true\">,</mo><mo>∧</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ \\neg,\\wedge \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">¬</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∧</span><span class=\"mclose\">}</span></span></span></span> 的命题公式等价代换。</p>\n<h2 id=\"与运算和或运算掩码\"><a class=\"markdownIt-Anchor\" href=\"#与运算和或运算掩码\"></a> 与运算和或运算（掩码）</h2>\n<p>单片机中寄存器设置常用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class=\"line\"><span class=\"comment\"> *              the legal operators except !</span></span><br><span class=\"line\"><span class=\"comment\"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">logicalNeg</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> res=x;</span><br><span class=\"line\">  res |=  res&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">  res |=  res&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">  res |=  res&gt;&gt;<span class=\"number\">4</span>;</span><br><span class=\"line\">  res |=  res&gt;&gt;<span class=\"number\">2</span>;</span><br><span class=\"line\">  res |=  res&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">  res = ~res;</span><br><span class=\"line\">  res &amp;= <span class=\"number\">0x01</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/77c7bcae/\"><span class=\"bilink-pop-up\">站内文章</span>计算汉明重量的两个技巧性算法</a> 中，介绍了 Brian Kernighan 算法中的与运算技巧， <code>x</code> 和 <code>x-1</code> 进行与运算所得的结果为 <code>x</code> 删去其二进制表示中最右侧的 1 的结果。</p>\n<h2 id=\"异或\"><a class=\"markdownIt-Anchor\" href=\"#异或\"></a> 异或</h2>\n<p>异或满足交换律和结合律。</p>\n<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align at position 7: \\begin{̲a̲l̲i̲g̲n̲}̲\na\\oplus 0&amp;=a \\…'>\\begin{align}\na\\oplus 0&amp;=a \\\\\na\\oplus a &amp;= 0 \\\\\na\\oplus b &amp;= b\\oplus a \\\\\n(a \\oplus b) \\oplus c &amp;= a \\oplus( b \\oplus c)\n\\end{align}\n</p>\n<p>两个数异或的结果意味着：</p>\n<ul>\n<li>如果二进制结果中第 i 位为 1，说明这两个数在第 i 位上不相同</li>\n<li>如果二进制结果中第 i 位为 1，说明这两个数在第 i 位上相同</li>\n</ul>\n<p>我们可以使用异或实现一些函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 判断数字是否相等</span></span><br><span class=\"line\"><span class=\"comment\">* 要求只允许使用位运算符号</span></span><br><span class=\"line\"><span class=\"comment\">* 只返回0或1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_equal</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !!(x^y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现三元运算符</span></span><br><span class=\"line\"><span class=\"comment\">* x ? y : z</span></span><br><span class=\"line\"><span class=\"comment\">* 利用 x^x==0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">conditional</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> z)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> mix = y^z;</span><br><span class=\"line\">  <span class=\"type\">int</span> signal = !!x;</span><br><span class=\"line\">  signal = (signal&lt;&lt;<span class=\"number\">31</span>)&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((signal&amp;z)|((~signal)&amp;y))^mix; <span class=\"comment\">// y^z^y =z; z^y^z = y</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"补码\"><a class=\"markdownIt-Anchor\" href=\"#补码\"></a> 补码</h1>\n<p>一个补码表示的二进制数 <code>x</code>，通过「取反加一」的方式得到其补码表示的 <code>-x</code>。</p>\n<p>取反加一得到自身的特殊情况：</p>\n<ol>\n<li><code>TMin</code> 取反加 1 仍得到 <code>TMin</code>。符号位前后都是 1</li>\n<li>0 取反加 1 得到 0。符号位前后都是 0。</li>\n</ol>\n<p>至于其它数 <code>x</code>，取反加一得到的 <code>-x</code> 的符号位将会变化。</p>\n<p>那么，加上异或的判断数字相等的特性，我们可以：</p>\n<ol>\n<li>得出结论 x 不为 0 或 TMin 时，<code>(~x+1)^x</code> 结果的符号位为 1。</li>\n<li>验证一个数是否为 TMin、TMax</li>\n</ol>\n<h2 id=\"取出一个整数的二进制表示中的最低位\"><a class=\"markdownIt-Anchor\" href=\"#取出一个整数的二进制表示中的最低位\"></a> 取出一个整数的二进制表示中的最低位</h2>\n<p>快速计算补码的非有两种思考方式：</p>\n<ol>\n<li>补码的非 <code>-x==~x+1</code></li>\n<li>找出数 x 中最右边的为 1 的位（只要 x 不是 0，总能找到），将这个 1 的左边所有的位取反。</li>\n</ol>\n<p>根据第二种思考方式，我们可以得出：<strong>取出一个整数的二进制表示中的最低位 lowbit(x)</strong> 可以通过 <code>x&amp;-x</code> 得到。</p>\n\n<div class=\"callout\" data-callout=\"example\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-list\"><line x1=\"8\" x2=\"21\" y1=\"6\" y2=\"6\"/><line x1=\"8\" x2=\"21\" y1=\"12\" y2=\"12\"/><line x1=\"8\" x2=\"21\" y1=\"18\" y2=\"18\"/><line x1=\"3\" x2=\"3.01\" y1=\"6\" y2=\"6\"/><line x1=\"3\" x2=\"3.01\" y1=\"12\" y2=\"12\"/><line x1=\"3\" x2=\"3.01\" y1=\"18\" y2=\"18\"/></svg>\n</div>\n<div class=\"callout-title-inner\">例子</div>\n</div>\n<div class=\"callout-content\"><p>数字 10 的二进制表示：  <code>0b01010</code><br />\n数字 -10 的二进制表示：<code>0b10110</code><br />\n<code>5&amp;-5</code> 的结果：               <code>0b00010</code></p>\n</div></div><p>该技巧的应用文章：<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/bf3f2242/\"><span class=\"bilink-pop-up\">站内文章</span>在线性时间内找出只出现 1 次的数字</a>、<a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/47fd7a85/\"><span class=\"bilink-pop-up\">站内文章</span>树状数组上手了就十分简单</a>。</p>\n<h2 id=\"计算一个数的补码表示至少需要多少比特\"><a class=\"markdownIt-Anchor\" href=\"#计算一个数的补码表示至少需要多少比特\"></a> 计算一个数的补码表示至少需要多少比特</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class=\"line\"><span class=\"comment\"> *             two&#x27;s complement</span></span><br><span class=\"line\"><span class=\"comment\"> *  Examples: howManyBits(12) = 5  </span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(298) = 10</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(-5) = 4  </span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(0)  = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(-1) = 1</span></span><br><span class=\"line\"><span class=\"comment\"> *            howManyBits(0x80000000) = 32</span></span><br><span class=\"line\"><span class=\"comment\"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *  Max ops: 90</span></span><br><span class=\"line\"><span class=\"comment\"> *  Rating: 4</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">howManyBits</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> sign = x&gt;&gt;<span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> high16,high8,high4,high2,high1,high0;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sign ? -x : x;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mix = x^(~x);</span><br><span class=\"line\">  x = ((sign&amp;(x))|((~sign)&amp;(~x)))^mix;</span><br><span class=\"line\">  </span><br><span class=\"line\">  high16 = !!(x&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">  x &gt;&gt;= (high16&lt;&lt;<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  high8 = !!(x&gt;&gt;<span class=\"number\">8</span>);</span><br><span class=\"line\">  x &gt;&gt;= (high8&lt;&lt;<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  high4 = !!(x&gt;&gt;<span class=\"number\">4</span>);</span><br><span class=\"line\">  x &gt;&gt;= high4&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  high2 = !!(x&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">  x &gt;&gt;= high2&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  high1 = !!(x&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">  x &gt;&gt;= high1;</span><br><span class=\"line\"></span><br><span class=\"line\">  high0 = x; <span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (high16&lt;&lt;<span class=\"number\">4</span>) + (high8&lt;&lt;<span class=\"number\">3</span>) + (high4&lt;&lt;<span class=\"number\">2</span>) + (high2&lt;&lt;<span class=\"number\">1</span>) + high1 + high0 + <span class=\"number\">1</span> ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h1>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\"> 需消化「计算一个数的补码表示至少需要多少比特」的内容</li>\n</ul>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>研究生课程《CSAPP》相关实验与笔记</li>\n</ul>\n","raw":"---\ntitle: 位运算技巧总结\ntags:\n  - 位运算\n  - C\n  - CSAPP\ncover: 'https://cdn.gallery.uuanqin.top/img/202509222304567.webp'\nkatex: false\ncategories:\n  - 算法与数据结构\nabbrlink: d155facc\ndate: 2023-11-30 21:23:09\ndescription: 位运算的基础知识\ntop_img:\n---\n\n> [!note] 文章创作于 `231130`，`250922` 迁移至博客。\n\n更多 bit 处理技巧可尝试一下：[[CSAPP LAB-1 位操作]]。\n\n# 逻辑表达式\n\n任意的命题公式都可以仅包含 $\\{ \\neg,\\vee \\}$ 或 $\\{ \\neg,\\wedge \\}$ 的命题公式等价代换。\n\n## 与运算和或运算（掩码）\n\n单片机中寄存器设置常用。\n\n```c\n/* \n * logicalNeg - implement the ! operator, using all of \n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n */\nint logicalNeg(int x) {\n  int res=x;\n  res |=  res>>16;\n  res |=  res>>8;\n  res |=  res>>4;\n  res |=  res>>2;\n  res |=  res>>1;\n  res = ~res;\n  res &= 0x01;\n  return res;\n}\n```\n\n在 [[计算汉明重量的两个技巧性算法]] 中，介绍了 Brian Kernighan 算法中的与运算技巧， `x` 和 `x-1` 进行与运算所得的结果为 `x` 删去其二进制表示中最右侧的 1 的结果。\n\n## 异或\n\n异或满足交换律和结合律。\n\n$$\n\\begin{align}\na\\oplus 0&=a \\\\\na\\oplus a &= 0 \\\\\na\\oplus b &= b\\oplus a \\\\\n(a \\oplus b) \\oplus c &= a \\oplus( b \\oplus c)\n\\end{align}\n$$\n\n两个数异或的结果意味着：\n\n* 如果二进制结果中第 i 位为 1，说明这两个数在第 i 位上不相同\n* 如果二进制结果中第 i 位为 1，说明这两个数在第 i 位上相同\n\n我们可以使用异或实现一些函数：\n\n```c\n/* 判断数字是否相等\n* 要求只允许使用位运算符号\n* 只返回0或1\n*/\nint is_equal(int x,int y){\n\treturn !!(x^y);\n}\n\n/* 实现三元运算符\n* x ? y : z\n* 利用 x^x==0\n*/\nint conditional(int x, int y, int z) {\n  int mix = y^z;\n  int signal = !!x;\n  signal = (signal<<31)>>31;\n  return ((signal&z)|((~signal)&y))^mix; // y^z^y =z; z^y^z = y\n}\n```\n\n# 补码\n\n一个补码表示的二进制数 `x`，通过「取反加一」的方式得到其补码表示的 `-x`。\n\n取反加一得到自身的特殊情况：\n\n1. `TMin` 取反加 1 仍得到 `TMin`。符号位前后都是 1\n2. 0 取反加 1 得到 0。符号位前后都是 0。\n\n至于其它数 `x`，取反加一得到的 `-x` 的符号位将会变化。\n\n那么，加上异或的判断数字相等的特性，我们可以：\n\n1. 得出结论 x 不为 0 或 TMin 时，`(~x+1)^x` 结果的符号位为 1。\n2. 验证一个数是否为 TMin、TMax\n\n## 取出一个整数的二进制表示中的最低位\n\n快速计算补码的非有两种思考方式：\n\n1. 补码的非 `-x==~x+1`\n2. 找出数 x 中最右边的为 1 的位（只要 x 不是 0，总能找到），将这个 1 的左边所有的位取反。\n\n根据第二种思考方式，我们可以得出：**取出一个整数的二进制表示中的最低位 lowbit(x)** 可以通过 `x&-x` 得到。\n\n> [!example] 例子\n> 数字 10 的二进制表示：  `0b01010`\n> 数字 -10 的二进制表示：`0b10110`\n> `5&-5` 的结果：               `0b00010`\n\n该技巧的应用文章：[[在线性时间内找出只出现 1 次的数字]]、[[树状数组上手了就十分简单]]。\n\n## 计算一个数的补码表示至少需要多少比特\n\n```c\n/* howManyBits - return the minimum number of bits required to represent x in\n *             two's complement\n *  Examples: howManyBits(12) = 5  \n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4  \n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ & ^ | + << >>\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x) {\n  int sign = x>>31;\n  int high16,high8,high4,high2,high1,high0;\n\n  // sign ? -x : x;\n  int mix = x^(~x);\n  x = ((sign&(x))|((~sign)&(~x)))^mix;\n  \n  high16 = !!(x>>16);\n  x >>= (high16<<4);\n\n  high8 = !!(x>>8);\n  x >>= (high8<<3);\n\n  high4 = !!(x>>4);\n  x >>= high4<<2;\n\n  high2 = !!(x>>2);\n  x >>= high2<<1;\n\n  high1 = !!(x>>1);\n  x >>= high1;\n\n  high0 = x; //\n\n  return (high16<<4) + (high8<<3) + (high4<<2) + (high2<<1) + high1 + high0 + 1 ; \n}\n```\n\n# 后记\n\n- [ ] 需消化「计算一个数的补码表示至少需要多少比特」的内容\n\n# 本文参考\n\n- 研究生课程《CSAPP》相关实验与笔记\n\n","categories":[{"name":"算法与数据结构","api":"api/categories/算法与数据结构.json"}],"tags":[{"name":"CSAPP","api":"api/tags/CSAPP.json"},{"name":"C","api":"api/tags/C.json"},{"name":"位运算","api":"api/tags/位运算.json"}]},"api":"api/posts/p/d155facc.json"}