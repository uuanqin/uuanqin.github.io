{"data":{"title":"访问者模式填补单分派语言的缺陷","slug":"高质量代码及设计模式/访问者模式填补单分派语言的缺陷","description":"访问数据结构并处理数据","date":"2025-08-30T08:21:58.000Z","updated":"2026-01-14T15:40:16.751Z","language":"zh-CN","comments":true,"url":"p/b6ca7c41/","cover":"https://cdn.gallery.uuanqin.top/img/202601142339317.webp","images":[],"content":"<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508301624324.webp\" alt=\"image.png\" width=\"325px\" /></p>\n<p>访问者模式是 GoF 23 种经典设计模式中最难理解的模式之一。因为它难理解、难实现，应用它可能会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议不要使用访问者模式。</p>\n<h1 id=\"访问者模式的诞生过程\"><a class=\"markdownIt-Anchor\" href=\"#访问者模式的诞生过程\"></a> 访问者模式的诞生过程</h1>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/202508310016843.webp\" alt=\"image.png\" width=\"400px\" /></p>\n<h2 id=\"让元素打印自身的信息\"><a class=\"markdownIt-Anchor\" href=\"#让元素打印自身的信息\"></a> 让元素打印自身的信息</h2>\n<p>假设现在存在两个元素类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;aaaaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"number\">0xbbbbb</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%x\\n&quot;</span>,info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，每个 <code>ConcreteElement</code> 中保存的信息类型并不相同。</p>\n<p>给定元素的列表，我们可以打印每个元素的信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tList&lt;Element&gt; elements = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementA</span>()); <span class=\"comment\">// aaaaa</span></span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementB</span>()); <span class=\"comment\">// bbbbb</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Element e : elements) &#123;</span><br><span class=\"line\">\t\te.printInfo();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设现在每个元素需要在已有 <code>printInfo()</code> 方法的基础上，增加各种处理 <code>info</code> 的方法。这时候需要为每个类都实现这些新方法，这会导致：</p>\n<ul>\n<li>违背 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>开闭原则</a>，添加一个新的功能，所有类的代码都要修改；</li>\n<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>\n<li>将一些比较上层的业务逻辑耦合到了每个 <code>ConcreteElement</code> 中，导致类的职责不单一。</li>\n</ul>\n<h2 id=\"让访问者打印元素信息的尝试\"><a class=\"markdownIt-Anchor\" href=\"#让访问者打印元素信息的尝试\"></a> 让访问者打印元素信息的尝试</h2>\n<p>下面将使用访问者模式重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;aaaaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"number\">0xbbbbb</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Visitor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(ConcreteElementA a)</span> &#123;</span><br><span class=\"line\">        System.out.println(a.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(ConcreteElementB b)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%x\\n&quot;</span>, b.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Visitor</code> 包揽打印元素信息的活，通过重载的方式对不同元素实现不同的打印方法。</p>\n<p>打印元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tList&lt;Element&gt; elements = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementA</span>());</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementB</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">Visitor</span> <span class=\"variable\">visitor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Visitor</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Element e : elements) &#123;</span><br><span class=\"line\">\t\tvisitor.printInfo(e); <span class=\"comment\">// Cannot resolve method &#x27;printInfo(Element)&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div class=\"callout\" data-callout=\"error\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-zap\"><polygon points=\"13 2 3 14 12 14 11 22 21 10 12 10 13 2\"/></svg>\n</div>\n<div class=\"callout-title-inner\">以上代码无法通过编译</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li>IDE 会在 <code>visitor.printInfo(e);</code> 中报 <code>Cannot resolve method 'printInfo(Element)&quot;</code> 错误提示。</li>\n<li>编译出错：<code>java: 对于printInfo(top.uuanqin.Element), 找不到合适的方法</code></li>\n</ul>\n</div></div><p>原因：多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p>\n<h2 id=\"让访问者传入元素内并打印信息\"><a class=\"markdownIt-Anchor\" href=\"#让访问者传入元素内并打印信息\"></a> 让访问者传入元素内并打印信息</h2>\n<p>我们为每个具体元素实现接收访问者的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Visitor visitor)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;aaaaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Visitor visitor)</span> &#123;</span><br><span class=\"line\">        visitor.printInfo(<span class=\"built_in\">this</span>); <span class=\"comment\">// visitor 中的重载函数能被正确调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"number\">0xbbbbb</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Visitor visitor)</span> &#123;</span><br><span class=\"line\">        visitor.printInfo(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Visitor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(ConcreteElementA a)</span> &#123;</span><br><span class=\"line\">        System.out.println(a.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(ConcreteElementB b)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%x\\n&quot;</span>, b.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>遍历元素集合，将访问者传入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tList&lt;Element&gt; elements = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementA</span>());</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementB</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">Visitor</span> <span class=\"variable\">visitor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Visitor</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Element e: elements) &#123;</span><br><span class=\"line\">\t\te.accept(visitor); <span class=\"comment\">// 多态特性调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>Visitor</code> 中的重载函数能被成功调用的关键，在于每个 <code>ConcreteElement</code> 的 <code>accept()</code> 方法接收了访问者，并将自身 <code>this</code> 传递进去。连同着 <code>ConcreteElement</code> 的类型信息传给 <code>Visitor</code> 后，编译器自然会知道应当调用 <code>Visitor</code> 的哪个重载函数。</p>\n<p>不要因为看到每个 <code>ConcreteElement</code> 的 <code>accept()</code> 代码似乎都一样就把它提到父类中。如果这样的话， <code>Visitor</code> 重载还是会出现和之前一样的编译错误。</p>\n<blockquote>\n<p>不知道为什么，访问者模式让我想起三借芭蕉扇中，铁扇公主吞下孙悟空的场景。</p>\n</blockquote>\n<h2 id=\"最终版访问者模式中添加新的功能\"><a class=\"markdownIt-Anchor\" href=\"#最终版访问者模式中添加新的功能\"></a> 最终版：访问者模式中添加新的功能</h2>\n<p>假设除了每个元素除了 <code>printInfo()</code> 外，还需要新增方法 <code>printInfoType()</code> 用于打印消息类型。一个想法是：</p>\n<ul>\n<li><code>Element</code> 新增抽象接口接收新的 <code>visitor</code>。相应的，所有的 <code>ConcreteElement</code> 都实现这个接口。</li>\n<li>新增 <code>visitor</code>，编写重载函数 <code>printInfoType()</code>。</li>\n</ul>\n<p>这种想法存在一些问题，当我们需要添加新的业务时，还是会需要改动到 <code>Element</code> 的代码。针对这个问题，我们抽象出一个 <code>Visitor</code> 接口，包含一个名为 <code>visit()</code> 的重载函数。<code>visit()</code> 是一个通用化的起名方式，不同的 <code>ConcreteVisitor</code> 将会有不同的实现，代表不同的业务。</p>\n<p><code>Visitor</code> 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提供重载方法</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Visitor</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ConcreteElementA a)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ConcreteElementB b)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体访问者知晓具体元素</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InfoVisitor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Visitor</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ConcreteElementA a)</span> &#123;</span><br><span class=\"line\">        System.out.println(a.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ConcreteElementB b)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%x\\n&quot;</span>, b.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InfoTypeVisitor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Visitor</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ConcreteElementA a)</span> &#123;</span><br><span class=\"line\">        System.out.println(a.info.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ConcreteElementB b)</span> &#123;</span><br><span class=\"line\">        System.out.println(b.info.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Element</code> 的代码在业务增加时不需要改动。注意，此处的 <code>Visitor</code> 是个更为通用的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Visitor visitor)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体元素必须实现接收方法（即使父类实现了，子类必须实现）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;aaaaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Visitor visitor)</span> &#123;</span><br><span class=\"line\">        visitor.visit(<span class=\"built_in\">this</span>); <span class=\"comment\">// 访问者模式的关键</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"number\">0xbbbbb</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(Visitor visitor)</span> &#123;</span><br><span class=\"line\">        visitor.visit(<span class=\"built_in\">this</span>); <span class=\"comment\">// 访问者模式的关键</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Main</code> 中的调用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tList&lt;Element&gt; elements = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementA</span>());</span><br><span class=\"line\">\telements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementB</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">Visitor</span> <span class=\"variable\">infoVisitor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InfoVisitor</span>();</span><br><span class=\"line\">\t<span class=\"type\">Visitor</span> <span class=\"variable\">infoTypeVisitor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InfoTypeVisitor</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Element e: elements) &#123;</span><br><span class=\"line\">\t\te.accept(infoVisitor);</span><br><span class=\"line\">\t\te.accept(infoTypeVisitor);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"访问者模式\"><a class=\"markdownIt-Anchor\" href=\"#访问者模式\"></a> 访问者模式</h1>\n\n<div class=\"callout\" data-callout=\"tldr\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-clipboard-list\"><rect width=\"8\" height=\"4\" x=\"8\" y=\"2\" rx=\"1\" ry=\"1\"/><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"/><path d=\"M12 11h4\"/><path d=\"M12 16h4\"/><path d=\"M8 11h.01\"/><path d=\"M8 16h.01\"/></svg>\n</div>\n<div class=\"callout-title-inner\">访问者模式 Visitor Design Pattern</div>\n</div>\n<div class=\"callout-content\"><p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.——GoF<br />\n允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>\n</div></div><p>在访问者模式中，数据结构与处理被分离开来。我们编写一个表示「访问者」的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可。</p>\n<p>登场角色：</p>\n<ul>\n<li><code>Visitor</code>（访问者）：<code>Visitor</code> 角色负责对数据结构中每个具体的元素（<code>ConcreteElement</code> 角色）声明一个用于访问 <code>Xxxxx</code> 的 <code>visit(Xxxxx)</code> 方法。<code>visit(Xxxxx)</code> 是用于处理 <code>Xxxxx</code> 的方法，负责实现该方法的是 <code>ConcreteVisitor</code> 角色。</li>\n<li><code>ConcreteVisitor</code>（具体的访问者）：<code>ConcreteVisitor</code> 角色负责实现 <code>Visitor</code> 角色所定义的接口（API）。它要实现所有的 <code>visit(Xxxxx)</code> 方法，即实现如何处理每个 <code>ConcreteElement</code> 角色。具体访问者知晓具体元素。</li>\n<li><code>Element</code>（元素）：<code>Element</code> 角色表示 <code>Visitor</code> 角色的访问对象。它声明了接受访问者的 <code>accept</code> 方法。<code>accept</code> 方法接收到的参数是 <code>Visitor</code> 角色。</li>\n<li><code>ConcreteElement</code>（具体元素）：<code>ConcreteElement</code> 角色负责实现 <code>Element</code> 角色所定义的接口（API）。</li>\n<li><code>ObjectStructure</code>（对象结构）：<code>ObjectStructure</code> 角色负责处理 <code>Element</code> 角色的集合。<code>ConcreteVisitor</code> 角色为每个 <code>Element</code> 角色都准备了处理方法。</li>\n</ul>\n<p>一般来说，访问者模式针对的是一组类型不同的对象 <code>ConcreteElement</code>。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类 <code>Element</code> 或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作，但为了避免不断添加功能导致 <code>ConcreteElement</code> 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者 <code>ConcreteVisitor</code> 中。</p>\n<p><code>Visitor</code> 工作条件：<code>Element</code> 角色必须向 <code>Visitor</code> 角色公开足够多的信息。缺点就是，如果公开了不应当被公开的信息，将来对数据结构的改良就会变得非常困难。</p>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开闭原则。可以引入在不同类对象上执行的新行为，且无需对这些类做出修改。</td>\n<td>难以增加 <code>ConcreteElement</code> 角色。每次在元素层次结构中添加或移除一个类时，你都要更新所有的访问者。</td>\n</tr>\n<tr>\n<td>单一职责原则。可将同一行为的不同版本移到同一个类中。</td>\n<td>在访问者同某个元素进行交互时，它们可能没有访问元素私有成员变量和方法的必要权限。如果公开了不应当被公开的信息，将来对数据结构的改良就会变得非常困难。</td>\n</tr>\n<tr>\n<td>访问者对象可以在与各种对象交互时收集一些有用的信息。当你想要遍历一些复杂的对象结构 （例如对象树），并在结构中的每个对象上应用访问者时，这些信息可能会有所帮助。</td>\n<td rowspan=\"2\"></td>\n</tr>\n<tr>\n<td>易于增加 <code>ConcreteVisitor</code> 角色。</td>\n</tr>\n</tbody>\n</table>\n<p>拓展思路：</p>\n<ul>\n<li>扩展点在于容易拓展访问者 <code>ConcreteVisitor</code>，不易扩展被访问者 <code>ConcreteElement</code>。新增 <code>ConcreteElement</code> 后，需要在所有 <code>ConcreteVisitor</code> 中添加相应的重载方法。</li>\n<li>访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。</li>\n</ul>\n<h1 id=\"相关的设计模式\"><a class=\"markdownIt-Anchor\" href=\"#相关的设计模式\"></a> 相关的设计模式</h1>\n<p>其他相关设计模式：</p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/61ade5c3/\"><span class=\"bilink-pop-up\">站内文章</span>迭代器模式</a>：迭代器模式和访问者模式都是在某种数据结构上进行处理。\n<ul>\n<li>迭代器模式用于逐个遍历保存在数据结构中的元素。</li>\n<li>访问者模式用于对保存在数据结构中的元素进行某种特定的处理。</li>\n</ul>\n</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>组合模式</a>：有时访问者所访问的数据结构会使用组合模式。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>解释器模式</a>：在解释器模式中，有时会使用访问者模式。例如，在生成了语法树后，可能会使用访问者模式访问语法树的各个节点进行处理。</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/undefined/\"><span class=\"bilink-pop-up\">站内文章</span>命令模式</a>：可以将访问者模式看成是命令模式的加强版，其对象可对不同类的多种对象执行操作。</li>\n</ul>\n<p>在本文首章中提到的案例是访问者模式的简化版，如果业务功能并不多，我们其实可以使用 <a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3a9f48af/\"><span class=\"bilink-pop-up\">站内文章</span>工厂模式</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.uuanqin.dispatch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> uuanqin</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FactoryTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;Element&gt; elements = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        elements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementA</span>());</span><br><span class=\"line\">        elements.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteElementB</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element e: elements) &#123;</span><br><span class=\"line\">            <span class=\"type\">InfoPrinter</span> <span class=\"variable\">infoPrinter</span> <span class=\"operator\">=</span> InfoPrinterFactory.getInfoPrinter(e);</span><br><span class=\"line\">            infoPrinter.printInfo(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Element</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;aaaaa&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteElementB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"number\">0xbbbbb</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">InfoPrinter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(Element e)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ElementAInfoPrinter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InfoPrinter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(Element e)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConcreteElementA</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> (ConcreteElementA) e;</span><br><span class=\"line\">        System.out.println(a.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ElementBInfoPrinter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InfoPrinter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printInfo</span><span class=\"params\">(Element e)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConcreteElementB</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> (ConcreteElementB) e;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%x\\n&quot;</span>, b.info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InfoPrinterFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, InfoPrinter&gt; INFO_PRINTERS = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        INFO_PRINTERS.put(ConcreteElementA.class.getName(), <span class=\"keyword\">new</span> <span class=\"title class_\">ElementAInfoPrinter</span>());</span><br><span class=\"line\">        INFO_PRINTERS.put(ConcreteElementB.class.getName(), <span class=\"keyword\">new</span> <span class=\"title class_\">ElementBInfoPrinter</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> InfoPrinter <span class=\"title function_\">getInfoPrinter</span><span class=\"params\">(Element element)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INFO_PRINTERS.get(element.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当需要增加功能时，如 <code>printInfoType</code>，我们需要增加：</p>\n<ul>\n<li>工厂类 <code>InfoTypePrinterFactory</code></li>\n<li>接口 <code>InfoTypePrinter</code></li>\n<li>实现类 <code>ElementAInfoTypePrinter</code>、<code>ElementBInfoTypePrinter</code></li>\n</ul>\n<h1 id=\"双分派的语言不需要访问者模式\"><a class=\"markdownIt-Anchor\" href=\"#双分派的语言不需要访问者模式\"></a> 双分派的语言不需要访问者模式</h1>\n<p>单分派和双分派：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>单分派 Single Dispatch</th>\n<th>双分派 Double Dispatch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>执行哪个对象</td>\n<td>根据对象 <strong>运行时类型</strong> 决定</td>\n<td>根据对象的 <strong>运行时类型</strong> 来决定</td>\n</tr>\n<tr>\n<td>执行对象 <code>A</code> 的哪个方法</td>\n<td>根据方法参数的 <strong>编译时类型</strong> 来决定</td>\n<td>根据方法参数的 <strong>运行时类型</strong> 来决定</td>\n</tr>\n<tr>\n<td>语言</td>\n<td>Java、C++、C#</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是「分派 Dispatch」。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。</p>\n<blockquote>\n<p>具体到访问者模式中，<code>element</code> 接受 <code>visitor</code>，而 <code>visitor</code> 又访问 <code>element</code>。<code>ConcreteElement</code> 和 <code>ConcreteVisitor</code> 这两个角色共同决定了实际进行的处理。这种消息分发的方式一般被称为双重分发（Double dispatch）。</p>\n</blockquote>\n<p>所谓「单」「双」，指的是执行哪个对象的哪个方法，跟几个因素的<strong>运行时类型</strong>有关。具体到编程语言的语法机制，单分派和双分派和多态、函数重载直接相关。以 Java 为例，Java 支持多态特性，代码可以在运行时获得对象的实际类型（运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则时，并不是在运行时根据传递进函数的参数的实际类型来决定调用哪个重载函数，而是在编译时根据传递进函数的参数的声明类型（编译时类型）来决定调用哪个重载函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DispatchTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SingleDispatchClass</span> <span class=\"variable\">demo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SingleDispatchClass</span>();</span><br><span class=\"line\">        <span class=\"type\">ParentClass</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ChildClass</span>();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;示例1：&quot;</span>);</span><br><span class=\"line\">        demo.polymorphismFunction(p);<span class=\"comment\">//执行哪个对象的方法，由对象的实际类型决定</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;\\n示例2：&quot;</span>);</span><br><span class=\"line\">        demo.overloadFunction(p);<span class=\"comment\">//执行对象的哪个方法，由参数对象的声明类型决定</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ParentClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 ParentClass&#x27;s f().&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ChildClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ParentClass</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 ChildClass&#x27;s f().&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleDispatchClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">polymorphismFunction</span><span class=\"params\">(ParentClass p)</span> &#123;</span><br><span class=\"line\">        p.f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">overloadFunction</span><span class=\"params\">(ParentClass p)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;进入重载函数 overloadFunction(ParentClass p).&quot;</span>);</span><br><span class=\"line\">        p.f(); <span class=\"comment\">// 多态起作用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">overloadFunction</span><span class=\"params\">(ChildClass c)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;进入重载函数 overloadFunction(ChildClass c).&quot;</span>);</span><br><span class=\"line\">        c.f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码执行结果：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例1：</span><br><span class=\"line\">执行 ChildClass&#x27;s f().</span><br><span class=\"line\"></span><br><span class=\"line\">示例2：</span><br><span class=\"line\">进入重载函数 overloadFunction(ParentClass p).</span><br><span class=\"line\">执行 ChildClass&#x27;s f().</span><br></pre></td></tr></table></figure>\n<p>访问者模式使用了双分派的技巧，让单分派的语言选择正确的类并执行正确的方法。尽管访问者模式基于双分派的原则创建，但这并不是其主要目的。访问者的目的是让你能为整个类层次结构添加「外部」操作，而无需修改这些类的已有代码。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li>《图解设计模式》第 13 章</li>\n<li>本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️</li>\n<li><a href=\"https://gitee.com/buxsren/design-pattern-books/blob/master/\">极客时间专栏 - 设计模式之美 - 王争</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/visitor\">访问者设计模式</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/602031602\">Double Dispatch 和 Visitors - 知乎</a></li>\n</ul>\n","raw":"---\ntitle: 访问者模式填补单分派语言的缺陷\ntags:\n  - Java\n  - 设计模式\n  - 单分派\n  - 双分派\ncover: 'https://cdn.gallery.uuanqin.top/img/202601142339317.webp'\ndescription: 访问数据结构并处理数据\nkatex: false\ncategories:\n  - 高质量代码及设计模式\nabbrlink: b6ca7c41\ndate: 2025-08-30 16:21:58\ntop_img:\n---\n\n![image.png|325](https://cdn.gallery.uuanqin.top/img/202508301624324.webp)\n\n访问者模式是 GoF 23 种经典设计模式中最难理解的模式之一。因为它难理解、难实现，应用它可能会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议不要使用访问者模式。\n\n# 访问者模式的诞生过程\n\n![image.png|400](https://cdn.gallery.uuanqin.top/img/202508310016843.webp)\n\n## 让元素打印自身的信息\n\n假设现在存在两个元素类：\n\n```java\nabstract class Element {\n    abstract void printInfo();\n}\n\nclass ConcreteElementA extends Element {\n    String info = \"aaaaa\";\n\n    @Override\n    public void printInfo() {\n        System.out.println(info);\n    }\n}\n\nclass ConcreteElementB extends Element {\n    Integer info = 0xbbbbb;\n\n    @Override\n    public void printInfo() {\n        System.out.printf(\"%x\\n\",info);\n    }\n}\n```\n\n注意到，每个 `ConcreteElement` 中保存的信息类型并不相同。\n\n给定元素的列表，我们可以打印每个元素的信息：\n\n```java\npublic static void main(String[] args) {\n\tList<Element> elements = new ArrayList<>();\n\telements.add(new ConcreteElementA()); // aaaaa\n\telements.add(new ConcreteElementB()); // bbbbb\n\tfor (Element e : elements) {\n\t\te.printInfo();\n\t}\n}\n```\n\n假设现在每个元素需要在已有 `printInfo()` 方法的基础上，增加各种处理 `info` 的方法。这时候需要为每个类都实现这些新方法，这会导致：\n\n- 违背 [[设计原则|开闭原则]]，添加一个新的功能，所有类的代码都要修改；\n- 虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；\n- 将一些比较上层的业务逻辑耦合到了每个 `ConcreteElement` 中，导致类的职责不单一。\n\n## 让访问者打印元素信息的尝试\n\n下面将使用访问者模式重构：\n\n```java\nabstract class Element {\n}\n\nclass ConcreteElementA extends Element {\n    String info = \"aaaaa\";\n\n}\n\nclass ConcreteElementB extends Element {\n    Integer info = 0xbbbbb;\n\n}\n\n\nclass Visitor {\n    public void printInfo(ConcreteElementA a) {\n        System.out.println(a.info);\n    }\n\n    public void printInfo(ConcreteElementB b) {\n        System.out.printf(\"%x\\n\", b.info);\n    }\n}\n```\n\n`Visitor` 包揽打印元素信息的活，通过重载的方式对不同元素实现不同的打印方法。\n\n打印元素：\n\n```java\npublic static void main(String[] args) {\n\tList<Element> elements = new ArrayList<>();\n\telements.add(new ConcreteElementA());\n\telements.add(new ConcreteElementB());\n\n\tVisitor visitor = new Visitor();\n\tfor (Element e : elements) {\n\t\tvisitor.printInfo(e); // Cannot resolve method 'printInfo(Element)\"\n\t}\n}\n```\n\n> [!error] 以上代码无法通过编译\n>\n> - IDE 会在 `visitor.printInfo(e);` 中报 `Cannot resolve method 'printInfo(Element)\"` 错误提示。\n> - 编译出错：`java: 对于printInfo(top.uuanqin.Element), 找不到合适的方法`\n\n原因：多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。\n\n## 让访问者传入元素内并打印信息\n\n我们为每个具体元素实现接收访问者的方法：\n\n```java\nabstract class Element {\n    abstract public void accept(Visitor visitor);\n}\n\nclass ConcreteElementA extends Element {\n    String info = \"aaaaa\";\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.printInfo(this); // visitor 中的重载函数能被正确调用\n    }\n}\n\nclass ConcreteElementB extends Element {\n    Integer info = 0xbbbbb;\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.printInfo(this);\n    }\n}\n\n\nclass Visitor {\n    public void printInfo(ConcreteElementA a) {\n        System.out.println(a.info);\n    }\n\n    public void printInfo(ConcreteElementB b) {\n        System.out.printf(\"%x\\n\", b.info);\n    }\n}\n\n```\n\n遍历元素集合，将访问者传入：\n\n```java\npublic static void main(String[] args) {\n\tList<Element> elements = new ArrayList<>();\n\telements.add(new ConcreteElementA());\n\telements.add(new ConcreteElementB());\n\n\tVisitor visitor = new Visitor();\n\tfor (Element e: elements) {\n\t\te.accept(visitor); // 多态特性调用\n\t}\n}\n```\n\n这里的 `Visitor` 中的重载函数能被成功调用的关键，在于每个 `ConcreteElement` 的 `accept()` 方法接收了访问者，并将自身 `this` 传递进去。连同着 `ConcreteElement` 的类型信息传给 `Visitor` 后，编译器自然会知道应当调用 `Visitor` 的哪个重载函数。\n\n不要因为看到每个 `ConcreteElement` 的 `accept()` 代码似乎都一样就把它提到父类中。如果这样的话， `Visitor` 重载还是会出现和之前一样的编译错误。\n\n> 不知道为什么，访问者模式让我想起三借芭蕉扇中，铁扇公主吞下孙悟空的场景。\n\n## 最终版：访问者模式中添加新的功能\n\n假设除了每个元素除了 `printInfo()` 外，还需要新增方法 `printInfoType()` 用于打印消息类型。一个想法是：\n\n- `Element` 新增抽象接口接收新的 `visitor`。相应的，所有的 `ConcreteElement` 都实现这个接口。\n- 新增 `visitor`，编写重载函数 `printInfoType()`。\n\n这种想法存在一些问题，当我们需要添加新的业务时，还是会需要改动到 `Element` 的代码。针对这个问题，我们抽象出一个 `Visitor` 接口，包含一个名为 `visit()` 的重载函数。`visit()` 是一个通用化的起名方式，不同的 `ConcreteVisitor` 将会有不同的实现，代表不同的业务。\n\n`Visitor` 的实现：\n\n```java\n// 提供重载方法\ninterface Visitor{\n    public void visit(ConcreteElementA a);\n    public void visit(ConcreteElementB b);\n}\n\n// 具体访问者知晓具体元素\nclass InfoVisitor implements Visitor{\n    @Override\n    public void visit(ConcreteElementA a) {\n        System.out.println(a.info);\n    }\n    @Override\n    public void visit(ConcreteElementB b) {\n        System.out.printf(\"%x\\n\", b.info);\n    }\n}\n\nclass InfoTypeVisitor implements Visitor{\n\n    @Override\n    public void visit(ConcreteElementA a) {\n        System.out.println(a.info.getClass().getName());\n    }\n\n    @Override\n    public void visit(ConcreteElementB b) {\n        System.out.println(b.info.getClass().getName());\n    }\n}\n```\n\n`Element` 的代码在业务增加时不需要改动。注意，此处的 `Visitor` 是个更为通用的接口：\n\n```java\nabstract class Element {\n    abstract public void accept(Visitor visitor);\n}\n\n// 具体元素必须实现接收方法（即使父类实现了，子类必须实现）\nclass ConcreteElementA extends Element {\n    String info = \"aaaaa\";\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this); // 访问者模式的关键\n    }\n}\n\nclass ConcreteElementB extends Element {\n    Integer info = 0xbbbbb;\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this); // 访问者模式的关键\n    }\n}\n```\n\n`Main` 中的调用方法：\n\n```java\npublic static void main(String[] args) {\n\tList<Element> elements = new ArrayList<>();\n\telements.add(new ConcreteElementA());\n\telements.add(new ConcreteElementB());\n\n\tVisitor infoVisitor = new InfoVisitor();\n\tVisitor infoTypeVisitor = new InfoTypeVisitor();\n\tfor (Element e: elements) {\n\t\te.accept(infoVisitor);\n\t\te.accept(infoTypeVisitor);\n\t}\n}\n```\n\n# 访问者模式\n\n> [!tldr] 访问者模式 Visitor Design Pattern\n> Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.——GoF\n> 允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。\n\n在访问者模式中，数据结构与处理被分离开来。我们编写一个表示「访问者」的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可。\n\n登场角色：\n\n- `Visitor`（访问者）：`Visitor` 角色负责对数据结构中每个具体的元素（`ConcreteElement` 角色）声明一个用于访问 `Xxxxx` 的 `visit(Xxxxx)` 方法。`visit(Xxxxx)` 是用于处理 `Xxxxx` 的方法，负责实现该方法的是 `ConcreteVisitor` 角色。\n- `ConcreteVisitor`（具体的访问者）：`ConcreteVisitor` 角色负责实现 `Visitor` 角色所定义的接口（API）。它要实现所有的 `visit(Xxxxx)` 方法，即实现如何处理每个 `ConcreteElement` 角色。具体访问者知晓具体元素。\n- `Element`（元素）：`Element` 角色表示 `Visitor` 角色的访问对象。它声明了接受访问者的 `accept` 方法。`accept` 方法接收到的参数是 `Visitor` 角色。\n- `ConcreteElement`（具体元素）：`ConcreteElement` 角色负责实现 `Element` 角色所定义的接口（API）。\n- `ObjectStructure`（对象结构）：`ObjectStructure` 角色负责处理 `Element` 角色的集合。`ConcreteVisitor` 角色为每个 `Element` 角色都准备了处理方法。\n\n一般来说，访问者模式针对的是一组类型不同的对象 `ConcreteElement`。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类 `Element` 或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作，但为了避免不断添加功能导致 `ConcreteElement` 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者 `ConcreteVisitor` 中。\n\n`Visitor` 工作条件：`Element` 角色必须向 `Visitor` 角色公开足够多的信息。缺点就是，如果公开了不应当被公开的信息，将来对数据结构的改良就会变得非常困难。\n\n| 优点                                                                               | 缺点                                                                         |\n| -------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |\n| 开闭原则。可以引入在不同类对象上执行的新行为，且无需对这些类做出修改。                                              | 难以增加 `ConcreteElement` 角色。每次在元素层次结构中添加或移除一个类时，你都要更新所有的访问者。                 |\n| 单一职责原则。可将同一行为的不同版本移到同一个类中。                                                       | 在访问者同某个元素进行交互时，它们可能没有访问元素私有成员变量和方法的必要权限。如果公开了不应当被公开的信息，将来对数据结构的改良就会变得非常困难。 |\n| 访问者对象可以在与各种对象交互时收集一些有用的信息。当你想要遍历一些复杂的对象结构 （例如对象树），并在结构中的每个对象上应用访问者时，这些信息可能会有所帮助。 |                                                                            |\n| 易于增加 `ConcreteVisitor` 角色。                                                       |                                                                            |\n\n拓展思路：\n\n- 扩展点在于容易拓展访问者 `ConcreteVisitor`，不易扩展被访问者 `ConcreteElement`。新增 `ConcreteElement` 后，需要在所有 `ConcreteVisitor` 中添加相应的重载方法。\n- 访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。\n\n# 相关的设计模式\n\n其他相关设计模式：\n\n- [[迭代器模式：游标|迭代器模式]]：迭代器模式和访问者模式都是在某种数据结构上进行处理。\n\t- 迭代器模式用于逐个遍历保存在数据结构中的元素。\n\t- 访问者模式用于对保存在数据结构中的元素进行某种特定的处理。\n- [[组合模式：树形结构|组合模式]]：有时访问者所访问的数据结构会使用组合模式。\n- [[「用类来表现」的设计模式|解释器模式]]：在解释器模式中，有时会使用访问者模式。例如，在生成了语法树后，可能会使用访问者模式访问语法树的各个节点进行处理。\n- [[「用类来表现」的设计模式|命令模式]]：可以将访问者模式看成是命令模式的加强版，其对象可对不同类的多种对象执行操作。\n\n在本文首章中提到的案例是访问者模式的简化版，如果业务功能并不多，我们其实可以使用 [[类的工厂|工厂模式]]。\n\n```java\npackage top.uuanqin.dispatch;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author uuanqin\n */\npublic class FactoryTest {\n\n    public static void main(String[] args) {\n        List<Element> elements = new ArrayList<>();\n        elements.add(new ConcreteElementA());\n        elements.add(new ConcreteElementB());\n\n        for (Element e: elements) {\n            InfoPrinter infoPrinter = InfoPrinterFactory.getInfoPrinter(e);\n            infoPrinter.printInfo(e);\n        }\n    }\n}\n\nabstract class Element {}\n\nclass ConcreteElementA extends Element {\n    String info = \"aaaaa\";\n}\n\nclass ConcreteElementB extends Element {\n    Integer info = 0xbbbbb;\n\n}\n\ninterface InfoPrinter {\n    void printInfo(Element e);\n}\n\nclass ElementAInfoPrinter implements InfoPrinter {\n\n    @Override\n    public void printInfo(Element e) {\n        ConcreteElementA a = (ConcreteElementA) e;\n        System.out.println(a.info);\n    }\n}\n\nclass ElementBInfoPrinter implements InfoPrinter {\n\n    @Override\n    public void printInfo(Element e) {\n        ConcreteElementB b = (ConcreteElementB) e;\n        System.out.printf(\"%x\\n\", b.info);\n    }\n}\n\nclass InfoPrinterFactory {\n    public static final Map<String, InfoPrinter> INFO_PRINTERS = new HashMap<>();\n\n    static {\n        INFO_PRINTERS.put(ConcreteElementA.class.getName(), new ElementAInfoPrinter());\n        INFO_PRINTERS.put(ConcreteElementB.class.getName(), new ElementBInfoPrinter());\n    }\n\n    public static InfoPrinter getInfoPrinter(Element element) {\n        return INFO_PRINTERS.get(element.getClass().getName());\n    }\n}\n\n```\n\n当需要增加功能时，如 `printInfoType`，我们需要增加：\n\n- 工厂类 `InfoTypePrinterFactory`\n- 接口 `InfoTypePrinter`\n- 实现类 `ElementAInfoTypePrinter`、`ElementBInfoTypePrinter`\n\n# 双分派的语言不需要访问者模式\n\n单分派和双分派：\n\n|                | 单分派 Single Dispatch   | 双分派 Double Dispatch   |\n| -------------- | --------------------- | --------------------- |\n| 执行哪个对象         | 根据对象 **运行时类型** 决定     | 根据对象的 **运行时类型** 来决定   |\n| 执行对象 `A` 的哪个方法 | 根据方法参数的 **编译时类型** 来决定 | 根据方法参数的 **运行时类型** 来决定 |\n| 语言             | Java、C++、C#           |                       |\n\n在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是「分派 Dispatch」。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。\n\n> 具体到访问者模式中，`element` 接受 `visitor`，而 `visitor` 又访问 `element`。`ConcreteElement` 和 `ConcreteVisitor` 这两个角色共同决定了实际进行的处理。这种消息分发的方式一般被称为双重分发（Double dispatch）。\n\n所谓「单」「双」，指的是执行哪个对象的哪个方法，跟几个因素的**运行时类型**有关。具体到编程语言的语法机制，单分派和双分派和多态、函数重载直接相关。以 Java 为例，Java 支持多态特性，代码可以在运行时获得对象的实际类型（运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则时，并不是在运行时根据传递进函数的参数的实际类型来决定调用哪个重载函数，而是在编译时根据传递进函数的参数的声明类型（编译时类型）来决定调用哪个重载函数。\n\n```java\npublic class DispatchTest {\n    public static void main(String[] args) {\n        SingleDispatchClass demo = new SingleDispatchClass();\n        ParentClass p = new ChildClass();\n        System.out.println(\"示例1：\");\n        demo.polymorphismFunction(p);//执行哪个对象的方法，由对象的实际类型决定\n        System.out.println(\"\\n示例2：\");\n        demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定\n    }\n}\n\n\nclass ParentClass {\n    public void f() {\n        System.out.println(\"执行 ParentClass's f().\");\n    }\n}\n\nclass ChildClass extends ParentClass {\n    @Override\n    public void f() {\n        System.out.println(\"执行 ChildClass's f().\");\n    }\n}\n\nclass SingleDispatchClass {\n    public void polymorphismFunction(ParentClass p) {\n        p.f();\n    }\n\n    public void overloadFunction(ParentClass p) {\n        System.out.println(\"进入重载函数 overloadFunction(ParentClass p).\");\n        p.f(); // 多态起作用\n    }\n\n    public void overloadFunction(ChildClass c) {\n        System.out.println(\"进入重载函数 overloadFunction(ChildClass c).\");\n        c.f();\n    }\n}\n```\n\n代码执行结果：\n\n```text\n示例1：\n执行 ChildClass's f().\n\n示例2：\n进入重载函数 overloadFunction(ParentClass p).\n执行 ChildClass's f().\n```\n\n访问者模式使用了双分派的技巧，让单分派的语言选择正确的类并执行正确的方法。尽管访问者模式基于双分派的原则创建，但这并不是其主要目的。访问者的目的是让你能为整个类层次结构添加「外部」操作，而无需修改这些类的已有代码。\n\n# 本文参考\n\n- 《图解设计模式》第 13 章\n- 本科生课程笔记《程序设计中级实践＆设计模式》 - TJU 🍐⚱️\n- [极客时间专栏 - 设计模式之美 - 王争](https://gitee.com/buxsren/design-pattern-books/blob/master/)\n- [访问者设计模式](https://refactoringguru.cn/design-patterns/visitor)\n- [Double Dispatch 和 Visitors - 知乎](https://zhuanlan.zhihu.com/p/602031602)\n","categories":[{"name":"高质量代码及设计模式","api":"api/categories/高质量代码及设计模式.json"}],"tags":[{"name":"Java","api":"api/tags/Java.json"},{"name":"设计模式","api":"api/tags/设计模式.json"},{"name":"单分派","api":"api/tags/单分派.json"},{"name":"双分派","api":"api/tags/双分派.json"}]},"api":"api/posts/p/b6ca7c41.json"}