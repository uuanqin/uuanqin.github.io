{"data":{"title":"CSAPP LAB-4 代码优化","slug":"CSAPP LABS/CSAPP LAB-4 代码优化","description":"烧脑的循环展开","date":"2024-06-03T05:01:05.000Z","updated":"2024-06-17T14:27:57.559Z","language":"zh-CN","comments":true,"url":"p/9d6b717/","cover":"https://cdn.gallery.uuanqin.top/img/20240603130349.webp","images":[],"content":"\n<div class=\"callout\" data-callout=\"notice\">\n<div class=\"callout-title\">\n<div class=\"callout-title-icon\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>\n</div>\n<div class=\"callout-title-inner\">CSAPP LAB 实验</div>\n</div>\n<div class=\"callout-content\"><p></p>\n<ul>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/c5970284/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-1 位操作</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/d1f3cf37/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-2 二进制炸弹实验</a></li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/67787353/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-3 缓冲区溢出炸弹</a></li>\n<li>CSAPP LAB-4 代码优化（本文）</li>\n<li><a class=\"uuanqin-bilink\" target=\"_blank\" href=\"/p/3eb1abc7/\"><span class=\"yukari\">站内文章</span>CSAPP LAB-5 手写动态存储分配器</a></li>\n</ul>\n</div></div><h1 id=\"实验介绍\"><a class=\"markdownIt-Anchor\" href=\"#实验介绍\"></a> 实验介绍</h1>\n<p>图像处理中存在很多函数，可以对这些函数进行优化。本实验主要关注两种图像处理操作：</p>\n<ul>\n<li>旋转：对图像逆时针旋转 90 度</li>\n<li>平滑：对图像进行模糊操作</li>\n</ul>\n<p>图像用二维矩阵 M 表示，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">M_{ij}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 表示图像 M 的第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 像素的值，像素值用红，绿，蓝表示。</p>\n<p>旋转操作用下面 2 个操作表示：</p>\n<ul>\n<li>Transpose：对第（i,j）个像素对，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">M_{ij}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">M_{ji}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 交换</li>\n<li>Exchange rows：行 i 和行 <code>N-1-i</code> 交换</li>\n</ul>\n<p>平滑操作：每个像素用周围像素值的平均值表示（相当于进行均值滤波）。比如：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.24999999999999992em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><msub><mi>M</mi><mn>1</mn></msub><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><mn>9</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo stretchy=\"false\">[</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>N</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>N</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>M</mi><mn>1</mn></msub><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><mn>4</mn></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\nM_2[1][1] = &amp; \\frac{\\sum_{i=0}^2 \\sum_{j=0}^2 M_1[i][j]}{9} \\\\\nM_2[N-1][N-1] = &amp; \\frac{\\sum_{i=N-2}^{N-1} \\sum_{j=N-2}^{N-1} M_1[i][j]}{4} \n\\end{aligned}\n\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:5.5588750000000005em;vertical-align:-2.5294375000000007em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.0294375em;\"><span style=\"top:-5.0566605em;\"><span class=\"pstrut\" style=\"height:3.807049em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span><span style=\"top:-2.2636114999999997em;\"><span class=\"pstrut\" style=\"height:3.807049em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5294375000000007em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.0294375em;\"><span style=\"top:-5.0566605em;\"><span class=\"pstrut\" style=\"height:3.807049em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.779826em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">9</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.825818em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span><span style=\"top:-2.2636114999999997em;\"><span class=\"pstrut\" style=\"height:3.807049em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8070490000000001em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">4</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.825818em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.981231em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.35804100000000005em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.981231em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5294375000000007em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240603130915.webp\" alt=\"image.png\" /></p>\n<p>编码规则：</p>\n<ul>\n<li>只能用 ANSI C，不能用嵌入式汇编</li>\n<li>不能修改测量时间的机制（CPE）</li>\n<li>只能修改 <code>kernels.c</code>，可以定义宏，全局变量，函数</li>\n</ul>\n<h1 id=\"实验开始\"><a class=\"markdownIt-Anchor\" href=\"#实验开始\"></a> 实验开始</h1>\n<h2 id=\"知识回顾\"><a class=\"markdownIt-Anchor\" href=\"#知识回顾\"></a> 知识回顾</h2>\n<p>回顾一下 CSAPP 第 5 第 6 章学到了哪些优化代码的小技巧：</p>\n<ul>\n<li>消除冗余的函数调用。比如避免在 for 循环里用 strlen。</li>\n<li>消除不必要的内存引用。比如引入临时变量来把中间结果保存到寄存器里，在全部计算完成后把最终结果存到数组或全局变量里。</li>\n<li>循环展开，降低判断语句和增减循环变量的开销。</li>\n<li>累积变量和重新组合，提高指令并行性。</li>\n<li>功能性风格重写条件操作，即用三元运算符。</li>\n<li>提高空间局部性，尽量按照数组在内存里存储的顺序，以 1 为步长进行读取。</li>\n<li>提高时间局部性，一旦在内存里读出一个变量，就尽可能频繁且集中的使用它。</li>\n</ul>\n<p>Cache 的理论依据：</p>\n<ul>\n<li>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。也就是说：被引用过一次的存储器位置在未来会被多次引用，比如循环操作。</li>\n<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。也就是说：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用，比如 cache。</li>\n<li>Cache 有读命中和写命中，写不命中开销比读不命中大。因为在计算机缓存机制中，写操作通常比读操作更为复杂和成本较高。</li>\n</ul>\n<h2 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\"></a> 准备工作</h2>\n<p>解压作业包：<code>tar xvf perflab-handout.tar</code>。</p>\n<p>只能允许修改 <code>kernels.c</code> 文件。我们首先在 <code>kernels.c</code> 填上自己的信息，程序才能成功启动：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Please fill in the following team struct</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">team_t</span> team = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;casa&quot;</span>, <span class=\"comment\">/* Team name */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;</span>,                <span class=\"comment\">/* First member full name */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;</span>, <span class=\"comment\">/* First member email address */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;</span>, <span class=\"comment\">/* Second member full name (leave blank if none) */</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;</span>  <span class=\"comment\">/* Second member email addr (leave blank if none) */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试和运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make driver</span><br><span class=\"line\">./driver</span><br></pre></td></tr></table></figure>\n<p>得到的其中一条示例结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Smooth: Version = naive_smooth: Naive baseline implementation:</span><br><span class=\"line\">Dim             32      64      128     256     512     Mean</span><br><span class=\"line\">Your CPEs       27.0    28.0    26.3    29.2    24.1</span><br><span class=\"line\">Baseline CPEs   695.0   698.0   702.0   717.0   722.0</span><br><span class=\"line\">Speedup         25.7    25.0    26.6    24.6    29.9    26.3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有时候运行会抽风，计算的 CPE 出现负数。并且提示：Fatal Error: Non-positive CPE value… 这时候重新运行一遍就行。另外每次运行 <code>driver</code> 得到的分数都会不一样。</p>\n</blockquote>\n<p>第一行表示执行的方法与函数信息，我们的目标让自己的函数的 Your CPEs 尽可能低，让 Speedup 的 Mean（平均值）比使用默认方法要高。</p>\n<blockquote>\n<p>CPE or Cycles per Element。如果一个函数使用 C 个周期去执行一个大小为 N*N 的图像，那么 CPE=C/(N*N),因此 CPE 越小越好。</p>\n</blockquote>\n<p>在 <code>kernel.c</code> 中有 rotate 的实现方法，我们需要添加自己的 rotate 实现，函数名自己命名，然后通过以下方式注册函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">register_rotate_functions</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">\tadd_rotate_function(&amp;rotate, rotate_descr); </span><br><span class=\"line\">\tadd_rotate_function(&amp;my_rotate，my_rotate_descr);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>每个像素的结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> </span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> red; <span class=\"comment\">/* R value */</span> </span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> green; <span class=\"comment\">/* G value */</span> </span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> blue; <span class=\"comment\">/* B value */</span> </span><br><span class=\"line\">&#125; pixel</span><br></pre></td></tr></table></figure>\n<p>图像用一维数组表示，第（i,j）个像素表示为 <code>I[RIDX(i,j,n)]</code>，n 为图像的维数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RIDX(i,j,n) ((i)*(n)+(j))</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"图像旋转\"><a class=\"markdownIt-Anchor\" href=\"#图像旋转\"></a> 图像旋转</h2>\n<p>原函数的实现为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">naive_rotate</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; dim; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; dim; j++)</span><br><span class=\"line\">            dst[RIDX(dim - <span class=\"number\">1</span> - j, i, dim)] = src[RIDX(i, j, dim)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"减少写数据的迭代步长\"><a class=\"markdownIt-Anchor\" href=\"#减少写数据的迭代步长\"></a> 减少写数据的迭代步长</h3>\n<p>利用知识点：写不命中开销比读不命中大。我们应该优先对写入像素点的索引进行优化。</p>\n<p>观察原函数得知，dst 在进行写时，单次迭代的步长很大。以下是针对这点进行改进的三个版本，它们都比原始方法的性能更好。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t单纯交换两个for循环的i和j</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">char</span> rotateij_rev_descr[] = <span class=\"string\">&quot;rotate:  单纯 i,j 调换(遍历顺序调换)&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rotateij_rev</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; dim; j++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; dim; i++)</span><br><span class=\"line\">            dst[RIDX(dim - <span class=\"number\">1</span> - j, i, dim)] = src[RIDX(i, j, dim)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t改写取dst索引的方式，按顺序写入dst。</span></span><br><span class=\"line\"><span class=\"comment\">\t索引的推导方法可以通过自己手动模拟，写出src对应的索引式子：jn+n-1-i = (j+1)n-1-i</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">char</span> rotateij_descr[] = <span class=\"string\">&quot;rotate:  单纯 i,j 调换&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rotateij</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; dim; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; dim; j++)</span><br><span class=\"line\">            dst[RIDX(i, j, dim)] = src[RIDX(j+<span class=\"number\">1</span>, <span class=\"number\">-1</span>-i, dim)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t在rotateij的基础上把索引变量提取出来，尽量不使用乘法。使用指针代替RIDX进行数组访问。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">char</span> rotateij_local_descr[] = <span class=\"string\">&quot;rotate: i,j 调换 + 使用局部变量 &quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rotateij_local</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"type\">int</span> didx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> osidx = RIDX(<span class=\"number\">1</span>, <span class=\"number\">-1</span>, dim);</span><br><span class=\"line\">    <span class=\"type\">int</span> sidx = osidx--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; dim; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; dim; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dst[didx++] = src[sidx];</span><br><span class=\"line\">            sidx += dim;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sidx = osidx--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rotate: Version = rotate:  单纯 i,j 调换(遍历顺序调换):</span><br><span class=\"line\">Dim             64      128     256     512     1024    Mean</span><br><span class=\"line\">Your CPEs       1.0     1.1     2.0     2.3     5.8</span><br><span class=\"line\">Baseline CPEs   14.7    40.1    46.4    65.9    94.5</span><br><span class=\"line\">Speedup         14.3    35.2    23.3    28.6    16.4    22.3</span><br><span class=\"line\"></span><br><span class=\"line\">Rotate: Version = rotate:  单纯 i,j 调换:</span><br><span class=\"line\">Dim             64      128     256     512     1024    Mean</span><br><span class=\"line\">Your CPEs       1.3     1.2     1.9     2.6     5.8</span><br><span class=\"line\">Baseline CPEs   14.7    40.1    46.4    65.9    94.5</span><br><span class=\"line\">Speedup         11.2    32.1    24.3    25.1    16.2    20.4</span><br><span class=\"line\"></span><br><span class=\"line\">Rotate: Version = rotate: i,j 调换 + 使用局部变量 :</span><br><span class=\"line\">Dim             64      128     256     512     1024    Mean</span><br><span class=\"line\">Your CPEs       1.3     1.2     1.8     2.5     5.6</span><br><span class=\"line\">Baseline CPEs   14.7    40.1    46.4    65.9    94.5</span><br><span class=\"line\">Speedup         11.3    32.9    25.6    26.4    16.9    21.2</span><br></pre></td></tr></table></figure>\n<p>观察可知 <code>rotateij_rev</code> 效果更好。由于历史原因（由于我懒得改代码了），我这里使用了 <code>rotateij_local</code> 方法。读者可随意选取方法，不影响后续的改进。</p>\n<h3 id=\"矩阵分块计算\"><a class=\"markdownIt-Anchor\" href=\"#矩阵分块计算\"></a> 矩阵分块计算</h3>\n<p>观察到测试的图像长宽都是 16 或 32 的倍数。我们可以考虑矩阵分块。</p>\n<p>矩阵分块可以减少缓存的不命中率。空间局部性更好。这里测试了 32*32 分块和 16*16 分块代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> rotate_blc32_descr[] = <span class=\"string\">&quot;rotate: 32 大小的块&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rotate_blc32</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// naive_rotate(dim, src, dst);</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, I, J;</span><br><span class=\"line\">    <span class=\"type\">int</span> block_size = <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (I = <span class=\"number\">0</span>; I &lt; dim; I += block_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (J = <span class=\"number\">0</span>; J &lt; dim; J += block_size)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; block_size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; block_size; j++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dst[RIDX(i + I, j + J, dim)] = src[RIDX(J + j + <span class=\"number\">1</span>, <span class=\"number\">-1</span> - i - I, dim)];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> rotate_blc16_descr[] = <span class=\"string\">&quot;rotate: 16 大小的块&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rotate_blc16</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// naive_rotate(dim, src, dst);</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, I, J;</span><br><span class=\"line\">    <span class=\"type\">int</span> block_size = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (I = <span class=\"number\">0</span>; I &lt; dim; I += block_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (J = <span class=\"number\">0</span>; J &lt; dim; J += block_size)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; block_size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; block_size; j++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dst[RIDX(i + I, j + J, dim)] = src[RIDX(J + j + <span class=\"number\">1</span>, <span class=\"number\">-1</span> - i - I, dim)];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多次测试表明按 16*16 分块效果会好一点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rotate: Version = rotate: 32 大小的块:</span><br><span class=\"line\">Dim             64      128     256     512     1024    Mean</span><br><span class=\"line\">Your CPEs       1.6     1.4     1.5     1.7     2.5</span><br><span class=\"line\">Baseline CPEs   14.7    40.1    46.4    65.9    94.5</span><br><span class=\"line\">Speedup         9.0     28.1    31.4    38.6    37.5    25.8</span><br><span class=\"line\"></span><br><span class=\"line\">Rotate: Version = rotate: 16 大小的块:</span><br><span class=\"line\">Dim             64      128     256     512     1024    Mean</span><br><span class=\"line\">Your CPEs       1.4     1.5     1.4     1.8     2.5</span><br><span class=\"line\">Baseline CPEs   14.7    40.1    46.4    65.9    94.5</span><br><span class=\"line\">Speedup         10.2    27.5    32.7    36.0    38.0    26.3</span><br></pre></td></tr></table></figure>\n<p>关于矩阵分块的具体原理推荐阅读：</p>\n<ul>\n<li><a href=\"http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf\">waside-blocking.pdf (cmu.edu)</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv24735613/\">CSAPP LAB之cachelab，缓存、命中率、矩阵处理 - 哔哩哔哩 (bilibili.com)</a></li>\n</ul>\n<h3 id=\"循环展开\"><a class=\"markdownIt-Anchor\" href=\"#循环展开\"></a> 循环展开</h3>\n<p>循环展开是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。循环展开的本质是，利用 CPU 指令级并行，来降低循环的开销，当然，同时也有利于指令流水线的高效调度。</p>\n<p>优点：</p>\n<ul>\n<li>提高缓存命中（cache hit）率，增加循环体内语句并发执行的可能性（需要循环体内语句不相关）；</li>\n<li>减少分支预测失败的可能性，提高性能</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>程序代码膨胀、代码可读性降低</li>\n<li>消耗较多寄存器缓存</li>\n</ul>\n<p>在分块的基础上进行循环展开：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> rotate_blc16_16_descr[] = <span class=\"string\">&quot;rotate: 16 块 16*1 循环展开&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rotate_blc16_16</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, I, J;</span><br><span class=\"line\">    <span class=\"type\">int</span> block_size = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> didx, sidx;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (I = <span class=\"number\">0</span>; I &lt; dim; I += block_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (J = <span class=\"number\">0</span>; J &lt; dim; J += block_size)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; block_size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                didx = RIDX(i + I, J, dim);</span><br><span class=\"line\">                sidx = RIDX(J + <span class=\"number\">1</span>, <span class=\"number\">-1</span> - i - I, dim);</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">                dst[didx++] = src[sidx];</span><br><span class=\"line\">                sidx += dim;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rotate: Version = rotate: 16 块 16*1 循环展开:</span><br><span class=\"line\">Dim             64      128     256     512     1024    Mean</span><br><span class=\"line\">Your CPEs       1.2     1.2     1.3     1.5     2.3</span><br><span class=\"line\">Baseline CPEs   14.7    40.1    46.4    65.9    94.5</span><br><span class=\"line\">Speedup         12.4    33.8    34.6    45.3    40.4    30.5</span><br></pre></td></tr></table></figure>\n<h2 id=\"平滑操作\"><a class=\"markdownIt-Anchor\" href=\"#平滑操作\"></a> 平滑操作</h2>\n<p>原函数存在的问题是频繁的调用 <code>avg</code> 函数、<code>min</code>、<code>max</code> 等各种函数开销较大。</p>\n<p>我们可以考虑循环展开或者消除函数调用，进一步，可以将重复利用的数据存储在了数组之中。</p>\n<p>思路：</p>\n<ul>\n<li>不使用其他任何函数，自己实现平滑计算</li>\n<li>对四个点、四条边和中间内容分别处理</li>\n<li>充分利用统计先前的统计结果统计像素值的总和</li>\n</ul>\n<p><code>temp_pixel_group</code> 用于统计列的像素之和。为了便于迭代操作和空间利用，<code>temp_pixel_group</code> 安排方式为：</p>\n<p><img src= \"/image/loading.gif\" data-lazy-src=\"https://cdn.gallery.uuanqin.top/img/20240603155715.webp\" alt=\"image.png\" /></p>\n<blockquote>\n<p>循环展开后的代码看着眼花，调试 Bug 更是折磨人。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义自己的数据结构。注意成员的类型是int类型。</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> red;</span><br><span class=\"line\">    <span class=\"type\">int</span> green;</span><br><span class=\"line\">    <span class=\"type\">int</span> blue;</span><br><span class=\"line\">&#125; my_pixel_sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> smooth_my_descr[] = <span class=\"string\">&quot;smooth: 我的实现版本&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">smooth_my</span><span class=\"params\">(<span class=\"type\">int</span> dim, pixel *src, pixel *dst)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 四点处理</span></span><br><span class=\"line\">    <span class=\"type\">int</span> q1, q2, q3, q4, idx;</span><br><span class=\"line\">    q1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q3 = dim;</span><br><span class=\"line\">    q4 = dim + <span class=\"number\">1</span>;</span><br><span class=\"line\">    idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q1 = dim - <span class=\"number\">2</span>;</span><br><span class=\"line\">    q2 = dim - <span class=\"number\">1</span>;</span><br><span class=\"line\">    q3 = dim + dim - <span class=\"number\">2</span>;</span><br><span class=\"line\">    q4 = dim + dim - <span class=\"number\">1</span>;</span><br><span class=\"line\">    idx = dim - <span class=\"number\">1</span>;</span><br><span class=\"line\">    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q1 = (dim - <span class=\"number\">2</span>) * dim;</span><br><span class=\"line\">    q2 = (dim - <span class=\"number\">2</span>) * dim + <span class=\"number\">1</span>;</span><br><span class=\"line\">    q3 = (dim - <span class=\"number\">1</span>) * dim;</span><br><span class=\"line\">    q4 = (dim - <span class=\"number\">1</span>) * dim + <span class=\"number\">1</span>;</span><br><span class=\"line\">    idx = (dim - <span class=\"number\">1</span>) * dim;</span><br><span class=\"line\">    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q1 = dim * dim - <span class=\"number\">2</span> - dim;</span><br><span class=\"line\">    q2 = dim * dim - <span class=\"number\">1</span> - dim;</span><br><span class=\"line\">    q3 = dim * dim - <span class=\"number\">2</span>;</span><br><span class=\"line\">    q4 = dim * dim - <span class=\"number\">1</span>;</span><br><span class=\"line\">    idx = dim * dim - <span class=\"number\">1</span>;</span><br><span class=\"line\">    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    my_pixel_sum *temp_pixel_group = (my_pixel_sum *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(my_pixel_sum) * <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 上边处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化temp_pixel_group</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        temp_pixel_group[i].blue = src[RIDX(<span class=\"number\">0</span>, i, dim)].blue + src[RIDX(<span class=\"number\">1</span>, i, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[i].green = src[RIDX(<span class=\"number\">0</span>, i, dim)].green + src[RIDX(<span class=\"number\">1</span>, i, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[i].red = src[RIDX(<span class=\"number\">0</span>, i, dim)].red + src[RIDX(<span class=\"number\">1</span>, i, dim)].red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt;= dim - <span class=\"number\">2</span>; j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q1 = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].blue = src[RIDX(<span class=\"number\">0</span>, q1, dim)].blue + src[RIDX(<span class=\"number\">1</span>, q1, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].green = src[RIDX(<span class=\"number\">0</span>, q1, dim)].green + src[RIDX(<span class=\"number\">1</span>, q1, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].red = src[RIDX(<span class=\"number\">0</span>, q1, dim)].red + src[RIDX(<span class=\"number\">1</span>, q1, dim)].red;</span><br><span class=\"line\">        dst[RIDX(<span class=\"number\">0</span>, j, dim)].blue = (temp_pixel_group[<span class=\"number\">0</span>].blue + temp_pixel_group[<span class=\"number\">1</span>].blue + temp_pixel_group[<span class=\"number\">2</span>].blue) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(<span class=\"number\">0</span>, j, dim)].red = (temp_pixel_group[<span class=\"number\">0</span>].red + temp_pixel_group[<span class=\"number\">1</span>].red + temp_pixel_group[<span class=\"number\">2</span>].red) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(<span class=\"number\">0</span>, j, dim)].green = (temp_pixel_group[<span class=\"number\">0</span>].green + temp_pixel_group[<span class=\"number\">1</span>].green + temp_pixel_group[<span class=\"number\">2</span>].green) / <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下边处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化temp_pixel_group</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        temp_pixel_group[i].blue = src[RIDX(dim - <span class=\"number\">1</span>, i, dim)].blue + src[RIDX(dim - <span class=\"number\">2</span>, i, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[i].green = src[RIDX(dim - <span class=\"number\">1</span>, i, dim)].green + src[RIDX(dim - <span class=\"number\">2</span>, i, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[i].red = src[RIDX(dim - <span class=\"number\">1</span>, i, dim)].red + src[RIDX(dim - <span class=\"number\">2</span>, i, dim)].red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt;= dim - <span class=\"number\">2</span>; j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q1 = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// q2 = q1 + dim;</span></span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].blue = src[RIDX(dim - <span class=\"number\">1</span>, q1, dim)].blue + src[RIDX(dim - <span class=\"number\">2</span>, q1, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].green = src[RIDX(dim - <span class=\"number\">1</span>, q1, dim)].green + src[RIDX(dim - <span class=\"number\">2</span>, q1, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].red = src[RIDX(dim - <span class=\"number\">1</span>, q1, dim)].red + src[RIDX(dim - <span class=\"number\">2</span>, q1, dim)].red;</span><br><span class=\"line\">        dst[RIDX(dim - <span class=\"number\">1</span>, j, dim)].blue = (temp_pixel_group[<span class=\"number\">0</span>].blue + temp_pixel_group[<span class=\"number\">1</span>].blue + temp_pixel_group[<span class=\"number\">2</span>].blue) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(dim - <span class=\"number\">1</span>, j, dim)].red = (temp_pixel_group[<span class=\"number\">0</span>].red + temp_pixel_group[<span class=\"number\">1</span>].red + temp_pixel_group[<span class=\"number\">2</span>].red) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(dim - <span class=\"number\">1</span>, j, dim)].green = (temp_pixel_group[<span class=\"number\">0</span>].green + temp_pixel_group[<span class=\"number\">1</span>].green + temp_pixel_group[<span class=\"number\">2</span>].green) / <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 左边处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化temp_pixel_group</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t    </span><br><span class=\"line\">        temp_pixel_group[i].blue = src[RIDX(i, <span class=\"number\">0</span>, dim)].blue + src[RIDX(i, <span class=\"number\">1</span>, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[i].green = src[RIDX(i, <span class=\"number\">0</span>, dim)].green + src[RIDX(i, <span class=\"number\">1</span>, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[i].red = src[RIDX(i, <span class=\"number\">0</span>, dim)].red + src[RIDX(i, <span class=\"number\">1</span>, dim)].red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= dim - <span class=\"number\">2</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q1 = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// q2 = q1 + dim;</span></span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].blue = src[RIDX(q1, <span class=\"number\">0</span>, dim)].blue + src[RIDX(q1, <span class=\"number\">1</span>, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].green = src[RIDX(q1, <span class=\"number\">0</span>, dim)].green + src[RIDX(q1, <span class=\"number\">1</span>, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].red = src[RIDX(q1, <span class=\"number\">0</span>, dim)].red + src[RIDX(q1, <span class=\"number\">1</span>, dim)].red;</span><br><span class=\"line\">        dst[RIDX(i, <span class=\"number\">0</span>, dim)].blue = (temp_pixel_group[<span class=\"number\">0</span>].blue + temp_pixel_group[<span class=\"number\">1</span>].blue + temp_pixel_group[<span class=\"number\">2</span>].blue) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(i, <span class=\"number\">0</span>, dim)].red = (temp_pixel_group[<span class=\"number\">0</span>].red + temp_pixel_group[<span class=\"number\">1</span>].red + temp_pixel_group[<span class=\"number\">2</span>].red) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(i, <span class=\"number\">0</span>, dim)].green = (temp_pixel_group[<span class=\"number\">0</span>].green + temp_pixel_group[<span class=\"number\">1</span>].green + temp_pixel_group[<span class=\"number\">2</span>].green) / <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 右边处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化temp_pixel_group</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        temp_pixel_group[i].blue = src[RIDX(i, dim - <span class=\"number\">1</span>, dim)].blue + src[RIDX(i, dim - <span class=\"number\">2</span>, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[i].green = src[RIDX(i, dim - <span class=\"number\">1</span>, dim)].green + src[RIDX(i, dim - <span class=\"number\">2</span>, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[i].red = src[RIDX(i, dim - <span class=\"number\">1</span>, dim)].red + src[RIDX(i, dim - <span class=\"number\">2</span>, dim)].red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= dim - <span class=\"number\">2</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q1 = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].blue = src[RIDX(q1, dim - <span class=\"number\">1</span>, dim)].blue + src[RIDX(q1, dim - <span class=\"number\">2</span>, dim)].blue;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].green = src[RIDX(q1, dim - <span class=\"number\">1</span>, dim)].green + src[RIDX(q1, dim - <span class=\"number\">2</span>, dim)].green;</span><br><span class=\"line\">        temp_pixel_group[q1 % <span class=\"number\">3</span>].red = src[RIDX(q1, dim - <span class=\"number\">1</span>, dim)].red + src[RIDX(q1, dim - <span class=\"number\">2</span>, dim)].red;</span><br><span class=\"line\">        dst[RIDX(i, dim - <span class=\"number\">1</span>, dim)].blue = (temp_pixel_group[<span class=\"number\">0</span>].blue + temp_pixel_group[<span class=\"number\">1</span>].blue + temp_pixel_group[<span class=\"number\">2</span>].blue) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(i, dim - <span class=\"number\">1</span>, dim)].red = (temp_pixel_group[<span class=\"number\">0</span>].red + temp_pixel_group[<span class=\"number\">1</span>].red + temp_pixel_group[<span class=\"number\">2</span>].red) / <span class=\"number\">6</span>;</span><br><span class=\"line\">        dst[RIDX(i, dim - <span class=\"number\">1</span>, dim)].green = (temp_pixel_group[<span class=\"number\">0</span>].green + temp_pixel_group[<span class=\"number\">1</span>].green + temp_pixel_group[<span class=\"number\">2</span>].green) / <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中间通用</span></span><br><span class=\"line\">    <span class=\"type\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= dim - <span class=\"number\">2</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 换行初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k = <span class=\"number\">0</span>; k &lt;= <span class=\"number\">2</span>; k++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            temp_pixel_group[k].blue = src[RIDX(i<span class=\"number\">-1</span>, k, dim)].blue + src[RIDX(i, k, dim)].blue + src[RIDX(i+<span class=\"number\">1</span>, k, dim)].blue;</span><br><span class=\"line\">            temp_pixel_group[k].green = src[RIDX(i<span class=\"number\">-1</span>, k, dim)].green + src[RIDX(i, k, dim)].green + src[RIDX(i+<span class=\"number\">1</span>, k, dim)].green;</span><br><span class=\"line\">            temp_pixel_group[k].red = src[RIDX(i<span class=\"number\">-1</span>, k, dim)].red + src[RIDX(i, k, dim)].red + src[RIDX(i+<span class=\"number\">1</span>, k, dim)].red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt;= dim - <span class=\"number\">2</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q1 = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">            temp_pixel_group[q1 % <span class=\"number\">3</span>].blue = src[RIDX(i<span class=\"number\">-1</span>, j+<span class=\"number\">1</span>, dim)].blue + src[RIDX(i, j+<span class=\"number\">1</span>, dim)].blue+ src[RIDX(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, dim)].blue;</span><br><span class=\"line\">            temp_pixel_group[q1 % <span class=\"number\">3</span>].green = src[RIDX(i<span class=\"number\">-1</span>, j+<span class=\"number\">1</span>, dim)].green + src[RIDX(i, j+<span class=\"number\">1</span>, dim)].green+ src[RIDX(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, dim)].green;</span><br><span class=\"line\">            temp_pixel_group[q1 % <span class=\"number\">3</span>].red = src[RIDX(i<span class=\"number\">-1</span>, j+<span class=\"number\">1</span>, dim)].red + src[RIDX(i, j+<span class=\"number\">1</span>, dim)].red+ src[RIDX(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, dim)].red;</span><br><span class=\"line\">            dst[RIDX(i, j, dim)].blue = (temp_pixel_group[<span class=\"number\">0</span>].blue + temp_pixel_group[<span class=\"number\">1</span>].blue + temp_pixel_group[<span class=\"number\">2</span>].blue) / <span class=\"number\">9</span>;</span><br><span class=\"line\">            dst[RIDX(i, j, dim)].red = (temp_pixel_group[<span class=\"number\">0</span>].red + temp_pixel_group[<span class=\"number\">1</span>].red + temp_pixel_group[<span class=\"number\">2</span>].red) / <span class=\"number\">9</span>;</span><br><span class=\"line\">            dst[RIDX(i, j, dim)].green = (temp_pixel_group[<span class=\"number\">0</span>].green + temp_pixel_group[<span class=\"number\">1</span>].green + temp_pixel_group[<span class=\"number\">2</span>].green) / <span class=\"number\">9</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后续可进行的优化就交给大家了：分块求平均。我眼睛花了。</p>\n<h1 id=\"本文参考\"><a class=\"markdownIt-Anchor\" href=\"#本文参考\"></a> 本文参考</h1>\n<ul>\n<li><a href=\"https://bbs.huaweicloud.com/blogs/343018\">《深入理解计算机系统》（CSAPP）实验五 —— Perfom Lab-云社区-华为云 (huaweicloud.com)</a></li>\n<li><a href=\"https://blog.csdn.net/mdzzname/article/details/111999693\">CSAPP Lab4: Performance Lab_csapp实验四perflab-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/ustca/p/11790314.html\">CSAPP：代码优化【矩阵读写】 - 东寻 - 博客园 (cnblogs.com)</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41140987/article/details/105329531\">CSAPP：PerfLab实验_csapp perflab-CSDN博客</a></li>\n<li><a href=\"https://www.cnblogs.com/kangyupl/p/13258095.html\">【CSAPP】Performance Lab 实验笔记 - 康宇PL - 博客园 (cnblogs.com)</a></li>\n<li><a href=\"https://xymeow.github.io/post/csapp-lab4/\">CSAPP LAB4：perflab-优化两个奇怪的函数 - 中鸽院专家楼 (xymeow.github.io)</a></li>\n<li><a href=\"https://blog.csdn.net/u010420283/article/details/134741705\">编译代码性能优化实践：理解循环展开(pragma unroll)_#pragma unroll-CSDN博客</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80/6322872\">循环展开_百度百科 (baidu.com)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/596619805\">Csapp Lab5: perflab - 知乎 (zhihu.com)</a></li>\n</ul>\n","raw":"---\ntitle: CSAPP LAB-4 代码优化\ntags:\n  - CSAPP\n  - C\ncover: 'https://cdn.gallery.uuanqin.top/img/20240603130349.webp'\ndescription: 烧脑的循环展开\ncategories:\n  - CSAPP LABS\nabbrlink: 9d6b717\ndate: 2024-06-03 13:01:05\ntop_img:\n---\n\n> [!notice] CSAPP LAB 实验\n>\n> - [[CSAPP LAB-1 位操作]]\n> - [[CSAPP LAB-2 二进制炸弹实验]]\n> - [[CSAPP LAB-3 缓冲区溢出炸弹]]\n> - CSAPP LAB-4 代码优化（本文）\n> - [[CSAPP LAB-5 手写动态存储分配器]]\n\n# 实验介绍\n\n图像处理中存在很多函数，可以对这些函数进行优化。本实验主要关注两种图像处理操作：\n\n- 旋转：对图像逆时针旋转 90 度\n- 平滑：对图像进行模糊操作\n\n图像用二维矩阵 M 表示，$M_{ij}$ 表示图像 M 的第 $(i,j)$ 像素的值，像素值用红，绿，蓝表示。\n\n旋转操作用下面 2 个操作表示：\n\n- Transpose：对第（i,j）个像素对，$M_{ij}$ 和 $M_{ji}$ 交换\n- Exchange rows：行 i 和行 `N-1-i` 交换\n\n平滑操作：每个像素用周围像素值的平均值表示（相当于进行均值滤波）。比如：\n\n$$\n\\begin{aligned}\nM_2[1][1] = & \\frac{\\sum_{i=0}^2 \\sum_{j=0}^2 M_1[i][j]}{9} \\\\\nM_2[N-1][N-1] = & \\frac{\\sum_{i=N-2}^{N-1} \\sum_{j=N-2}^{N-1} M_1[i][j]}{4} \n\\end{aligned}\n\n$$\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240603130915.webp)\n\n编码规则：\n\n- 只能用 ANSI C，不能用嵌入式汇编\n- 不能修改测量时间的机制（CPE）\n- 只能修改 `kernels.c`，可以定义宏，全局变量，函数\n\n\n# 实验开始\n\n## 知识回顾\n\n回顾一下 CSAPP 第 5 第 6 章学到了哪些优化代码的小技巧：\n\n- 消除冗余的函数调用。比如避免在 for 循环里用 strlen。\n- 消除不必要的内存引用。比如引入临时变量来把中间结果保存到寄存器里，在全部计算完成后把最终结果存到数组或全局变量里。\n- 循环展开，降低判断语句和增减循环变量的开销。\n- 累积变量和重新组合，提高指令并行性。\n- 功能性风格重写条件操作，即用三元运算符。\n- 提高空间局部性，尽量按照数组在内存里存储的顺序，以 1 为步长进行读取。\n- 提高时间局部性，一旦在内存里读出一个变量，就尽可能频繁且集中的使用它。\n\nCache 的理论依据：\n\n- 时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。也就是说：被引用过一次的存储器位置在未来会被多次引用，比如循环操作。\n- 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。也就是说：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用，比如 cache。\n- Cache 有读命中和写命中，写不命中开销比读不命中大。因为在计算机缓存机制中，写操作通常比读操作更为复杂和成本较高。\n\n## 准备工作\n\n解压作业包：`tar xvf perflab-handout.tar`。\n\n只能允许修改 `kernels.c` 文件。我们首先在 `kernels.c` 填上自己的信息，程序才能成功启动：\n\n```c\n/*\n * Please fill in the following team struct\n */\nteam_t team = {\n    \"casa\", /* Team name */\n\n    \"\",                /* First member full name */\n    \"\", /* First member email address */\n\n    \"\", /* Second member full name (leave blank if none) */\n    \"\"  /* Second member email addr (leave blank if none) */\n};\n```\n\n测试和运行：\n\n```sh\nmake driver\n./driver\n```\n\n得到的其中一条示例结果为：\n\n```\nSmooth: Version = naive_smooth: Naive baseline implementation:\nDim             32      64      128     256     512     Mean\nYour CPEs       27.0    28.0    26.3    29.2    24.1\nBaseline CPEs   695.0   698.0   702.0   717.0   722.0\nSpeedup         25.7    25.0    26.6    24.6    29.9    26.3\n```\n\n> 有时候运行会抽风，计算的 CPE 出现负数。并且提示：Fatal Error: Non-positive CPE value... 这时候重新运行一遍就行。另外每次运行 `driver` 得到的分数都会不一样。\n\n第一行表示执行的方法与函数信息，我们的目标让自己的函数的 Your CPEs 尽可能低，让 Speedup 的 Mean（平均值）比使用默认方法要高。\n\n> CPE or Cycles per Element。如果一个函数使用 C 个周期去执行一个大小为 N\\*N 的图像，那么 CPE=C/(N\\*N),因此 CPE 越小越好。\n\n在 `kernel.c` 中有 rotate 的实现方法，我们需要添加自己的 rotate 实现，函数名自己命名，然后通过以下方式注册函数：\n\n```c\nvoid register_rotate_functions() { \n\tadd_rotate_function(&rotate, rotate_descr); \n\tadd_rotate_function(&my_rotate，my_rotate_descr);\n} \n```\n\n每个像素的结构：\n\n```c\ntypedef struct { \n\tunsigned short red; /* R value */ \n\tunsigned short green; /* G value */ \n\tunsigned short blue; /* B value */ \n} pixel\n```\n\n图像用一维数组表示，第（i,j）个像素表示为 `I[RIDX(i,j,n)]`，n 为图像的维数。\n\n```c\n#define RIDX(i,j,n) ((i)*(n)+(j))\n```\n\n## 图像旋转\n\n原函数的实现为：\n\n```c\nvoid naive_rotate(int dim, pixel *src, pixel *dst)\n{\n    int i, j;\n\n    for (i = 0; i < dim; i++)\n        for (j = 0; j < dim; j++)\n            dst[RIDX(dim - 1 - j, i, dim)] = src[RIDX(i, j, dim)];\n}\n```\n\n### 减少写数据的迭代步长\n\n利用知识点：写不命中开销比读不命中大。我们应该优先对写入像素点的索引进行优化。\n\n观察原函数得知，dst 在进行写时，单次迭代的步长很大。以下是针对这点进行改进的三个版本，它们都比原始方法的性能更好。\n\n```c\n/*\n\t单纯交换两个for循环的i和j\n*/\nchar rotateij_rev_descr[] = \"rotate:  单纯 i,j 调换(遍历顺序调换)\";\nvoid rotateij_rev(int dim, pixel *src, pixel *dst)\n{\n    int i, j;\n\n    for (j = 0; j < dim; j++)\n        for (i = 0; i < dim; i++)\n            dst[RIDX(dim - 1 - j, i, dim)] = src[RIDX(i, j, dim)];\n}\n\n\n/*\n\t改写取dst索引的方式，按顺序写入dst。\n\t索引的推导方法可以通过自己手动模拟，写出src对应的索引式子：jn+n-1-i = (j+1)n-1-i\n*/\nchar rotateij_descr[] = \"rotate:  单纯 i,j 调换\";\nvoid rotateij(int dim, pixel *src, pixel *dst)\n{\n    int i, j;\n\n    for (i = 0; i < dim; i++)\n        for (j = 0; j < dim; j++)\n            dst[RIDX(i, j, dim)] = src[RIDX(j+1, -1-i, dim)];\n}\n\n/*\n\t在rotateij的基础上把索引变量提取出来，尽量不使用乘法。使用指针代替RIDX进行数组访问。\n*/\nchar rotateij_local_descr[] = \"rotate: i,j 调换 + 使用局部变量 \";\nvoid rotateij_local(int dim, pixel *src, pixel *dst)\n{\n    int i, j;\n    int didx = 0;\n    int osidx = RIDX(1, -1, dim);\n    int sidx = osidx--;\n    for (i = 0; i < dim; i++)\n    {\n        for (j = 0; j < dim; j++)\n        {\n            dst[didx++] = src[sidx];\n            sidx += dim;\n        }\n        sidx = osidx--;\n    }\n}\n```\n\n结果如下：\n\n```\nRotate: Version = rotate:  单纯 i,j 调换(遍历顺序调换):\nDim             64      128     256     512     1024    Mean\nYour CPEs       1.0     1.1     2.0     2.3     5.8\nBaseline CPEs   14.7    40.1    46.4    65.9    94.5\nSpeedup         14.3    35.2    23.3    28.6    16.4    22.3\n\nRotate: Version = rotate:  单纯 i,j 调换:\nDim             64      128     256     512     1024    Mean\nYour CPEs       1.3     1.2     1.9     2.6     5.8\nBaseline CPEs   14.7    40.1    46.4    65.9    94.5\nSpeedup         11.2    32.1    24.3    25.1    16.2    20.4\n\nRotate: Version = rotate: i,j 调换 + 使用局部变量 :\nDim             64      128     256     512     1024    Mean\nYour CPEs       1.3     1.2     1.8     2.5     5.6\nBaseline CPEs   14.7    40.1    46.4    65.9    94.5\nSpeedup         11.3    32.9    25.6    26.4    16.9    21.2\n```\n\n观察可知 `rotateij_rev` 效果更好。由于历史原因（由于我懒得改代码了），我这里使用了 `rotateij_local` 方法。读者可随意选取方法，不影响后续的改进。\n\n### 矩阵分块计算\n\n观察到测试的图像长宽都是 16 或 32 的倍数。我们可以考虑矩阵分块。\n\n矩阵分块可以减少缓存的不命中率。空间局部性更好。这里测试了 32\\*32 分块和 16\\*16 分块代码。\n\n```c\nchar rotate_blc32_descr[] = \"rotate: 32 大小的块\";\nvoid rotate_blc32(int dim, pixel *src, pixel *dst)\n{\n    // naive_rotate(dim, src, dst);\n    int i, j, I, J;\n    int block_size = 32;\n    for (I = 0; I < dim; I += block_size)\n    {\n        for (J = 0; J < dim; J += block_size)\n        {\n            for (i = 0; i < block_size; i++)\n            {\n                for (j = 0; j < block_size; j++)\n                {\n                    dst[RIDX(i + I, j + J, dim)] = src[RIDX(J + j + 1, -1 - i - I, dim)];\n                }\n            }\n        }\n    }\n}\n\nchar rotate_blc16_descr[] = \"rotate: 16 大小的块\";\nvoid rotate_blc16(int dim, pixel *src, pixel *dst)\n{\n    // naive_rotate(dim, src, dst);\n    int i, j, I, J;\n    int block_size = 16;\n    for (I = 0; I < dim; I += block_size)\n    {\n        for (J = 0; J < dim; J += block_size)\n        {\n            for (i = 0; i < block_size; i++)\n            {\n                for (j = 0; j < block_size; j++)\n                {\n                    dst[RIDX(i + I, j + J, dim)] = src[RIDX(J + j + 1, -1 - i - I, dim)];\n                }\n            }\n        }\n    }\n}\n```\n\n多次测试表明按 16\\*16 分块效果会好一点。\n\n```\nRotate: Version = rotate: 32 大小的块:\nDim             64      128     256     512     1024    Mean\nYour CPEs       1.6     1.4     1.5     1.7     2.5\nBaseline CPEs   14.7    40.1    46.4    65.9    94.5\nSpeedup         9.0     28.1    31.4    38.6    37.5    25.8\n\nRotate: Version = rotate: 16 大小的块:\nDim             64      128     256     512     1024    Mean\nYour CPEs       1.4     1.5     1.4     1.8     2.5\nBaseline CPEs   14.7    40.1    46.4    65.9    94.5\nSpeedup         10.2    27.5    32.7    36.0    38.0    26.3\n```\n\n关于矩阵分块的具体原理推荐阅读：\n\n- [waside-blocking.pdf (cmu.edu)](http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf)\n- [CSAPP LAB之cachelab，缓存、命中率、矩阵处理 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv24735613/)\n\n### 循环展开\n\n循环展开是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。循环展开的本质是，利用 CPU 指令级并行，来降低循环的开销，当然，同时也有利于指令流水线的高效调度。\n\n优点：\n\n- 提高缓存命中（cache hit）率，增加循环体内语句并发执行的可能性（需要循环体内语句不相关）；\n- 减少分支预测失败的可能性，提高性能\n\n缺点：\n\n- 程序代码膨胀、代码可读性降低\n- 消耗较多寄存器缓存\n\n在分块的基础上进行循环展开：\n\n```c\nchar rotate_blc16_16_descr[] = \"rotate: 16 块 16*1 循环展开\";\nvoid rotate_blc16_16(int dim, pixel *src, pixel *dst)\n{\n    int i, I, J;\n    int block_size = 16;\n    int didx, sidx;\n    for (I = 0; I < dim; I += block_size)\n    {\n        for (J = 0; J < dim; J += block_size)\n        {\n            for (i = 0; i < block_size; i++)\n            {\n                didx = RIDX(i + I, J, dim);\n                sidx = RIDX(J + 1, -1 - i - I, dim);\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n                dst[didx++] = src[sidx];\n                sidx += dim;\n            }\n        }\n    }\n}\n```\n\n```\nRotate: Version = rotate: 16 块 16*1 循环展开:\nDim             64      128     256     512     1024    Mean\nYour CPEs       1.2     1.2     1.3     1.5     2.3\nBaseline CPEs   14.7    40.1    46.4    65.9    94.5\nSpeedup         12.4    33.8    34.6    45.3    40.4    30.5\n```\n\n## 平滑操作\n\n原函数存在的问题是频繁的调用 `avg` 函数、`min`、`max` 等各种函数开销较大。\n\n我们可以考虑循环展开或者消除函数调用，进一步，可以将重复利用的数据存储在了数组之中。\n\n思路：\n\n- 不使用其他任何函数，自己实现平滑计算\n- 对四个点、四条边和中间内容分别处理\n- 充分利用统计先前的统计结果统计像素值的总和\n\n`temp_pixel_group` 用于统计列的像素之和。为了便于迭代操作和空间利用，`temp_pixel_group` 安排方式为：\n\n![image.png](https://cdn.gallery.uuanqin.top/img/20240603155715.webp)\n\n> 循环展开后的代码看着眼花，调试 Bug 更是折磨人。\n\n```c\n// 定义自己的数据结构。注意成员的类型是int类型。\ntypedef struct\n{\n    int red;\n    int green;\n    int blue;\n} my_pixel_sum;\n\nchar smooth_my_descr[] = \"smooth: 我的实现版本\";\nvoid smooth_my(int dim, pixel *src, pixel *dst){\n    int i, j;\n\n    // 四点处理\n    int q1, q2, q3, q4, idx;\n    q1 = 0;\n    q2 = 1;\n    q3 = dim;\n    q4 = dim + 1;\n    idx = 0;\n    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / 4;\n    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / 4;\n    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / 4;\n\n    q1 = dim - 2;\n    q2 = dim - 1;\n    q3 = dim + dim - 2;\n    q4 = dim + dim - 1;\n    idx = dim - 1;\n    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / 4;\n    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / 4;\n    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / 4;\n\n    q1 = (dim - 2) * dim;\n    q2 = (dim - 2) * dim + 1;\n    q3 = (dim - 1) * dim;\n    q4 = (dim - 1) * dim + 1;\n    idx = (dim - 1) * dim;\n    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / 4;\n    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / 4;\n    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / 4;\n\n    q1 = dim * dim - 2 - dim;\n    q2 = dim * dim - 1 - dim;\n    q3 = dim * dim - 2;\n    q4 = dim * dim - 1;\n    idx = dim * dim - 1;\n    dst[idx].blue = (src[q1].blue + src[q2].blue + src[q3].blue + src[q4].blue) / 4;\n    dst[idx].green = (src[q1].green + src[q2].green + src[q3].green + src[q4].green) / 4;\n    dst[idx].red = (src[q1].red + src[q2].red + src[q3].red + src[q4].red) / 4;\n\n    my_pixel_sum *temp_pixel_group = (my_pixel_sum *)malloc(sizeof(my_pixel_sum) * 3);\n\n    // 上边处理\n    // 初始化temp_pixel_group\n    for (i = 0; i <= 1; i++)\n    {\n        temp_pixel_group[i].blue = src[RIDX(0, i, dim)].blue + src[RIDX(1, i, dim)].blue;\n        temp_pixel_group[i].green = src[RIDX(0, i, dim)].green + src[RIDX(1, i, dim)].green;\n        temp_pixel_group[i].red = src[RIDX(0, i, dim)].red + src[RIDX(1, i, dim)].red;\n    }\n    for (j = 1; j <= dim - 2; j++)\n    {\n        q1 = j + 1;\n        temp_pixel_group[q1 % 3].blue = src[RIDX(0, q1, dim)].blue + src[RIDX(1, q1, dim)].blue;\n        temp_pixel_group[q1 % 3].green = src[RIDX(0, q1, dim)].green + src[RIDX(1, q1, dim)].green;\n        temp_pixel_group[q1 % 3].red = src[RIDX(0, q1, dim)].red + src[RIDX(1, q1, dim)].red;\n        dst[RIDX(0, j, dim)].blue = (temp_pixel_group[0].blue + temp_pixel_group[1].blue + temp_pixel_group[2].blue) / 6;\n        dst[RIDX(0, j, dim)].red = (temp_pixel_group[0].red + temp_pixel_group[1].red + temp_pixel_group[2].red) / 6;\n        dst[RIDX(0, j, dim)].green = (temp_pixel_group[0].green + temp_pixel_group[1].green + temp_pixel_group[2].green) / 6;\n    }\n\n    // 下边处理\n    // 初始化temp_pixel_group\n    for (i = 0; i <= 1; i++)\n    {\n        temp_pixel_group[i].blue = src[RIDX(dim - 1, i, dim)].blue + src[RIDX(dim - 2, i, dim)].blue;\n        temp_pixel_group[i].green = src[RIDX(dim - 1, i, dim)].green + src[RIDX(dim - 2, i, dim)].green;\n        temp_pixel_group[i].red = src[RIDX(dim - 1, i, dim)].red + src[RIDX(dim - 2, i, dim)].red;\n    }\n    for (j = 1; j <= dim - 2; j++)\n    {\n        q1 = j + 1;\n        // q2 = q1 + dim;\n        temp_pixel_group[q1 % 3].blue = src[RIDX(dim - 1, q1, dim)].blue + src[RIDX(dim - 2, q1, dim)].blue;\n        temp_pixel_group[q1 % 3].green = src[RIDX(dim - 1, q1, dim)].green + src[RIDX(dim - 2, q1, dim)].green;\n        temp_pixel_group[q1 % 3].red = src[RIDX(dim - 1, q1, dim)].red + src[RIDX(dim - 2, q1, dim)].red;\n        dst[RIDX(dim - 1, j, dim)].blue = (temp_pixel_group[0].blue + temp_pixel_group[1].blue + temp_pixel_group[2].blue) / 6;\n        dst[RIDX(dim - 1, j, dim)].red = (temp_pixel_group[0].red + temp_pixel_group[1].red + temp_pixel_group[2].red) / 6;\n        dst[RIDX(dim - 1, j, dim)].green = (temp_pixel_group[0].green + temp_pixel_group[1].green + temp_pixel_group[2].green) / 6;\n    }\n\n    // 左边处理\n    // 初始化temp_pixel_group\n    for (i = 0; i <= 1; i++)\n    {\n\t    \n        temp_pixel_group[i].blue = src[RIDX(i, 0, dim)].blue + src[RIDX(i, 1, dim)].blue;\n        temp_pixel_group[i].green = src[RIDX(i, 0, dim)].green + src[RIDX(i, 1, dim)].green;\n        temp_pixel_group[i].red = src[RIDX(i, 0, dim)].red + src[RIDX(i, 1, dim)].red;\n    }\n    for (i = 1; i <= dim - 2; i++)\n    {\n        q1 = i + 1;\n        // q2 = q1 + dim;\n        temp_pixel_group[q1 % 3].blue = src[RIDX(q1, 0, dim)].blue + src[RIDX(q1, 1, dim)].blue;\n        temp_pixel_group[q1 % 3].green = src[RIDX(q1, 0, dim)].green + src[RIDX(q1, 1, dim)].green;\n        temp_pixel_group[q1 % 3].red = src[RIDX(q1, 0, dim)].red + src[RIDX(q1, 1, dim)].red;\n        dst[RIDX(i, 0, dim)].blue = (temp_pixel_group[0].blue + temp_pixel_group[1].blue + temp_pixel_group[2].blue) / 6;\n        dst[RIDX(i, 0, dim)].red = (temp_pixel_group[0].red + temp_pixel_group[1].red + temp_pixel_group[2].red) / 6;\n        dst[RIDX(i, 0, dim)].green = (temp_pixel_group[0].green + temp_pixel_group[1].green + temp_pixel_group[2].green) / 6;\n    }\n\n    // 右边处理\n    // 初始化temp_pixel_group\n    for (i = 0; i <= 1; i++)\n    {\n        temp_pixel_group[i].blue = src[RIDX(i, dim - 1, dim)].blue + src[RIDX(i, dim - 2, dim)].blue;\n        temp_pixel_group[i].green = src[RIDX(i, dim - 1, dim)].green + src[RIDX(i, dim - 2, dim)].green;\n        temp_pixel_group[i].red = src[RIDX(i, dim - 1, dim)].red + src[RIDX(i, dim - 2, dim)].red;\n    }\n    for (i = 1; i <= dim - 2; i++)\n    {\n        q1 = i + 1;\n        temp_pixel_group[q1 % 3].blue = src[RIDX(q1, dim - 1, dim)].blue + src[RIDX(q1, dim - 2, dim)].blue;\n        temp_pixel_group[q1 % 3].green = src[RIDX(q1, dim - 1, dim)].green + src[RIDX(q1, dim - 2, dim)].green;\n        temp_pixel_group[q1 % 3].red = src[RIDX(q1, dim - 1, dim)].red + src[RIDX(q1, dim - 2, dim)].red;\n        dst[RIDX(i, dim - 1, dim)].blue = (temp_pixel_group[0].blue + temp_pixel_group[1].blue + temp_pixel_group[2].blue) / 6;\n        dst[RIDX(i, dim - 1, dim)].red = (temp_pixel_group[0].red + temp_pixel_group[1].red + temp_pixel_group[2].red) / 6;\n        dst[RIDX(i, dim - 1, dim)].green = (temp_pixel_group[0].green + temp_pixel_group[1].green + temp_pixel_group[2].green) / 6;\n    }\n\n    // 中间通用\n    int k;\n    for (i = 1; i <= dim - 2; i++)\n    {\n        // 换行初始化\n        for (k = 0; k <= 2; k++)\n        {\n            temp_pixel_group[k].blue = src[RIDX(i-1, k, dim)].blue + src[RIDX(i, k, dim)].blue + src[RIDX(i+1, k, dim)].blue;\n            temp_pixel_group[k].green = src[RIDX(i-1, k, dim)].green + src[RIDX(i, k, dim)].green + src[RIDX(i+1, k, dim)].green;\n            temp_pixel_group[k].red = src[RIDX(i-1, k, dim)].red + src[RIDX(i, k, dim)].red + src[RIDX(i+1, k, dim)].red;\n        }\n        for (j = 1; j <= dim - 2; j++)\n        {\n            q1 = j+1;\n            temp_pixel_group[q1 % 3].blue = src[RIDX(i-1, j+1, dim)].blue + src[RIDX(i, j+1, dim)].blue+ src[RIDX(i+1, j+1, dim)].blue;\n            temp_pixel_group[q1 % 3].green = src[RIDX(i-1, j+1, dim)].green + src[RIDX(i, j+1, dim)].green+ src[RIDX(i+1, j+1, dim)].green;\n            temp_pixel_group[q1 % 3].red = src[RIDX(i-1, j+1, dim)].red + src[RIDX(i, j+1, dim)].red+ src[RIDX(i+1, j+1, dim)].red;\n            dst[RIDX(i, j, dim)].blue = (temp_pixel_group[0].blue + temp_pixel_group[1].blue + temp_pixel_group[2].blue) / 9;\n            dst[RIDX(i, j, dim)].red = (temp_pixel_group[0].red + temp_pixel_group[1].red + temp_pixel_group[2].red) / 9;\n            dst[RIDX(i, j, dim)].green = (temp_pixel_group[0].green + temp_pixel_group[1].green + temp_pixel_group[2].green) / 9;\n        }\n    }\n}\n```\n\n后续可进行的优化就交给大家了：分块求平均。我眼睛花了。\n\n# 本文参考\n- [《深入理解计算机系统》（CSAPP）实验五 —— Perfom Lab-云社区-华为云 (huaweicloud.com)](https://bbs.huaweicloud.com/blogs/343018)\n- [CSAPP Lab4: Performance Lab_csapp实验四perflab-CSDN博客](https://blog.csdn.net/mdzzname/article/details/111999693)\n- [CSAPP：代码优化【矩阵读写】 - 东寻 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ustca/p/11790314.html)\n- [CSAPP：PerfLab实验_csapp perflab-CSDN博客](https://blog.csdn.net/qq_41140987/article/details/105329531)\n- [【CSAPP】Performance Lab 实验笔记 - 康宇PL - 博客园 (cnblogs.com)](https://www.cnblogs.com/kangyupl/p/13258095.html)\n- [CSAPP LAB4：perflab-优化两个奇怪的函数 - 中鸽院专家楼 (xymeow.github.io)](https://xymeow.github.io/post/csapp-lab4/)\n- [编译代码性能优化实践：理解循环展开(pragma unroll)_#pragma unroll-CSDN博客](https://blog.csdn.net/u010420283/article/details/134741705)\n- [循环展开_百度百科 (baidu.com)](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80/6322872)\n- [Csapp Lab5: perflab - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/596619805)\n","categories":[{"name":"CSAPP LABS","api":"api/categories/CSAPP-LABS.json"}],"tags":[{"name":"CSAPP","api":"api/tags/CSAPP.json"},{"name":"C","api":"api/tags/C.json"}]},"api":"api/posts/p/9d6b717.json"}